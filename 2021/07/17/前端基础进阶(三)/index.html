<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/bitbug_favicon32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/bitbug_favicon16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"crystalsummer.gitee.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>


  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "4b921942"
    }); 
  daovoice('update');
  </script>


  <meta property="og:type" content="article">
<meta property="og:title" content="前端基础进阶(三)">
<meta property="og:url" content="http://crystalsummer.gitee.io/2021/07/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%B8%89)/index.html">
<meta property="og:site_name" content="Crystal&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.pixabay.com/photo/2020/06/10/14/19/landscape-5282903_960_720.jpg">
<meta property="og:image" content="https://s2.loli.net/2022/03/15/dNIwf489nURFMLs.png">
<meta property="og:image" content="https://s2.loli.net/2022/03/15/kTzItvyePnXDGcS.png">
<meta property="article:published_time" content="2021-07-17T10:45:50.000Z">
<meta property="article:modified_time" content="2022-08-10T07:37:05.813Z">
<meta property="article:author" content="Crystal">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="JS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.pixabay.com/photo/2020/06/10/14/19/landscape-5282903_960_720.jpg">

<link rel="canonical" href="http://crystalsummer.gitee.io/2021/07/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%B8%89)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>前端基础进阶(三) | Crystal's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Crystal's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Crystal's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/crystal-summer" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crystalsummer.gitee.io/2021/07/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%B8%89)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar2.png">
      <meta itemprop="name" content="Crystal">
      <meta itemprop="description" content="Only for recording life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crystal's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端基础进阶(三)
        </h1>

        <div class="post-meta">

           
            <i class="fa fa-thumbtack"></i> <font color=7D26CD>top</font> <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">posted</span>

              <time title="创建时间：2021-07-17 18:45:50" itemprop="dateCreated datePublished" datetime="2021-07-17T18:45:50+08:00">2021-07-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">in</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/JS/" itemprop="url" rel="index"><span itemprop="name">JS</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="count">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">count：</span>
              <span>44k</span>
            </span>
            <span class="post-meta-item" title="readingTime">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">readingTime &asymp;</span>
              <span>40 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://cdn.pixabay.com/photo/2020/06/10/14/19/landscape-5282903_960_720.jpg" alt=""></p>
<a id="more"></a>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是无序属性的集合，属性包含基本值、对象或者函数。对象的创建有以下几种方式：</p>
<ol>
<li>对象字面量直接创建<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name: &quot;TOM&quot;,</span><br><span class="line">  getName: function() &#123;</span><br><span class="line">      return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 new 关键字创建<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; new Object()</span><br><span class="line">person.name &#x3D; &quot;TOM&quot;;</span><br><span class="line">person.getName &#x3D; function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>工厂模式<br>以person对象为例，假如在实际开发中，不仅仅需要一个名字叫做TOM的person对象，同时还需要另外一个名为Jake的person对象，虽然他们有很多相似之处，但是我们不得不重复写两次。工厂模式就是为了解决这个问题，工厂模式相当于提供一个模子，通过模子复制出多个我们需要的对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var createPerson &#x3D; function(name, age) &#123;</span><br><span class="line">    &#x2F;&#x2F; 声明一个中间对象，该对象就是工厂模式的模子</span><br><span class="line">    var o &#x3D; new Object();</span><br><span class="line">    &#x2F;&#x2F; 依次添加我们需要的属性与方法</span><br><span class="line">    o.name &#x3D; name;</span><br><span class="line">    o.age &#x3D; age;</span><br><span class="line">    o.getName &#x3D; function() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 创建两个实例</span><br><span class="line">var perTom &#x3D; createPerson(&#39;TOM&#39;, 20);</span><br><span class="line">var PerJake &#x3D; createPerson(&#39;Jake&#39;, 22);</span><br></pre></td></tr></table></figure>
但是，工厂模式有两个缺点：</li>
</ol>
<ul>
<li>没有办法识别实例和对象的关系，需要使用构造函数来解决这个问题；</li>
<li>对象复制，声明多个对象，就有多个getName的方法被重新生成，需要为getName分配空间。</li>
</ul>
<ol start="4">
<li>构造函数<br>解决了实例和对象的关系，即判断实例类型的问题，但是依然没有解决对象复制的问题。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var Person &#x3D; function(name, age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.getName &#x3D; function() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p1 &#x3D; new Person(&#39;Ness&#39;, 20);</span><br><span class="line">console.log(p1.getName());  &#x2F;&#x2F; Ness</span><br><span class="line"></span><br><span class="line">console.log(p1 instanceof Person); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>构造函数虽然解决了判断实例类型的问题，但是对象复制问题依然没有解决。原型帮我们解决了这个问题。</p>
<ul>
<li>我们创建的每一个函数，都会有一个<code>prototype</code>属性，该属性指向一个对象。这个对象，就是我们这里说的原型。</li>
<li>当我们创建对象的时候，可以选择性的将一些属性和方法通过<code>prototype</code>属性，挂载在原型对象上。</li>
<li>每一个new出来的实例，都有一个<code>__proto__</code>属性，该属性指向构造函数的原型对象，通过这个属性，让实例对象也能够访问原型对象上的方法。</li>
<li>当所有的实例都能够通过<code>__proto__</code>访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性。</li>
<li>原型对象的<code>constructor</code>指向构造函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明构造函数</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 通过prototye属性，将方法挂载到原型对象上</span><br><span class="line">Person.prototype.getName &#x3D; function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">var p1 &#x3D; new Person(&#39;tim&#39;, 10);</span><br><span class="line">var p2 &#x3D; new Person(&#39;jak&#39;, 22);</span><br><span class="line">console.log(p1.getName &#x3D;&#x3D;&#x3D; p2.getName); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2022/03/15/dNIwf489nURFMLs.png" alt=""><br>通过图示我们可以看出，构造函数的<code>prototype</code>与所有实例对象的<code>__proto__</code>都指向原型对象。而原型对象的<code>constructor</code>指向构造函数。<br>根据构造函数与原型的特性，我们可以将在构造函数中，通过<strong>this声明</strong>的属性与方法称为<strong>私有变量与方法</strong>，它们被某一个实例对象所独有。而通过<strong>原型声明</strong>的属性与方法，我们可以称之为<strong>共有属性与方法</strong>，它们可以被所有的实例对象访问。<blockquote>
<p><strong>当我们访问实例对象中的属性或者方法时，会优先访问实例对象自身的属性和方法。</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  &#x2F;&#x2F; this 声明的属性和方法--私有变量和方法</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">  this.getName &#x3D; function() &#123;</span><br><span class="line">      console.log(&#39;this is constructor.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 通过原型声明的属性与方法--共有变量和方法</span><br><span class="line">Person.prototype.getName &#x3D; function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">var p1 &#x3D; new Person(&#39;tim&#39;, 10);</span><br><span class="line">&#x2F;&#x2F; 访问实例对象中的属性或者方法时，会优先访问实例对象自身的属性和方法。</span><br><span class="line">p1.getName(); &#x2F;&#x2F; this is constructor.</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>更简单的原型写法：<br><strong>注意：</strong><code>Person.prototype = {}</code>实际上是重新创建了一个<code>{}</code>对象并赋值给<code>Person.prototype</code>，这里的<code>{}</code>并不是最初的那个原型对象。因此它里面并不包含<code>constructor</code>属性。为了保证正确性，我们必须在新创建的<code>{}</code>对象中显式的设置<code>constructor</code>的指向，即<code>constructor: Person</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">Person.prototype &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 新建的对象无constructor，必须显式设置</span><br><span class="line">  constructor: Person,</span><br><span class="line">  getName: function() &#123;&#125;,</span><br><span class="line">  getAge: function() &#123;&#125;,</span><br><span class="line">  sayHello: function() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>由对象及其原型组成的链就叫做原型链。当访问一个对象的属性时，先在对象的本身找，找不到就去对象的原型上找，如果还是找不到，就去对象的原型（原型也是对象，也有它自己的原型）的原型上找，如此继续，直到找到为止，或者查找到最顶层的原型对象中也没有找到，就结束查找，返回undefined。<br>以函数对象的原型链为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add()&#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 分析过程如下：</span><br><span class="line">1.函数有__proto__属性，指向Function原型，所以add.__proto__&#x3D;&#x3D;&#x3D;Function.prototype</span><br><span class="line">2.原型Function.prototype也有__proto__属性，指向Object原型，所以</span><br><span class="line">  Function.prototype.__proto__&#x3D;&#x3D;&#x3D;Object.prototype</span><br><span class="line">3.这里需要注意：Object.prototype.__proto__&#x3D;&#x3D;&#x3D;null</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/15/kTzItvyePnXDGcS.png" alt=""><br>所以我们也可以换个方式描述下原型链 ：由对象的<code>__proto__</code>属性串连起来的直到<code>Object.prototype.__proto__</code>（为null）的链就是原型链。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 父级对象</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName &#x3D; function() &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getAge &#x3D; function() &#123;</span><br><span class="line">  return this.age;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子级对象-构造函数继承</span><br><span class="line">function Student(name, age, grade) &#123;</span><br><span class="line">  Person.call(this, name, age);</span><br><span class="line">  this.grade &#x3D; grade;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子级对象-原型继承</span><br><span class="line">Student.prototype &#x3D; new Person(name, age);</span><br><span class="line">Student.prototype.getGrade &#x3D; function() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>子级对象的原型继承，如何将子级对象的原型加入到原型链中？</p>
<ul>
<li>让子级对象的原型，成为父级对象的一个实例。</li>
<li>然后通过<code>__proto__</code>就可以访问父级对象的原型，这样就继承了父级原型中的方法与属性了。<br>这是<strong>更好的继承</strong>，封装一个继承的方法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function create(proto, options) &#123;</span><br><span class="line">  &#x2F;&#x2F; 创建一个空对象</span><br><span class="line">  var tmp &#x3D; &#123;&#125;;</span><br><span class="line">  &#x2F;&#x2F; 让这个新的空对象成为父类对象的实例</span><br><span class="line">  tmp.__proto__ &#x3D; proto;</span><br><span class="line">  &#x2F;&#x2F; 传入的方法都挂载到新对象上，新的对象将作为子类对象的原型</span><br><span class="line">  Object.defineProperties(tmp, options);</span><br><span class="line">  return tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实现原型的继承</span><br><span class="line">Student.prototype &#x3D; create(Person.prototype, &#123;</span><br><span class="line">  &#x2F;&#x2F; 不要忘了重新指定构造函数</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: Student</span><br><span class="line">  &#125;</span><br><span class="line">  getGrade: &#123;</span><br><span class="line">    value: function() &#123;</span><br><span class="line">      return this.grade</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>在ECMAScript5中提供了<code>Object.create()</code>方法来实现继承</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype &#x3D; Object.create(Person.prototype, &#123;</span><br><span class="line">  &#x2F;&#x2F; 不要忘了重新指定构造函数</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: Student</span><br><span class="line">  &#125;</span><br><span class="line">  getGrade: &#123;</span><br><span class="line">    value: function() &#123;</span><br><span class="line">      return this.grade</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="对象新增方法"><a href="#对象新增方法" class="headerlink" title="对象新增方法"></a>对象新增方法</h2><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p><code>Object.is()</code>用于比较两个值是否相等，比较两值是否相等可以使用运算符<code>==</code>或者<code>===</code>，但是<code>==</code>不严谨，会自动转换数据类型，<code>===</code>严谨，但是存在以下问题，使用<code>Object.is()</code>就可以解决该问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 &#x3D;&#x3D;&#x3D; -0 &#x2F;&#x2F; true</span><br><span class="line">NaN &#x3D;&#x3D;&#x3D; NaN &#x2F;&#x2F; false</span><br><span class="line">Object.is(0,-0) &#x2F;&#x2F; false</span><br><span class="line">Object.is(NaN,NaN) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p><code>Object.assign()</code>用于对象合并，将源对象（source，可选，一个或者多个）所有可枚举的属性复制到目标对象。<br><strong>注意：</strong>这里的复制是指拷贝属性名和对象的值，如果该属性是get（取值函数）或者set（赋值函数），拷贝的是函数执行之后返回的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const obj1 &#x3D; &#123;a:1&#125;</span><br><span class="line">const obj2 &#x3D; Object.assign(obj1) &#x2F;&#x2F; &#123;a:1&#125;</span><br><span class="line">obj2 &#x3D;&#x3D;&#x3D; obj1 &#x2F;&#x2F; true</span><br><span class="line">obj2.b &#x3D; 2 &#x2F;&#x2F; obj1&#x3D;obj2&#x3D;&#123;a:1,b:2&#125;</span><br><span class="line"></span><br><span class="line">const obj3 &#x3D; &#123;a:1,b:2&#125;</span><br><span class="line">const obj4 &#x3D; &#123;a:11,b:22,c:33&#125;</span><br><span class="line">const obj5 &#x3D; Object.assign(&#123;&#125;,obj3,obj4) &#x2F;&#x2F; &#123;a:11,b:22,c:33&#125;</span><br></pre></td></tr></table></figure>
<p>属于<strong>浅拷贝</strong>行为，如果源对象的某个属性是对象，那么目标对象里面合并的是该对象的引用，该对象数据发生变更，目标对象也会发生改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const source &#x3D; &#123;a:1,b:&#123;c:2&#125;&#125;</span><br><span class="line">const target &#x3D; Object.assign(&#123;&#125;,source) &#x2F;&#x2F; target &#x3D; &#123;a:1,b:&#123;c:2&#125;&#125;</span><br><span class="line">source.a &#x3D; 3</span><br><span class="line">source.b.c &#x3D; 4 &#x2F;&#x2F; target &#x3D; &#123;a:1,b:&#123;c:4&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如果目标对象不是对象，会先将其转为对象，像null、undefined这样不能转为对象的，会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(2) &#x2F;&#x2F; Number &#123;2&#125;</span><br><span class="line">Object.assign(null) &#x2F;&#x2F; 报错</span><br><span class="line">Object.assign(undefined) &#x2F;&#x2F; 报错</span><br><span class="line">const obj &#x3D; &#123;a:1&#125;</span><br><span class="line">Object.assign(obj,null) &#x3D;&#x3D;&#x3D; obj &#x2F;&#x2F; true</span><br><span class="line">Object.assign(obj,undefined) &#x3D;&#x3D;&#x3D; obj &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p><strong>用途：</strong>合并对象；为对象添加属性或者方法；克隆对象等等。</p>
<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p><code>Object.getOwnPropertyDescriptor()</code>返回对象指定属性的描述对象（descriptor）;<br><code>Object.getOwnPropertyDescriptors()</code>返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  foo: 123,</span><br><span class="line">  get bar() &#123; return &#39;abc&#39; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Object.getOwnPropertyDescriptor(obj,&#39;foo&#39;)</span><br><span class="line">&#x2F;&#x2F; foo:&#123;</span><br><span class="line">&#x2F;&#x2F;   configurable: true</span><br><span class="line">&#x2F;&#x2F;   enumerable: true</span><br><span class="line">&#x2F;&#x2F;   value: 123</span><br><span class="line">&#x2F;&#x2F;   writable: true</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line">Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F;   bar:&#123;</span><br><span class="line">&#x2F;&#x2F;     configurable:true,</span><br><span class="line">&#x2F;&#x2F;     enumerable:true,</span><br><span class="line">&#x2F;&#x2F;     get:[Function: get bar],</span><br><span class="line">&#x2F;&#x2F;     set:undefined,</span><br><span class="line">&#x2F;&#x2F;   &#125;,</span><br><span class="line">&#x2F;&#x2F;   foo:&#123;</span><br><span class="line">&#x2F;&#x2F;     configurable: true</span><br><span class="line">&#x2F;&#x2F;     enumerable: true</span><br><span class="line">&#x2F;&#x2F;     value: 123</span><br><span class="line">&#x2F;&#x2F;     writable: true</span><br><span class="line">&#x2F;&#x2F;   &#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>用途：</strong>解决<code>Object.assign()</code>无法正确拷贝 get 和 set 属性的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const source &#x3D; &#123;</span><br><span class="line">  set foo(value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const target1 &#x3D; &#123;&#125;;</span><br><span class="line">Object.assign(target1, source); &#x2F;&#x2F; target1&#x3D;&#123;foo:undefined&#125;</span><br><span class="line"></span><br><span class="line">const target2 &#x3D; &#123;&#125;;</span><br><span class="line">Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));</span><br><span class="line">Object.getOwnPropertyDescriptor(target2, &#39;foo&#39;)</span><br><span class="line">&#x2F;&#x2F; &#123; get: undefined,</span><br><span class="line">&#x2F;&#x2F;   set: [Function: set foo],</span><br><span class="line">&#x2F;&#x2F;   enumerable: true,</span><br><span class="line">&#x2F;&#x2F;   configurable: true &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p>每个对象都有<code>__proto__</code>属性，这个属性指向构造函数的原型对象<code>prototype</code>，我们可以通过<code>__proto__</code>这个属性来操作对象的原型对象。</p>
<p>但是这个属性前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，所以当我们想要生成、读、写原型上的方法时，尽量不使用这个属性，使用对应的方法<code>Object.create()</code>、<code>Object.getPrototypeOf()</code>、<code>Object.setPrototypeOf()</code>。</p>
<p><code>Object.setPrototypeOf(object,prototype)</code>用来设置一个对象的原型对象，返回的参数是对象本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将proto对象设为obj对象的原型，所以可以通过obj读取proto的属性</span><br><span class="line">let proto &#x3D; &#123;&#125;;</span><br><span class="line">let obj &#x3D; &#123; x: 10 &#125;;</span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line">proto.y &#x3D; 20;</span><br><span class="line">proto.z &#x3D; 40;</span><br><span class="line">obj.x &#x2F;&#x2F; 10</span><br><span class="line">obj.y &#x2F;&#x2F; 20</span><br><span class="line">obj.z &#x2F;&#x2F; 40</span><br></pre></td></tr></table></figure>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p><code>Object.getPrototypeOf()</code>用来读取对象的原型对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a&#x3D;[1,2,3]</span><br><span class="line">Object.getPrototypeOf(a) &#x3D;&#x3D;&#x3D; Array.prototype &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p><code>Object.keys()</code>返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。可以和<code>Object.values()</code>和<code>Object.entries()</code>搭配使用实现对象的循环遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;</span><br><span class="line">Object.keys(obj) &#x2F;&#x2F; [&#39;foo&#39;,&#39;baz&#39;]</span><br></pre></td></tr></table></figure>
<h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p><code>Object.values()</code>返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<p>如果入参不是对象，会先将入参转为对象，比如字符串转成数组字符串，但是数字或者布尔值的包装对象，都不会为实例添加非继承的属性。所以<code>Object.values</code>会返回空数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;</span><br><span class="line">Object.values(obj) &#x2F;&#x2F; [&#39;bar&#39;,42]</span><br><span class="line"></span><br><span class="line">Object.values(&#39;foo&#39;) &#x2F;&#x2F; [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]</span><br><span class="line">Object.values(42) &#x2F;&#x2F; []</span><br><span class="line">Object.values(true) &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>
<h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p><code>Object.entries()</code>返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;</span><br><span class="line">Object.entries(obj) &#x2F;&#x2F; [[&#39;foo&#39;,&#39;bar&#39;],[&#39;baz&#39;,42]]</span><br></pre></td></tr></table></figure>
<p><strong>用途：</strong>1、遍历对象；2、对象转Map；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 遍历对象</span><br><span class="line">let obj &#x3D; &#123; one: 1, two: 2 &#125;;</span><br><span class="line">for (let [k, v] of Object.entries(obj)) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &#96;$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;&#96;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;one&quot;: 1</span><br><span class="line">&#x2F;&#x2F; &quot;two&quot;: 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象转Map</span><br><span class="line">const obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;;</span><br><span class="line">const map &#x3D; new Map(Object.entries(obj));</span><br><span class="line">map &#x2F;&#x2F; Map(2) &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p><code>Object.fromEntries()</code>是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.fromEntries([</span><br><span class="line">  [&#39;foo&#39;, &#39;bar&#39;],</span><br><span class="line">  [&#39;baz&#39;, 42]</span><br><span class="line">])</span><br><span class="line">&#x2F;&#x2F; &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>用途：</strong>1、将 Map 结构转换成对象；2、将查询字符串转换为对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Map转对象</span><br><span class="line">const entries &#x3D; new Map([</span><br><span class="line">  [&#39;foo&#39;, &#39;bar&#39;],</span><br><span class="line">  [&#39;baz&#39;, 42]</span><br><span class="line">]);</span><br><span class="line">Object.fromEntries(entries) &#x2F;&#x2F; &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br><span class="line">const map &#x3D; new Map().set(&#39;foo&#39;, true).set(&#39;bar&#39;, false);</span><br><span class="line">Object.fromEntries(map) &#x2F;&#x2F; &#123; foo: true, bar: false &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询字符串转对象</span><br><span class="line">Object.fromEntries(new URLSearchParams(&#39;foo&#x3D;bar&amp;baz&#x3D;qux&#39;))</span><br><span class="line">&#x2F;&#x2F; &#123; foo: &quot;bar&quot;, baz: &quot;qux&quot; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><h3 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h3><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let birth &#x3D; &#39;2000&#x2F;01&#x2F;01&#39;;</span><br><span class="line">const Person &#x3D; &#123;</span><br><span class="line">  name: &#39;张三&#39;,</span><br><span class="line">  &#x2F;&#x2F;等同于birth: birth</span><br><span class="line">  birth,</span><br><span class="line">  &#x2F;&#x2F; 等同于hello: function ()...</span><br><span class="line">  hello() &#123; console.log(&#39;我的名字是&#39;, this.name); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>简写的对象方法不能用作构造函数，会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const obj&#x3D;&#123;</span><br><span class="line">    a:function()&#123;</span><br><span class="line">      console.log(111)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 函数简写</span><br><span class="line">    b()&#123;</span><br><span class="line">      console.log(222)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new obj.a())</span><br><span class="line">console.log(new obj.b())</span><br><span class="line">&#x2F;&#x2F; 111</span><br><span class="line">&#x2F;&#x2F; a &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: obj.b is not a constructor</span><br></pre></td></tr></table></figure>
<h3 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h3><p>对象的每个属性都有一个描述对象，可以用<code>Object.getOwnPrototypeDescriptor()</code>方法获取对象指定属性的描述对象，描述对象的<code>enumerable</code>属性，就是可枚举性。</p>
<p>如果<code>enumerable</code>属性为false，就表明该属性是不可枚举的，当我们使用以下四个方法操作对象的时候，会跳过不可枚举的属性：</p>
<ul>
<li>for…in循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名。</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性。</li>
<li>Object.assign()：只拷贝对象自身的可枚举的属性。</li>
</ul>
<p>所以可以利用这个不可枚举来规避for…in循环对象内部所有属性和方法的问题。比如对象的toString()方法，因为不可枚举，循坏的时候就不会循环该方法。</p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>对象有一个super关键字，代表该对象的原型对象，但是super关键字只能用在对象的方法里面，用在其他地方会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const proto &#x3D; &#123;</span><br><span class="line">  foo: &#39;hello&#39;</span><br><span class="line">&#125;</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  foo: &#39;world&#39;,</span><br><span class="line">  find() &#123;</span><br><span class="line">    return super.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Object.setPrototypeOf(obj, proto) &#x2F;&#x2F; obj 的原型对象是 proto</span><br><span class="line">obj.find() &#x2F;&#x2F; &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以下三种情况都报错</span><br><span class="line">const obj &#x3D; &#123;foo: super.foo&#125;</span><br><span class="line">const obj &#x3D; &#123;foo: () &#x3D;&gt; super.foo&#125;</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  foo: function () &#123;</span><br><span class="line">    return super.foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><code>__proto__</code>和<code>prototype</code></li>
</ol>
<ul>
<li>对象有<code>__proto__</code>属性，函数有<code>__proto__</code>属性，数组也有<code>__proto__</code>属性，只要是引用类型，就有<code>__proto__</code>属性，指向其原型。</li>
<li>只有函数有<code>prototype</code>属性，只有函数有<code>prototype</code>属性，只有函数有<code>prototype</code>属性，指向new操作符加调用该函数创建的对象实例的原型对象。</li>
</ul>
<ol start="2">
<li><code>instanceof</code><br>判断数据类型，可以使用<code>typeof</code>运算符，但是引用数据类型并不适用，除了函数返回的是<code>function</code>，其他返回的全是<code>object</code>。我们想要知道一个对象的具体类型，就需要使用到<code>instanceof</code>。<code>instanceof</code>的实际原理就是判断右侧的<code>prototype</code>是否在左侧对象的原型链上。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例：函数对象和数组对象最终的原型链顶层就是Object</span><br><span class="line">let fn &#x3D; function() &#123;&#125;</span><br><span class="line">let arr &#x3D; []</span><br><span class="line">fn instanceof Function &#x2F;&#x2F; true</span><br><span class="line">arr instanceof Array &#x2F;&#x2F; true</span><br><span class="line">fn instanceof Object &#x2F;&#x2F; true</span><br><span class="line">arr instanceof Object &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 手动实现instanceof</span><br><span class="line">var myInstanceof &#x3D; function(target,origin)&#123;</span><br><span class="line">  const proto &#x3D; target.__proto__</span><br><span class="line">  if(proto)&#123;</span><br><span class="line">    if(origin.prototype &#x3D;&#x3D;&#x3D; proto)&#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      return myInstanceof(proto,origin)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如何创建一个没有原型的对象？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const tempObj &#x3D; Object.create(null)</span><br><span class="line">console.log(tempObj.__proto__) &#x2F;&#x2F; undefined</span><br><span class="line">&#x2F;&#x2F; Object.create的第一个入参只能是null或者非原始包装对象，否则会抛出异常</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>在JavaScript中，生成实例对象的传统写法是通过构造函数，但是这种写法和面向对象的传统编程语言差异很大，为了更接近传统语言，引入 Class 类，类可以看作是构造函数的另一种写法。</p>
<p><strong>类所有的属性和方法，都定义在类的prototype属性上面</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 传统写法</span><br><span class="line">function Point1(x, y) &#123;</span><br><span class="line">  this.x &#x3D; x;</span><br><span class="line">  this.y &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line">Point1.prototype.toString &#x3D; function () &#123;</span><br><span class="line">  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">&#125;;</span><br><span class="line">var p1 &#x3D; new Point1(1, 2);</span><br><span class="line">&#x2F;&#x2F; Class 写法</span><br><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const p &#x3D; new Point(1,2)</span><br><span class="line">&#x2F;&#x2F; 类可以看作是构造函数的另一种写法</span><br><span class="line">Point &#x3D;&#x3D;&#x3D; Point.prototype.constructor &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 类所有的属性和方法，都定义在类的prototype属性上面</span><br><span class="line">p.constructor &#x3D;&#x3D;&#x3D; Point.prototype.constructor &#x2F;&#x2F; true</span><br><span class="line">p.hasOwnProperty(&#39;x&#39;) &#x2F;&#x2F; true</span><br><span class="line">p.hasOwnProperty(&#39;y&#39;) &#x2F;&#x2F; true</span><br><span class="line">p.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; false</span><br><span class="line">p.__proto__.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p><code>constructor()</code>类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的constructor()方法会被默认添加。</p>
<p><code>constructor()</code>方法默认返回实例对象（即this）</p>
<h2 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h2><h3 id="实例属性新写法"><a href="#实例属性新写法" class="headerlink" title="实例属性新写法"></a>实例属性新写法</h3><p>属性除了可以定义在<code>constructor()</code>里的<code>this</code>上，还可以定义在类内部的最顶层。虽然写法不一样，但是都是指向实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  &#x2F;&#x2F; 新写法</span><br><span class="line">  x &#x3D; 0</span><br><span class="line">  y &#x3D; 0</span><br><span class="line">  &#x2F;&#x2F; 旧写法</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="取值函数-getter-和存值函数-setter"><a href="#取值函数-getter-和存值函数-setter" class="headerlink" title="取值函数(getter)和存值函数(setter)"></a>取值函数(getter)和存值函数(setter)</h3><p>类可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置取值函数和存值函数，拦截该属性的存取行为。<br>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;&#125;</span><br><span class="line">  get num() &#123;</span><br><span class="line">    return &#39;getter&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  set num(value) &#123;</span><br><span class="line">    console.log(&#39;setter:&#39;+value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const p &#x3D; new Point()</span><br><span class="line">p.num &#x3D; 1 &#x2F;&#x2F; setter:1</span><br><span class="line">p.num &#x2F;&#x2F; getter</span><br><span class="line">const desc &#x3D; Object.getOwnPropertyDescriptor(Point.prototype,&#39;num&#39;)</span><br><span class="line">&#39;get&#39; in desc &#x2F;&#x2F; true</span><br><span class="line">&#39;set&#39; in desc &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h3 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h3><p>静态属性和方法，就是在属性和方法前面加上<code>static</code>关键字，表示该属性和方法<strong>不会被实例继承</strong>，但是会被子类继承，可以直接通过类来操作。</p>
<p>静态方法里面的this，指向类，而不是实例。</p>
<p>静态方法可以和非静态方法重名，静态方法可以从<code>super</code>对象上调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static prop &#x3D; 1; &#x2F;&#x2F; 静态属性</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    return &#39;hello&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  static bar() &#123;</span><br><span class="line">    this.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  static baz() &#123;</span><br><span class="line">    console.log(&#39;hello&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  baz() &#123;   &#x2F;&#x2F; 静态方法可以和非静态方法重名</span><br><span class="line">    console.log(&#39;world&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() &#x2F;&#x2F; &#39;hello&#39; 静态方法通过类来操作</span><br><span class="line"></span><br><span class="line">var foo &#x3D; new Foo();</span><br><span class="line">foo.classMethod() &#x2F;&#x2F; 静态方法不会被实例继承</span><br><span class="line">&#x2F;&#x2F; TypeError: foo.classMethod is not a function</span><br><span class="line"></span><br><span class="line">Foo.bar() &#x2F;&#x2F; hello 静态方法里的this指向类</span><br><span class="line"></span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">  static classMethod2() &#123;</span><br><span class="line">    return super.classMethod() + &#39;, too&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() &#x2F;&#x2F; &#39;hello&#39; 静态方法可以被子类继承</span><br><span class="line">Bar.classMethod(2) &#x2F;&#x2F; &#39;hello, too&#39; 静态方法可以用super对象调用</span><br></pre></td></tr></table></figure>
<h3 id="私有属性和方法"><a href="#私有属性和方法" class="headerlink" title="私有属性和方法"></a>私有属性和方法</h3><p>私有属性和方法，就是在属性和方法前面加上<code>#</code>，表示该属性和方法<strong>只能在类的内部使用</strong>。</p>
<p>私有属性和方法<strong>不能被子类继承</strong>。</p>
<p>私有属性也可以设置 getter 和 setter 函数进行操作拦截。</p>
<h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><p>类可以通过<code>extends</code>关键字实现继承，让子类继承父类的所有属性和方法，除了私有属性和方法。</p>
<p><strong>子类必须在<code>constructor()</code>方法中先调用<code>super()</code>，否则会报错。</strong><br>这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用super()方法，子类就得不到自己的this对象。</p>
<p><code>super()</code>作为函数，表示父类的构造函数，只能在子类的<code>constructor()</code>里使用，被调用的时候用来创建一个父类的实例，但是返回的是子类的实例。<br><code>super</code>作为对象，在普通方法里，指向父类的原型对象；在静态方法里，指向父类。</p>
<p>如果子类没有显示的定义<code>constructor()</code>，这个方法默认添加，并且里面会调用<code>super()</code>。</p>
<p>可以使用<code>Object.getPrototypeOf()</code>来获取子类的父类。</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>Set，它类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成 Set 数据结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const s &#x3D; new Set();</span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].forEach(x &#x3D;&gt; s.add(x));</span><br><span class="line">for (let i of s) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 2 3 5 4</span><br><span class="line"></span><br><span class="line">const set &#x3D; new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...set]</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 去除数组的重复成员</span><br><span class="line">const array&#x3D;[1,1,2,2,3,3]</span><br><span class="line">&#x2F;&#x2F; 方法一：</span><br><span class="line">[...new Set(array)]</span><br><span class="line">&#x2F;&#x2F; 方法二：该方法可将Set转换成数组</span><br><span class="line">Array.from(new Set(array))</span><br><span class="line">&#x2F;&#x2F; [1,2,3]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 去除字符串的重复字符</span><br><span class="line">[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)</span><br><span class="line">&#x2F;&#x2F; &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;'>
往 Set 里面加值的时候，内部判断两值是否相等的算法，叫做“Same-value-zero equality”，它类似于精确相等运算符（`===`），区别就在于向 Set 加入值时认为NaN等于自身（即不能添加两个NaN），而精确相等运算符认为NaN不等于自身。
</div>

<h2 id="实例属性-size"><a href="#实例属性-size" class="headerlink" title="实例属性-size"></a>实例属性-size</h2><p><code>Set.prototype.size</code>：返回Set实例的成员总数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.add(1).add(2).add(2);</span><br><span class="line">&#x2F;&#x2F; 注意2被加入了两次</span><br><span class="line"></span><br><span class="line">s.size &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<h2 id="实例操作方法-add-delete-has-clear"><a href="#实例操作方法-add-delete-has-clear" class="headerlink" title="实例操作方法-add/delete/has/clear"></a>实例操作方法-add/delete/has/clear</h2><ul>
<li><code>Set.property.add()</code>：添加某个值，返回 Set 结构本身。</li>
<li><code>Set.property.delete()</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>Set.property.has()</code>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><code>Set.property.clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s.add(1).add(2).add(2);</span><br><span class="line">&#x2F;&#x2F; 注意2被加入了两次</span><br><span class="line"></span><br><span class="line">s.size &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">s.has(1) &#x2F;&#x2F; true</span><br><span class="line">s.has(2) &#x2F;&#x2F; true</span><br><span class="line">s.has(3) &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">s.delete(2); &#x2F;&#x2F; true-表示删除成功</span><br><span class="line">s.has(2) &#x2F;&#x2F; false</span><br><span class="line">s.clear() &#x2F;&#x2F; 清空，无返回值</span><br></pre></td></tr></table></figure>

<h2 id="实例遍历方法-keys-values-entries-forEach"><a href="#实例遍历方法-keys-values-entries-forEach" class="headerlink" title="实例遍历方法-keys/values/entries/forEach"></a>实例遍历方法-keys/values/entries/forEach</h2><ul>
<li><code>Set.prototype.keys()</code>：返回键名的遍历器。</li>
<li><code>Set.prototype.values()</code>：返回键值的遍历器。</li>
<li><code>Set.prototype.entries()</code>：返回键值对的遍历器。</li>
<li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员。</li>
</ul>
<p>keys方法、values方法、entries方法返回的都是遍历器对象。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致，entries方法同时包含键名和键值，键名和键值一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let set &#x3D; new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);</span><br><span class="line"></span><br><span class="line">for (let item of set.keys()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; red</span><br><span class="line">&#x2F;&#x2F; green</span><br><span class="line">&#x2F;&#x2F; blue</span><br><span class="line"></span><br><span class="line">for (let item of set.values()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; red</span><br><span class="line">&#x2F;&#x2F; green</span><br><span class="line">&#x2F;&#x2F; blue</span><br><span class="line"></span><br><span class="line">for (let item of set.entries()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [&quot;red&quot;, &quot;red&quot;]</span><br><span class="line">&#x2F;&#x2F; [&quot;green&quot;, &quot;green&quot;]</span><br><span class="line">&#x2F;&#x2F; [&quot;blue&quot;, &quot;blue&quot;]</span><br><span class="line"></span><br><span class="line">set.forEach((value, key) &#x3D;&gt; console.log(key + &#39; : &#39; + value))</span><br><span class="line">&#x2F;&#x2F; red : red</span><br><span class="line">&#x2F;&#x2F; green : green</span><br><span class="line">&#x2F;&#x2F; blue : blue</span><br></pre></td></tr></table></figure>
<p><strong>Set 实例默认可遍历，它的默认遍历器生成函数就是它的values方法，所以可以省略values方法，直接使用<code>for...of</code>遍历</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 下面两种用法一致</span><br><span class="line">for (let item of set.values()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">for (let item of set) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。它与 Set 区别如下：</p>
<ul>
<li>WeakSet 的成员只能是对象，而不能是其他类型的值；Set 可以是任意类型。</li>
<li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</li>
<li>WeakSet 只有 <code>add()/delete()/has()</code> 方法，不支持<code>clear()</code>、<code>size</code>属性和遍历方法。</li>
</ul>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h2><p>Map，它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将对象作为键</span><br><span class="line">const m &#x3D; new Map();</span><br><span class="line">const o &#x3D; &#123;p: &#39;Hello World&#39;&#125;;</span><br><span class="line">m.set(o, &#39;content&#39;)</span><br><span class="line">&#x2F;&#x2F; 接受数组作为参数，数组的成员是一个个键值对的数组</span><br><span class="line">const map &#x3D; new Map([</span><br><span class="line">  [&#39;name&#39;, &#39;张三&#39;],</span><br><span class="line">  [&#39;title&#39;, &#39;Author&#39;]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<h2 id="实例属性-size-1"><a href="#实例属性-size-1" class="headerlink" title="实例属性-size"></a>实例属性-size</h2><p><code>Map.property.size</code>：返回Map实例的成员总数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const map &#x3D; new Map();</span><br><span class="line">map.set(&#39;foo&#39;, true);</span><br><span class="line">map.set(&#39;bar&#39;, false);</span><br><span class="line"></span><br><span class="line">map.size &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<h2 id="实例操作方法-set-get-has-delete-clear"><a href="#实例操作方法-set-get-has-delete-clear" class="headerlink" title="实例操作方法-set/get/has/delete/clear"></a>实例操作方法-set/get/has/delete/clear</h2><ul>
<li><code>Map.prototype.set(key, value)</code>：set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</li>
<li><code>Map.prototype.get(key)</code>：get方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li><code>Map.prototype.has(key)</code>：has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>
<li><code>Map.prototype.delete(key)</code>：delete方法删除某个键，返回true。如果删除失败，返回false。</li>
<li><code>Map.prototype.clear()</code>：clear方法清除所有成员，没有返回值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const m &#x3D; new Map();</span><br><span class="line"></span><br><span class="line">m.set(&#39;edition&#39;, 6)        &#x2F;&#x2F; 键是字符串</span><br><span class="line">m.set(262, &#39;standard&#39;)     &#x2F;&#x2F; 键是数值</span><br><span class="line">m.set(undefined, &#39;nah&#39;)    &#x2F;&#x2F; 键是 undefined</span><br><span class="line">m.set(1,&#39;1&#39;).set(2,&#39;2&#39;)    &#x2F;&#x2F; set返回的是当前Map对象，所以可以采用链式写法</span><br><span class="line">m.set(1,&#39;一&#39;)</span><br><span class="line">m.get(1)  &#x2F;&#x2F; 一 key已经存在，重复赋值键值会被更新</span><br><span class="line">m.set([&#39;aaa&#39;],1)</span><br><span class="line">m.get([&#39;aaa&#39;]) &#x2F;&#x2F; undefined </span><br><span class="line">&#x2F;&#x2F; 如果键是引用数据类型，那么set和get表面上针对的是同一个键，但是键的内存地址不同，所以get方法无法读物键值，返回undefined</span><br><span class="line">const k1 &#x3D; [&#39;a&#39;]</span><br><span class="line">const k2 &#x3D; [&#39;a&#39;]</span><br><span class="line">m.set(k1,1).set(k2,2)</span><br><span class="line">m.get(k1) &#x2F;&#x2F; 1</span><br><span class="line">m.get(k2) &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">m.has(&#39;edition&#39;) &#x2F;&#x2F; true</span><br><span class="line">m.has(11111) &#x2F;&#x2F; false</span><br><span class="line">m.delete(262) &#x2F;&#x2F; true</span><br><span class="line">m.get(262) &#x2F;&#x2F; undefined</span><br><span class="line">m.clear()</span><br><span class="line">m.size &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>
<h2 id="实例遍历方法-keys-values-entries-forEach-1"><a href="#实例遍历方法-keys-values-entries-forEach-1" class="headerlink" title="实例遍历方法-keys/values/entries/forEach"></a>实例遍历方法-keys/values/entries/forEach</h2><ul>
<li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li>
<li><code>Map.prototype.values()</code>：返回键值的遍历器。</li>
<li><code>Map.prototype.entries()</code>：返回键值对的遍历器。</li>
<li><code>Map.prototype.forEach()</code>：使用回调函数遍历每个成员。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">const map &#x3D; new Map([</span><br><span class="line">  [&#39;F&#39;, &#39;no&#39;],</span><br><span class="line">  [&#39;T&#39;,  &#39;yes&#39;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">for (let key of map.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot;</span><br><span class="line">[...map.keys()]</span><br><span class="line">&#x2F;&#x2F; [&quot;F&quot;,&quot;T&quot;]</span><br><span class="line"></span><br><span class="line">for (let value of map.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;yes&quot;</span><br><span class="line">[...map.values()]</span><br><span class="line">&#x2F;&#x2F; [&quot;no&quot;,&quot;yes&quot;]</span><br><span class="line"></span><br><span class="line">for (let item of map.entries()) &#123;</span><br><span class="line">  console.log(item[0], item[1]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot; &quot;yes&quot;</span><br><span class="line">[...map.entries()]</span><br><span class="line">&#x2F;&#x2F; [[&quot;F&quot;,&quot;no&quot;],[&quot;T&quot;,&quot;yes&quot;]]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">for (let [key, value] of map.entries()) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot; &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于使用map.entries()</span><br><span class="line">for (let [key, value] of map) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot; &quot;yes&quot;</span><br><span class="line">[...map]</span><br><span class="line">&#x2F;&#x2F; [[&quot;F&quot;,&quot;no&quot;],[&quot;T&quot;,&quot;yes&quot;]]</span><br><span class="line"></span><br><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; Key: F, Value: no</span><br><span class="line">&#x2F;&#x2F; Key: T, Value: yes</span><br></pre></td></tr></table></figure>
<h2 id="数据结构相互转化"><a href="#数据结构相互转化" class="headerlink" title="数据结构相互转化"></a>数据结构相互转化</h2><ul>
<li>Map &lt;==&gt; 数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Map 转 数组，使用扩展运算符(...)</span><br><span class="line">const myMap &#x3D; new Map().set(true, 7).set(&#123;foo: 3&#125;, [&#39;abc&#39;]);</span><br><span class="line">[...myMap]</span><br><span class="line">&#x2F;&#x2F; [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#39;abc&#39; ] ] ]</span><br><span class="line">&#x2F;&#x2F; 数组 转 Map，将数组传入Map构造函数即可</span><br><span class="line">new Map([</span><br><span class="line">  [true, 7],</span><br><span class="line">  [&#123;foo: 3&#125;, [&#39;abc&#39;]]</span><br><span class="line">])</span><br></pre></td></tr></table></figure></li>
<li>Map &lt;==&gt; 对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Map 转 对象，如果键是字符串可以无损转化，不是的话会被转成字符串</span><br><span class="line">function strMapToObj(strMap) &#123;</span><br><span class="line">  let obj &#x3D; Object.create(null);</span><br><span class="line">  for (let [k,v] of strMap) &#123;</span><br><span class="line">    obj[k] &#x3D; v;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 对象 转 Map，使用 Object.entries() 最方便</span><br><span class="line">let obj &#x3D; &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;</span><br><span class="line">let map &#x3D; new Map(Object.entries(obj));</span><br><span class="line">&#x2F;&#x2F; 也可以自己手写函数</span><br><span class="line">function objToStrMap(obj) &#123;</span><br><span class="line">  let strMap &#x3D; new Map();</span><br><span class="line">  for (let k of Object.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  return strMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p>WeakMap 与 Map 类似，都是用于生成键值对的集合。它与 Map 区别如下：</p>
<ul>
<li>WeakMap 只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li>
<li>WeakMap 的键名所指向的对象，不计入垃圾回收机制。<br>它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用<strong>手动删除</strong>引用。</li>
<li>WeakMap 只有 <code>set()/get()/delete()/has()</code> 方法，不支持<code>clear()</code>、<code>size</code>属性和遍历方法。</li>
</ul>
<h1 id="ES6新增运算符"><a href="#ES6新增运算符" class="headerlink" title="ES6新增运算符"></a>ES6新增运算符</h1><h2 id="指数运算符"><a href="#指数运算符" class="headerlink" title="** 指数运算符"></a>** 指数运算符</h2><p>当有多个指数运算符的时候，从最右边开始计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 5</span><br><span class="line">a ** 3 &#x2F;&#x2F; 5*5*5 &#x3D; 125</span><br><span class="line">&#x2F;&#x2F; 右结合</span><br><span class="line">2 ** 3 ** 2 &#x2F;&#x2F; 2**(3**2) 先计算3*3等于9，再计算2^9等于512</span><br><span class="line">a **&#x3D; 3 &#x2F;&#x2F; a&#x3D;a**3&#x3D;a*a*a</span><br></pre></td></tr></table></figure>
<h2 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="?. 链判断运算符"></a>?. 链判断运算符</h2><p>直接访问对象上的某个属性，如<code>obj.a</code>，如果obj是null或者undefined，访问属性的话会报错。</p>
<p><code>?.</code>链判断运算符会判断左侧对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj ?. a</span><br><span class="line">obj ? obj.a : undefined</span><br></pre></td></tr></table></figure>
<h2 id="Null判断运算符"><a href="#Null判断运算符" class="headerlink" title="?? Null判断运算符"></a>?? Null判断运算符</h2><p>行为类似<code>||</code>，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值，否则返回左侧的值。<br><code>||</code>会在左操作数为假值（0,null,undefined,’’,NAN）时返回右侧的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const a &#x3D; 0</span><br><span class="line">const b &#x3D; a ?? 1 &#x2F;&#x2F; b&#x3D;0</span><br><span class="line">const c &#x3D; a || 1 &#x2F;&#x2F; b&#x3D;1</span><br></pre></td></tr></table></figure>

<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>Proxy 代理器，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var proxy &#x3D; new Proxy(target, handler)</span><br></pre></td></tr></table></figure>
<ul>
<li>target 参数表示所要拦截的目标对象</li>
<li>handler参数也是一个对象，用来定制拦截行为，具体拦截方法如下：<ul>
<li><code>get()</code>：用于拦截某个属性的读取操作</li>
<li><code>set()</code>：用于拦截某个属性的赋值操作</li>
<li><code>has()</code>：用于拦截判断对象是否具有某个属性的操作</li>
<li><code>apply()</code>：用于拦截函数的调用、call和apply操作</li>
<li><code>construct()</code>：用于拦截 new 操作</li>
<li><code>defineProperty()</code>：用于拦截添加属性操作</li>
<li><code>deleteProperty()</code>：用于拦截 delete 操作</li>
<li><code>setPrototypeOf()</code>：用于拦截设置对象的原型对象的操作，如<code>Object.setPrototypeOf()</code></li>
<li><code>getPrototypeOf()</code>：用于拦截读取对象的原型对象的操作，如<code>Object.getPrototypeOf()</code>等</li>
<li><code>ownKeys()</code>：用于拦截对象自身属性的读取的操作，如<code>Object.keys()</code>等</li>
<li><code>getOwnPropertyDescriptor()</code>：用于拦截取对象指定属性描述对象的操作，如<code>Object.getOwnPropertyDescriptor()</code></li>
<li><code>isExtensible()</code>：用于拦截判断对象是否可扩展（是否可以添加属性）的操作，如<code>Object.isExtensible()</code></li>
<li><code>preventExtensions()</code>：用于拦截将对象变得不可扩展的操作，如<code>Object.preventExtensions()</code></li>
</ul>
</li>
</ul>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;'>
如果想要 Proxy 起作用，必须针对 Proxy 的实例进行操作，而不是针对目标对象 target 进行操作。
除非 handler 没有设置任何拦截行为，访问 Proxy 实例就相当于访问目标对象 target。
</div>

<h2 id="拦截方法"><a href="#拦截方法" class="headerlink" title="拦截方法"></a>拦截方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p><code>get(target, propKey, receiver)</code>：用于拦截某个属性的读取操作，接受三个参数，依次为目标对象、属性名和 proxy 实例本身，最后一个参数可选。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果访问目标对象不存在的属性，会抛出一个错误。</span><br><span class="line">&#x2F;&#x2F; 如果没有这个拦截函数，访问不存在的属性，只会返回undefined。</span><br><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name: &quot;张三&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var proxy &#x3D; new Proxy(person, &#123;</span><br><span class="line">  get: function(target, propKey) &#123;</span><br><span class="line">    if (propKey in target) &#123;</span><br><span class="line">      return target[propKey];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new ReferenceError(&quot;Prop name \&quot;&quot; + propKey + &quot;\&quot; does not exist.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name &#x2F;&#x2F; &quot;张三&quot;</span><br><span class="line">proxy.age &#x2F;&#x2F; 抛出一个错误</span><br></pre></td></tr></table></figure>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><code>set(target, propKey, value, receiver)</code>：用于拦截某个属性的赋值操作，接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。</span><br><span class="line">const handler &#x3D; &#123;</span><br><span class="line">  get (target, key) &#123;</span><br><span class="line">    invariant(key, &#39;get&#39;);</span><br><span class="line">    return target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, key, value) &#123;</span><br><span class="line">    invariant(key, &#39;set&#39;);</span><br><span class="line">    target[key] &#x3D; value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function invariant (key, action) &#123;</span><br><span class="line">  if (key[0] &#x3D;&#x3D;&#x3D; &#39;_&#39;) &#123;</span><br><span class="line">    throw new Error(&#96;Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const target &#x3D; &#123;&#125;;</span><br><span class="line">const proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">proxy._prop</span><br><span class="line">&#x2F;&#x2F; Error: Invalid attempt to get private &quot;_prop&quot; property</span><br><span class="line">proxy._prop &#x3D; &#39;c&#39;</span><br><span class="line">&#x2F;&#x2F; Error: Invalid attempt to set private &quot;_prop&quot; property</span><br></pre></td></tr></table></figure>
<h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><p><code>has(target, propKey)</code>：用于拦截判断对象是否具有某个属性的操作，典型的操作就是in运算符，返回布尔值。接受两个参数，分别是目标对象、需查询的属性名。</p>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:10px;'>
has()方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has()方法不判断一个属性是对象自身的属性，还是继承的属性。
</div>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:10px;'>
虽然for...in循环也用到了in运算符，但是has()拦截对for...in循环不生效。
</div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">let stu1 &#x3D; &#123;name: &#39;张三&#39;, score: 59&#125;;</span><br><span class="line">let stu2 &#x3D; &#123;name: &#39;李四&#39;, score: 99&#125;;</span><br><span class="line"></span><br><span class="line">let handler &#x3D; &#123;</span><br><span class="line">  has(target, prop) &#123;</span><br><span class="line">    if (prop &#x3D;&#x3D;&#x3D; &#39;score&#39; &amp;&amp; target[prop] &lt; 60) &#123;</span><br><span class="line">      console.log(&#96;$&#123;target.name&#125; 不及格&#96;);</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return prop in target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let oproxy1 &#x3D; new Proxy(stu1, handler);</span><br><span class="line">let oproxy2 &#x3D; new Proxy(stu2, handler);</span><br><span class="line"></span><br><span class="line">&#39;score&#39; in oproxy1</span><br><span class="line">&#x2F;&#x2F; 张三 不及格</span><br><span class="line">&#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#39;score&#39; in oproxy2</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">for (let a in oproxy1) &#123;</span><br><span class="line">  console.log(oproxy1[a]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 张三</span><br><span class="line">&#x2F;&#x2F; 59</span><br><span class="line"></span><br><span class="line">for (let b in oproxy2) &#123;</span><br><span class="line">  console.log(oproxy2[b]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 李四</span><br><span class="line">&#x2F;&#x2F; 99</span><br></pre></td></tr></table></figure>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p><code>apply(target, object, args)</code>：用于拦截函数的调用、call和apply操作，接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截。</span><br><span class="line">var twice &#x3D; &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    return Reflect.apply(...arguments) * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function sum (left, right) &#123;</span><br><span class="line">  return left + right;</span><br><span class="line">&#125;;</span><br><span class="line">var proxy &#x3D; new Proxy(sum, twice);</span><br><span class="line">proxy(1, 2) &#x2F;&#x2F; 6</span><br><span class="line">proxy.call(null, 5, 6) &#x2F;&#x2F; 22</span><br><span class="line">proxy.apply(null, [7, 8]) &#x2F;&#x2F; 30</span><br></pre></td></tr></table></figure>
<h3 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h3><p><code>construct(terget, args, newTarget)</code>：用于拦截 new 操作，接受三个参数，依次是目标对象、构造函数的参数数组、创造实例对象时，new命令作用的构造函数（下面例子的p）。</p>
<p><strong>目标对象必须是函数，否则会报错</strong><br><strong><code>construct()</code>方法必须返回对象，否则报错</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const p &#x3D; new Proxy(function () &#123;&#125;, &#123;</span><br><span class="line">  construct: function(target, args) &#123;</span><br><span class="line">    console.log(&#39;called: &#39; + args.join(&#39;, &#39;));</span><br><span class="line">    return &#123; value: args[0] * 10 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(new p(1)).value</span><br><span class="line">&#x2F;&#x2F; &quot;called: 1&quot;</span><br><span class="line">&#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">const p1 &#x3D; new Proxy(function() &#123;&#125;, &#123;</span><br><span class="line">  construct: function(target, argumentsList) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new p1() &#x2F;&#x2F; 报错 construct必须返回对象</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: &#39;construct&#39; on proxy: trap returned non-object (&#39;1&#39;)</span><br><span class="line"></span><br><span class="line">const p2 &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  construct: function(target, argumentsList) &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new p2() &#x2F;&#x2F; 报错 目标对象必须是函数</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: p is not a constructor</span><br></pre></td></tr></table></figure>
<h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h3><p><code>defineProperty(target, propKey, propDesc)</code>：用于拦截添加属性操作，如<code>Object.defineProperty()</code>，接受三个参数，依次是目标对象、要添加的属性和其描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var handler &#x3D; &#123;</span><br><span class="line">  defineProperty (target, key, descriptor) &#123;</span><br><span class="line">    return false; &#x2F;&#x2F; 返回布尔值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target &#x3D; &#123;&#125;;</span><br><span class="line">var proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">proxy.foo &#x3D; &#39;bar&#39; &#x2F;&#x2F; 不会生效</span><br></pre></td></tr></table></figure>
<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty"></a>deleteProperty</h3><p><code>deleteProperty(target, propKey)</code>：用于拦截 delete 删除属性的操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除第一个字符为下划线的属性会报错。</span><br><span class="line">var handler &#x3D; &#123;</span><br><span class="line">  deleteProperty (target, key) &#123;</span><br><span class="line">    invariant(key, &#39;delete&#39;);</span><br><span class="line">    delete target[key];</span><br><span class="line">    return true; &#x2F;&#x2F; 返回布尔值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function invariant (key, action) &#123;</span><br><span class="line">  if (key[0] &#x3D;&#x3D;&#x3D; &#39;_&#39;) &#123;</span><br><span class="line">    throw new Error(&#96;Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var target &#x3D; &#123; _prop: &#39;foo&#39; &#125;;</span><br><span class="line">var proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">delete proxy._prop</span><br><span class="line">&#x2F;&#x2F; Error: Invalid attempt to delete private &quot;_prop&quot; property</span><br></pre></td></tr></table></figure>
<h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf"></a>setPrototypeOf</h3><p><code>setPrototypeOf(target, proto)</code>：用于拦截设置对象的原型对象的操作，如<code>Object.setPrototypeOf()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var handler &#x3D; &#123;</span><br><span class="line">  setPrototypeOf (target, proto) &#123;</span><br><span class="line">    throw new Error(&#39;Changing the prototype is forbidden&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var proto &#x3D; &#123;&#125;;</span><br><span class="line">var target &#x3D; function () &#123;&#125;;</span><br><span class="line">var proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">Object.setPrototypeOf(proxy, proto);</span><br><span class="line">&#x2F;&#x2F; Error: Changing the prototype is forbidden</span><br></pre></td></tr></table></figure>
<h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf"></a>getPrototypeOf</h3><p><code>getPrototypeOf(target)</code>：用于拦截读取对象的原型对象的操作。如：</p>
<ul>
<li><code>Object.prototype.__proto__</code></li>
<li><code>Object.prototype.isPrototypeOf()</code></li>
<li><code>Object.getPrototypeOf()</code></li>
<li><code>Reflect.getPrototypeOf()</code></li>
<li><code>instanceof</code></li>
</ul>
<p><strong><code>getPrototypeOf()</code>的返回值必须是对象或者null，否则报错</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var proto &#x3D; &#123;&#125;;</span><br><span class="line">var p &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  getPrototypeOf(target) &#123;</span><br><span class="line">    return proto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.getPrototypeOf(p) &#x3D;&#x3D;&#x3D; proto &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h3><p><code>ownKeys(target)</code>：用于拦截对象自身属性的读取的操作，如：</p>
<ul>
<li><code>Object.getOwnPropertyNames()</code></li>
<li><code>Object.getOwnPropertySymbols()</code></li>
<li><code>Object.keys()</code></li>
<li><code>for.....in</code>循环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let target &#x3D; &#123;</span><br><span class="line">  _bar: &#39;foo&#39;,</span><br><span class="line">  _prop: &#39;bar&#39;,</span><br><span class="line">  prop: &#39;baz&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let handler &#x3D; &#123;</span><br><span class="line">  ownKeys (target) &#123;</span><br><span class="line">    return Reflect.ownKeys(target).filter(key &#x3D;&gt; key[0] !&#x3D;&#x3D; &#39;_&#39;); &#x2F;&#x2F; 返回满足条件的keys数组</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">for (let key of Object.keys(proxy)) &#123;</span><br><span class="line">  console.log(target[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;baz&quot;</span><br></pre></td></tr></table></figure>
<h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor"></a>getOwnPropertyDescriptor</h3><p><code>getOwnPropertyDescriptor(target, propKey)</code>：用于拦截取对象指定属性描述对象的操作，如<code>Object.getOwnPropertyDescriptor()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var handler &#x3D; &#123;</span><br><span class="line">  getOwnPropertyDescriptor (target, key) &#123;</span><br><span class="line">    if (key[0] &#x3D;&#x3D;&#x3D; &#39;_&#39;) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    return Object.getOwnPropertyDescriptor(target, key); &#x2F;&#x2F; 返回描述对象</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target &#x3D; &#123; _foo: &#39;bar&#39;, baz: &#39;tar&#39; &#125;;</span><br><span class="line">var proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, &#39;wat&#39;)</span><br><span class="line">&#x2F;&#x2F; undefined</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, &#39;_foo&#39;)</span><br><span class="line">&#x2F;&#x2F; undefined</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, &#39;baz&#39;)</span><br><span class="line">&#x2F;&#x2F; &#123; value: &#39;tar&#39;, writable: true, enumerable: true, configurable: true &#125;</span><br></pre></td></tr></table></figure>
<h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible"></a>isExtensible</h3><p><code>isExtensible(target)</code>：用于拦截判断对象是否可扩展（是否可以添加属性）的操作，如<code>Object.isExtensible()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: function(target) &#123;</span><br><span class="line">    console.log(&quot;called&quot;);</span><br><span class="line">    return true; &#x2F;&#x2F; 返回布尔值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.isExtensible(p)</span><br><span class="line">&#x2F;&#x2F; &quot;called&quot;</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions"></a>preventExtensions</h3><p><code>preventExtensions(target)</code>：用于拦截将对象变得不可扩展的操作，如<code>Object.preventExtensions()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var proxy &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: function(target) &#123;</span><br><span class="line">    console.log(&#39;called&#39;);</span><br><span class="line">    Object.preventExtensions(target); &#x2F;&#x2F; 如果没有这步操作，会报错</span><br><span class="line">    return true; &#x2F;&#x2F; 返回布尔值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.preventExtensions(proxy)</span><br><span class="line">&#x2F;&#x2F; &quot;called&quot;</span><br><span class="line">&#x2F;&#x2F; Proxy &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h2><p><code>Proxy.revocable(target,handler)</code>方法返回一个可取消的 Proxy 实例，主要使用场景是：目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let target &#x3D; &#123;&#125;;</span><br><span class="line">let handler &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">let &#123;proxy, revoke&#125; &#x3D; Proxy.revocable(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo &#x3D; 123;</span><br><span class="line">proxy.foo &#x2F;&#x2F; 123</span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo &#x2F;&#x2F; TypeError: Revoked</span><br></pre></td></tr></table></figure>
<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p>在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const target &#x3D; &#123;</span><br><span class="line">  m: function () &#123;</span><br><span class="line">    console.log(this &#x3D;&#x3D;&#x3D; proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const handler &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">const proxy &#x3D; new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">target.m() &#x2F;&#x2F; false</span><br><span class="line">proxy.m()  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><p>Reflect 和 Proxy 一样，也是用来操作对象，不同点在于：</p>
<ul>
<li>将 Object 对象的内部方法放到 Reflect 对象上，目前某些方法 Object 和 Reflect 都部署了，未来只会在 Reflect 上部署。</li>
<li>修改某些 Object 方法的返回值，让其合理，比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回false。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 老写法</span><br><span class="line">try &#123;</span><br><span class="line">  Object.defineProperty(target, property, attributes);</span><br><span class="line">  &#x2F;&#x2F; success</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  &#x2F;&#x2F; failure</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新写法</span><br><span class="line">if (Reflect.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  &#x2F;&#x2F; success</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; failure</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>让 Object 的命令式操作变成函数行为。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 老写法</span><br><span class="line">&#39;assign&#39; in Object &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新写法</span><br><span class="line">Reflect.has(Object, &#39;assign&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li>
<li>Reflect 对象的方法和 Proxy 对象的13中拦截方法一一对应。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Proxy(target, &#123;</span><br><span class="line">  set: function(target, name, value, receiver) &#123;</span><br><span class="line">    var success &#x3D; Reflect.set(target, name, value, receiver);</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      console.log(&#39;property &#39; + name + &#39; on &#39; + target + &#39; set to &#39; + value);</span><br><span class="line">    &#125;</span><br><span class="line">    return success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组常用方法总结如下：</p>
<ul>
<li>调用之后会改变原有的数组的方法，如：<ul>
<li><code>unshift()</code>：在数组第一位添加元素，返回更新后的数组长度</li>
<li><code>shift()</code>：删除数组的第一个元素，返回该元素</li>
<li><code>push()</code>：在数组末尾添加元素，返回更新后的数组的长度</li>
<li><code>pop()</code>：删除数组最后一个元素，返回该元素</li>
<li><code>sort()</code>：数组排序，也可添加回调函数定义自己想要的排序规则</li>
<li><code>reverse()</code>：数组倒序</li>
<li><code>splice(index,howMany)</code>：从index位置删除howMany个数组元素<br><code>splice(index,howMany,item1...itemX)</code>：从index位置删除howMany个数组元素，然后添加item1…itemX元素至数组</li>
</ul>
</li>
<li>调用之后不会改变原有数组的方法，如：<ul>
<li><code>concat(arr1,arr2...)</code>：连接两个或者更多个数组</li>
<li><code>every((index,value,arr)=&gt;{},thisArg)</code>：遍历每一个元素，判断所有元素是不是都符合条件，有一个不符合就返回false，全部符合返回true</li>
<li><code>some((index,value,arr)=&gt;{},thisArg)</code>：遍历每一个元素，判断所有元素是不是都符合条件，有一个符合就返回true，全部不符合返回false</li>
<li><code>filter()</code>：数组过滤</li>
<li><code>map()</code>：数组遍历</li>
<li><code>forEach()</code>：数组遍历</li>
<li><code>slice(start=0,end=this.length)</code>：数组截取，包含开始参数，不包含结束参数</li>
</ul>
</li>
</ul>
<h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p><code>Array.form()</code>将 类似数组的对象 / 可遍历的对象 转为数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 类似数组的对象</span><br><span class="line">let arrayLike &#x3D; &#123;</span><br><span class="line">    &#39;0&#39;: &#39;a&#39;,</span><br><span class="line">    &#39;1&#39;: &#39;b&#39;,</span><br><span class="line">    &#39;2&#39;: &#39;c&#39;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;</span><br><span class="line">Array.from(arrayLike) &#x2F;&#x2F; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可遍历的对象 - 即该对象带有length属性</span><br><span class="line">function foo() &#123;</span><br><span class="line">  var args &#x3D; Array.from(arguments);</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.from(&#39;hello&#39;) &#x2F;&#x2F; [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]</span><br></pre></td></tr></table></figure>
<h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p><code>Array.of()</code>将一组值转化成数组，用于解决<code>Array()</code>或者<code>new Array()</code>因为参数个数不同引起行为差异的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Array() &#x2F; new Array()</span><br><span class="line">Array() &#x2F;&#x2F; [] 无参数的时候返回的是空数组</span><br><span class="line">Array(2) &#x2F;&#x2F; [,,] 只有一个参数时，实际上指的是数组的长度</span><br><span class="line">Array(3,4) &#x2F;&#x2F; [3,4] 只有当参数不少于2个的时候，才会是数组</span><br><span class="line">Array(3,4,5) &#x2F;&#x2F; [3,4,5]</span><br><span class="line"></span><br><span class="line">Array.of() &#x2F;&#x2F; []</span><br><span class="line">Array.of(undefined) &#x2F;&#x2F; [undefined]</span><br><span class="line">Array.of(2) &#x2F;&#x2F; [2]</span><br><span class="line">Array.of(3,4) &#x2F;&#x2F; [3,4]</span><br><span class="line">&#x2F;&#x2F; 具体实现</span><br><span class="line">function ArrayOf()&#123;</span><br><span class="line">  return [].slice.call(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-at"><a href="#Array-prototype-at" class="headerlink" title="Array.prototype.at()"></a>Array.prototype.at()</h2><p>根据传入的参数索引获取索引对应的值。解决之前数据没有办法倒序获取元素的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [5, 12, 8, 130, 44]</span><br><span class="line">arr[arr.length-1] &#x2F;&#x2F; 44</span><br><span class="line">arr.at(-1) &#x2F;&#x2F; 44</span><br><span class="line">arr.at(2) &#x2F;&#x2F; 8</span><br><span class="line">arr.at(-2) &#x2F;&#x2F; 130</span><br><span class="line">arr.at(10) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-copyWithin"><a href="#Array-prototype-copyWithin" class="headerlink" title="Array.prototype.copyWithin()"></a>Array.prototype.copyWithin()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.copyWithin(target, start &#x3D; 0, end &#x3D; this.length)</span><br></pre></td></tr></table></figure>
<p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3) &#x2F;&#x2F; [4, 5, 3, 4, 5]</span><br><span class="line">&#x2F;&#x2F; 从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将3号位复制到0号位</span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3, 4) &#x2F;&#x2F; [4, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -2相当于3号位，-1相当于4号位</span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, -2, -1) &#x2F;&#x2F; [4, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0,2) &#x2F;&#x2F; [3, 4, 5, 4, 5]</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-find-findIndex-findLast-findLastIndex-indexOf"><a href="#Array-prototype-find-findIndex-findLast-findLastIndex-indexOf" class="headerlink" title="Array.prototype.find/findIndex/findLast/findLastIndex/indexOf()"></a>Array.prototype.find/findIndex/findLast/findLastIndex/indexOf()</h2><ul>
<li><code>find()</code>：从前向后，返回符合条件的第一个元素的值，不符合返回 undefined；</li>
<li><code>findIndex()</code>：从前向后，返回符合条件的第一个元素的下标，不符合返回-1；</li>
<li><code>findLast()</code>：从后向前，返回符合条件的第一个元素的值，不符合返回 undefined；</li>
<li><code>findLastIndex()</code>：从后向前，返回符合条件的第一个元素的下标，不符合返回-1；</li>
<li><code>indexOf()</code>：从前向后，返回元素所在的第一个下标，元素不存在返回-1。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 4, -5, 10, -5]</span><br><span class="line">arr.find((value,index,arr)&#x3D;&gt;&#123;return value &lt; 0&#125;) &#x2F;&#x2F; -5</span><br><span class="line">arr.findIndex((value,index,arr)&#x3D;&gt;&#123;return value &lt; 0&#125;) &#x2F;&#x2F; 2</span><br><span class="line">let person &#x3D; &#123;name: &#39;John&#39;, age: 9&#125;;</span><br><span class="line">arr.find((value,index,arr)&#x3D;&gt;&#123;</span><br><span class="line">  return value &gt; this.age  &#x2F;&#x2F; this 指向第二个入参 -- person</span><br><span class="line">&#125;,person) &#x2F;&#x2F; 10</span><br><span class="line">arr.findIndex((value,index,arr)&#x3D;&gt;&#123;</span><br><span class="line">  return value &gt; this.age &#x2F;&#x2F; this 指向第二个入参 -- person</span><br><span class="line">&#125;,person) &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">arr.indexOf(-5) &#x2F;&#x2F; 2</span><br><span class="line">arr.indexOf(-5,3) &#x2F;&#x2F; 从3号位开始找-5，所以下标是4</span><br><span class="line">arr.indexOf(-5,2) &#x2F;&#x2F; 2</span><br><span class="line">arr.indexOf(-5,6) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-fill"><a href="#Array-prototype-fill" class="headerlink" title="Array.prototype.fill()"></a>Array.prototype.fill()</h2><p><code>fill(target, start=0, end=this.length)</code>方法用来填充数组，一般用于数组初始化的时候赋值。<br>target：要填充的数值；start：填充起始位置；end：填充结束位置。<br><strong>如果填充的是对象，那么被赋值的是同一个内存地址的对象，是浅拷贝，会相互影响。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3].fill(7) &#x2F;&#x2F; [7,7,7] 数组有值默认会被覆盖</span><br><span class="line">new Array(3).fill(7) &#x2F;&#x2F; [7,7,7]</span><br><span class="line">[1,2,3].fill(7,1,2) &#x2F;&#x2F; [1,7,3] 从一号位开始填充，2号位结束</span><br><span class="line"></span><br><span class="line">let arr &#x3D; new Array(3).fill(&#123;name: &quot;Mike&quot;&#125;);</span><br><span class="line">arr[0].name &#x3D; &quot;Ben&quot;;</span><br><span class="line">arr &#x2F;&#x2F; [&#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-keys-values-entries"><a href="#Array-prototype-keys-values-entries" class="headerlink" title="Array.prototype.keys/values/entries()"></a>Array.prototype.keys/values/entries()</h2><p>这三个方法用来搭配<code>for...of</code>对数组进行遍历，返回的是遍历器对象：</p>
<ul>
<li><code>keys()</code>是对键名的遍历；</li>
<li><code>values()</code>是对键值的遍历；</li>
<li><code>entries()</code>是对键值对的遍历。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &#39;a&#39;</span><br><span class="line">&#x2F;&#x2F; &#39;b&#39;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0 &quot;a&quot;</span><br><span class="line">&#x2F;&#x2F; 1 &quot;b&quot;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-flat-flatMap"><a href="#Array-prototype-flat-flatMap" class="headerlink" title="Array.prototype.flat/flatMap()"></a>Array.prototype.flat/flatMap()</h2><ul>
<li><code>flat(num=1)</code>：将多维数组拉平为一维数组，num表示拉平的层数，默认为1，num=Infinity表示不管数组是几维，都被拉平为一维数组。</li>
<li><code>flatMap((value,index,arr)=&gt;{},thisArg)</code>：执行函数遍历数组成员，将返回的新的数组进行flat操作，thisArg用来绑定遍历函数里面this的指向。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, [3, [4, 5]]].flat()</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, [4, 5]]  默认拉平一层</span><br><span class="line"></span><br><span class="line">[1, 2, [3, [4, 5]]].flat(2)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 5]   指定拉平两层</span><br><span class="line"></span><br><span class="line">[1, [2, [3]]].flat(Infinity)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3] 不管多少层，全部拉平至一维</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span><br><span class="line">[1, 2, 3, 4].flatMap(x &#x3D;&gt; [[x * 2]])</span><br><span class="line">&#x2F;&#x2F; [[2], [4], [6], [8]]  flatMap只能拉平一层</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-toReversed-toSorted-toSplice-with"><a href="#Array-prototype-toReversed-toSorted-toSplice-with" class="headerlink" title="Array.prototype.toReversed/toSorted/toSplice/with()"></a>Array.prototype.toReversed/toSorted/toSplice/with()</h2><p>数组有一些方法调用后会修改原有的数组，为了实现调用该方法但是不修改原有数组，就有了以下和之前方法类似单数不修改原有数组的新方法。</p>
<ul>
<li><code>toReversed()</code>对应<code>reverse()</code>，用来颠倒数组成员的位置。</li>
<li><code>toSorted()</code>对应<code>sort()</code>，用来对数组成员排序。</li>
<li><code>toSpliced()</code>对应<code>splice()</code>，用来在指定位置，删除指定数量的成员，并插入新成员。</li>
<li><code>with(index, value)</code>对应<code>splice(index, 1, value)</code>，用来将指定位置的成员替换为新的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const sequence &#x3D; [1, 2, 3];</span><br><span class="line">sequence.toReversed() &#x2F;&#x2F; [3, 2, 1]</span><br><span class="line">sequence &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line"></span><br><span class="line">const outOfOrder &#x3D; [3, 1, 2];</span><br><span class="line">outOfOrder.toSorted() &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">outOfOrder &#x2F;&#x2F; [3, 1, 2]</span><br><span class="line"></span><br><span class="line">const array &#x3D; [1, 2, 3, 4];</span><br><span class="line">array.toSpliced(1, 2, 5, 6, 7) &#x2F;&#x2F; [1, 5, 6, 7, 4]</span><br><span class="line">array &#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">const correctionNeeded &#x3D; [1, 1, 3];</span><br><span class="line">correctionNeeded.with(1, 2) &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">correctionNeeded &#x2F;&#x2F; [1, 1, 3]</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-group-groupMap"><a href="#Array-prototype-group-groupMap" class="headerlink" title="Array.prototype.group/groupMap()"></a>Array.prototype.group/groupMap()</h2><ul>
<li><code>group((value,index,arr)=&gt;{},thisArg)</code>：该方法用来对数组进行分组，返回值是一个对象，键名是分组名，值是被分组的数组，入参函数必须返回一个字符串，即分组名。</li>
<li><code>groupMap((value,index,arr)=&gt;{},thisArg)</code>：作用和用法和``group()`一致，区别在于返回值是Map。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const array &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">array.group((num, index, array) &#x3D;&gt; &#123;</span><br><span class="line">  return num % 2 &#x3D;&#x3D;&#x3D; 0 ? &#39;even&#39;: &#39;odd&#39;;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; &#123; odd: [1, 3, 5], even: [2, 4] &#125;</span><br><span class="line"></span><br><span class="line">const odd  &#x3D; &#123; odd: true &#125;;</span><br><span class="line">const even &#x3D; &#123; even: true &#125;;</span><br><span class="line">array.groupToMap((num, index, array) &#x3D;&gt; &#123;</span><br><span class="line">  return num % 2 &#x3D;&#x3D;&#x3D; 0 ? even: odd;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;  Map &#123; &#123;odd: true&#125;: [1, 3, 5], &#123;even: true&#125;: [2, 4] &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h2><p><code>reduce((total,value,index,arr)=&gt;{},initialValue)</code>：该方法将数组缩减为单个值，入参函数第一个入参是先前执行后返回的结果，initialValue是要传给入参函数的初始值。<br><strong>如果没有设置initialValue，total是数组的第一个元素，value是数组的第二个元素；如果有，total=initialValue,value是数组的第一个元素。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var numbers &#x3D; [175, 50, 25];</span><br><span class="line">numbers.reduce((total,value)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(total,value)</span><br><span class="line">    return total - value</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 175 50</span><br><span class="line">&#x2F;&#x2F; 125 25</span><br><span class="line">&#x2F;&#x2F; 100</span><br><span class="line"></span><br><span class="line">numbers.reduce((total,value)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(total,value)</span><br><span class="line">    return total - value</span><br><span class="line">&#125;,10);</span><br><span class="line">&#x2F;&#x2F; 10 175</span><br><span class="line">&#x2F;&#x2F; -165 50</span><br><span class="line">&#x2F;&#x2F; -215 25</span><br><span class="line">&#x2F;&#x2F; -240</span><br></pre></td></tr></table></figure>
<h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><ul>
<li>方法一：flat<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const flat &#x3D; arr &#x3D;&gt; arr.flat(Infinity)</span><br></pre></td></tr></table></figure></li>
<li>方法二：递归<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const flat &#x3D; (array) &#x3D;&gt; &#123;</span><br><span class="line">  let result &#x3D; [];</span><br><span class="line">  for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if (Array.isArray(array[i])) &#123;</span><br><span class="line">      result &#x3D; result.concat(flat(array[i]));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法三：reduce<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const flat &#x3D; (array) &#x3D;&gt; &#123;</span><br><span class="line">  return array.reduce(</span><br><span class="line">    (target, current) &#x3D;&gt;</span><br><span class="line">      Array.isArray(current) ?</span><br><span class="line">        target.concat(flatten(current)) :</span><br><span class="line">        target.concat(current)</span><br><span class="line">    , [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定拉平层数</span><br><span class="line">const flattenByDeep &#x3D; (array, deep &#x3D; 1) &#x3D;&gt; &#123;</span><br><span class="line">  return array.reduce(</span><br><span class="line">    (target, current) &#x3D;&gt;</span><br><span class="line">      Array.isArray(current) &amp;&amp; deep &gt; 1 ?</span><br><span class="line">        target.concat(flattenByDeep(current, deep - 1)) :</span><br><span class="line">        target.concat(current)</span><br><span class="line">    , [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><ul>
<li>方法一：使用Set<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const unique &#x3D; arr &#x3D;&gt; Array.from(new Set(arr));</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const unique &#x3D; arr &#x3D;&gt; [...new Set(arr)];</span><br></pre></td></tr></table></figure></li>
<li>方法二：filter + indexOf <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const unique &#x3D; arr &#x3D;&gt; arr.filter((e,i) &#x3D;&gt; arr.indexOf(e) &#x3D;&#x3D;&#x3D; i);</span><br></pre></td></tr></table></figure></li>
<li>方法三：indexOf/includes + push<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const unique &#x3D; (array)&#x3D;&gt; &#123;</span><br><span class="line">  const newArray &#x3D; []</span><br><span class="line">  array.forEach((cu,index)&#x3D;&gt;&#123;</span><br><span class="line">    if(newArray.indexOf(cu)&#x3D;&#x3D;&#x3D;-1) newArray.push(cu)</span><br><span class="line">    &#x2F;&#x2F; if(!newArray.includes(cu)) newArray.push(cu)</span><br><span class="line">  &#125;)</span><br><span class="line">  return newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法四：对象：标记元素是否存在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const unique &#x3D; (array)&#x3D;&gt; &#123;</span><br><span class="line">    var container &#x3D; &#123;&#125;;</span><br><span class="line">    return array.filter((item, index) &#x3D;&gt;  container.hasOwnProperty(item) ? false : (container[item] &#x3D; true));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="数组乱序-洗牌"><a href="#数组乱序-洗牌" class="headerlink" title="数组乱序-洗牌"></a>数组乱序-洗牌</h2><p>实现原理：从最后一个元素开始，从数组中随机选出一个位置，交换，直到第一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function disorder(array) &#123;</span><br><span class="line">  const length &#x3D; array.length;</span><br><span class="line">  let current &#x3D; length - 1;</span><br><span class="line">  let random;</span><br><span class="line">  while (current &gt;-1) &#123;</span><br><span class="line">    random &#x3D; Math.floor(length * Math.random());</span><br><span class="line">    [array[current], array[random]] &#x3D; [array[random], array[current]];</span><br><span class="line">    current--;</span><br><span class="line">  &#125;</span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p>函数的name属性返回函数名，对象的方法也是函数，所以也有name属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const a &#x3D; function()&#123;&#125;</span><br><span class="line">console.log(a.name) &#x2F;&#x2F; a</span><br><span class="line"></span><br><span class="line">const obj1 &#x3D; &#123;</span><br><span class="line">  getName()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj1.getName.name) &#x2F;&#x2F; getName</span><br></pre></td></tr></table></figure>
<p>如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const obj2 &#x3D; &#123;</span><br><span class="line">  get func()&#123;&#125;</span><br><span class="line">  set func(val)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj2.func.name) &#x2F;&#x2F; TypeError: Cannot read property &#39;name&#39; of undefined</span><br><span class="line">const descriptor &#x3D; Object.getOwnPropertyDescriptor(obj2, &#39;func&#39;);</span><br><span class="line">descriptor.get.name &#x2F;&#x2F; &quot;get func&quot;</span><br><span class="line">descriptor.set.name &#x2F;&#x2F; &quot;set func&quot;</span><br></pre></td></tr></table></figure>
<p>Function构造函数创造的函数，name属性返回anonymous。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log((new Function()).name) &#x2F;&#x2F; &quot;anonymous&quot;</span><br></pre></td></tr></table></figure>
<p>bind方法创造的函数，name属性返回bound加上原函数的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(a.bind().name) &#x2F;&#x2F; &quot;bound a&quot;</span><br></pre></td></tr></table></figure>
<p>如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const key1 &#x3D; Symbol(&#39;description&#39;)</span><br><span class="line">let obj3 &#x3D; &#123;</span><br><span class="line">  [key1]() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj3[key1].name) &#x2F;&#x2F; &quot;[description]&quot;</span><br></pre></td></tr></table></figure>
<h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><ul>
<li>箭头函数没有this，普通函数有（独立调用this指向全局，对象内部调用，this指向这个对象）；</li>
<li>箭头函数全是匿名函数，普通函数既可以是匿名函数，也可以是具名函数；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 具名函数</span><br><span class="line">function func()&#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 匿名函数</span><br><span class="line">let func &#x3D; function()&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>箭头函数不能当做构造函数，即不可以使用new命令，普通函数可以；</li>
<li>箭头函数不可以使用arguments函数，如果要用，可以使用reset参数代替，普通函数可以使用arguments；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function A(a)&#123;</span><br><span class="line">  console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">A(1,2,3,4,5) &#x2F;&#x2F; [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">let B &#x3D; (b)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">B(1,2,3,4,5) &#x2F;&#x2F; Uncaught ReferenceError: arguments is not defined</span><br><span class="line"></span><br><span class="line">let C &#x3D; (...c)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(c)</span><br><span class="line">&#125;</span><br><span class="line">C(1,2,3,4,5) &#x2F;&#x2F; [1,2,3,4,5]</span><br></pre></td></tr></table></figure></li>
<li>箭头函数没有prototype原型对象，不具有super。</li>
</ul>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>Symbol，生成一个独一无二的值，引入这个 API 的原因是对象的键名是字符串，很容易冲突，如果键名是 Symbol 类型的话，就是独一无二的，不会产生冲突。</p>
<p>针对 Symbol，ES6 新增了两个新的方法：<code>Symbol.for()</code> 和 <code>Symbol().keyFor()</code></p>
<ul>
<li><code>Symbol.for(key)</code>：可以用来生成同一个 symbol 值，它会根据传入的 key 值登记，再次调用该方法的时候回去搜索 key 是否存在，如果不存在才会直接创建新值。而<code>Symbol(key)</code>没有登记搜索这一操作，每次调用都会创建新值。</li>
<li><code>Symbol.keyFor()</code>：返回一个已登记的 Symbol 类型值的key。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let s &#x3D; Symbol()</span><br><span class="line">typeof s &#x2F;&#x2F; &#39;symbol&#39;</span><br><span class="line"></span><br><span class="line">let s1 &#x3D; Symbol(&#39;foo&#39;);</span><br><span class="line">let s2 &#x3D; Symbol(&#39;bar&#39;);</span><br><span class="line">s1 &#x2F;&#x2F; Symbol(foo)</span><br><span class="line">s2 &#x2F;&#x2F; Symbol(bar)</span><br><span class="line">s1.toString() &#x2F;&#x2F; &quot;Symbol(foo)&quot;</span><br><span class="line">s2.toString() &#x2F;&#x2F; &quot;Symbol(bar)&quot;</span><br><span class="line"></span><br><span class="line">let s3 &#x3D; Symbol.for(&#39;foo&#39;);</span><br><span class="line">let s4 &#x3D; Symbol.for(&#39;foo&#39;);</span><br><span class="line">s3 &#x3D;&#x3D;&#x3D; s4 &#x2F;&#x2F; true</span><br><span class="line">Symbol(&quot;bar&quot;) &#x3D;&#x3D;&#x3D; Symbol(&quot;bar&quot;) &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">Symbol.keyFor(s3) &#x2F;&#x2F; &quot;foo&quot;</span><br><span class="line">let s5 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class="line">Symbol.keyFor(s5) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
    
    
      <div>
          <div>
    
        <div style="text-align:center;color: #666;font-size:14px;">-------------本文结束　<i class="fa fa-hourglass-end" style="color:rgb(90,85,85)"></i>　感谢阅读-------------</div>
    
</div>
      </div>
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Crystal
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://crystalsummer.gitee.io/2021/07/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%B8%89)/" title="前端基础进阶(三)">http://crystalsummer.gitee.io/2021/07/17/前端基础进阶(三)/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Web/" rel="tag"><i class="fa fa-tag"></i> Web</a>
              <a href="/tags/JS/" rel="tag"><i class="fa fa-tag"></i> JS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/30/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%BA%8C)/" rel="prev" title="前端基础进阶(二)">
      <i class="fa fa-chevron-left"></i> 前端基础进阶(二)
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/18/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/" rel="next" title="图片懒加载">
      图片懒加载 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81MDEyMC8yNjYxMA"></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象"><span class="nav-number">1.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象"><span class="nav-number">1.1.</span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型"><span class="nav-number">1.2.</span> <span class="nav-text">原型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型链"><span class="nav-number">1.3.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">1.4.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象新增方法"><span class="nav-number">1.5.</span> <span class="nav-text">对象新增方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-is"><span class="nav-number">1.5.1.</span> <span class="nav-text">Object.is()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-assign"><span class="nav-number">1.5.2.</span> <span class="nav-text">Object.assign()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-getOwnPropertyDescriptors"><span class="nav-number">1.5.3.</span> <span class="nav-text">Object.getOwnPropertyDescriptors()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-setPrototypeOf"><span class="nav-number">1.5.4.</span> <span class="nav-text">Object.setPrototypeOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-getPrototypeOf"><span class="nav-number">1.5.5.</span> <span class="nav-text">Object.getPrototypeOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-keys"><span class="nav-number">1.5.6.</span> <span class="nav-text">Object.keys()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-values"><span class="nav-number">1.5.7.</span> <span class="nav-text">Object.values()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-entries"><span class="nav-number">1.5.8.</span> <span class="nav-text">Object.entries()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-fromEntries"><span class="nav-number">1.5.9.</span> <span class="nav-text">Object.fromEntries()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的扩展"><span class="nav-number">1.6.</span> <span class="nav-text">对象的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#属性的简洁表示法"><span class="nav-number">1.6.1.</span> <span class="nav-text">属性的简洁表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性的可枚举性"><span class="nav-number">1.6.2.</span> <span class="nav-text">属性的可枚举性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super关键字"><span class="nav-number">1.6.3.</span> <span class="nav-text">super关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Class"><span class="nav-number">2.</span> <span class="nav-text">Class</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#由来"><span class="nav-number">2.1.</span> <span class="nav-text">由来</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constructor-NaN"><span class="nav-number">2.2.</span> <span class="nav-text">constructor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性和方法"><span class="nav-number">2.3.</span> <span class="nav-text">属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实例属性新写法"><span class="nav-number">2.3.1.</span> <span class="nav-text">实例属性新写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取值函数-getter-和存值函数-setter"><span class="nav-number">2.3.2.</span> <span class="nav-text">取值函数(getter)和存值函数(setter)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态属性和方法"><span class="nav-number">2.3.3.</span> <span class="nav-text">静态属性和方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#私有属性和方法"><span class="nav-number">2.3.4.</span> <span class="nav-text">私有属性和方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承-1"><span class="nav-number">2.4.</span> <span class="nav-text">继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Set"><span class="nav-number">3.</span> <span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本用法"><span class="nav-number">3.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例属性-size"><span class="nav-number">3.2.</span> <span class="nav-text">实例属性-size</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例操作方法-add-delete-has-clear"><span class="nav-number">3.3.</span> <span class="nav-text">实例操作方法-add&#x2F;delete&#x2F;has&#x2F;clear</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例遍历方法-keys-values-entries-forEach"><span class="nav-number">3.4.</span> <span class="nav-text">实例遍历方法-keys&#x2F;values&#x2F;entries&#x2F;forEach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WeakSet"><span class="nav-number">3.5.</span> <span class="nav-text">WeakSet</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map"><span class="nav-number">4.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本用法-1"><span class="nav-number">4.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例属性-size-1"><span class="nav-number">4.2.</span> <span class="nav-text">实例属性-size</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例操作方法-set-get-has-delete-clear"><span class="nav-number">4.3.</span> <span class="nav-text">实例操作方法-set&#x2F;get&#x2F;has&#x2F;delete&#x2F;clear</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例遍历方法-keys-values-entries-forEach-1"><span class="nav-number">4.4.</span> <span class="nav-text">实例遍历方法-keys&#x2F;values&#x2F;entries&#x2F;forEach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构相互转化"><span class="nav-number">4.5.</span> <span class="nav-text">数据结构相互转化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WeakMap"><span class="nav-number">4.6.</span> <span class="nav-text">WeakMap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6新增运算符"><span class="nav-number">5.</span> <span class="nav-text">ES6新增运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#指数运算符"><span class="nav-number">5.1.</span> <span class="nav-text">** 指数运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链判断运算符"><span class="nav-number">5.2.</span> <span class="nav-text">?. 链判断运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Null判断运算符"><span class="nav-number">5.3.</span> <span class="nav-text">?? Null判断运算符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Proxy"><span class="nav-number">6.</span> <span class="nav-text">Proxy</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本使用"><span class="nav-number">6.1.</span> <span class="nav-text">基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拦截方法"><span class="nav-number">6.2.</span> <span class="nav-text">拦截方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#get"><span class="nav-number">6.2.1.</span> <span class="nav-text">get</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">6.2.2.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#has"><span class="nav-number">6.2.3.</span> <span class="nav-text">has</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apply"><span class="nav-number">6.2.4.</span> <span class="nav-text">apply</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#construct"><span class="nav-number">6.2.5.</span> <span class="nav-text">construct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defineProperty"><span class="nav-number">6.2.6.</span> <span class="nav-text">defineProperty</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deleteProperty"><span class="nav-number">6.2.7.</span> <span class="nav-text">deleteProperty</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setPrototypeOf"><span class="nav-number">6.2.8.</span> <span class="nav-text">setPrototypeOf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getPrototypeOf"><span class="nav-number">6.2.9.</span> <span class="nav-text">getPrototypeOf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ownKeys"><span class="nav-number">6.2.10.</span> <span class="nav-text">ownKeys</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getOwnPropertyDescriptor"><span class="nav-number">6.2.11.</span> <span class="nav-text">getOwnPropertyDescriptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isExtensible"><span class="nav-number">6.2.12.</span> <span class="nav-text">isExtensible</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#preventExtensions"><span class="nav-number">6.2.13.</span> <span class="nav-text">preventExtensions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Proxy-revocable"><span class="nav-number">6.3.</span> <span class="nav-text">Proxy.revocable()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this指向"><span class="nav-number">6.4.</span> <span class="nav-text">this指向</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reflect"><span class="nav-number">7.</span> <span class="nav-text">Reflect</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组"><span class="nav-number">8.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-from"><span class="nav-number">8.1.</span> <span class="nav-text">Array.from()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-of"><span class="nav-number">8.2.</span> <span class="nav-text">Array.of()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-prototype-at"><span class="nav-number">8.3.</span> <span class="nav-text">Array.prototype.at()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-prototype-copyWithin"><span class="nav-number">8.4.</span> <span class="nav-text">Array.prototype.copyWithin()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-prototype-find-findIndex-findLast-findLastIndex-indexOf"><span class="nav-number">8.5.</span> <span class="nav-text">Array.prototype.find&#x2F;findIndex&#x2F;findLast&#x2F;findLastIndex&#x2F;indexOf()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-prototype-fill"><span class="nav-number">8.6.</span> <span class="nav-text">Array.prototype.fill()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-prototype-keys-values-entries"><span class="nav-number">8.7.</span> <span class="nav-text">Array.prototype.keys&#x2F;values&#x2F;entries()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-prototype-flat-flatMap"><span class="nav-number">8.8.</span> <span class="nav-text">Array.prototype.flat&#x2F;flatMap()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-prototype-toReversed-toSorted-toSplice-with"><span class="nav-number">8.9.</span> <span class="nav-text">Array.prototype.toReversed&#x2F;toSorted&#x2F;toSplice&#x2F;with()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-prototype-group-groupMap"><span class="nav-number">8.10.</span> <span class="nav-text">Array.prototype.group&#x2F;groupMap()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-prototype-reduce"><span class="nav-number">8.11.</span> <span class="nav-text">Array.prototype.reduce()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组扁平化"><span class="nav-number">8.12.</span> <span class="nav-text">数组扁平化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组去重"><span class="nav-number">8.13.</span> <span class="nav-text">数组去重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组乱序-洗牌"><span class="nav-number">8.14.</span> <span class="nav-text">数组乱序-洗牌</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">9.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#name-属性"><span class="nav-number">9.1.</span> <span class="nav-text">name 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#箭头函数和普通函数的区别"><span class="nav-number">9.2.</span> <span class="nav-text">箭头函数和普通函数的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Symbol"><span class="nav-number">10.</span> <span class="nav-text">Symbol</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Crystal"
      src="/uploads/avatar2.png">
  <p class="site-author-name" itemprop="name">Crystal</p>
  <div class="site-description" itemprop="description">Only for recording life</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/crystal-summer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;crystal-summer" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:herr_510@163.com" title="E-Mail → mailto:herr_510@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/5596982190/profile?rightmod=1&wvr=6&mod=personnumber&is_all=1" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;5596982190&#x2F;profile?rightmod&#x3D;1&amp;wvr&#x3D;6&amp;mod&#x3D;personnumber&amp;is_all&#x3D;1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.ruanyifeng.com/blog/" title="http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blog&#x2F;" rel="noopener" target="_blank">阮一峰</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://juejin.im/" title="https:&#x2F;&#x2F;juejin.im&#x2F;" rel="noopener" target="_blank">掘金</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://developer.mozilla.org/zh-CN/" title="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;" rel="noopener" target="_blank">MDN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.zhangxinxu.com/" title="https:&#x2F;&#x2F;www.zhangxinxu.com&#x2F;" rel="noopener" target="_blank">张鑫旭</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://codepen.io/" title="https:&#x2F;&#x2F;codepen.io&#x2F;" rel="noopener" target="_blank">CodePen</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.nowcoder.com/" title="https:&#x2F;&#x2F;www.nowcoder.com&#x2F;" rel="noopener" target="_blank">牛客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.dandyweng.com/" title="https:&#x2F;&#x2F;www.dandyweng.com&#x2F;" rel="noopener" target="_blank">翁天信</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Crystal Summer</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">480k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">7:16</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script color='34,34,34' opacity='0.5' zIndex='' count='99' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
