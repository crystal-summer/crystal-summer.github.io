<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue3后台管理框架搭建</title>
    <url>/2022/03/28/Vue3%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2018/04/28/22/03/dawn-3358468_960_720.jpg" alt=""></p>
<a id="more"></a>

<p>Vue3已经成功落地，并成为默认版本，这里使用以下技术栈搭建一套后台管理的前端框架：</p>
<ul>
<li><a href="https://v3.cn.vuejs.org/" target="_blank" rel="noopener">Vue3</a></li>
<li><a href="https://cn.vitejs.dev/" target="_blank" rel="noopener">Vite2.9</a></li>
<li><a href="https://router.vuejs.org/" target="_blank" rel="noopener">vue-router4</a></li>
<li><a href="https://pinia.vuejs.org/" target="_blank" rel="noopener">pinia</a></li>
<li><a href="https://pnpm.io/zh/" target="_blank" rel="noopener">pnpm</a></li>
<li><a href="https://element-plus.gitee.io/zh-CN/" target="_blank" rel="noopener">Element Plus</a></li>
<li><a href="https://github.com/axios/axios/blob/master/README.md" target="_blank" rel="noopener">axios</a></li>
<li><a href="https://www.sass.hk/" target="_blank" rel="noopener">Sass</a></li>
</ul>
<!-- 该框架的接口和数据均来自[若依](http://www.ruoyi.vip/)，在此特别声明。 -->

<p>框架gitee地址：<a href="https://gitee.com/crystalSummer/vue3-admin" target="_blank" rel="noopener"><strong>vue3-admin-gitee</strong></a><br>框架github地址：<a href="https://github.com/crystal-summer/vue3-admin" target="_blank" rel="noopener"><strong>vue3-admin-github</strong></a></p>
<h1 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h1><p><a href="https://pnpm.io/zh/" target="_blank" rel="noopener">pnpm</a>是包管理器，类似 npm，yarn，但是 npm 和 yarn 存在以下问题：</p>
<ul>
<li>扁平化算法要遍历所有的依赖关系，消耗时间，下载安装慢；</li>
<li>依赖包非法访问；</li>
<li>一个项目一个 node_modules，占磁盘空间。</li>
</ul>
<p>而 pnpm 速度快、不占磁盘空间，解决了扁平化算法复杂、避免依赖包非法访问的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局安装 pnpm</span><br><span class="line">npm install -g pnpm</span><br></pre></td></tr></table></figure>
<h1 id="ni"><a href="#ni" class="headerlink" title="ni"></a>ni</h1><p><a href="https://github.com/antfu/ni" target="_blank" rel="noopener">ni</a>根据当前项目的锁文件，采用对应的包管理工具对项目进行依赖安装、脚本运行等操作的一个小工具，安装这个小工具，可以不用考虑当前项目的包管理工具是什么，也方便使用不同包管理工具的项目的管理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局安装 ni</span><br><span class="line">npm i -g @antfu&#x2F;ni</span><br><span class="line">&#x2F;&#x2F; 安装依赖</span><br><span class="line">ni  &#x3D;&#x3D;&#x3D; npm install &#x3D;&#x3D;&#x3D; pnpm install &#x3D;&#x3D;&#x3D; yarn install</span><br><span class="line">&#x2F;&#x2F; 运行脚本</span><br><span class="line">nr dev &#x3D;&#x3D;&#x3D; npm run dev &#x3D;&#x3D;&#x3D; pnpm run dev &#x3D;&#x3D;&#x3D; yarn run dev </span><br><span class="line">&#x2F;&#x2F; 安装某个包</span><br><span class="line">ni antd-mobile &#x3D;&#x3D;&#x3D; npm i antd-mobile</span><br></pre></td></tr></table></figure>
<h1 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h1><h2 id="Vite初始化项目"><a href="#Vite初始化项目" class="headerlink" title="Vite初始化项目"></a>Vite初始化项目</h2><p><a href="https://cn.vitejs.dev/" target="_blank" rel="noopener">Vite</a>是新一代前端开发与构建工具，类似 webpack。</p>
<p>webpack、Rollup 和 Parcel 等工具的诞生，极大地改善了前端开发者的开发体验。但是，当构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。我们开始遇到性能瓶颈 —— <strong>使用 JavaScript 开发的工具通常需要很长时间（甚至是几分钟！）才能启动开发服务器</strong>。</p>
<p>而Vite旨在解决这个问题，将应用中的模块区分为 依赖 和 源码 两类，让浏览器接管了打包程序的部分工作，改进了开发服务器启动时间；将动态模块热重载（HMR）在原生 ESM 上执行，保持 HMR 快速更新；利用 HTTP 头来加速整个页面的重新加载，源码模块请求根据 304 进行协商缓存，依赖模块请求进行强缓存。<br>总而言之，Vite神速！！！</p>
<p>注意：如果使用Vite，那么vscode需要安装volar插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行以下命令搭建一个 JS 版的 Vue 项目</span><br><span class="line">pnpm create vite vue3-admin -- --template vue</span><br><span class="line">&#x2F;&#x2F; 创建完成后执行以下命令运行项目</span><br><span class="line">cd vue3-admin</span><br><span class="line">pnpm install</span><br><span class="line">pnpm run dev</span><br></pre></td></tr></table></figure>
<p>生成的项目初始目录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public</span><br><span class="line">  - favicon.ico</span><br><span class="line">src</span><br><span class="line">  - assets</span><br><span class="line">    - logo.png</span><br><span class="line">  - components</span><br><span class="line">    - HelloWord.vue</span><br><span class="line">  - APP.vue</span><br><span class="line">  - main.js</span><br><span class="line">.gitignore</span><br><span class="line">index.html</span><br><span class="line">package.json</span><br><span class="line">README.md</span><br><span class="line">vite.config.js</span><br></pre></td></tr></table></figure>
<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>使用 Vite 初始化项目之后，使用 EditorConfig + Prettier + ESLint 设置代码规范。</p>
<h3 id="EditorConfig"><a href="#EditorConfig" class="headerlink" title="EditorConfig"></a>EditorConfig</h3><p><a href="https://editorconfig.org/" target="_blank" rel="noopener">EditorConfig</a><br>vscode先安装插件：EditorConfig for VS Code，webstorm或者IDEA不需要安装插件，直接配置，在项目根目录下面新建.editorconfig文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Editor configuration, see http:&#x2F;&#x2F;editorconfig.org </span><br><span class="line"></span><br><span class="line">root &#x3D; true # 表示是最顶层的 EditorConfig 配置文件 </span><br><span class="line"></span><br><span class="line">[*] # 表示所有文件适用 </span><br><span class="line">charset &#x3D; utf-8 # 设置文件字符集为 utf-8 </span><br><span class="line">indent_style &#x3D; space # 缩进风格（tab | space） </span><br><span class="line">indent_size &#x3D; 2 # 缩进大小 </span><br><span class="line">end_of_line &#x3D; lf # 控制换行类型(lf | cr | crlf) </span><br><span class="line">trim_trailing_whitespace &#x3D; true # 去除行首的任意空白字符 </span><br><span class="line">insert_final_newline &#x3D; true # 始终在文件末尾插入一个新行 </span><br><span class="line"></span><br><span class="line">[*.md] # 表示仅 md 文件适用以下规则 </span><br><span class="line">max_line_length &#x3D; off </span><br><span class="line">trim_trailing_whitespace &#x3D; false</span><br></pre></td></tr></table></figure>
<h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><p><a href="https://prettier.io/" target="_blank" rel="noopener">Prettier</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pnpm install prettier -D</span><br></pre></td></tr></table></figure>
<p>vscode先安装插件：Prettier - Code formatter，webstorm或者IDEA不需要安装插件，直接配置，在项目根目录下面新建.prettierrc.js 和 .prettierignore文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .prettierignore</span><br><span class="line">node_modules</span><br><span class="line">dist</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; .prettierrc.js</span><br><span class="line">module.exports &#x3D;&#123;</span><br><span class="line">  tabWidth: 2,</span><br><span class="line">  printWidth: 100,</span><br><span class="line">  singleQuote: true,</span><br><span class="line">  semi: false,</span><br><span class="line">  overrides: [</span><br><span class="line">    &#123;</span><br><span class="line">      files: &#39;*.json&#39;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        printWidth: 200,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  arrowParens: &#39;always&#39;,</span><br><span class="line">  endOfLine: &#39;auto&#39;,</span><br><span class="line">  vueIndentScriptAndStyle: true,</span><br><span class="line">  trailingComma: &#39;all&#39;,</span><br><span class="line">  proseWrap: &#39;never&#39;,</span><br><span class="line">  htmlWhitespaceSensitivity: &#39;strict&#39;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vscode打开文件-》首选项-》设置-》当前工作区，<br>搜索formatter，将 Editor:Default Formatter 选择为 prettier<br>搜索save，将 Editor:Formatter On Save勾选<br>这样保存文件的时候就会自动格式化代码。</p>
<h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><p><a href="https://github.com/eslint/eslint" target="_blank" rel="noopener">ESLint</a><br>vscode先安装插件：ESLint，webstorm或者IDEA不需要安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装</span><br><span class="line">pnpm install eslint -D</span><br><span class="line">&#x2F;&#x2F; 执行以下命令完成设置，并创建.eslintrc.js配置文件</span><br><span class="line">pnpm init @eslint&#x2F;config</span><br><span class="line"> How would you like to use ESLint? （你想如何使用 ESLint?）</span><br><span class="line">     To check syntax, find problems, and enforce code style（检查语法、发现问题并强制执行代码风格）</span><br><span class="line"> What type of modules does your project use?（你的项目使用哪种类型的模块?）</span><br><span class="line">     JavaScript modules (import&#x2F;export)</span><br><span class="line"> Which framework does your project use? （你的项目使用哪种框架?）</span><br><span class="line">     Vue.js</span><br><span class="line">Does your project use TypeScript?（你的项目是否使用 TypeScript？）</span><br><span class="line">    Yes</span><br><span class="line">Where does your code run?（你的代码在哪里运行?）</span><br><span class="line">    Browser 和 Node（按空格键进行选择，a全选，选完按回车键确定）      </span><br><span class="line">How would you like to define a style for your project?（你想怎样为你的项目定义风格？）</span><br><span class="line">    Use a popular style guide（使用一种流行的风格指南）</span><br><span class="line">Which style guide do you want to follow?（你想遵循哪一种风格指南?）</span><br><span class="line">    Airbnb、Standard、Google中我选择了Airbnb(https:&#x2F;&#x2F;github.com&#x2F;airbnb&#x2F;javascript)</span><br><span class="line">What format do you want your config file to be in?（你希望你的配置文件是什么格式?）</span><br><span class="line">    JavaScript</span><br><span class="line">Would you like to install them now with npm?（你想现在就用 NPM 安装它们吗?）  </span><br><span class="line">    Yes    &#x2F;&#x2F; 如果安装失败，手动安装</span><br></pre></td></tr></table></figure>
<p>配置完成后在项目根目录下面自动生成.eslintrc.js文件，在根目录下面新建.eslintignore文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .eslintignore</span><br><span class="line"># eslint 忽略检查</span><br><span class="line">node_modules</span><br><span class="line">dist</span><br><span class="line">!.prettierrc.js</span><br></pre></td></tr></table></figure>
<p>vscode在settings.json设置文件中增加以下代码，我是在工作区的设置文件中添加的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 每次保存时将代码按eslint格式进行保存</span><br><span class="line">  &quot;editor.codeActionsOnSave&quot;: &#123;</span><br><span class="line">    &quot;source.fixAll.eslint&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;eslint.run&quot;: &quot;onSave&quot;,</span><br><span class="line">  &#x2F;&#x2F; 添加vue支持</span><br><span class="line">  &quot;eslint.validate&quot;: [&quot;javascript&quot;, &quot;vue&quot;, &quot;html&quot;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解决-ESLint-和-Prettier-的冲突"><a href="#解决-ESLint-和-Prettier-的冲突" class="headerlink" title="解决 ESLint 和 Prettier 的冲突"></a>解决 ESLint 和 Prettier 的冲突</h3><p>比如Airbnb代码结束需要增加封号，而Prettier不需要。<br>解决两者冲突问题，需要用到 eslint-plugin-prettier 和 eslint-config-prettier。</p>
<ul>
<li>eslint-plugin-prettier 将 Prettier 的规则设置到 ESLint 的规则中;</li>
<li>eslint-config-prettier 关闭 ESLint 中与 Prettier 中会发生冲突的规则;</li>
</ul>
<p>最后形成优先级：Prettier 配置规则 &gt; ESLint 配置规则。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装</span><br><span class="line">pnpm install eslint-plugin-prettier eslint-config-prettier -D</span><br><span class="line">&#x2F;&#x2F; 修改.eslintrc.js文件</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">     ... extends: [ </span><br><span class="line">         &#39;plugin:vue&#x2F;essential&#39;, </span><br><span class="line">         &#39;airbnb-base&#39;, </span><br><span class="line">         &#39;plugin:prettier&#x2F;recommended&#39; &#x2F;&#x2F; 添加 prettier 插件 </span><br><span class="line">     ], ... </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置vite-config-js"><a href="#配置vite-config-js" class="headerlink" title="配置vite.config.js"></a>配置vite.config.js</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &#39;vite&#39;</span><br><span class="line">import &#123; resolve &#125; from &#39;path&#39;</span><br><span class="line">import createVitePlugins from &#39;.&#x2F;vite&#x2F;plugins&#39;</span><br><span class="line"></span><br><span class="line">function resolvePath(paths) &#123;</span><br><span class="line">  return resolve(__dirname, paths)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;vitejs.dev&#x2F;config&#x2F;</span><br><span class="line">export default defineConfig((&#123; mode, command &#125;) &#x3D;&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    &#x2F;&#x2F; 项目中用到的插件集合</span><br><span class="line">    plugins: createVitePlugins(command &#x3D;&#x3D;&#x3D; &#39;build&#39;),</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      &#x2F;&#x2F; alias - 路径别名 https:&#x2F;&#x2F;cn.vitejs.dev&#x2F;config&#x2F;#resolve-alias</span><br><span class="line">      alias: &#123;</span><br><span class="line">        &#39;@&#39;: resolvePath(&#39;src&#39;),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 导入时想要省略的扩展名列表 https:&#x2F;&#x2F;cn.vitejs.dev&#x2F;config&#x2F;#resolve-extensions</span><br><span class="line">      extensions: [&#39;.mjs&#39;, &#39;.js&#39;, &#39;.ts&#39;, &#39;.jsx&#39;, &#39;.tsx&#39;, &#39;.json&#39;, &#39;.vue&#39;],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; server - 本地开发相关配置</span><br><span class="line">    server: &#123;</span><br><span class="line">      host: &#39;0.0.0.0&#39;, &#x2F;&#x2F; IP配置，支持从IP启动</span><br><span class="line">      port: 3000, &#x2F;&#x2F; 端口号</span><br><span class="line">      open: true, &#x2F;&#x2F; 自动打开浏览器</span><br><span class="line">      &#x2F;&#x2F; 接口代理</span><br><span class="line">      proxy: &#123;</span><br><span class="line">        &#39;&#x2F;vue3-admin&#39;: &#123;</span><br><span class="line">          target: &#96;http:&#x2F;&#x2F;vue.ruoyi.vip&#x2F;prod-api&#96;,</span><br><span class="line">          changeOrigin: true,</span><br><span class="line">          rewrite: (path) &#x3D;&gt; path.replace(&#x2F;^\&#x2F;vue3-admin&#x2F;, &#39;&#39;),</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="element-plus"><a href="#element-plus" class="headerlink" title="element-plus"></a>element-plus</h2><ol>
<li>安装并引入<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装</span><br><span class="line">pnpm install element-plus</span><br><span class="line">&#x2F;&#x2F; main.js 完整引入</span><br><span class="line">import &#123; createApp &#125; from &#39;vue&#39;</span><br><span class="line">import ElementPlus from &#39;element-plus&#39;</span><br><span class="line">import &#39;element-plus&#x2F;dist&#x2F;index.css&#39;</span><br><span class="line">&#x2F;&#x2F; element-plus 国际化</span><br><span class="line">import zhCn from &#39;element-plus&#x2F;es&#x2F;locale&#x2F;lang&#x2F;zh-cn&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line"></span><br><span class="line">const app &#x3D; createApp(App)</span><br><span class="line">app.use(ElementPlus, &#123; size: &#39;small&#39;, locale: zhCn &#125;)</span><br><span class="line">app.mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure></li>
<li>自定义主题<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; assets&#x2F;styles&#x2F;element-index.scss</span><br><span class="line">&#x2F;*</span><br><span class="line">  只需要重写你需要改变的颜色即可</span><br><span class="line">  可以在  element-plus&#x2F;theme-chalk&#x2F;src&#x2F;common&#x2F;var.scss 文件中查找SCSS变量。</span><br><span class="line">*&#x2F;</span><br><span class="line">$--color-primary: #409eff;</span><br><span class="line">$--color-success: #67c23a;</span><br><span class="line">$--color-warning: #e6a23c;</span><br><span class="line">$--color-danger: #f56c6c;</span><br><span class="line">$--color-info: #909399;</span><br><span class="line">@forward &#39;element-plus&#x2F;theme-chalk&#x2F;src&#x2F;common&#x2F;var.scss&#39; with (</span><br><span class="line">  $colors: (</span><br><span class="line">    &#39;primary&#39;: (</span><br><span class="line">      &#39;base&#39;: $--color-primary,</span><br><span class="line">    ),</span><br><span class="line">    &#39;success&#39;: (</span><br><span class="line">      &#39;base&#39;: $--color-success,</span><br><span class="line">    ),</span><br><span class="line">    &#39;warning&#39;: (</span><br><span class="line">      &#39;base&#39;: $--color-warning,</span><br><span class="line">    ),</span><br><span class="line">    &#39;danger&#39;: (</span><br><span class="line">      &#39;base&#39;: $--color-danger,</span><br><span class="line">    ),</span><br><span class="line">    &#39;error&#39;: (</span><br><span class="line">      &#39;base&#39;: $--color-danger,</span><br><span class="line">    ),</span><br><span class="line">    &#39;info&#39;: (</span><br><span class="line">      &#39;base&#39;: $--color-info,</span><br><span class="line">    ),</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 如果你想导入所有样式:</span><br><span class="line">@use &#39;element-plus&#x2F;theme-chalk&#x2F;src&#x2F;index.scss&#39; as *;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; main.js修改</span><br><span class="line">&#x2F;&#x2F; 引入element-index.scss文件，必须在引入element-plus之前，防止样式错乱</span><br><span class="line">import &#39;@&#x2F;assets&#x2F;styles&#x2F;element-index.scss&#39;</span><br><span class="line">import ElementPlus from &#39;element-plus&#39;</span><br></pre></td></tr></table></figure></li>
<li>全局使用icon<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、安装</span><br><span class="line">pnpm install @element-plus&#x2F;icons-vue</span><br><span class="line">&#x2F;&#x2F; 2、components&#x2F;SvgIcon&#x2F;svgicon.js</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @name install</span><br><span class="line"> * @description 全局注册使用element-plus的icon</span><br><span class="line"> *&#x2F;</span><br><span class="line">import * as components from &#39;@element-plus&#x2F;icons-vue&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  install: (app) &#x3D;&gt; &#123;</span><br><span class="line">    for (const key in components) &#123;</span><br><span class="line">      const componentConfig &#x3D; components[key]</span><br><span class="line">      app.component(componentConfig.name, componentConfig)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 3、全局注册main.js</span><br><span class="line">import elementIcons from &#39;@&#x2F;components&#x2F;SvgIcon&#x2F;svgicon&#39;</span><br><span class="line">app.use(elementIcons)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="vue-router4"><a href="#vue-router4" class="headerlink" title="vue-router4"></a>vue-router4</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装</span><br><span class="line">pnpm install vue-router@4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; src下新建router&#x2F;index.js，里面有constantRoutes（公共路由）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import &#123; createApp &#125; from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">const app &#x3D; createApp(App)</span><br><span class="line">app.use(router)</span><br></pre></td></tr></table></figure>
<h2 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h2><p><a href="https://pinia.vuejs.org/" target="_blank" rel="noopener">pinia</a>状态管理，类似Vuex。<br><strong>Vuex 和 Pinia 的区别？</strong></p>
<ul>
<li>Pinia更轻量，比Vuex快；</li>
<li>没有mutations，更加简洁；</li>
<li>Pinia完整的支持TypeScript，添加TS比Vuex更容易；</li>
<li>Pinia支持多个store，Vuex一般只定义一个；</li>
<li>Pinia的action和普通函数一样，直接调用，而Vuex的action需要使用dispatch或者mapaction辅助函数；</li>
<li>Pinia不支持时间旅行和编辑等调试功能，而Vuex支持；</li>
<li>Pinia适合中小型项目，Vuex适合大型、高复杂度的项目。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 安装</span><br><span class="line">pnpm install pinia</span><br><span class="line">&#x2F;&#x2F; 2. 使用 src&#x2F;store</span><br><span class="line">&#x2F;&#x2F; src&#x2F;store&#x2F;index.js  全局pinia</span><br><span class="line">import &#123; createPinia &#125; from &#39;pinia&#39;</span><br><span class="line">const pinia &#x3D; createPinia()</span><br><span class="line">export default pinia</span><br><span class="line">&#x2F;&#x2F; src&#x2F;store&#x2F;modules  pinia模块</span><br><span class="line">app.js - 侧边栏配置、当前设备、element-plus的size</span><br><span class="line">permission.js - 动态路由</span><br><span class="line">settings.js - 项目布局模块</span><br><span class="line">tagsView.js - 框架顶部tags模块</span><br><span class="line">user.js - 用户操作模块：登录、用户信息、退出登录</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. main.js</span><br><span class="line">import &#123; createApp &#125; from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;</span><br><span class="line">const app &#x3D; createApp(App)</span><br><span class="line">app.use(store)</span><br></pre></td></tr></table></figure>

<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、安装</span><br><span class="line">pnpm install axios</span><br><span class="line">&#x2F;&#x2F; 2、src&#x2F;utils&#x2F;request.js 定义通讯</span><br><span class="line">&#x2F;&#x2F; 具体请查看https:&#x2F;&#x2F;gitee.com&#x2F;crystalSummer&#x2F;vue3-admin&#x2F;blob&#x2F;master&#x2F;src&#x2F;utils&#x2F;request.js</span><br></pre></td></tr></table></figure>
<h2 id="css处理器-–-Sass"><a href="#css处理器-–-Sass" class="headerlink" title="css处理器 – Sass"></a>css处理器 – Sass</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pnpm install sass</span><br><span class="line">&#x2F;&#x2F; src&#x2F;assets&#x2F;styles下写样式</span><br><span class="line">&#x2F;&#x2F; 具体请查看https:&#x2F;&#x2F;gitee.com&#x2F;crystalSummer&#x2F;vue3-admin&#x2F;tree&#x2F;master&#x2F;src&#x2F;assets&#x2F;styles</span><br></pre></td></tr></table></figure>

<h1 id="Vite插件"><a href="#Vite插件" class="headerlink" title="Vite插件"></a>Vite插件</h1><p>在项目根目录新建vite/plugins文件夹，下面是所有用到的Vite插件的配置。</p>
<h2 id="unplugin-auto-import-vite"><a href="#unplugin-auto-import-vite" class="headerlink" title="unplugin-auto-import/vite"></a>unplugin-auto-import/vite</h2><p><a href="https://www.npmjs.com/package/unplugin-auto-import" target="_blank" rel="noopener">unplugin-auto-import/vite</a>的作用是按需引入项目中常用的api，比如ref、computed就不需要手动引入，项目运行时会自动生成auto-imports.d.js文件，里面是全局声明的api。</p>
<h2 id="unplugin-vue-components-vite"><a href="#unplugin-vue-components-vite" class="headerlink" title="unplugin-vue-components/vite"></a>unplugin-vue-components/vite</h2><p><a href="https://www.npmjs.com/package/unplugin-vue-components" target="_blank" rel="noopener">unplugin-vue-components/vite</a>的作用是自动引入页面需要的组件，项目运行的时候会自动新建components.d.js文件，里面是全局安装的自动引入的组件。</p>
<p><strong>本框架未使用该插件</strong>。</p>
<h2 id="vite-plugin-svg-icons"><a href="#vite-plugin-svg-icons" class="headerlink" title="vite-plugin-svg-icons"></a>vite-plugin-svg-icons</h2><p><a href="https://github.com/vbenjs/vite-plugin-svg-icons/blob/main/README.zh_CN.md" target="_blank" rel="noopener">vite-plugin-svg-icons</a>用于生成svg雪碧图。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、安装</span><br><span class="line">pnpm install vite-plugin-svg-icons -D</span><br><span class="line">&#x2F;&#x2F; 2、在 src&#x2F;main.js 内引入注册脚本</span><br><span class="line">import &#39;virtual:svg-icons-register&#39;</span><br><span class="line">import SvgIcon from &#39;@&#x2F;components&#x2F;SvgIcon&#39;</span><br><span class="line">app.component(&#39;svg-icon&#39;, SvgIcon)</span><br><span class="line">&#x2F;&#x2F; 3、使用-新增svgIcon组件</span><br><span class="line">&#x2F;&#x2F; 详情请查看https:&#x2F;&#x2F;gitee.com&#x2F;crystalSummer&#x2F;vue3-admin&#x2F;blob&#x2F;master&#x2F;src&#x2F;components&#x2F;SvgIcon&#x2F;index.vue</span><br></pre></td></tr></table></figure>
<h2 id="vite-plugin-compression"><a href="#vite-plugin-compression" class="headerlink" title="vite-plugin-compression"></a>vite-plugin-compression</h2><p><a href="https://github.com/vbenjs/vite-plugin-compression/blob/main/README.zh_CN.md" target="_blank" rel="noopener">vite-plugin-compression</a>的作用是使用 gzip 或者 brotli 来压缩资源。</p>
<h2 id="vite-plugin-vue-setup-extend"><a href="#vite-plugin-vue-setup-extend" class="headerlink" title="vite-plugin-vue-setup-extend"></a>vite-plugin-vue-setup-extend</h2><p><a href="https://github.com/vbenjs/vite-plugin-vue-setup-extend" target="_blank" rel="noopener">vite-plugin-vue-setup-extend</a>的作用是解决vue3下 script setup语法糖 下 ，手动设置组件name不方便的问题。</p>
<h1 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h1><h2 id="nprogress"><a href="#nprogress" class="headerlink" title="nprogress"></a>nprogress</h2><p><a href="https://ricostacruz.com/nprogress/" target="_blank" rel="noopener">nprogress</a>是一个进度条插件，通过和路由配合，显示页面切换进程的进度条。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 安装</span><br><span class="line">pnpm  install --save nprogress</span><br><span class="line">&#x2F;&#x2F; 2. 使用</span><br><span class="line">import NProgress from &#39;nprogress&#39;</span><br><span class="line">import &#39;nprogress&#x2F;nprogress.css&#39;</span><br><span class="line">NProgress.configure(&#123; showSpinner: false &#125;)</span><br><span class="line">NProgress.start()</span><br><span class="line">NProgress.done()</span><br></pre></td></tr></table></figure>

<h1 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h1><h2 id="js-cookie"><a href="#js-cookie" class="headerlink" title="js-cookie"></a>js-cookie</h2><p><a href="https://www.npmjs.com/package/js-cookie" target="_blank" rel="noopener">js-cookie</a>一个简单、轻量级的处理cookie的js API。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 安装</span><br><span class="line">pnpm install js-cookie</span><br><span class="line">&#x2F;&#x2F; 2. 使用 src&#x2F;utils&#x2F;auth.js 用于操作token</span><br><span class="line">import Cookies from &#39;js-cookie&#39;</span><br><span class="line">const TokenKey &#x3D; &#39;Admin-Token&#39;</span><br><span class="line">export function getToken() &#123;</span><br><span class="line">  return Cookies.get(TokenKey)</span><br><span class="line">&#125;</span><br><span class="line">export function setToken(token) &#123;</span><br><span class="line">  return Cookies.set(TokenKey, token)</span><br><span class="line">&#125;</span><br><span class="line">export function removeToken() &#123;</span><br><span class="line">  return Cookies.remove(TokenKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="file-saver"><a href="#file-saver" class="headerlink" title="file-saver"></a>file-saver</h2><p><a href="https://www.npmjs.com/package/file-saver" target="_blank" rel="noopener">file-saver</a>浏览器下载文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 安装</span><br><span class="line">pnpm install file-saver --save</span><br><span class="line">&#x2F;&#x2F; 2. 使用 src&#x2F;utils&#x2F;request.js 下载</span><br><span class="line">import &#123; saveAs &#125; from &#39;file-saver&#39;;</span><br><span class="line">saveAs(Blob&#x2F;File&#x2F;Url, optional DOMString filename, optional Object &#123; autoBom &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="jsencrypt"><a href="#jsencrypt" class="headerlink" title="jsencrypt"></a>jsencrypt</h2><p>jsencrypt是基于RSA对数据进行加解密的JS工具，RSA是非对称加密，采用不同的密钥（加密用公钥，解密用私钥）对数据进行加密和解密操作，具体的算法原理可以查看以下文章：</p>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener"><strong>阮一峰网络日志-RSA算法原理（一）</strong></a></li>
<li><a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener"><strong>阮一峰网络日志-RSA算法原理（二）</strong></a></li>
</ul>
<p>密钥对生成：</p>
<ul>
<li>MAC系统内置OpenSSL(开源加密库),所以可以直接在终端上使用命令；</li>
<li>Windows系统可以使用Git命令行工具；</li>
<li>在线生成密钥对：<a href="http://web.chacuo.net/netrsakeypair" target="_blank" rel="noopener"><strong>http://web.chacuo.net/netrsakeypair</strong></a>。</li>
</ul>
<p>目前最常用的场景就是前端记住密码的操作，将密码加密保存在cookie中，回显的时候获取加密的数据进行解密，比如若依前端。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 安装</span><br><span class="line">pnpm install jsencrypt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 引入</span><br><span class="line">import JSEncrypt from &#39;jsencrypt&#x2F;bin&#x2F;jsencrypt.min&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 具体使用</span><br><span class="line">const publicKey &#x3D; &#39;...........&#39;</span><br><span class="line">const privateKey &#x3D; &#39;...........&#39;</span><br><span class="line">&#x2F;&#x2F; 加密</span><br><span class="line">export function encrypt(txt: string) &#123;</span><br><span class="line">  const encryptor &#x3D; new JSEncrypt()</span><br><span class="line">  encryptor.setPublicKey(publicKey) &#x2F;&#x2F; 设置公钥</span><br><span class="line">  return encryptor.encrypt(txt) &#x2F;&#x2F; 对数据进行加密</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解密</span><br><span class="line">export function decrypt(txt: string) &#123;</span><br><span class="line">  const encryptor &#x3D; new JSEncrypt()</span><br><span class="line">  encryptor.setPrivateKey(privateKey) &#x2F;&#x2F; 设置私钥</span><br><span class="line">  return encryptor.decrypt(txt) &#x2F;&#x2F; 对数据进行解密</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="vueuse-core"><a href="#vueuse-core" class="headerlink" title="@vueuse/core"></a>@vueuse/core</h2><p>@vueuse/core是为Vue 2和3服务的一套Vue Composition API的常用工具集，通俗的来说，就是一个工具函数包，它可以帮助快速实现一些常见的功能，不用自己手写，解决重复手写工具函数实现的问题。</p>
<p>常见常用的API如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装</span><br><span class="line">pnpm install @vueuse&#x2F;core</span><br><span class="line">&#x2F;&#x2F; 监听视窗尺寸</span><br><span class="line">import &#123; useWindowSize &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">const windowSize &#x3D; reactive(useWindowSize())</span><br><span class="line">console.log(windowSize.width,windowSize.height)</span><br><span class="line">&#x2F;&#x2F; 监听鼠标坐标位置</span><br><span class="line">import &#123; useMouse &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">const mousePosition &#x3D; reactive(useMouse())</span><br><span class="line">console.log(mousePosition.x,mousePosition.y)</span><br><span class="line">&#x2F;&#x2F; 判断用户是否喜欢深色</span><br><span class="line">import &#123; usePreferredDark &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">const isDark &#x3D; usePreferredDark()</span><br><span class="line">&#x2F;&#x2F; 设置浏览器title</span><br><span class="line">import &#123; useTitle &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">const title &#x3D; useTitle()</span><br><span class="line">console.log(title.value) &#x2F;&#x2F; print current title</span><br><span class="line">title.value &#x3D; &#39;Hello&#39; &#x2F;&#x2F; change current title</span><br><span class="line">&#x2F;&#x2F; copy</span><br><span class="line">import &#123; useClipboard &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">const source &#x3D; ref(&#39;Hello&#39;)</span><br><span class="line">const &#123; text, copy, copied, isSupported &#125; &#x3D; useClipboard(&#123; source &#125;)</span><br><span class="line">&#x2F;&#x2F; 防抖</span><br><span class="line">import &#123; debounceFilter &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">&#x2F;&#x2F; 100ms后更新鼠标的位置</span><br><span class="line">const &#123; x, y &#125; &#x3D; useMouse(&#123; eventFilter: debounceFilter(100) &#125;)</span><br><span class="line">&#x2F;&#x2F; 节流</span><br><span class="line">import &#123; throttleFilter，useLocalStorage &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">&#x2F;&#x2F; 以节流的方式去改变 localStorage 的值</span><br><span class="line">const storage &#x3D; useLocalStorage(&#39;my-key&#39;, &#123; foo: &#39;bar&#39; &#125;, &#123; eventFilter: throttleFilter(1000) &#125;)</span><br><span class="line">&#x2F;&#x2F; 全屏</span><br><span class="line">import &#123; useFullscreen &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">const &#123; isFullscreen, enter, exit, toggle &#125; &#x3D; useFullscreen();</span><br></pre></td></tr></table></figure>
<p>VueUse封装了很多其他的API，具体内容可以查看<a href="https://vueuse.org/" target="_blank" rel="noopener"><strong>VueUse官网</strong></a>。</p>
<h2 id="fuse-js"><a href="#fuse-js" class="headerlink" title="fuse.js"></a>fuse.js</h2><p><a href="https://fusejs.io/" target="_blank" rel="noopener">Fuse.js</a>是一个功能强大、轻量级的模糊搜索库，没有依赖关系。一般来说，模糊搜索（更正式地称为近似字符串匹配）是一种寻找近似等于给定模式（而不是精确地）的字符串的技术。</p>
<h1 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h1><h2 id="新增-view"><a href="#新增-view" class="headerlink" title="新增 view"></a>新增 view</h2><p>在<code>@/views</code>文件下创建对应的文件夹，一般一个路由对应一个文件，该模块下的功能就建议在本文件夹下创建一个新文件夹，各个功能模块维护自己的<code>utils</code>或<code>components</code>组件。</p>
<h2 id="新增-api"><a href="#新增-api" class="headerlink" title="新增 api"></a>新增 api</h2><p>在<code>@/api</code>文件夹下创建本模块对应的 api 服务。</p>
<h2 id="新增组件"><a href="#新增组件" class="headerlink" title="新增组件"></a>新增组件</h2><p>在全局的<code>@/components</code>写一些全局的组件，如富文本，各种搜索组件，封装的分页组件等等能被公用的组件。<br>每个页面或者模块特定的业务组件则会写在当前<code>@/views</code>下面。如：<code>@/views/system/user/components/xxx.vue</code>。这样拆分大大减轻了维护成本。</p>
<h2 id="新增样式"><a href="#新增样式" class="headerlink" title="新增样式"></a>新增样式</h2><p>页面的样式和组件是一个道理，全局的<code>@/style</code>放置一下全局公用的样式，每一个页面的样式就写在当前<code>views</code>下面，请记住加上<code>scoped</code>就只会作用在当前组件内了，避免造成全局的样式污染。</p>
<h1 id="权限-角色使用"><a href="#权限-角色使用" class="headerlink" title="权限/角色使用"></a>权限/角色使用</h1><p>框架封装了全局指令<code>v-hasPermi</code>权限字符串和<code>v-hasRole</code>角色字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 单个权限</span><br><span class="line">&lt;el-button v-hasPermi&#x3D;&quot;[&#39;system:user:add&#39;]&quot;&gt;存在权限字符串才能看到&lt;&#x2F;el-button&gt;</span><br><span class="line">&#x2F;&#x2F; 多个权限</span><br><span class="line">&lt;el-button v-hasPermi&#x3D;&quot;[&#39;system:user:add&#39;, &#39;system:user:edit&#39;]&quot;&gt;包含权限字符串才能看到&lt;&#x2F;el-button&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 单个角色</span><br><span class="line">&lt;el-button v-hasRole&#x3D;&quot;[&#39;admin&#39;]&quot;&gt;管理员才能看到&lt;&#x2F;el-button&gt;</span><br><span class="line">&#x2F;&#x2F; 多个角色</span><br><span class="line">&lt;el-button v-hasRole&#x3D;&quot;[&#39;role1&#39;, &#39;role2&#39;]&quot;&gt;包含角色才能看到&lt;&#x2F;el-button&gt;</span><br></pre></td></tr></table></figure>
<p>在某些情况下，不适合使用指令，只能通过<code>v-if</code>手动设置，以使用全局权限/角色判断函数<code>checkPermi</code>和<code>checkRole</code>，用法和指令 <code>v-hasPermi</code>和<code>v-hasRole</code> 类似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-tabs&gt;</span><br><span class="line">    &lt;el-tab-pane v-if&#x3D;&quot;checkPermi([&#39;system:user:add&#39;])&quot; label&#x3D;&quot;用户管理&quot; name&#x3D;&quot;user&quot;&gt;用户管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">    &lt;el-tab-pane v-if&#x3D;&quot;checkPermi([&#39;system:user:add&#39;, &#39;system:user:edit&#39;])&quot; label&#x3D;&quot;参数管理&quot; name&#x3D;&quot;menu&quot;&gt;参数管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">    &lt;el-tab-pane v-if&#x3D;&quot;checkRole([&#39;admin&#39;])&quot; label&#x3D;&quot;角色管理&quot; name&#x3D;&quot;role&quot;&gt;角色管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">    &lt;el-tab-pane v-if&#x3D;&quot;checkRole([&#39;admin&#39;,&#39;common&#39;])&quot; label&#x3D;&quot;定时任务&quot; name&#x3D;&quot;job&quot;&gt;定时任务&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">   &lt;&#x2F;el-tabs&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> &#x2F;&#x2F; 权限判断函数</span><br><span class="line">import &#123; checkPermi, checkRole &#125; from &quot;@&#x2F;utils&#x2F;permission&quot;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h1><h2 id="auth对象"><a href="#auth对象" class="headerlink" title="$auth对象"></a>$auth对象</h2><p><code>$auth</code>对象用于验证用户是否拥有某（些）权限或角色，它定义在<code>plugins/auth.js</code>文件中，它有如下方法：</p>
<ul>
<li>验证用户权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 验证用户是否具备某权限</span><br><span class="line">this.$auth.hasPermi(&quot;system:user:add&quot;);</span><br><span class="line">&#x2F;&#x2F; 验证用户是否含有指定权限，只需包含其中一个</span><br><span class="line">this.$auth.hasPermiOr([&quot;system:user:add&quot;, &quot;system:user:update&quot;]);</span><br><span class="line">&#x2F;&#x2F; 验证用户是否含有指定权限，必须全部拥有</span><br><span class="line">this.$auth.hasPermiAnd([&quot;system:user:add&quot;, &quot;system:user:update&quot;]);</span><br></pre></td></tr></table></figure></li>
<li>验证用户角色<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 验证用户是否具备某角色</span><br><span class="line">this.$auth.hasRole(&quot;admin&quot;);</span><br><span class="line">&#x2F;&#x2F; 验证用户是否含有指定角色，只需包含其中一个</span><br><span class="line">this.$auth.hasRoleOr([&quot;admin&quot;, &quot;common&quot;]);</span><br><span class="line">&#x2F;&#x2F; 验证用户是否含有指定角色，必须全部拥有</span><br><span class="line">this.$auth.hasRoleAnd([&quot;admin&quot;, &quot;common&quot;]);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="download对象"><a href="#download对象" class="headerlink" title="$download对象"></a>$download对象</h2><p><code>$download</code>对象用于文件下载，它定义在<code>plugins/download.js</code>文件中，它有如下方法：</p>
<ul>
<li>根据名称下载download路径下的文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const name &#x3D; &quot;be756b96-c8b5-46c4-ab67-02e988973090.xlsx&quot;;</span><br><span class="line">const isDelete &#x3D; true;</span><br><span class="line">&#x2F;&#x2F; 默认下载方法</span><br><span class="line">this.$download.name(name);</span><br><span class="line">&#x2F;&#x2F; 下载完成后是否删除文件</span><br><span class="line">this.$download.name(name, isDelete);</span><br></pre></td></tr></table></figure></li>
<li>根据名称下载upload路径下的文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const resource &#x3D; &quot;&#x2F;profile&#x2F;upload&#x2F;2021&#x2F;09&#x2F;27&#x2F;be756b96-c8b5-46c4-ab67-02e988973090.png&quot;;</span><br><span class="line">&#x2F;&#x2F; 默认方法</span><br><span class="line">this.$download.resource(resource);</span><br></pre></td></tr></table></figure></li>
<li>根据请求地址下载zip包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const url &#x3D; &quot;&#x2F;tool&#x2F;gen&#x2F;batchGenCode?tables&#x3D;&quot; + tableNames;</span><br><span class="line">const name &#x3D; &quot;vue3-admin&quot;;</span><br><span class="line">&#x2F;&#x2F; 默认方法</span><br><span class="line">this.$download.zip(url, name);</span><br></pre></td></tr></table></figure></li>
<li>更多文件下载操作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义文本保存</span><br><span class="line">var blob &#x3D; new Blob([&quot;Hello, world!&quot;], &#123;type: &quot;text&#x2F;plain;charset&#x3D;utf-8&quot;&#125;);</span><br><span class="line">this.$download.saveAs(blob, &quot;hello world.txt&quot;);</span><br><span class="line">&#x2F;&#x2F; 自定义文件保存</span><br><span class="line">var file &#x3D; new File([&quot;Hello, world!&quot;], &quot;hello world.txt&quot;, &#123;type: &quot;text&#x2F;plain;charset&#x3D;utf-8&quot;&#125;);</span><br><span class="line">this.$download.saveAs(file);</span><br><span class="line">&#x2F;&#x2F; 自定义data数据保存</span><br><span class="line">const blob &#x3D; new Blob([data], &#123; type: &#39;text&#x2F;plain;charset&#x3D;utf-8&#39; &#125;)</span><br><span class="line">this.$download.saveAs(blob, name)</span><br><span class="line">&#x2F;&#x2F; 根据地址保存文件</span><br><span class="line">this.$download.saveAs(&quot;https:&#x2F;&#x2F;ruoyi.vip&#x2F;images&#x2F;logo.png&quot;, &quot;logo.jpg&quot;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="modal对象"><a href="#modal对象" class="headerlink" title="$modal对象"></a>$modal对象</h2><p><code>$modal</code>对象用于做消息提示、通知提示、对话框提醒、二次确认、遮罩等，它定义在<code>plugins/modal.js</code>文件中，它有如下方法：</p>
<ul>
<li>提供成功、警告和错误等反馈信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$modal.msg(&quot;默认反馈&quot;);</span><br><span class="line">this.$modal.msgError(&quot;错误反馈&quot;);</span><br><span class="line">this.$modal.msgSuccess(&quot;成功反馈&quot;);</span><br><span class="line">this.$modal.msgWarning(&quot;警告反馈&quot;);</span><br></pre></td></tr></table></figure></li>
<li>提供成功、警告和错误等提示信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$modal.alert(&quot;默认提示&quot;);</span><br><span class="line">this.$modal.alertError(&quot;错误提示&quot;);</span><br><span class="line">this.$modal.alertSuccess(&quot;成功提示&quot;);</span><br><span class="line">this.$modal.alertWarning(&quot;警告提示&quot;);</span><br></pre></td></tr></table></figure></li>
<li>提供成功、警告和错误等通知信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$modal.notify(&quot;默认通知&quot;);</span><br><span class="line">this.$modal.notifyError(&quot;错误通知&quot;);</span><br><span class="line">this.$modal.notifySuccess(&quot;成功通知&quot;);</span><br><span class="line">this.$modal.notifyWarning(&quot;警告通知&quot;);</span><br></pre></td></tr></table></figure></li>
<li>提供确认窗体信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$modal.confirm(&#39;确认信息&#39;).then(function() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;).catch(() &#x3D;&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure></li>
<li>提供遮罩层信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打开遮罩层</span><br><span class="line">this.$modal.loading(&quot;正在导出数据，请稍后...&quot;);</span><br><span class="line">&#x2F;&#x2F; 关闭遮罩层</span><br><span class="line">this.$modal.closeLoading();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="cache对象"><a href="#cache对象" class="headerlink" title="$cache对象"></a>$cache对象</h2><p><code>$cache</code>对象用于处理缓存。不建议直接使用sessionStorage或localStorage，因为项目的缓存策略可能发生变化，通过$cache对象做一层调用代理则是一个不错的选择。$cache提供session和local两种级别的缓存。</p>
<h2 id="tab对象"><a href="#tab对象" class="headerlink" title="$tab对象"></a>$tab对象</h2><p><code>$tab</code>对象用于做页签操作、刷新页签、关闭页签、打开页签、修改页签等，它定义在<code>plugins/tab.js</code>文件中。</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Frame</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Frame</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础进阶(三)</title>
    <url>/2021/07/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%B8%89)/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2020/06/10/14/19/landscape-5282903_960_720.jpg" alt=""></p>
<a id="more"></a>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是无序属性的集合，属性包含基本值、对象或者函数。对象的创建有以下几种方式：</p>
<ol>
<li>对象字面量直接创建<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name: &quot;TOM&quot;,</span><br><span class="line">  getName: function() &#123;</span><br><span class="line">      return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 new 关键字创建<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person &#x3D; new Object()</span><br><span class="line">person.name &#x3D; &quot;TOM&quot;;</span><br><span class="line">person.getName &#x3D; function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>工厂模式<br>以person对象为例，假如在实际开发中，不仅仅需要一个名字叫做TOM的person对象，同时还需要另外一个名为Jake的person对象，虽然他们有很多相似之处，但是我们不得不重复写两次。工厂模式就是为了解决这个问题，工厂模式相当于提供一个模子，通过模子复制出多个我们需要的对象。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var createPerson &#x3D; function(name, age) &#123;</span><br><span class="line">    &#x2F;&#x2F; 声明一个中间对象，该对象就是工厂模式的模子</span><br><span class="line">    var o &#x3D; new Object();</span><br><span class="line">    &#x2F;&#x2F; 依次添加我们需要的属性与方法</span><br><span class="line">    o.name &#x3D; name;</span><br><span class="line">    o.age &#x3D; age;</span><br><span class="line">    o.getName &#x3D; function() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 创建两个实例</span><br><span class="line">var perTom &#x3D; createPerson(&#39;TOM&#39;, 20);</span><br><span class="line">var PerJake &#x3D; createPerson(&#39;Jake&#39;, 22);</span><br></pre></td></tr></table></figure>
但是，工厂模式有两个缺点：</li>
</ol>
<ul>
<li>没有办法识别实例和对象的关系，需要使用构造函数来解决这个问题；</li>
<li>对象复制，声明多个对象，就有多个getName的方法被重新生成，需要为getName分配空间。</li>
</ul>
<ol start="4">
<li>构造函数<br>解决了实例和对象的关系，即判断实例类型的问题，但是依然没有解决对象复制的问题。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Person &#x3D; function(name, age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.getName &#x3D; function() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p1 &#x3D; new Person(&#39;Ness&#39;, 20);</span><br><span class="line">console.log(p1.getName());  &#x2F;&#x2F; Ness</span><br><span class="line"></span><br><span class="line">console.log(p1 instanceof Person); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>构造函数虽然解决了判断实例类型的问题，但是对象复制问题依然没有解决。原型帮我们解决了这个问题。</p>
<ul>
<li>我们创建的每一个函数，都会有一个<code>prototype</code>属性，该属性指向一个对象。这个对象，就是我们这里说的原型。</li>
<li>当我们创建对象的时候，可以选择性的将一些属性和方法通过<code>prototype</code>属性，挂载在原型对象上。</li>
<li>每一个new出来的实例，都有一个<code>__proto__</code>属性，该属性指向构造函数的原型对象，通过这个属性，让实例对象也能够访问原型对象上的方法。</li>
<li>当所有的实例都能够通过<code>__proto__</code>访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性。</li>
<li>原型对象的<code>constructor</code>指向构造函数。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明构造函数</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 通过prototye属性，将方法挂载到原型对象上</span><br><span class="line">Person.prototype.getName &#x3D; function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">var p1 &#x3D; new Person(&#39;tim&#39;, 10);</span><br><span class="line">var p2 &#x3D; new Person(&#39;jak&#39;, 22);</span><br><span class="line">console.log(p1.getName &#x3D;&#x3D;&#x3D; p2.getName); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2022/03/15/dNIwf489nURFMLs.png" alt=""><br>通过图示我们可以看出，构造函数的<code>prototype</code>与所有实例对象的<code>__proto__</code>都指向原型对象。而原型对象的<code>constructor</code>指向构造函数。<br>根据构造函数与原型的特性，我们可以将在构造函数中，通过<strong>this声明</strong>的属性与方法称为<strong>私有变量与方法</strong>，它们被某一个实例对象所独有。而通过<strong>原型声明</strong>的属性与方法，我们可以称之为<strong>共有属性与方法</strong>，它们可以被所有的实例对象访问。<blockquote>
<p><strong>当我们访问实例对象中的属性或者方法时，会优先访问实例对象自身的属性和方法。</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  &#x2F;&#x2F; this 声明的属性和方法--私有变量和方法</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">  this.getName &#x3D; function() &#123;</span><br><span class="line">      console.log(&#39;this is constructor.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 通过原型声明的属性与方法--共有变量和方法</span><br><span class="line">Person.prototype.getName &#x3D; function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">var p1 &#x3D; new Person(&#39;tim&#39;, 10);</span><br><span class="line">&#x2F;&#x2F; 访问实例对象中的属性或者方法时，会优先访问实例对象自身的属性和方法。</span><br><span class="line">p1.getName(); &#x2F;&#x2F; this is constructor.</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>更简单的原型写法：<br><strong>注意：</strong><code>Person.prototype = {}</code>实际上是重新创建了一个<code>{}</code>对象并赋值给<code>Person.prototype</code>，这里的<code>{}</code>并不是最初的那个原型对象。因此它里面并不包含<code>constructor</code>属性。为了保证正确性，我们必须在新创建的<code>{}</code>对象中显式的设置<code>constructor</code>的指向，即<code>constructor: Person</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">Person.prototype &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 新建的对象无constructor，必须显式设置</span><br><span class="line">  constructor: Person,</span><br><span class="line">  getName: function() &#123;&#125;,</span><br><span class="line">  getAge: function() &#123;&#125;,</span><br><span class="line">  sayHello: function() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>由对象及其原型组成的链就叫做原型链。当访问一个对象的属性时，先在对象的本身找，找不到就去对象的原型上找，如果还是找不到，就去对象的原型（原型也是对象，也有它自己的原型）的原型上找，如此继续，直到找到为止，或者查找到最顶层的原型对象中也没有找到，就结束查找，返回undefined。<br>以函数对象的原型链为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add()&#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 分析过程如下：</span><br><span class="line">1.函数有__proto__属性，指向Function原型，所以add.__proto__&#x3D;&#x3D;&#x3D;Function.prototype</span><br><span class="line">2.原型Function.prototype也有__proto__属性，指向Object原型，所以</span><br><span class="line">  Function.prototype.__proto__&#x3D;&#x3D;&#x3D;Object.prototype</span><br><span class="line">3.这里需要注意：Object.prototype.__proto__&#x3D;&#x3D;&#x3D;null</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/15/kTzItvyePnXDGcS.png" alt=""><br>所以我们也可以换个方式描述下原型链 ：由对象的<code>__proto__</code>属性串连起来的直到<code>Object.prototype.__proto__</code>（为null）的链就是原型链。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父级对象</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName &#x3D; function() &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getAge &#x3D; function() &#123;</span><br><span class="line">  return this.age;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子级对象-构造函数继承</span><br><span class="line">function Student(name, age, grade) &#123;</span><br><span class="line">  Person.call(this, name, age);</span><br><span class="line">  this.grade &#x3D; grade;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子级对象-原型继承</span><br><span class="line">Student.prototype &#x3D; new Person(name, age);</span><br><span class="line">Student.prototype.getGrade &#x3D; function() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>子级对象的原型继承，如何将子级对象的原型加入到原型链中？</p>
<ul>
<li>让子级对象的原型，成为父级对象的一个实例。</li>
<li>然后通过<code>__proto__</code>就可以访问父级对象的原型，这样就继承了父级原型中的方法与属性了。<br>这是<strong>更好的继承</strong>，封装一个继承的方法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function create(proto, options) &#123;</span><br><span class="line">  &#x2F;&#x2F; 创建一个空对象</span><br><span class="line">  var tmp &#x3D; &#123;&#125;;</span><br><span class="line">  &#x2F;&#x2F; 让这个新的空对象成为父类对象的实例</span><br><span class="line">  tmp.__proto__ &#x3D; proto;</span><br><span class="line">  &#x2F;&#x2F; 传入的方法都挂载到新对象上，新的对象将作为子类对象的原型</span><br><span class="line">  Object.defineProperties(tmp, options);</span><br><span class="line">  return tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实现原型的继承</span><br><span class="line">Student.prototype &#x3D; create(Person.prototype, &#123;</span><br><span class="line">  &#x2F;&#x2F; 不要忘了重新指定构造函数</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: Student</span><br><span class="line">  &#125;</span><br><span class="line">  getGrade: &#123;</span><br><span class="line">    value: function() &#123;</span><br><span class="line">      return this.grade</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>在ECMAScript5中提供了<code>Object.create()</code>方法来实现继承</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student.prototype &#x3D; Object.create(Person.prototype, &#123;</span><br><span class="line">  &#x2F;&#x2F; 不要忘了重新指定构造函数</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: Student</span><br><span class="line">  &#125;</span><br><span class="line">  getGrade: &#123;</span><br><span class="line">    value: function() &#123;</span><br><span class="line">      return this.grade</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="对象新增方法"><a href="#对象新增方法" class="headerlink" title="对象新增方法"></a>对象新增方法</h2><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p><code>Object.is()</code>用于比较两个值是否相等，比较两值是否相等可以使用运算符<code>==</code>或者<code>===</code>，但是<code>==</code>不严谨，会自动转换数据类型，<code>===</code>严谨，但是存在以下问题，使用<code>Object.is()</code>就可以解决该问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &#x3D;&#x3D;&#x3D; -0 &#x2F;&#x2F; true</span><br><span class="line">NaN &#x3D;&#x3D;&#x3D; NaN &#x2F;&#x2F; false</span><br><span class="line">Object.is(0,-0) &#x2F;&#x2F; false</span><br><span class="line">Object.is(NaN,NaN) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p><code>Object.assign()</code>用于对象合并，将源对象（source，可选，一个或者多个）所有可枚举的属性复制到目标对象。<br><strong>注意：</strong>这里的复制是指拷贝属性名和对象的值，如果该属性是get（取值函数）或者set（赋值函数），拷贝的是函数执行之后返回的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj1 &#x3D; &#123;a:1&#125;</span><br><span class="line">const obj2 &#x3D; Object.assign(obj1) &#x2F;&#x2F; &#123;a:1&#125;</span><br><span class="line">obj2 &#x3D;&#x3D;&#x3D; obj1 &#x2F;&#x2F; true</span><br><span class="line">obj2.b &#x3D; 2 &#x2F;&#x2F; obj1&#x3D;obj2&#x3D;&#123;a:1,b:2&#125;</span><br><span class="line"></span><br><span class="line">const obj3 &#x3D; &#123;a:1,b:2&#125;</span><br><span class="line">const obj4 &#x3D; &#123;a:11,b:22,c:33&#125;</span><br><span class="line">const obj5 &#x3D; Object.assign(&#123;&#125;,obj3,obj4) &#x2F;&#x2F; &#123;a:11,b:22,c:33&#125;</span><br></pre></td></tr></table></figure>
<p>属于<strong>浅拷贝</strong>行为，如果源对象的某个属性是对象，那么目标对象里面合并的是该对象的引用，该对象数据发生变更，目标对象也会发生改变。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const source &#x3D; &#123;a:1,b:&#123;c:2&#125;&#125;</span><br><span class="line">const target &#x3D; Object.assign(&#123;&#125;,source) &#x2F;&#x2F; target &#x3D; &#123;a:1,b:&#123;c:2&#125;&#125;</span><br><span class="line">source.a &#x3D; 3</span><br><span class="line">source.b.c &#x3D; 4 &#x2F;&#x2F; target &#x3D; &#123;a:1,b:&#123;c:4&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如果目标对象不是对象，会先将其转为对象，像null、undefined这样不能转为对象的，会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.assign(2) &#x2F;&#x2F; Number &#123;2&#125;</span><br><span class="line">Object.assign(null) &#x2F;&#x2F; 报错</span><br><span class="line">Object.assign(undefined) &#x2F;&#x2F; 报错</span><br><span class="line">const obj &#x3D; &#123;a:1&#125;</span><br><span class="line">Object.assign(obj,null) &#x3D;&#x3D;&#x3D; obj &#x2F;&#x2F; true</span><br><span class="line">Object.assign(obj,undefined) &#x3D;&#x3D;&#x3D; obj &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p><strong>用途：</strong>合并对象；为对象添加属性或者方法；克隆对象等等。</p>
<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p><code>Object.getOwnPropertyDescriptor()</code>返回对象指定属性的描述对象（descriptor）;<br><code>Object.getOwnPropertyDescriptors()</code>返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  foo: 123,</span><br><span class="line">  get bar() &#123; return &#39;abc&#39; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Object.getOwnPropertyDescriptor(obj,&#39;foo&#39;)</span><br><span class="line">&#x2F;&#x2F; foo:&#123;</span><br><span class="line">&#x2F;&#x2F;   configurable: true</span><br><span class="line">&#x2F;&#x2F;   enumerable: true</span><br><span class="line">&#x2F;&#x2F;   value: 123</span><br><span class="line">&#x2F;&#x2F;   writable: true</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line">Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F;   bar:&#123;</span><br><span class="line">&#x2F;&#x2F;     configurable:true,</span><br><span class="line">&#x2F;&#x2F;     enumerable:true,</span><br><span class="line">&#x2F;&#x2F;     get:[Function: get bar],</span><br><span class="line">&#x2F;&#x2F;     set:undefined,</span><br><span class="line">&#x2F;&#x2F;   &#125;,</span><br><span class="line">&#x2F;&#x2F;   foo:&#123;</span><br><span class="line">&#x2F;&#x2F;     configurable: true</span><br><span class="line">&#x2F;&#x2F;     enumerable: true</span><br><span class="line">&#x2F;&#x2F;     value: 123</span><br><span class="line">&#x2F;&#x2F;     writable: true</span><br><span class="line">&#x2F;&#x2F;   &#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>用途：</strong>解决<code>Object.assign()</code>无法正确拷贝 get 和 set 属性的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const source &#x3D; &#123;</span><br><span class="line">  set foo(value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const target1 &#x3D; &#123;&#125;;</span><br><span class="line">Object.assign(target1, source); &#x2F;&#x2F; target1&#x3D;&#123;foo:undefined&#125;</span><br><span class="line"></span><br><span class="line">const target2 &#x3D; &#123;&#125;;</span><br><span class="line">Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));</span><br><span class="line">Object.getOwnPropertyDescriptor(target2, &#39;foo&#39;)</span><br><span class="line">&#x2F;&#x2F; &#123; get: undefined,</span><br><span class="line">&#x2F;&#x2F;   set: [Function: set foo],</span><br><span class="line">&#x2F;&#x2F;   enumerable: true,</span><br><span class="line">&#x2F;&#x2F;   configurable: true &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p>每个对象都有<code>__proto__</code>属性，这个属性指向构造函数的原型对象<code>prototype</code>，我们可以通过<code>__proto__</code>这个属性来操作对象的原型对象。</p>
<p>但是这个属性前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，所以当我们想要生成、读、写原型上的方法时，尽量不使用这个属性，使用对应的方法<code>Object.create()</code>、<code>Object.getPrototypeOf()</code>、<code>Object.setPrototypeOf()</code>。</p>
<p><code>Object.setPrototypeOf(object,prototype)</code>用来设置一个对象的原型对象，返回的参数是对象本身。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将proto对象设为obj对象的原型，所以可以通过obj读取proto的属性</span><br><span class="line">let proto &#x3D; &#123;&#125;;</span><br><span class="line">let obj &#x3D; &#123; x: 10 &#125;;</span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line">proto.y &#x3D; 20;</span><br><span class="line">proto.z &#x3D; 40;</span><br><span class="line">obj.x &#x2F;&#x2F; 10</span><br><span class="line">obj.y &#x2F;&#x2F; 20</span><br><span class="line">obj.z &#x2F;&#x2F; 40</span><br></pre></td></tr></table></figure>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p><code>Object.getPrototypeOf()</code>用来读取对象的原型对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a&#x3D;[1,2,3]</span><br><span class="line">Object.getPrototypeOf(a) &#x3D;&#x3D;&#x3D; Array.prototype &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p><code>Object.keys()</code>返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。可以和<code>Object.values()</code>和<code>Object.entries()</code>搭配使用实现对象的循环遍历。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;</span><br><span class="line">Object.keys(obj) &#x2F;&#x2F; [&#39;foo&#39;,&#39;baz&#39;]</span><br></pre></td></tr></table></figure>
<h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p><code>Object.values()</code>返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<p>如果入参不是对象，会先将入参转为对象，比如字符串转成数组字符串，但是数字或者布尔值的包装对象，都不会为实例添加非继承的属性。所以<code>Object.values</code>会返回空数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;</span><br><span class="line">Object.values(obj) &#x2F;&#x2F; [&#39;bar&#39;,42]</span><br><span class="line"></span><br><span class="line">Object.values(&#39;foo&#39;) &#x2F;&#x2F; [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]</span><br><span class="line">Object.values(42) &#x2F;&#x2F; []</span><br><span class="line">Object.values(true) &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>
<h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p><code>Object.entries()</code>返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;</span><br><span class="line">Object.entries(obj) &#x2F;&#x2F; [[&#39;foo&#39;,&#39;bar&#39;],[&#39;baz&#39;,42]]</span><br></pre></td></tr></table></figure>
<p><strong>用途：</strong>1、遍历对象；2、对象转Map；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 遍历对象</span><br><span class="line">let obj &#x3D; &#123; one: 1, two: 2 &#125;;</span><br><span class="line">for (let [k, v] of Object.entries(obj)) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &#96;$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;&#96;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;one&quot;: 1</span><br><span class="line">&#x2F;&#x2F; &quot;two&quot;: 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象转Map</span><br><span class="line">const obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;;</span><br><span class="line">const map &#x3D; new Map(Object.entries(obj));</span><br><span class="line">map &#x2F;&#x2F; Map(2) &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p><code>Object.fromEntries()</code>是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.fromEntries([</span><br><span class="line">  [&#39;foo&#39;, &#39;bar&#39;],</span><br><span class="line">  [&#39;baz&#39;, 42]</span><br><span class="line">])</span><br><span class="line">&#x2F;&#x2F; &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>用途：</strong>1、将 Map 结构转换成对象；2、将查询字符串转换为对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Map转对象</span><br><span class="line">const entries &#x3D; new Map([</span><br><span class="line">  [&#39;foo&#39;, &#39;bar&#39;],</span><br><span class="line">  [&#39;baz&#39;, 42]</span><br><span class="line">]);</span><br><span class="line">Object.fromEntries(entries) &#x2F;&#x2F; &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br><span class="line">const map &#x3D; new Map().set(&#39;foo&#39;, true).set(&#39;bar&#39;, false);</span><br><span class="line">Object.fromEntries(map) &#x2F;&#x2F; &#123; foo: true, bar: false &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询字符串转对象</span><br><span class="line">Object.fromEntries(new URLSearchParams(&#39;foo&#x3D;bar&amp;baz&#x3D;qux&#39;))</span><br><span class="line">&#x2F;&#x2F; &#123; foo: &quot;bar&quot;, baz: &quot;qux&quot; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><h3 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h3><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let birth &#x3D; &#39;2000&#x2F;01&#x2F;01&#39;;</span><br><span class="line">const Person &#x3D; &#123;</span><br><span class="line">  name: &#39;张三&#39;,</span><br><span class="line">  &#x2F;&#x2F;等同于birth: birth</span><br><span class="line">  birth,</span><br><span class="line">  &#x2F;&#x2F; 等同于hello: function ()...</span><br><span class="line">  hello() &#123; console.log(&#39;我的名字是&#39;, this.name); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>简写的对象方法不能用作构造函数，会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj&#x3D;&#123;</span><br><span class="line">    a:function()&#123;</span><br><span class="line">      console.log(111)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 函数简写</span><br><span class="line">    b()&#123;</span><br><span class="line">      console.log(222)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new obj.a())</span><br><span class="line">console.log(new obj.b())</span><br><span class="line">&#x2F;&#x2F; 111</span><br><span class="line">&#x2F;&#x2F; a &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: obj.b is not a constructor</span><br></pre></td></tr></table></figure>
<h3 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h3><p>对象的每个属性都有一个描述对象，可以用<code>Object.getOwnPrototypeDescriptor()</code>方法获取对象指定属性的描述对象，描述对象的<code>enumerable</code>属性，就是可枚举性。</p>
<p>如果<code>enumerable</code>属性为false，就表明该属性是不可枚举的，当我们使用以下四个方法操作对象的时候，会跳过不可枚举的属性：</p>
<ul>
<li>for…in循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名。</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性。</li>
<li>Object.assign()：只拷贝对象自身的可枚举的属性。</li>
</ul>
<p>所以可以利用这个不可枚举来规避for…in循环对象内部所有属性和方法的问题。比如对象的toString()方法，因为不可枚举，循坏的时候就不会循环该方法。</p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>对象有一个super关键字，代表该对象的原型对象，但是super关键字只能用在对象的方法里面，用在其他地方会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const proto &#x3D; &#123;</span><br><span class="line">  foo: &#39;hello&#39;</span><br><span class="line">&#125;</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  foo: &#39;world&#39;,</span><br><span class="line">  find() &#123;</span><br><span class="line">    return super.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Object.setPrototypeOf(obj, proto) &#x2F;&#x2F; obj 的原型对象是 proto</span><br><span class="line">obj.find() &#x2F;&#x2F; &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以下三种情况都报错</span><br><span class="line">const obj &#x3D; &#123;foo: super.foo&#125;</span><br><span class="line">const obj &#x3D; &#123;foo: () &#x3D;&gt; super.foo&#125;</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  foo: function () &#123;</span><br><span class="line">    return super.foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><code>__proto__</code>和<code>prototype</code></li>
</ol>
<ul>
<li>对象有<code>__proto__</code>属性，函数有<code>__proto__</code>属性，数组也有<code>__proto__</code>属性，只要是引用类型，就有<code>__proto__</code>属性，指向其原型。</li>
<li>只有函数有<code>prototype</code>属性，只有函数有<code>prototype</code>属性，只有函数有<code>prototype</code>属性，指向new操作符加调用该函数创建的对象实例的原型对象。</li>
</ul>
<ol start="2">
<li><code>instanceof</code><br>判断数据类型，可以使用<code>typeof</code>运算符，但是引用数据类型并不适用，除了函数返回的是<code>function</code>，其他返回的全是<code>object</code>。我们想要知道一个对象的具体类型，就需要使用到<code>instanceof</code>。<code>instanceof</code>的实际原理就是判断右侧的<code>prototype</code>是否在左侧对象的原型链上。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例：函数对象和数组对象最终的原型链顶层就是Object</span><br><span class="line">let fn &#x3D; function() &#123;&#125;</span><br><span class="line">let arr &#x3D; []</span><br><span class="line">fn instanceof Function &#x2F;&#x2F; true</span><br><span class="line">arr instanceof Array &#x2F;&#x2F; true</span><br><span class="line">fn instanceof Object &#x2F;&#x2F; true</span><br><span class="line">arr instanceof Object &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 手动实现instanceof</span><br><span class="line">var myInstanceof &#x3D; function(target,origin)&#123;</span><br><span class="line">  const proto &#x3D; target.__proto__</span><br><span class="line">  if(proto)&#123;</span><br><span class="line">    if(origin.prototype &#x3D;&#x3D;&#x3D; proto)&#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      return myInstanceof(proto,origin)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如何创建一个没有原型的对象？<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const tempObj &#x3D; Object.create(null)</span><br><span class="line">console.log(tempObj.__proto__) &#x2F;&#x2F; undefined</span><br><span class="line">&#x2F;&#x2F; Object.create的第一个入参只能是null或者非原始包装对象，否则会抛出异常</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>在JavaScript中，生成实例对象的传统写法是通过构造函数，但是这种写法和面向对象的传统编程语言差异很大，为了更接近传统语言，引入 Class 类，类可以看作是构造函数的另一种写法。</p>
<p><strong>类所有的属性和方法，都定义在类的prototype属性上面</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 传统写法</span><br><span class="line">function Point1(x, y) &#123;</span><br><span class="line">  this.x &#x3D; x;</span><br><span class="line">  this.y &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line">Point1.prototype.toString &#x3D; function () &#123;</span><br><span class="line">  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">&#125;;</span><br><span class="line">var p1 &#x3D; new Point1(1, 2);</span><br><span class="line">&#x2F;&#x2F; Class 写法</span><br><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const p &#x3D; new Point(1,2)</span><br><span class="line">&#x2F;&#x2F; 类可以看作是构造函数的另一种写法</span><br><span class="line">Point &#x3D;&#x3D;&#x3D; Point.prototype.constructor &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 类所有的属性和方法，都定义在类的prototype属性上面</span><br><span class="line">p.constructor &#x3D;&#x3D;&#x3D; Point.prototype.constructor &#x2F;&#x2F; true</span><br><span class="line">p.hasOwnProperty(&#39;x&#39;) &#x2F;&#x2F; true</span><br><span class="line">p.hasOwnProperty(&#39;y&#39;) &#x2F;&#x2F; true</span><br><span class="line">p.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; false</span><br><span class="line">p.__proto__.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p><code>constructor()</code>类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的constructor()方法会被默认添加。</p>
<p><code>constructor()</code>方法默认返回实例对象（即this）</p>
<h2 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h2><h3 id="实例属性新写法"><a href="#实例属性新写法" class="headerlink" title="实例属性新写法"></a>实例属性新写法</h3><p>属性除了可以定义在<code>constructor()</code>里的<code>this</code>上，还可以定义在类内部的最顶层。虽然写法不一样，但是都是指向实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  &#x2F;&#x2F; 新写法</span><br><span class="line">  x &#x3D; 0</span><br><span class="line">  y &#x3D; 0</span><br><span class="line">  &#x2F;&#x2F; 旧写法</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="取值函数-getter-和存值函数-setter"><a href="#取值函数-getter-和存值函数-setter" class="headerlink" title="取值函数(getter)和存值函数(setter)"></a>取值函数(getter)和存值函数(setter)</h3><p>类可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置取值函数和存值函数，拦截该属性的存取行为。<br>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;&#125;</span><br><span class="line">  get num() &#123;</span><br><span class="line">    return &#39;getter&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  set num(value) &#123;</span><br><span class="line">    console.log(&#39;setter:&#39;+value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const p &#x3D; new Point()</span><br><span class="line">p.num &#x3D; 1 &#x2F;&#x2F; setter:1</span><br><span class="line">p.num &#x2F;&#x2F; getter</span><br><span class="line">const desc &#x3D; Object.getOwnPropertyDescriptor(Point.prototype,&#39;num&#39;)</span><br><span class="line">&#39;get&#39; in desc &#x2F;&#x2F; true</span><br><span class="line">&#39;set&#39; in desc &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h3 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h3><p>静态属性和方法，就是在属性和方法前面加上<code>static</code>关键字，表示该属性和方法<strong>不会被实例继承</strong>，但是会被子类继承，可以直接通过类来操作。</p>
<p>静态方法里面的this，指向类，而不是实例。</p>
<p>静态方法可以和非静态方法重名，静态方法可以从<code>super</code>对象上调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static prop &#x3D; 1; &#x2F;&#x2F; 静态属性</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    return &#39;hello&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  static bar() &#123;</span><br><span class="line">    this.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  static baz() &#123;</span><br><span class="line">    console.log(&#39;hello&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  baz() &#123;   &#x2F;&#x2F; 静态方法可以和非静态方法重名</span><br><span class="line">    console.log(&#39;world&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() &#x2F;&#x2F; &#39;hello&#39; 静态方法通过类来操作</span><br><span class="line"></span><br><span class="line">var foo &#x3D; new Foo();</span><br><span class="line">foo.classMethod() &#x2F;&#x2F; 静态方法不会被实例继承</span><br><span class="line">&#x2F;&#x2F; TypeError: foo.classMethod is not a function</span><br><span class="line"></span><br><span class="line">Foo.bar() &#x2F;&#x2F; hello 静态方法里的this指向类</span><br><span class="line"></span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">  static classMethod2() &#123;</span><br><span class="line">    return super.classMethod() + &#39;, too&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() &#x2F;&#x2F; &#39;hello&#39; 静态方法可以被子类继承</span><br><span class="line">Bar.classMethod(2) &#x2F;&#x2F; &#39;hello, too&#39; 静态方法可以用super对象调用</span><br></pre></td></tr></table></figure>
<h3 id="私有属性和方法"><a href="#私有属性和方法" class="headerlink" title="私有属性和方法"></a>私有属性和方法</h3><p>私有属性和方法，就是在属性和方法前面加上<code>#</code>，表示该属性和方法<strong>只能在类的内部使用</strong>。</p>
<p>私有属性和方法<strong>不能被子类继承</strong>。</p>
<p>私有属性也可以设置 getter 和 setter 函数进行操作拦截。</p>
<h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><p>类可以通过<code>extends</code>关键字实现继承，让子类继承父类的所有属性和方法，除了私有属性和方法。</p>
<p><strong>子类必须在<code>constructor()</code>方法中先调用<code>super()</code>，否则会报错。</strong><br>这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用super()方法，子类就得不到自己的this对象。</p>
<p><code>super()</code>作为函数，表示父类的构造函数，只能在子类的<code>constructor()</code>里使用，被调用的时候用来创建一个父类的实例，但是返回的是子类的实例。<br><code>super</code>作为对象，在普通方法里，指向父类的原型对象；在静态方法里，指向父类。</p>
<p>如果子类没有显示的定义<code>constructor()</code>，这个方法默认添加，并且里面会调用<code>super()</code>。</p>
<p>可以使用<code>Object.getPrototypeOf()</code>来获取子类的父类。</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>Set，它类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成 Set 数据结构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const s &#x3D; new Set();</span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].forEach(x &#x3D;&gt; s.add(x));</span><br><span class="line">for (let i of s) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 2 3 5 4</span><br><span class="line"></span><br><span class="line">const set &#x3D; new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...set]</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 去除数组的重复成员</span><br><span class="line">const array&#x3D;[1,1,2,2,3,3]</span><br><span class="line">&#x2F;&#x2F; 方法一：</span><br><span class="line">[...new Set(array)]</span><br><span class="line">&#x2F;&#x2F; 方法二：该方法可将Set转换成数组</span><br><span class="line">Array.from(new Set(array))</span><br><span class="line">&#x2F;&#x2F; [1,2,3]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 去除字符串的重复字符</span><br><span class="line">[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)</span><br><span class="line">&#x2F;&#x2F; &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;'>
往 Set 里面加值的时候，内部判断两值是否相等的算法，叫做“Same-value-zero equality”，它类似于精确相等运算符（`===`），区别就在于向 Set 加入值时认为NaN等于自身（即不能添加两个NaN），而精确相等运算符认为NaN不等于自身。
</div>

<h2 id="实例属性-size"><a href="#实例属性-size" class="headerlink" title="实例属性-size"></a>实例属性-size</h2><p><code>Set.prototype.size</code>：返回Set实例的成员总数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.add(1).add(2).add(2);</span><br><span class="line">&#x2F;&#x2F; 注意2被加入了两次</span><br><span class="line"></span><br><span class="line">s.size &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<h2 id="实例操作方法-add-delete-has-clear"><a href="#实例操作方法-add-delete-has-clear" class="headerlink" title="实例操作方法-add/delete/has/clear"></a>实例操作方法-add/delete/has/clear</h2><ul>
<li><code>Set.property.add()</code>：添加某个值，返回 Set 结构本身。</li>
<li><code>Set.property.delete()</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>Set.property.has()</code>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><code>Set.property.clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.add(1).add(2).add(2);</span><br><span class="line">&#x2F;&#x2F; 注意2被加入了两次</span><br><span class="line"></span><br><span class="line">s.size &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">s.has(1) &#x2F;&#x2F; true</span><br><span class="line">s.has(2) &#x2F;&#x2F; true</span><br><span class="line">s.has(3) &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">s.delete(2); &#x2F;&#x2F; true-表示删除成功</span><br><span class="line">s.has(2) &#x2F;&#x2F; false</span><br><span class="line">s.clear() &#x2F;&#x2F; 清空，无返回值</span><br></pre></td></tr></table></figure>

<h2 id="实例遍历方法-keys-values-entries-forEach"><a href="#实例遍历方法-keys-values-entries-forEach" class="headerlink" title="实例遍历方法-keys/values/entries/forEach"></a>实例遍历方法-keys/values/entries/forEach</h2><ul>
<li><code>Set.prototype.keys()</code>：返回键名的遍历器。</li>
<li><code>Set.prototype.values()</code>：返回键值的遍历器。</li>
<li><code>Set.prototype.entries()</code>：返回键值对的遍历器。</li>
<li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员。</li>
</ul>
<p>keys方法、values方法、entries方法返回的都是遍历器对象。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致，entries方法同时包含键名和键值，键名和键值一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let set &#x3D; new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);</span><br><span class="line"></span><br><span class="line">for (let item of set.keys()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; red</span><br><span class="line">&#x2F;&#x2F; green</span><br><span class="line">&#x2F;&#x2F; blue</span><br><span class="line"></span><br><span class="line">for (let item of set.values()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; red</span><br><span class="line">&#x2F;&#x2F; green</span><br><span class="line">&#x2F;&#x2F; blue</span><br><span class="line"></span><br><span class="line">for (let item of set.entries()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [&quot;red&quot;, &quot;red&quot;]</span><br><span class="line">&#x2F;&#x2F; [&quot;green&quot;, &quot;green&quot;]</span><br><span class="line">&#x2F;&#x2F; [&quot;blue&quot;, &quot;blue&quot;]</span><br><span class="line"></span><br><span class="line">set.forEach((value, key) &#x3D;&gt; console.log(key + &#39; : &#39; + value))</span><br><span class="line">&#x2F;&#x2F; red : red</span><br><span class="line">&#x2F;&#x2F; green : green</span><br><span class="line">&#x2F;&#x2F; blue : blue</span><br></pre></td></tr></table></figure>
<p><strong>Set 实例默认可遍历，它的默认遍历器生成函数就是它的values方法，所以可以省略values方法，直接使用<code>for...of</code>遍历</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 下面两种用法一致</span><br><span class="line">for (let item of set.values()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">for (let item of set) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。它与 Set 区别如下：</p>
<ul>
<li>WeakSet 的成员只能是对象，而不能是其他类型的值；Set 可以是任意类型。</li>
<li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</li>
<li>WeakSet 只有 <code>add()/delete()/has()</code> 方法，不支持<code>clear()</code>、<code>size</code>属性和遍历方法。</li>
</ul>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h2><p>Map，它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将对象作为键</span><br><span class="line">const m &#x3D; new Map();</span><br><span class="line">const o &#x3D; &#123;p: &#39;Hello World&#39;&#125;;</span><br><span class="line">m.set(o, &#39;content&#39;)</span><br><span class="line">&#x2F;&#x2F; 接受数组作为参数，数组的成员是一个个键值对的数组</span><br><span class="line">const map &#x3D; new Map([</span><br><span class="line">  [&#39;name&#39;, &#39;张三&#39;],</span><br><span class="line">  [&#39;title&#39;, &#39;Author&#39;]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<h2 id="实例属性-size-1"><a href="#实例属性-size-1" class="headerlink" title="实例属性-size"></a>实例属性-size</h2><p><code>Map.property.size</code>：返回Map实例的成员总数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const map &#x3D; new Map();</span><br><span class="line">map.set(&#39;foo&#39;, true);</span><br><span class="line">map.set(&#39;bar&#39;, false);</span><br><span class="line"></span><br><span class="line">map.size &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<h2 id="实例操作方法-set-get-has-delete-clear"><a href="#实例操作方法-set-get-has-delete-clear" class="headerlink" title="实例操作方法-set/get/has/delete/clear"></a>实例操作方法-set/get/has/delete/clear</h2><ul>
<li><code>Map.prototype.set(key, value)</code>：set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</li>
<li><code>Map.prototype.get(key)</code>：get方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li><code>Map.prototype.has(key)</code>：has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>
<li><code>Map.prototype.delete(key)</code>：delete方法删除某个键，返回true。如果删除失败，返回false。</li>
<li><code>Map.prototype.clear()</code>：clear方法清除所有成员，没有返回值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const m &#x3D; new Map();</span><br><span class="line"></span><br><span class="line">m.set(&#39;edition&#39;, 6)        &#x2F;&#x2F; 键是字符串</span><br><span class="line">m.set(262, &#39;standard&#39;)     &#x2F;&#x2F; 键是数值</span><br><span class="line">m.set(undefined, &#39;nah&#39;)    &#x2F;&#x2F; 键是 undefined</span><br><span class="line">m.set(1,&#39;1&#39;).set(2,&#39;2&#39;)    &#x2F;&#x2F; set返回的是当前Map对象，所以可以采用链式写法</span><br><span class="line">m.set(1,&#39;一&#39;)</span><br><span class="line">m.get(1)  &#x2F;&#x2F; 一 key已经存在，重复赋值键值会被更新</span><br><span class="line">m.set([&#39;aaa&#39;],1)</span><br><span class="line">m.get([&#39;aaa&#39;]) &#x2F;&#x2F; undefined </span><br><span class="line">&#x2F;&#x2F; 如果键是引用数据类型，那么set和get表面上针对的是同一个键，但是键的内存地址不同，所以get方法无法读物键值，返回undefined</span><br><span class="line">const k1 &#x3D; [&#39;a&#39;]</span><br><span class="line">const k2 &#x3D; [&#39;a&#39;]</span><br><span class="line">m.set(k1,1).set(k2,2)</span><br><span class="line">m.get(k1) &#x2F;&#x2F; 1</span><br><span class="line">m.get(k2) &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">m.has(&#39;edition&#39;) &#x2F;&#x2F; true</span><br><span class="line">m.has(11111) &#x2F;&#x2F; false</span><br><span class="line">m.delete(262) &#x2F;&#x2F; true</span><br><span class="line">m.get(262) &#x2F;&#x2F; undefined</span><br><span class="line">m.clear()</span><br><span class="line">m.size &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>
<h2 id="实例遍历方法-keys-values-entries-forEach-1"><a href="#实例遍历方法-keys-values-entries-forEach-1" class="headerlink" title="实例遍历方法-keys/values/entries/forEach"></a>实例遍历方法-keys/values/entries/forEach</h2><ul>
<li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li>
<li><code>Map.prototype.values()</code>：返回键值的遍历器。</li>
<li><code>Map.prototype.entries()</code>：返回键值对的遍历器。</li>
<li><code>Map.prototype.forEach()</code>：使用回调函数遍历每个成员。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const map &#x3D; new Map([</span><br><span class="line">  [&#39;F&#39;, &#39;no&#39;],</span><br><span class="line">  [&#39;T&#39;,  &#39;yes&#39;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">for (let key of map.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot;</span><br><span class="line">[...map.keys()]</span><br><span class="line">&#x2F;&#x2F; [&quot;F&quot;,&quot;T&quot;]</span><br><span class="line"></span><br><span class="line">for (let value of map.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;yes&quot;</span><br><span class="line">[...map.values()]</span><br><span class="line">&#x2F;&#x2F; [&quot;no&quot;,&quot;yes&quot;]</span><br><span class="line"></span><br><span class="line">for (let item of map.entries()) &#123;</span><br><span class="line">  console.log(item[0], item[1]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot; &quot;yes&quot;</span><br><span class="line">[...map.entries()]</span><br><span class="line">&#x2F;&#x2F; [[&quot;F&quot;,&quot;no&quot;],[&quot;T&quot;,&quot;yes&quot;]]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">for (let [key, value] of map.entries()) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot; &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于使用map.entries()</span><br><span class="line">for (let [key, value] of map) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot; &quot;yes&quot;</span><br><span class="line">[...map]</span><br><span class="line">&#x2F;&#x2F; [[&quot;F&quot;,&quot;no&quot;],[&quot;T&quot;,&quot;yes&quot;]]</span><br><span class="line"></span><br><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; Key: F, Value: no</span><br><span class="line">&#x2F;&#x2F; Key: T, Value: yes</span><br></pre></td></tr></table></figure>
<h2 id="数据结构相互转化"><a href="#数据结构相互转化" class="headerlink" title="数据结构相互转化"></a>数据结构相互转化</h2><ul>
<li>Map &lt;==&gt; 数组<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Map 转 数组，使用扩展运算符(...)</span><br><span class="line">const myMap &#x3D; new Map().set(true, 7).set(&#123;foo: 3&#125;, [&#39;abc&#39;]);</span><br><span class="line">[...myMap]</span><br><span class="line">&#x2F;&#x2F; [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#39;abc&#39; ] ] ]</span><br><span class="line">&#x2F;&#x2F; 数组 转 Map，将数组传入Map构造函数即可</span><br><span class="line">new Map([</span><br><span class="line">  [true, 7],</span><br><span class="line">  [&#123;foo: 3&#125;, [&#39;abc&#39;]]</span><br><span class="line">])</span><br></pre></td></tr></table></figure></li>
<li>Map &lt;==&gt; 对象<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Map 转 对象，如果键是字符串可以无损转化，不是的话会被转成字符串</span><br><span class="line">function strMapToObj(strMap) &#123;</span><br><span class="line">  let obj &#x3D; Object.create(null);</span><br><span class="line">  for (let [k,v] of strMap) &#123;</span><br><span class="line">    obj[k] &#x3D; v;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 对象 转 Map，使用 Object.entries() 最方便</span><br><span class="line">let obj &#x3D; &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;</span><br><span class="line">let map &#x3D; new Map(Object.entries(obj));</span><br><span class="line">&#x2F;&#x2F; 也可以自己手写函数</span><br><span class="line">function objToStrMap(obj) &#123;</span><br><span class="line">  let strMap &#x3D; new Map();</span><br><span class="line">  for (let k of Object.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  return strMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p>WeakMap 与 Map 类似，都是用于生成键值对的集合。它与 Map 区别如下：</p>
<ul>
<li>WeakMap 只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li>
<li>WeakMap 的键名所指向的对象，不计入垃圾回收机制。<br>它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用<strong>手动删除</strong>引用。</li>
<li>WeakMap 只有 <code>set()/get()/delete()/has()</code> 方法，不支持<code>clear()</code>、<code>size</code>属性和遍历方法。</li>
</ul>
<h1 id="ES6新增运算符"><a href="#ES6新增运算符" class="headerlink" title="ES6新增运算符"></a>ES6新增运算符</h1><h2 id="指数运算符"><a href="#指数运算符" class="headerlink" title="** 指数运算符"></a>** 指数运算符</h2><p>当有多个指数运算符的时候，从最右边开始计算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; 5</span><br><span class="line">a ** 3 &#x2F;&#x2F; 5*5*5 &#x3D; 125</span><br><span class="line">&#x2F;&#x2F; 右结合</span><br><span class="line">2 ** 3 ** 2 &#x2F;&#x2F; 2**(3**2) 先计算3*3等于9，再计算2^9等于512</span><br><span class="line">a **&#x3D; 3 &#x2F;&#x2F; a&#x3D;a**3&#x3D;a*a*a</span><br></pre></td></tr></table></figure>
<h2 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="?. 链判断运算符"></a>?. 链判断运算符</h2><p>直接访问对象上的某个属性，如<code>obj.a</code>，如果obj是null或者undefined，访问属性的话会报错。</p>
<p><code>?.</code>链判断运算符会判断左侧对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj ?. a</span><br><span class="line">obj ? obj.a : undefined</span><br></pre></td></tr></table></figure>
<h2 id="Null判断运算符"><a href="#Null判断运算符" class="headerlink" title="?? Null判断运算符"></a>?? Null判断运算符</h2><p>行为类似<code>||</code>，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值，否则返回左侧的值。<br><code>||</code>会在左操作数为假值（0,null,undefined,’’,NAN）时返回右侧的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a &#x3D; 0</span><br><span class="line">const b &#x3D; a ?? 1 &#x2F;&#x2F; b&#x3D;0</span><br><span class="line">const c &#x3D; a || 1 &#x2F;&#x2F; b&#x3D;1</span><br></pre></td></tr></table></figure>

<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>Proxy 代理器，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var proxy &#x3D; new Proxy(target, handler)</span><br></pre></td></tr></table></figure>
<ul>
<li>target 参数表示所要拦截的目标对象</li>
<li>handler参数也是一个对象，用来定制拦截行为，具体拦截方法如下：<ul>
<li><code>get()</code>：用于拦截某个属性的读取操作</li>
<li><code>set()</code>：用于拦截某个属性的赋值操作</li>
<li><code>has()</code>：用于拦截判断对象是否具有某个属性的操作</li>
<li><code>apply()</code>：用于拦截函数的调用、call和apply操作</li>
<li><code>construct()</code>：用于拦截 new 操作</li>
<li><code>defineProperty()</code>：用于拦截添加属性操作</li>
<li><code>deleteProperty()</code>：用于拦截 delete 操作</li>
<li><code>setPrototypeOf()</code>：用于拦截设置对象的原型对象的操作，如<code>Object.setPrototypeOf()</code></li>
<li><code>getPrototypeOf()</code>：用于拦截读取对象的原型对象的操作，如<code>Object.getPrototypeOf()</code>等</li>
<li><code>ownKeys()</code>：用于拦截对象自身属性的读取的操作，如<code>Object.keys()</code>等</li>
<li><code>getOwnPropertyDescriptor()</code>：用于拦截取对象指定属性描述对象的操作，如<code>Object.getOwnPropertyDescriptor()</code></li>
<li><code>isExtensible()</code>：用于拦截判断对象是否可扩展（是否可以添加属性）的操作，如<code>Object.isExtensible()</code></li>
<li><code>preventExtensions()</code>：用于拦截将对象变得不可扩展的操作，如<code>Object.preventExtensions()</code></li>
</ul>
</li>
</ul>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;'>
如果想要 Proxy 起作用，必须针对 Proxy 的实例进行操作，而不是针对目标对象 target 进行操作。
除非 handler 没有设置任何拦截行为，访问 Proxy 实例就相当于访问目标对象 target。
</div>

<h2 id="拦截方法"><a href="#拦截方法" class="headerlink" title="拦截方法"></a>拦截方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p><code>get(target, propKey, receiver)</code>：用于拦截某个属性的读取操作，接受三个参数，依次为目标对象、属性名和 proxy 实例本身，最后一个参数可选。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果访问目标对象不存在的属性，会抛出一个错误。</span><br><span class="line">&#x2F;&#x2F; 如果没有这个拦截函数，访问不存在的属性，只会返回undefined。</span><br><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name: &quot;张三&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var proxy &#x3D; new Proxy(person, &#123;</span><br><span class="line">  get: function(target, propKey) &#123;</span><br><span class="line">    if (propKey in target) &#123;</span><br><span class="line">      return target[propKey];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new ReferenceError(&quot;Prop name \&quot;&quot; + propKey + &quot;\&quot; does not exist.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name &#x2F;&#x2F; &quot;张三&quot;</span><br><span class="line">proxy.age &#x2F;&#x2F; 抛出一个错误</span><br></pre></td></tr></table></figure>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><code>set(target, propKey, value, receiver)</code>：用于拦截某个属性的赋值操作，接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。</span><br><span class="line">const handler &#x3D; &#123;</span><br><span class="line">  get (target, key) &#123;</span><br><span class="line">    invariant(key, &#39;get&#39;);</span><br><span class="line">    return target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, key, value) &#123;</span><br><span class="line">    invariant(key, &#39;set&#39;);</span><br><span class="line">    target[key] &#x3D; value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function invariant (key, action) &#123;</span><br><span class="line">  if (key[0] &#x3D;&#x3D;&#x3D; &#39;_&#39;) &#123;</span><br><span class="line">    throw new Error(&#96;Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const target &#x3D; &#123;&#125;;</span><br><span class="line">const proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">proxy._prop</span><br><span class="line">&#x2F;&#x2F; Error: Invalid attempt to get private &quot;_prop&quot; property</span><br><span class="line">proxy._prop &#x3D; &#39;c&#39;</span><br><span class="line">&#x2F;&#x2F; Error: Invalid attempt to set private &quot;_prop&quot; property</span><br></pre></td></tr></table></figure>
<h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><p><code>has(target, propKey)</code>：用于拦截判断对象是否具有某个属性的操作，典型的操作就是in运算符，返回布尔值。接受两个参数，分别是目标对象、需查询的属性名。</p>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:10px;'>
has()方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has()方法不判断一个属性是对象自身的属性，还是继承的属性。
</div>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:10px;'>
虽然for...in循环也用到了in运算符，但是has()拦截对for...in循环不生效。
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let stu1 &#x3D; &#123;name: &#39;张三&#39;, score: 59&#125;;</span><br><span class="line">let stu2 &#x3D; &#123;name: &#39;李四&#39;, score: 99&#125;;</span><br><span class="line"></span><br><span class="line">let handler &#x3D; &#123;</span><br><span class="line">  has(target, prop) &#123;</span><br><span class="line">    if (prop &#x3D;&#x3D;&#x3D; &#39;score&#39; &amp;&amp; target[prop] &lt; 60) &#123;</span><br><span class="line">      console.log(&#96;$&#123;target.name&#125; 不及格&#96;);</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return prop in target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let oproxy1 &#x3D; new Proxy(stu1, handler);</span><br><span class="line">let oproxy2 &#x3D; new Proxy(stu2, handler);</span><br><span class="line"></span><br><span class="line">&#39;score&#39; in oproxy1</span><br><span class="line">&#x2F;&#x2F; 张三 不及格</span><br><span class="line">&#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#39;score&#39; in oproxy2</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">for (let a in oproxy1) &#123;</span><br><span class="line">  console.log(oproxy1[a]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 张三</span><br><span class="line">&#x2F;&#x2F; 59</span><br><span class="line"></span><br><span class="line">for (let b in oproxy2) &#123;</span><br><span class="line">  console.log(oproxy2[b]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 李四</span><br><span class="line">&#x2F;&#x2F; 99</span><br></pre></td></tr></table></figure>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p><code>apply(target, object, args)</code>：用于拦截函数的调用、call和apply操作，接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截。</span><br><span class="line">var twice &#x3D; &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    return Reflect.apply(...arguments) * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function sum (left, right) &#123;</span><br><span class="line">  return left + right;</span><br><span class="line">&#125;;</span><br><span class="line">var proxy &#x3D; new Proxy(sum, twice);</span><br><span class="line">proxy(1, 2) &#x2F;&#x2F; 6</span><br><span class="line">proxy.call(null, 5, 6) &#x2F;&#x2F; 22</span><br><span class="line">proxy.apply(null, [7, 8]) &#x2F;&#x2F; 30</span><br></pre></td></tr></table></figure>
<h3 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h3><p><code>construct(terget, args, newTarget)</code>：用于拦截 new 操作，接受三个参数，依次是目标对象、构造函数的参数数组、创造实例对象时，new命令作用的构造函数（下面例子的p）。</p>
<p><strong>目标对象必须是函数，否则会报错</strong><br><strong><code>construct()</code>方法必须返回对象，否则报错</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p &#x3D; new Proxy(function () &#123;&#125;, &#123;</span><br><span class="line">  construct: function(target, args) &#123;</span><br><span class="line">    console.log(&#39;called: &#39; + args.join(&#39;, &#39;));</span><br><span class="line">    return &#123; value: args[0] * 10 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(new p(1)).value</span><br><span class="line">&#x2F;&#x2F; &quot;called: 1&quot;</span><br><span class="line">&#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">const p1 &#x3D; new Proxy(function() &#123;&#125;, &#123;</span><br><span class="line">  construct: function(target, argumentsList) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new p1() &#x2F;&#x2F; 报错 construct必须返回对象</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: &#39;construct&#39; on proxy: trap returned non-object (&#39;1&#39;)</span><br><span class="line"></span><br><span class="line">const p2 &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  construct: function(target, argumentsList) &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new p2() &#x2F;&#x2F; 报错 目标对象必须是函数</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: p is not a constructor</span><br></pre></td></tr></table></figure>
<h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h3><p><code>defineProperty(target, propKey, propDesc)</code>：用于拦截添加属性操作，如<code>Object.defineProperty()</code>，接受三个参数，依次是目标对象、要添加的属性和其描述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var handler &#x3D; &#123;</span><br><span class="line">  defineProperty (target, key, descriptor) &#123;</span><br><span class="line">    return false; &#x2F;&#x2F; 返回布尔值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target &#x3D; &#123;&#125;;</span><br><span class="line">var proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">proxy.foo &#x3D; &#39;bar&#39; &#x2F;&#x2F; 不会生效</span><br></pre></td></tr></table></figure>
<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty"></a>deleteProperty</h3><p><code>deleteProperty(target, propKey)</code>：用于拦截 delete 删除属性的操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除第一个字符为下划线的属性会报错。</span><br><span class="line">var handler &#x3D; &#123;</span><br><span class="line">  deleteProperty (target, key) &#123;</span><br><span class="line">    invariant(key, &#39;delete&#39;);</span><br><span class="line">    delete target[key];</span><br><span class="line">    return true; &#x2F;&#x2F; 返回布尔值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function invariant (key, action) &#123;</span><br><span class="line">  if (key[0] &#x3D;&#x3D;&#x3D; &#39;_&#39;) &#123;</span><br><span class="line">    throw new Error(&#96;Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var target &#x3D; &#123; _prop: &#39;foo&#39; &#125;;</span><br><span class="line">var proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">delete proxy._prop</span><br><span class="line">&#x2F;&#x2F; Error: Invalid attempt to delete private &quot;_prop&quot; property</span><br></pre></td></tr></table></figure>
<h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf"></a>setPrototypeOf</h3><p><code>setPrototypeOf(target, proto)</code>：用于拦截设置对象的原型对象的操作，如<code>Object.setPrototypeOf()</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var handler &#x3D; &#123;</span><br><span class="line">  setPrototypeOf (target, proto) &#123;</span><br><span class="line">    throw new Error(&#39;Changing the prototype is forbidden&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var proto &#x3D; &#123;&#125;;</span><br><span class="line">var target &#x3D; function () &#123;&#125;;</span><br><span class="line">var proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">Object.setPrototypeOf(proxy, proto);</span><br><span class="line">&#x2F;&#x2F; Error: Changing the prototype is forbidden</span><br></pre></td></tr></table></figure>
<h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf"></a>getPrototypeOf</h3><p><code>getPrototypeOf(target)</code>：用于拦截读取对象的原型对象的操作。如：</p>
<ul>
<li><code>Object.prototype.__proto__</code></li>
<li><code>Object.prototype.isPrototypeOf()</code></li>
<li><code>Object.getPrototypeOf()</code></li>
<li><code>Reflect.getPrototypeOf()</code></li>
<li><code>instanceof</code></li>
</ul>
<p><strong><code>getPrototypeOf()</code>的返回值必须是对象或者null，否则报错</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var proto &#x3D; &#123;&#125;;</span><br><span class="line">var p &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  getPrototypeOf(target) &#123;</span><br><span class="line">    return proto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.getPrototypeOf(p) &#x3D;&#x3D;&#x3D; proto &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h3><p><code>ownKeys(target)</code>：用于拦截对象自身属性的读取的操作，如：</p>
<ul>
<li><code>Object.getOwnPropertyNames()</code></li>
<li><code>Object.getOwnPropertySymbols()</code></li>
<li><code>Object.keys()</code></li>
<li><code>for.....in</code>循环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let target &#x3D; &#123;</span><br><span class="line">  _bar: &#39;foo&#39;,</span><br><span class="line">  _prop: &#39;bar&#39;,</span><br><span class="line">  prop: &#39;baz&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let handler &#x3D; &#123;</span><br><span class="line">  ownKeys (target) &#123;</span><br><span class="line">    return Reflect.ownKeys(target).filter(key &#x3D;&gt; key[0] !&#x3D;&#x3D; &#39;_&#39;); &#x2F;&#x2F; 返回满足条件的keys数组</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">for (let key of Object.keys(proxy)) &#123;</span><br><span class="line">  console.log(target[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;baz&quot;</span><br></pre></td></tr></table></figure>
<h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor"></a>getOwnPropertyDescriptor</h3><p><code>getOwnPropertyDescriptor(target, propKey)</code>：用于拦截取对象指定属性描述对象的操作，如<code>Object.getOwnPropertyDescriptor()</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var handler &#x3D; &#123;</span><br><span class="line">  getOwnPropertyDescriptor (target, key) &#123;</span><br><span class="line">    if (key[0] &#x3D;&#x3D;&#x3D; &#39;_&#39;) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    return Object.getOwnPropertyDescriptor(target, key); &#x2F;&#x2F; 返回描述对象</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target &#x3D; &#123; _foo: &#39;bar&#39;, baz: &#39;tar&#39; &#125;;</span><br><span class="line">var proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, &#39;wat&#39;)</span><br><span class="line">&#x2F;&#x2F; undefined</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, &#39;_foo&#39;)</span><br><span class="line">&#x2F;&#x2F; undefined</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, &#39;baz&#39;)</span><br><span class="line">&#x2F;&#x2F; &#123; value: &#39;tar&#39;, writable: true, enumerable: true, configurable: true &#125;</span><br></pre></td></tr></table></figure>
<h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible"></a>isExtensible</h3><p><code>isExtensible(target)</code>：用于拦截判断对象是否可扩展（是否可以添加属性）的操作，如<code>Object.isExtensible()</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: function(target) &#123;</span><br><span class="line">    console.log(&quot;called&quot;);</span><br><span class="line">    return true; &#x2F;&#x2F; 返回布尔值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.isExtensible(p)</span><br><span class="line">&#x2F;&#x2F; &quot;called&quot;</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions"></a>preventExtensions</h3><p><code>preventExtensions(target)</code>：用于拦截将对象变得不可扩展的操作，如<code>Object.preventExtensions()</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var proxy &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: function(target) &#123;</span><br><span class="line">    console.log(&#39;called&#39;);</span><br><span class="line">    Object.preventExtensions(target); &#x2F;&#x2F; 如果没有这步操作，会报错</span><br><span class="line">    return true; &#x2F;&#x2F; 返回布尔值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.preventExtensions(proxy)</span><br><span class="line">&#x2F;&#x2F; &quot;called&quot;</span><br><span class="line">&#x2F;&#x2F; Proxy &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h2><p><code>Proxy.revocable(target,handler)</code>方法返回一个可取消的 Proxy 实例，主要使用场景是：目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let target &#x3D; &#123;&#125;;</span><br><span class="line">let handler &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">let &#123;proxy, revoke&#125; &#x3D; Proxy.revocable(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo &#x3D; 123;</span><br><span class="line">proxy.foo &#x2F;&#x2F; 123</span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo &#x2F;&#x2F; TypeError: Revoked</span><br></pre></td></tr></table></figure>
<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p>在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const target &#x3D; &#123;</span><br><span class="line">  m: function () &#123;</span><br><span class="line">    console.log(this &#x3D;&#x3D;&#x3D; proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const handler &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">const proxy &#x3D; new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">target.m() &#x2F;&#x2F; false</span><br><span class="line">proxy.m()  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><p>Reflect 和 Proxy 一样，也是用来操作对象，不同点在于：</p>
<ul>
<li>将 Object 对象的内部方法放到 Reflect 对象上，目前某些方法 Object 和 Reflect 都部署了，未来只会在 Reflect 上部署。</li>
<li>修改某些 Object 方法的返回值，让其合理，比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回false。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 老写法</span><br><span class="line">try &#123;</span><br><span class="line">  Object.defineProperty(target, property, attributes);</span><br><span class="line">  &#x2F;&#x2F; success</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  &#x2F;&#x2F; failure</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新写法</span><br><span class="line">if (Reflect.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  &#x2F;&#x2F; success</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; failure</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>让 Object 的命令式操作变成函数行为。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 老写法</span><br><span class="line">&#39;assign&#39; in Object &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新写法</span><br><span class="line">Reflect.has(Object, &#39;assign&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li>
<li>Reflect 对象的方法和 Proxy 对象的13中拦截方法一一对应。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Proxy(target, &#123;</span><br><span class="line">  set: function(target, name, value, receiver) &#123;</span><br><span class="line">    var success &#x3D; Reflect.set(target, name, value, receiver);</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      console.log(&#39;property &#39; + name + &#39; on &#39; + target + &#39; set to &#39; + value);</span><br><span class="line">    &#125;</span><br><span class="line">    return success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组常用方法总结如下：</p>
<ul>
<li>调用之后会改变原有的数组的方法，如：<ul>
<li><code>unshift()</code>：在数组第一位添加元素，返回更新后的数组长度</li>
<li><code>shift()</code>：删除数组的第一个元素，返回该元素</li>
<li><code>push()</code>：在数组末尾添加元素，返回更新后的数组的长度</li>
<li><code>pop()</code>：删除数组最后一个元素，返回该元素</li>
<li><code>sort()</code>：数组排序，也可添加回调函数定义自己想要的排序规则</li>
<li><code>reverse()</code>：数组倒序</li>
<li><code>splice(index,howMany)</code>：从index位置删除howMany个数组元素<br><code>splice(index,howMany,item1...itemX)</code>：从index位置删除howMany个数组元素，然后添加item1…itemX元素至数组</li>
</ul>
</li>
<li>调用之后不会改变原有数组的方法，如：<ul>
<li><code>concat(arr1,arr2...)</code>：连接两个或者更多个数组</li>
<li><code>every((index,value,arr)=&gt;{},thisArg)</code>：遍历每一个元素，判断所有元素是不是都符合条件，有一个不符合就返回false，全部符合返回true</li>
<li><code>some((index,value,arr)=&gt;{},thisArg)</code>：遍历每一个元素，判断所有元素是不是都符合条件，有一个符合就返回true，全部不符合返回false</li>
<li><code>filter()</code>：数组过滤</li>
<li><code>map()</code>：数组遍历</li>
<li><code>forEach()</code>：数组遍历</li>
<li><code>slice(start=0,end=this.length)</code>：数组截取，包含开始参数，不包含结束参数</li>
</ul>
</li>
</ul>
<h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p><code>Array.form()</code>将 类似数组的对象 / 可遍历的对象 转为数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 类似数组的对象</span><br><span class="line">let arrayLike &#x3D; &#123;</span><br><span class="line">    &#39;0&#39;: &#39;a&#39;,</span><br><span class="line">    &#39;1&#39;: &#39;b&#39;,</span><br><span class="line">    &#39;2&#39;: &#39;c&#39;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;</span><br><span class="line">Array.from(arrayLike) &#x2F;&#x2F; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可遍历的对象 - 即该对象带有length属性</span><br><span class="line">function foo() &#123;</span><br><span class="line">  var args &#x3D; Array.from(arguments);</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.from(&#39;hello&#39;) &#x2F;&#x2F; [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]</span><br></pre></td></tr></table></figure>
<h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p><code>Array.of()</code>将一组值转化成数组，用于解决<code>Array()</code>或者<code>new Array()</code>因为参数个数不同引起行为差异的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Array() &#x2F; new Array()</span><br><span class="line">Array() &#x2F;&#x2F; [] 无参数的时候返回的是空数组</span><br><span class="line">Array(2) &#x2F;&#x2F; [,,] 只有一个参数时，实际上指的是数组的长度</span><br><span class="line">Array(3,4) &#x2F;&#x2F; [3,4] 只有当参数不少于2个的时候，才会是数组</span><br><span class="line">Array(3,4,5) &#x2F;&#x2F; [3,4,5]</span><br><span class="line"></span><br><span class="line">Array.of() &#x2F;&#x2F; []</span><br><span class="line">Array.of(undefined) &#x2F;&#x2F; [undefined]</span><br><span class="line">Array.of(2) &#x2F;&#x2F; [2]</span><br><span class="line">Array.of(3,4) &#x2F;&#x2F; [3,4]</span><br><span class="line">&#x2F;&#x2F; 具体实现</span><br><span class="line">function ArrayOf()&#123;</span><br><span class="line">  return [].slice.call(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-at"><a href="#Array-prototype-at" class="headerlink" title="Array.prototype.at()"></a>Array.prototype.at()</h2><p>根据传入的参数索引获取索引对应的值。解决之前数据没有办法倒序获取元素的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [5, 12, 8, 130, 44]</span><br><span class="line">arr[arr.length-1] &#x2F;&#x2F; 44</span><br><span class="line">arr.at(-1) &#x2F;&#x2F; 44</span><br><span class="line">arr.at(2) &#x2F;&#x2F; 8</span><br><span class="line">arr.at(-2) &#x2F;&#x2F; 130</span><br><span class="line">arr.at(10) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-copyWithin"><a href="#Array-prototype-copyWithin" class="headerlink" title="Array.prototype.copyWithin()"></a>Array.prototype.copyWithin()</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.copyWithin(target, start &#x3D; 0, end &#x3D; this.length)</span><br></pre></td></tr></table></figure>
<p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3) &#x2F;&#x2F; [4, 5, 3, 4, 5]</span><br><span class="line">&#x2F;&#x2F; 从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将3号位复制到0号位</span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3, 4) &#x2F;&#x2F; [4, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -2相当于3号位，-1相当于4号位</span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, -2, -1) &#x2F;&#x2F; [4, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0,2) &#x2F;&#x2F; [3, 4, 5, 4, 5]</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-find-findIndex-findLast-findLastIndex-indexOf"><a href="#Array-prototype-find-findIndex-findLast-findLastIndex-indexOf" class="headerlink" title="Array.prototype.find/findIndex/findLast/findLastIndex/indexOf()"></a>Array.prototype.find/findIndex/findLast/findLastIndex/indexOf()</h2><ul>
<li><code>find()</code>：从前向后，返回符合条件的第一个元素的值，不符合返回 undefined；</li>
<li><code>findIndex()</code>：从前向后，返回符合条件的第一个元素的下标，不符合返回-1；</li>
<li><code>findLast()</code>：从后向前，返回符合条件的第一个元素的值，不符合返回 undefined；</li>
<li><code>findLastIndex()</code>：从后向前，返回符合条件的第一个元素的下标，不符合返回-1；</li>
<li><code>indexOf()</code>：从前向后，返回元素所在的第一个下标，元素不存在返回-1。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [1, 4, -5, 10, -5]</span><br><span class="line">arr.find((value,index,arr)&#x3D;&gt;&#123;return value &lt; 0&#125;) &#x2F;&#x2F; -5</span><br><span class="line">arr.findIndex((value,index,arr)&#x3D;&gt;&#123;return value &lt; 0&#125;) &#x2F;&#x2F; 2</span><br><span class="line">let person &#x3D; &#123;name: &#39;John&#39;, age: 9&#125;;</span><br><span class="line">arr.find((value,index,arr)&#x3D;&gt;&#123;</span><br><span class="line">  return value &gt; this.age  &#x2F;&#x2F; this 指向第二个入参 -- person</span><br><span class="line">&#125;,person) &#x2F;&#x2F; 10</span><br><span class="line">arr.findIndex((value,index,arr)&#x3D;&gt;&#123;</span><br><span class="line">  return value &gt; this.age &#x2F;&#x2F; this 指向第二个入参 -- person</span><br><span class="line">&#125;,person) &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">arr.indexOf(-5) &#x2F;&#x2F; 2</span><br><span class="line">arr.indexOf(-5,3) &#x2F;&#x2F; 从3号位开始找-5，所以下标是4</span><br><span class="line">arr.indexOf(-5,2) &#x2F;&#x2F; 2</span><br><span class="line">arr.indexOf(-5,6) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-fill"><a href="#Array-prototype-fill" class="headerlink" title="Array.prototype.fill()"></a>Array.prototype.fill()</h2><p><code>fill(target, start=0, end=this.length)</code>方法用来填充数组，一般用于数组初始化的时候赋值。<br>target：要填充的数值；start：填充起始位置；end：填充结束位置。<br><strong>如果填充的是对象，那么被赋值的是同一个内存地址的对象，是浅拷贝，会相互影响。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3].fill(7) &#x2F;&#x2F; [7,7,7] 数组有值默认会被覆盖</span><br><span class="line">new Array(3).fill(7) &#x2F;&#x2F; [7,7,7]</span><br><span class="line">[1,2,3].fill(7,1,2) &#x2F;&#x2F; [1,7,3] 从一号位开始填充，2号位结束</span><br><span class="line"></span><br><span class="line">let arr &#x3D; new Array(3).fill(&#123;name: &quot;Mike&quot;&#125;);</span><br><span class="line">arr[0].name &#x3D; &quot;Ben&quot;;</span><br><span class="line">arr &#x2F;&#x2F; [&#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-keys-values-entries"><a href="#Array-prototype-keys-values-entries" class="headerlink" title="Array.prototype.keys/values/entries()"></a>Array.prototype.keys/values/entries()</h2><p>这三个方法用来搭配<code>for...of</code>对数组进行遍历，返回的是遍历器对象：</p>
<ul>
<li><code>keys()</code>是对键名的遍历；</li>
<li><code>values()</code>是对键值的遍历；</li>
<li><code>entries()</code>是对键值对的遍历。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &#39;a&#39;</span><br><span class="line">&#x2F;&#x2F; &#39;b&#39;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0 &quot;a&quot;</span><br><span class="line">&#x2F;&#x2F; 1 &quot;b&quot;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-flat-flatMap"><a href="#Array-prototype-flat-flatMap" class="headerlink" title="Array.prototype.flat/flatMap()"></a>Array.prototype.flat/flatMap()</h2><ul>
<li><code>flat(num=1)</code>：将多维数组拉平为一维数组，num表示拉平的层数，默认为1，num=Infinity表示不管数组是几维，都被拉平为一维数组。</li>
<li><code>flatMap((value,index,arr)=&gt;{},thisArg)</code>：执行函数遍历数组成员，将返回的新的数组进行flat操作，thisArg用来绑定遍历函数里面this的指向。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, [3, [4, 5]]].flat()</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, [4, 5]]  默认拉平一层</span><br><span class="line"></span><br><span class="line">[1, 2, [3, [4, 5]]].flat(2)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 5]   指定拉平两层</span><br><span class="line"></span><br><span class="line">[1, [2, [3]]].flat(Infinity)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3] 不管多少层，全部拉平至一维</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span><br><span class="line">[1, 2, 3, 4].flatMap(x &#x3D;&gt; [[x * 2]])</span><br><span class="line">&#x2F;&#x2F; [[2], [4], [6], [8]]  flatMap只能拉平一层</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-toReversed-toSorted-toSplice-with"><a href="#Array-prototype-toReversed-toSorted-toSplice-with" class="headerlink" title="Array.prototype.toReversed/toSorted/toSplice/with()"></a>Array.prototype.toReversed/toSorted/toSplice/with()</h2><p>数组有一些方法调用后会修改原有的数组，为了实现调用该方法但是不修改原有数组，就有了以下和之前方法类似单数不修改原有数组的新方法。</p>
<ul>
<li><code>toReversed()</code>对应<code>reverse()</code>，用来颠倒数组成员的位置。</li>
<li><code>toSorted()</code>对应<code>sort()</code>，用来对数组成员排序。</li>
<li><code>toSpliced()</code>对应<code>splice()</code>，用来在指定位置，删除指定数量的成员，并插入新成员。</li>
<li><code>with(index, value)</code>对应<code>splice(index, 1, value)</code>，用来将指定位置的成员替换为新的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const sequence &#x3D; [1, 2, 3];</span><br><span class="line">sequence.toReversed() &#x2F;&#x2F; [3, 2, 1]</span><br><span class="line">sequence &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line"></span><br><span class="line">const outOfOrder &#x3D; [3, 1, 2];</span><br><span class="line">outOfOrder.toSorted() &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">outOfOrder &#x2F;&#x2F; [3, 1, 2]</span><br><span class="line"></span><br><span class="line">const array &#x3D; [1, 2, 3, 4];</span><br><span class="line">array.toSpliced(1, 2, 5, 6, 7) &#x2F;&#x2F; [1, 5, 6, 7, 4]</span><br><span class="line">array &#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">const correctionNeeded &#x3D; [1, 1, 3];</span><br><span class="line">correctionNeeded.with(1, 2) &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">correctionNeeded &#x2F;&#x2F; [1, 1, 3]</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-group-groupMap"><a href="#Array-prototype-group-groupMap" class="headerlink" title="Array.prototype.group/groupMap()"></a>Array.prototype.group/groupMap()</h2><ul>
<li><code>group((value,index,arr)=&gt;{},thisArg)</code>：该方法用来对数组进行分组，返回值是一个对象，键名是分组名，值是被分组的数组，入参函数必须返回一个字符串，即分组名。</li>
<li><code>groupMap((value,index,arr)=&gt;{},thisArg)</code>：作用和用法和``group()`一致，区别在于返回值是Map。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const array &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">array.group((num, index, array) &#x3D;&gt; &#123;</span><br><span class="line">  return num % 2 &#x3D;&#x3D;&#x3D; 0 ? &#39;even&#39;: &#39;odd&#39;;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; &#123; odd: [1, 3, 5], even: [2, 4] &#125;</span><br><span class="line"></span><br><span class="line">const odd  &#x3D; &#123; odd: true &#125;;</span><br><span class="line">const even &#x3D; &#123; even: true &#125;;</span><br><span class="line">array.groupToMap((num, index, array) &#x3D;&gt; &#123;</span><br><span class="line">  return num % 2 &#x3D;&#x3D;&#x3D; 0 ? even: odd;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;  Map &#123; &#123;odd: true&#125;: [1, 3, 5], &#123;even: true&#125;: [2, 4] &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h2><p><code>reduce((total,value,index,arr)=&gt;{},initialValue)</code>：该方法将数组缩减为单个值，入参函数第一个入参是先前执行后返回的结果，initialValue是要传给入参函数的初始值。<br><strong>如果没有设置initialValue，total是数组的第一个元素，value是数组的第二个元素；如果有，total=initialValue,value是数组的第一个元素。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var numbers &#x3D; [175, 50, 25];</span><br><span class="line">numbers.reduce((total,value)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(total,value)</span><br><span class="line">    return total - value</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 175 50</span><br><span class="line">&#x2F;&#x2F; 125 25</span><br><span class="line">&#x2F;&#x2F; 100</span><br><span class="line"></span><br><span class="line">numbers.reduce((total,value)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(total,value)</span><br><span class="line">    return total - value</span><br><span class="line">&#125;,10);</span><br><span class="line">&#x2F;&#x2F; 10 175</span><br><span class="line">&#x2F;&#x2F; -165 50</span><br><span class="line">&#x2F;&#x2F; -215 25</span><br><span class="line">&#x2F;&#x2F; -240</span><br></pre></td></tr></table></figure>
<h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><ul>
<li>方法一：flat<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flat &#x3D; arr &#x3D;&gt; arr.flat(Infinity)</span><br></pre></td></tr></table></figure></li>
<li>方法二：递归<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flat &#x3D; (array) &#x3D;&gt; &#123;</span><br><span class="line">  let result &#x3D; [];</span><br><span class="line">  for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if (Array.isArray(array[i])) &#123;</span><br><span class="line">      result &#x3D; result.concat(flat(array[i]));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法三：reduce<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flat &#x3D; (array) &#x3D;&gt; &#123;</span><br><span class="line">  return array.reduce(</span><br><span class="line">    (target, current) &#x3D;&gt;</span><br><span class="line">      Array.isArray(current) ?</span><br><span class="line">        target.concat(flatten(current)) :</span><br><span class="line">        target.concat(current)</span><br><span class="line">    , [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定拉平层数</span><br><span class="line">const flattenByDeep &#x3D; (array, deep &#x3D; 1) &#x3D;&gt; &#123;</span><br><span class="line">  return array.reduce(</span><br><span class="line">    (target, current) &#x3D;&gt;</span><br><span class="line">      Array.isArray(current) &amp;&amp; deep &gt; 1 ?</span><br><span class="line">        target.concat(flattenByDeep(current, deep - 1)) :</span><br><span class="line">        target.concat(current)</span><br><span class="line">    , [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><ul>
<li>方法一：使用Set<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const unique &#x3D; arr &#x3D;&gt; Array.from(new Set(arr));</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const unique &#x3D; arr &#x3D;&gt; [...new Set(arr)];</span><br></pre></td></tr></table></figure></li>
<li>方法二：filter + indexOf <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const unique &#x3D; arr &#x3D;&gt; arr.filter((e,i) &#x3D;&gt; arr.indexOf(e) &#x3D;&#x3D;&#x3D; i);</span><br></pre></td></tr></table></figure></li>
<li>方法三：indexOf/includes + push<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const unique &#x3D; (array)&#x3D;&gt; &#123;</span><br><span class="line">  const newArray &#x3D; []</span><br><span class="line">  array.forEach((cu,index)&#x3D;&gt;&#123;</span><br><span class="line">    if(newArray.indexOf(cu)&#x3D;&#x3D;&#x3D;-1) newArray.push(cu)</span><br><span class="line">    &#x2F;&#x2F; if(!newArray.includes(cu)) newArray.push(cu)</span><br><span class="line">  &#125;)</span><br><span class="line">  return newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法四：对象：标记元素是否存在<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const unique &#x3D; (array)&#x3D;&gt; &#123;</span><br><span class="line">    var container &#x3D; &#123;&#125;;</span><br><span class="line">    return array.filter((item, index) &#x3D;&gt;  container.hasOwnProperty(item) ? false : (container[item] &#x3D; true));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="数组乱序-洗牌"><a href="#数组乱序-洗牌" class="headerlink" title="数组乱序-洗牌"></a>数组乱序-洗牌</h2><p>实现原理：从最后一个元素开始，从数组中随机选出一个位置，交换，直到第一个元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function disorder(array) &#123;</span><br><span class="line">  const length &#x3D; array.length;</span><br><span class="line">  let current &#x3D; length - 1;</span><br><span class="line">  let random;</span><br><span class="line">  while (current &gt;-1) &#123;</span><br><span class="line">    random &#x3D; Math.floor(length * Math.random());</span><br><span class="line">    [array[current], array[random]] &#x3D; [array[random], array[current]];</span><br><span class="line">    current--;</span><br><span class="line">  &#125;</span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p>函数的name属性返回函数名，对象的方法也是函数，所以也有name属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a &#x3D; function()&#123;&#125;</span><br><span class="line">console.log(a.name) &#x2F;&#x2F; a</span><br><span class="line"></span><br><span class="line">const obj1 &#x3D; &#123;</span><br><span class="line">  getName()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj1.getName.name) &#x2F;&#x2F; getName</span><br></pre></td></tr></table></figure>
<p>如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj2 &#x3D; &#123;</span><br><span class="line">  get func()&#123;&#125;</span><br><span class="line">  set func(val)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj2.func.name) &#x2F;&#x2F; TypeError: Cannot read property &#39;name&#39; of undefined</span><br><span class="line">const descriptor &#x3D; Object.getOwnPropertyDescriptor(obj2, &#39;func&#39;);</span><br><span class="line">descriptor.get.name &#x2F;&#x2F; &quot;get func&quot;</span><br><span class="line">descriptor.set.name &#x2F;&#x2F; &quot;set func&quot;</span><br></pre></td></tr></table></figure>
<p>Function构造函数创造的函数，name属性返回anonymous。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log((new Function()).name) &#x2F;&#x2F; &quot;anonymous&quot;</span><br></pre></td></tr></table></figure>
<p>bind方法创造的函数，name属性返回bound加上原函数的名字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(a.bind().name) &#x2F;&#x2F; &quot;bound a&quot;</span><br></pre></td></tr></table></figure>
<p>如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const key1 &#x3D; Symbol(&#39;description&#39;)</span><br><span class="line">let obj3 &#x3D; &#123;</span><br><span class="line">  [key1]() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj3[key1].name) &#x2F;&#x2F; &quot;[description]&quot;</span><br></pre></td></tr></table></figure>
<h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><ul>
<li>箭头函数没有this，普通函数有（独立调用this指向全局，对象内部调用，this指向这个对象）；</li>
<li>箭头函数全是匿名函数，普通函数既可以是匿名函数，也可以是具名函数；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 具名函数</span><br><span class="line">function func()&#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 匿名函数</span><br><span class="line">let func &#x3D; function()&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>箭头函数不能当做构造函数，即不可以使用new命令，普通函数可以；</li>
<li>箭头函数不可以使用arguments函数，如果要用，可以使用reset参数代替，普通函数可以使用arguments；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function A(a)&#123;</span><br><span class="line">  console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">A(1,2,3,4,5) &#x2F;&#x2F; [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">let B &#x3D; (b)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">B(1,2,3,4,5) &#x2F;&#x2F; Uncaught ReferenceError: arguments is not defined</span><br><span class="line"></span><br><span class="line">let C &#x3D; (...c)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(c)</span><br><span class="line">&#125;</span><br><span class="line">C(1,2,3,4,5) &#x2F;&#x2F; [1,2,3,4,5]</span><br></pre></td></tr></table></figure></li>
<li>箭头函数没有prototype原型对象，不具有super。</li>
</ul>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>Symbol，生成一个独一无二的值，引入这个 API 的原因是对象的键名是字符串，很容易冲突，如果键名是 Symbol 类型的话，就是独一无二的，不会产生冲突。</p>
<p>针对 Symbol，ES6 新增了两个新的方法：<code>Symbol.for()</code> 和 <code>Symbol().keyFor()</code></p>
<ul>
<li><code>Symbol.for(key)</code>：可以用来生成同一个 symbol 值，它会根据传入的 key 值登记，再次调用该方法的时候回去搜索 key 是否存在，如果不存在才会直接创建新值。而<code>Symbol(key)</code>没有登记搜索这一操作，每次调用都会创建新值。</li>
<li><code>Symbol.keyFor()</code>：返回一个已登记的 Symbol 类型值的key。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s &#x3D; Symbol()</span><br><span class="line">typeof s &#x2F;&#x2F; &#39;symbol&#39;</span><br><span class="line"></span><br><span class="line">let s1 &#x3D; Symbol(&#39;foo&#39;);</span><br><span class="line">let s2 &#x3D; Symbol(&#39;bar&#39;);</span><br><span class="line">s1 &#x2F;&#x2F; Symbol(foo)</span><br><span class="line">s2 &#x2F;&#x2F; Symbol(bar)</span><br><span class="line">s1.toString() &#x2F;&#x2F; &quot;Symbol(foo)&quot;</span><br><span class="line">s2.toString() &#x2F;&#x2F; &quot;Symbol(bar)&quot;</span><br><span class="line"></span><br><span class="line">let s3 &#x3D; Symbol.for(&#39;foo&#39;);</span><br><span class="line">let s4 &#x3D; Symbol.for(&#39;foo&#39;);</span><br><span class="line">s3 &#x3D;&#x3D;&#x3D; s4 &#x2F;&#x2F; true</span><br><span class="line">Symbol(&quot;bar&quot;) &#x3D;&#x3D;&#x3D; Symbol(&quot;bar&quot;) &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">Symbol.keyFor(s3) &#x2F;&#x2F; &quot;foo&quot;</span><br><span class="line">let s5 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class="line">Symbol.keyFor(s5) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础进阶(二)</title>
    <url>/2021/05/30/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%BA%8C)/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2018/02/28/10/04/soap-bubble-3187617_960_720.jpg" alt=""></p>
<a id="more"></a>

<h1 id="浅拷贝、深拷贝"><a href="#浅拷贝、深拷贝" class="headerlink" title="浅拷贝、深拷贝"></a>浅拷贝、深拷贝</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>JS执行上下文后会创建一个特殊对象叫做变量对象，JS的数据类型都会保存在变量对象中，对于基本数据类型来说，变量对象的变量名是数据参数，变量对象的具体值是数据值，而对于引用数据类型来说，变量对象的变量名是数据参数，变量对象的具体值是地址引用，数据值是保存在堆内存中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a1 &#x3D; 0;   &#x2F;&#x2F; 变量对象</span><br><span class="line">var a2 &#x3D; &#39;this is string&#39;; &#x2F;&#x2F; 变量对象</span><br><span class="line">var a3 &#x3D; null; &#x2F;&#x2F; 变量对象</span><br><span class="line">var b &#x3D; &#123; m: 20 &#125;; &#x2F;&#x2F; 变量b存在于变量对象中，&#123;m: 20&#125; 作为对象存在于堆内存中</span><br><span class="line">var c &#x3D; [1, 2, 3]; &#x2F;&#x2F; 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/08/FJMUZwGP62KvNjz.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 20;</span><br><span class="line">var b &#x3D; a;</span><br><span class="line">b &#x3D; 30;</span><br><span class="line">&#x2F;&#x2F; 这时a的值是多少？a&#x3D;20 b&#x3D;30</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/09/Lur3nBRVvwUftk7.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var m &#x3D; &#123; a: 10, b: 20 &#125;</span><br><span class="line">var n &#x3D; m;</span><br><span class="line">n.a &#x3D; 15;</span><br><span class="line">&#x2F;&#x2F; 这时m.a的值是多少 m&#x3D;n&#x3D;&#123;a:15,b:20&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/09/HXWIhxLNCAEvgaT.jpg" alt=""><br><strong>总结</strong>：<br>所谓拷贝，就是赋值，把一个变量赋给另外一个变量，把变量的内容进行拷贝。</p>
<ol>
<li>基本数据类型进行拷贝数据改变不会相互影响，是深拷贝；</li>
<li>引用数据类型进行拷贝数据改变会相互影响，是浅拷贝。</li>
</ol>
<h2 id="判断数据类型的方式"><a href="#判断数据类型的方式" class="headerlink" title="判断数据类型的方式"></a>判断数据类型的方式</h2><ol>
<li><strong>typeof</strong><br>typeof 返回的是数据类型的字符串，对于JS的基本数据类型除了null之外适用，但是引用数据类型和null全部返回object。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(typeof 1) &#x2F;&#x2F; number</span><br><span class="line">console.log(typeof &#39;12w&#39;) &#x2F;&#x2F; string</span><br><span class="line">console.log(typeof true) &#x2F;&#x2F; boolean</span><br><span class="line">console.log(typeof undefined) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(typeof Symbol(1)) &#x2F;&#x2F; symbol</span><br><span class="line">console.log(typeof function()&#123;&#125;) &#x2F;&#x2F; function</span><br><span class="line">console.log(typeof null) &#x2F;&#x2F; object</span><br><span class="line">console.log(typeof []) &#x2F;&#x2F; object</span><br><span class="line">&#x2F;&#x2F; 其他的全是object</span><br></pre></td></tr></table></figure></li>
<li><strong>instanceof</strong><br>instanceof 是判断A是否是B的实例，返回的是true or false，但是不能判断一个对象实例具体属于哪种类型。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log([] instanceof Array) &#x2F;&#x2F; true</span><br><span class="line">console.log([] instanceof Object) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; []的原型指向Array.prototype，间接指向Object.prototype，因此上面两个都是true</span><br><span class="line">console.log(function()&#123;&#125; instanceof Function) &#x2F;&#x2F; true</span><br><span class="line">console.log(&#123;&#125; instanceof Object) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li>
<li><strong>constructor</strong><br>除了null和undefined之外，都可以使用constructor来判断数据类型，返回true or false。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(100.constructor &#x3D;&#x3D;&#x3D; Number) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log(&#39;qwe&#39;.constructor &#x3D;&#x3D;&#x3D; String) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log(false.constructor &#x3D;&#x3D;&#x3D; Boolean) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log(Symbol(1).constructor &#x3D;&#x3D;&#x3D; Symbol) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log(&#x2F;^[a-zA-Z]&#123;5,20&#125;$&#x2F;.constructor &#x3D;&#x3D;&#x3D; RegExp) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log((function()&#123;&#125;).constructor &#x3D;&#x3D;&#x3D; Function) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log([].constructor &#x3D;&#x3D;&#x3D; Array) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log(&#123;&#125;.constructor &#x3D;&#x3D;&#x3D; Object) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log((new Date()).constructor &#x3D;&#x3D;&#x3D; Date) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log((new Error()).constructor &#x3D;&#x3D;&#x3D; Error) &#x2F;&#x2F;&#x3D;&gt; true</span><br></pre></td></tr></table></figure></li>
<li><strong>toString</strong><br>toString 是最完美的方法，返回格式为 [object Xxx] ，其中 Xxx 就是对象的类型。对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.prototype.toString.call(1) &#x2F;&#x2F; [object Number]</span><br><span class="line">Object.prototype.toString.call(&#39;&#39;) &#x2F;&#x2F; [object String]</span><br><span class="line">Object.prototype.toString.call(true) &#x2F;&#x2F; [object Boolean]</span><br><span class="line">Object.prototype.toString.call(null) &#x2F;&#x2F; [object Null]</span><br><span class="line">Object.prototype.toString.call(undefined) &#x2F;&#x2F; [object Undefined]</span><br><span class="line">Object.prototype.toString.call(Symbol()) &#x2F;&#x2F;[object Symbol]</span><br><span class="line">Object.prototype.toString.call([]) &#x2F;&#x2F; [object Array]</span><br><span class="line">Object.prototype.toString.call(new Date()) &#x2F;&#x2F; [object Date]</span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;) &#x2F;&#x2F; [object Function]</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;) &#x2F;&#x2F; [object Object]</span><br><span class="line">Object.prototype.toString.call(new RegExp()) &#x2F;&#x2F; [object RegExp]</span><br><span class="line">Object.prototype.toString.call(new Error()) &#x2F;&#x2F; [object Error]</span><br><span class="line">Object.prototype.toString.call(document) &#x2F;&#x2F; [object HTMLDocument]</span><br><span class="line">Object.prototype.toString.call(new Map()) &#x2F;&#x2F; [object Map]</span><br><span class="line">Object.prototype.toString.call(new Set()) &#x2F;&#x2F; [object Set]</span><br><span class="line">&#x2F;&#x2F; [object Window] window 是全局对象 global 的引用</span><br><span class="line">Object.prototype.toString.call(window)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 简易版</span><br><span class="line">deepClone(source) &#123;</span><br><span class="line">  if (!source &amp;&amp; typeof source !&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">    throw new Error(&#39;error arguments&#39;, &#39;deepClone&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  const targetObj &#x3D; source.constructor &#x3D;&#x3D;&#x3D; Array ? [] : &#123;&#125;</span><br><span class="line">  Object.keys(source).forEach(keys &#x3D;&gt; &#123;</span><br><span class="line">    if (source[keys] &amp;&amp; typeof source[keys] &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">      targetObj[keys] &#x3D; deepClone(source[keys])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      targetObj[keys] &#x3D; source[keys]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return targetObj</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 还可以使用JSON.parse(JSON.stringfy()) for..in 实现</span><br><span class="line">&#x2F;&#x2F; 也可以使用lodash._cloneDeep</span><br></pre></td></tr></table></figure>

<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>闭包是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>读取函数内部变量；</li>
<li>变量始终保存在内存中：JS的垃圾回收机制会每隔一段时间回收失去引用的值，释放内存，但是闭包的存在会阻止这一过程。</li>
</ol>
<h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><ol>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除；</li>
<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
</ol>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>原生的setTimeout第一个函数入参不同带参数，可以使用闭包实现传参效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f1(a)&#123;</span><br><span class="line">  return function f2()&#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var fun &#x3D; f1(5)</span><br><span class="line">setTimeout(fun,1000) &#x2F;&#x2F; 1秒后打印出5</span><br></pre></td></tr></table></figure>

<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>事件被触发N毫秒后再执行回调，若在这N毫秒内再次触发则将重新计算执行时间。<br>实际实现的关键是使用setTimeout这个函数，由于需要一个变量来保存计时器，为了维护全局纯净，可以借助闭包实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var debounce &#x3D; function(event, time &#x3D; 1000)&#123;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function(...args)&#123;</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    timer &#x3D; setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">      event.apply(this, args)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流（throttle）:不管事件触发频率多高，只在单位时间内执行一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(event, time) &#123;</span><br><span class="line">  let pre &#x3D; 0;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if (Date.now() - pre &gt; time) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer &#x3D; null;</span><br><span class="line">      pre &#x3D; Date.now();</span><br><span class="line">      event.apply(this, args);</span><br><span class="line">    &#125; else if (!timer) &#123;</span><br><span class="line">      timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        event.apply(this, args);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="instanceof的实现"><a href="#instanceof的实现" class="headerlink" title="instanceof的实现"></a>instanceof的实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; instanceof的实际原理就是判断右侧的prototype是否在左侧对象的原型链上</span><br><span class="line">var myInstanceof &#x3D; function(target,origin)&#123;</span><br><span class="line">  const proto &#x3D; target.__proto__</span><br><span class="line">  if(proto)&#123;</span><br><span class="line">    if(origin.prototype &#x3D;&#x3D;&#x3D; proto)&#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      return myInstanceof(proto,origin)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>详情请看下文。</p>
<h1 id="防抖-1"><a href="#防抖-1" class="headerlink" title="防抖"></a>防抖</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>防抖（debounce）：事件被触发N毫秒后再执行回调，若在这N毫秒内再次触发则将重新计算执行时间。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var debounce &#x3D; function(event, time &#x3D; 1000)&#123;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function(...args)&#123;</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    timer &#x3D; setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">      event.apply(this, args)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候我们需要让函数立即执行一次，再等后面事件触发后等待n秒执行，我们给debounce函数一个flag用于标示是否立即执行。当定时器变量timer为空时，说明是第一次执行，我们立即执行它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var debounce &#x3D; function(event, time &#x3D; 1000, flag) &#123;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    if (flag &amp;&amp; !timer) &#123;</span><br><span class="line">      event.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      event.apply(this, args);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>监听窗口大小变化：使用防抖让函数在窗口大小改变之后再执行，窗口大小改变过程中不执行。<br><code>window.addEventListener(&#39;resize&#39;, debounce(handleResize, 200));</code></li>
<li>搜索框实时搜索：使用防抖让函数在用户输入完毕之后再执行，输入过程中不执行。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-input v-model&#x3D;&quot;queryParams.sellerName&quot; placeholder&#x3D;&quot;请输入专柜名称&quot; clearable @input&#x3D;&quot;nameInput&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">queryParams:&#123;</span><br><span class="line">  sellerName:undefined,</span><br><span class="line">  pageNo:1,</span><br><span class="line">  pageSize:10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实时搜索</span><br><span class="line">nameInput(val)&#123;</span><br><span class="line">  &#x2F;&#x2F; val &#x3D; this.queryParams.sellerName</span><br><span class="line">  debounce(this.getTableData, 1000)(val)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 获取表格数据</span><br><span class="line"> * 入参 sellerName 没有值代表是通过点击查询&#x2F;重置按钮调用的接口</span><br><span class="line"> * 入参 sellerName 有值代表是实时搜索调用的接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">getTableData(sellerName) &#123;</span><br><span class="line">  this.loading &#x3D; true</span><br><span class="line">  sellerList(&#123;</span><br><span class="line">    ...this.queryParams,</span><br><span class="line">    sellerName: sellerName || this.queryParams.sellerName</span><br><span class="line">  &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">    this.tableData &#x3D; res.result.list || []</span><br><span class="line">    this.total &#x3D; res.result.total</span><br><span class="line">    this.loading &#x3D; false</span><br><span class="line">  &#125;).catch(() &#x3D;&gt; &#123;</span><br><span class="line">    this.loading &#x3D; false</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>表单验证：比如用户名、手机号、邮箱等的输入校验，使用防抖让函数在用户输入完成后校验，输入过程中不校验。</li>
</ol>
<h1 id="节流-1"><a href="#节流-1" class="headerlink" title="节流"></a>节流</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>节流（throttle）:不管事件触发频率多高，只在单位时间内执行一次。</p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ol>
<li><strong>时间戳</strong><br>用时间戳来判断是否已到执行时间，记录上次执行的时间戳，然后每次触发事件执行回调，回调中判断当前时间戳距离上次执行时间戳的间隔是否已经达到时间差（Xms） ，如果是则执行，并更新上次执行的时间戳，如此循环。<blockquote>
<p>第一次事件肯定触发，最后一次不会触发</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(event, time) &#123;</span><br><span class="line">  let pre &#x3D; 0;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if (Date.now() - pre &gt; time) &#123;</span><br><span class="line">      pre &#x3D; Date.now();</span><br><span class="line">      event.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>定时器</strong><blockquote>
<p>第一次事件不会触发，最后一次一定触发</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(event, time) &#123;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        timer &#x3D; null;</span><br><span class="line">        event.apply(this, args);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>结合版</strong><blockquote>
<p>定时器和时间戳的结合版，也相当于节流和防抖的结合版，第一次和最后一次都会触发</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(event, time) &#123;</span><br><span class="line">  let pre &#x3D; 0;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if (Date.now() - pre &gt; time) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer &#x3D; null;</span><br><span class="line">      pre &#x3D; Date.now();</span><br><span class="line">      event.apply(this, args);</span><br><span class="line">    &#125; else if (!timer) &#123;</span><br><span class="line">      timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        event.apply(this, args);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>滚动条滚动：比如<a href="https://crystalsummer.gitee.io/2021/09/18/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"><strong>图片懒加载</strong></a></li>
<li>防止按钮频繁点击触发多余请求</li>
<li>搜索框联想功能</li>
</ol>
<p>总体来看，函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行</p>
<h1 id="函数柯里化-1"><a href="#函数柯里化-1" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><h2 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h2><p><strong>柯里化</strong>是指这样一个函数(假设叫做createCurry)，他接收函数fn作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数fn的剩余参数。函数柯里化主要就是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>
<blockquote>
<p>通俗易懂的解释：用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数。</p>
</blockquote>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><ul>
<li>判断当前函数传入的参数是否大于或等于fn需要参数的数量，如果是，直接执行fn；</li>
<li>如果传入参数数量不够，返回一个闭包，暂存传入的参数，并重新返回createCurry函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 柯里化函数</span><br><span class="line">function createCurry(fn, ...args) &#123;</span><br><span class="line">  if (args.length &gt;&#x3D; fn.length) &#123;</span><br><span class="line">    return fn(...args);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (...args2) &#x3D;&gt; createCurry(fn, ...args, ...args2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 求和函数</span><br><span class="line">function A(a,b,c)&#123;</span><br><span class="line">  return a+b+c</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 柯里化函数使用</span><br><span class="line">const curring &#x3D; createCurry(A)</span><br><span class="line">curring(1,2,3)</span><br><span class="line">curring(1)(2)(3)</span><br><span class="line">curring(1,2)(3)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h2><ol>
<li>异步任务：同步任务在主线程上排队执行，只有上一个任务执行完毕，才能执行下一个任务；而异步任务是前一个任务有没有执行完毕不影响下一个任务的执行。</li>
<li>回调函数：将一个函数作为参数传入另一个函数中，并且这个函数不会立刻执行，需要满足一定的条件才会执行的函数就叫做回调函数。回调函数主要是为了实现异步操作。</li>
</ol>
<p>比如前端发送一个请求，但是这个请求需要a请求返回的数据，而a请求又需要b请求的数据，像这样回调函数嵌套回调函数，代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为”回调函数地狱”（callback hell）。回调地狱就是为是实现代码顺序执行而出现的一种操作，它会造成我们的代码可读性非常差，后期不好维护。Promise就可以通过then的链式来解决这个问题。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise(function(resolve,reject)&#123;...&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise对象是一个构造函数，用来生成Promise实例，将一个函数作为参数，这个函数就是用来处理Promise的状态变化。这个函数有resolve和reject入参：</p>
<ul>
<li>resolve的作用是将Promise对象的状态从pending变成fulfilled，在异步操作成功时回调，并将异步操作的结果作为参数传递出去；</li>
<li>reject的作用是将Promise对象的状态从pending变成rejected，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>
</ul>
<p>Promise的缺点：</p>
<ol>
<li>无法取消Promise，一旦新建它就会立即执行，无法中途取消；</li>
<li>如果不设置catch()指定错误处理的回调函数，Promise内部出错，不会反映到外部；</li>
<li>当处于pending状态，无法得知是刚刚开始还是即将结束。</li>
</ol>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>Promise对象有三个状态：</p>
<ul>
<li>pending：进行中</li>
<li>fulfilled：已成功</li>
<li>rejected：已失败</li>
</ul>
<p>这三个状态不受外界影响，而且一旦状态从pending变成fulfilled或者rejected，就不会再变。</p>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><ol>
<li>Promise.prototype.then()<br>它的作用是为 Promise 实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数，它们都是可选的。但是建议第二个参数使用Promise.prototype.catch()。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p1 &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  if(&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class="line">    resolve(data)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(</span><br><span class="line">  data &#x3D;&gt;&#123;&#x2F;&#x2F; 成功操作&#125;,</span><br><span class="line">  error &#x3D;&gt;&#123;&#x2F;&#x2F; 失败操作&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
then方法返回的是一个新的Promise实例，不是原来的Promise实例。因此可以采用链式操作。链式调用：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(&quot;foo&quot;).then((string)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(string) &#x2F;&#x2F; foo</span><br><span class="line">  return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      string +&#x3D; &#39;bar&#39;;</span><br><span class="line">      resolve(string);</span><br><span class="line">    &#125;, 1);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then((string)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(string) &#x2F;&#x2F; foobar</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    string +&#x3D; &#39;baz&#39;;</span><br><span class="line">    console.log(string+&#39;1&#39;);</span><br><span class="line">  &#125;, 1)</span><br><span class="line">  return string</span><br><span class="line">&#125;).then((string)&#x3D;&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>Promise.prototype.catch()<br>它是<code>.then(null/undefined,rejection)</code>的别名，用于异步操作发生错误的时候执行。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p1 &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  if(&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class="line">    resolve(data)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(data &#x3D;&#123;&#x2F;&#x2F; 成功操作&#125;).catch(error &#x3D;&gt;&#123;&#x2F;&#x2F; 失败操作&#125;)</span><br></pre></td></tr></table></figure>
Promise会吃掉错误：当Promise内部出错但是没有指定catch()处理错误的回调函数，控制台会打印错误但是不影响下面代码的运行。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const someAsyncThing &#x3D; function() &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    &#x2F;&#x2F; 下面一行会报错，因为x没有声明</span><br><span class="line">    resolve(x + 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">someAsyncThing().then(function() &#123;</span><br><span class="line">  console.log(&#39;everything is great&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123; console.log(123) &#125;, 2000);</span><br><span class="line">&#x2F;&#x2F; Uncaught (in promise) ReferenceError: x is not defined</span><br><span class="line">&#x2F;&#x2F; 123</span><br></pre></td></tr></table></figure></li>
<li>Promise.prototype.finally()<br>finally是不管Promise最后一步操作是成功还是失败，都会执行的操作。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(result &#x3D;&gt; &#123;···&#125;)</span><br><span class="line">.catch(error &#x3D;&gt; &#123;···&#125;)</span><br><span class="line">.finally(() &#x3D;&gt; &#123;···&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>定义各方法入参的Promise对象数组为PA，定义各方法创建的实例对象为P</p>
<ol>
<li>Promise.all()<br><code>Promise.all()</code>接收一个Promise对象组成的数组PA作为参数，如果数组元素不是Promise对象，那么会调用<code>Promise.resolve()</code>转成Promise对象。<code>Promise.all()</code>处理完后返回的是一个新的Promise对象。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p &#x3D; Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>所有参数实例的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li>
<li>只要参数实例之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。但是如果p1、p2、p3 rejected的实例有自己的catch方法，那么一旦被rejected，并不会触发<code>Promise.all()</code>的catch方法。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; p2有自己的catch方法</span><br><span class="line">const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&#39;hello&#39;);</span><br><span class="line">&#125;).then(result &#x3D;&gt; result)</span><br><span class="line">.catch(e &#x3D;&gt; e);</span><br><span class="line"></span><br><span class="line">const p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  throw new Error(&#39;报错了&#39;);</span><br><span class="line">&#125;).then(result &#x3D;&gt; result)</span><br><span class="line">.catch(e &#x3D;&gt; e);</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2])</span><br><span class="line">.then(result &#x3D;&gt; console.log(result))</span><br><span class="line">.catch(e &#x3D;&gt; console.log(e));</span><br><span class="line">&#x2F;&#x2F; p2有自己的catch方法，会返回一个新的Promise实例，p2指向的实际上是这个实例。该实例执行完catch方法后，</span><br><span class="line">&#x2F;&#x2F; 也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数。</span><br><span class="line">&#x2F;&#x2F; [&quot;hello&quot;, Error: 报错了]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。</span><br><span class="line">&#x2F;&#x2F; Error: 报错了</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>Promise.race()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p &#x3D; Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
参数实例中任意一个的状态变成fulfilled或者rejected，p的状态才会变成fulfilled或者rejected。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p1 &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">    setTimeout(resolve, 500, &#39;one&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">var p2 &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">    setTimeout(resolve, 100, &#39;two&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">var p3 &#x3D; new Promise(function(resolve, reject) &#123; </span><br><span class="line">    setTimeout(reject, 100, &quot;three&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; p2先变成fulfilled状态，所以打印出value two</span><br><span class="line">Promise.race([p1, p2]).then(function(value) &#123;</span><br><span class="line">  console.log(&#39;value &#39;+value);</span><br><span class="line">&#125;).catch(error&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;error &#39;+error)</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; p3先变成rejected状态，所以执行catch，打印出error three</span><br><span class="line">Promise.race([p1, p3]).then(function(value) &#123;</span><br><span class="line">  console.log(&#39;value &#39;+value);</span><br><span class="line">&#125;).catch(error&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;error &#39;+error)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>Promise.allSettled()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p &#x3D; Promise.allSettled([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
参数实例全都变成fulfilled或者rejected，p才会变成fulfilled。只有fulfilled状态，没有rejected状态。状态变成fulfilled后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。</li>
<li>Promise.any()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p &#x3D; Promise.any([p1, p2, p3]);</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态。</li>
<li>如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</li>
</ul>
<ol start="5">
<li>Promise.resolve()<br>将现有对象转为Promise对象。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(&#39;foo&#39;)</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">new Promise(resolve &#x3D;&gt; resolve(&#39;foo&#39;))</span><br></pre></td></tr></table></figure></li>
<li>Promise.reject()<br>返回一个rejected状态的Promise实例。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p &#x3D; Promise.reject(&#39;出错了&#39;);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">const p &#x3D; new Promise((resolve, reject) &#x3D;&gt; reject(&#39;出错了&#39;))</span><br></pre></td></tr></table></figure></li>
<li>Promie.try()<br><code>Promie.try</code>是模拟try catch中的try。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  database.users.get(&#123;id: userId&#125;)</span><br><span class="line">  .then(...)</span><br><span class="line">  .catch(...)</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 使用Promise.try</span><br><span class="line">Promise.try(() &#x3D;&gt; database.users.get(&#123;id: userId&#125;))</span><br><span class="line">  .then(...)</span><br><span class="line">  .catch(...)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>总结：</p>
<ul>
<li><code>Promise.all</code>：PA里面所有的实例的状态变成fulfilled，P的状态才会变成fulfilled；PA里面所有的实例，只要有一个实例状态变成rejected，P的实例的状态才会变成rejected。</li>
<li><code>Promise.any</code>：PA里面所有的实例状态，只要任意一个的状态变成fulfilled，P的状态才会变成fulfilled；PA里面所有的实例状态全部变成rejected，P实例的状态才会变成rejected。</li>
<li><code>Promise.race</code>：PA里面所有的实例，只要任意一个的状态变成fulfilled或者rejected，P的状态才会变成fulfilled或者rejected。</li>
<li><code>Promise.allSettled</code>：PA里面所有的实例状态变成fulfilled或者rejected，P的状态才会变成fulfilled，没有rejected。回调函数的入参是一个数组，数组里面的元素是PA数组里面的Promise对象。</li>
</ul>
<h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><p>具体内容参考：<a href="https://juejin.cn/post/6994594642280857630" target="_blank" rel="noopener"><strong>看了就会，手写Promise原理，最通俗易懂的版本！！！</strong></a><br>解析过程如下：</p>
<ol>
<li>实现 resolve 和 reject</li>
</ol>
<ul>
<li>PromiseState-保存Promise状态，pending、fulfilled、rejected；<br>PromiseResult-保存Promise状态改变回调函数的入参，fulfilled时是value，rejected时是reason；</li>
<li>执行resolve，Promise状态会变成fulfilled；执行reject，Promise状态会变成rejected</li>
<li>Promise只以第一次为准，第一次成功就永久为fulfilled，第一次失败就永远状态为rejected</li>
<li>Promise中有throw的话，就相当于执行了reject</li>
</ul>
<ol start="2">
<li>实现then</li>
</ol>
<ul>
<li>then接收两个回调，一个是成功回调，一个是失败回调，当Promise状态为fulfilled执行成功回调，为rejected执行失败回调。</li>
<li>如果resolve或reject在定时器里，则定时器结束后再执行then：我们可以在定时器还未结束的时候将then的两个回调函数保存起来，等定时器结束执行resolve或者reject的时候再去执行回调函数。我们可以通过当转状态是不是pending来判断定时器是否结束。</li>
<li>then支持链式调用，下一次then执行受上一次then返回值的影响：我们可以在then执行完毕之后返回一个新的Promise（thenPromise），这样就可以实现then的链式调用。在thenPromise里面定义一个<code>resolvePromise</code>函数，这个专门用来处理回调函数</li>
<li>then方法是微任务：只需要让<code>resolvePromise</code>函数异步执行就可以了，可以使用setTimeout实现。</li>
</ul>
<p>完整代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化值</span><br><span class="line">    this.initValue()</span><br><span class="line">    &#x2F;&#x2F; 初始化this指向</span><br><span class="line">    this.initBind()</span><br><span class="line">    &#x2F;&#x2F; Promise中有throw的话，就相当于执行了reject</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 执行传进来的函数</span><br><span class="line">      executor(this.resolve, this.reject)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      &#x2F;&#x2F; 捕捉到错误直接执行reject</span><br><span class="line">      this.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 初始化值</span><br><span class="line">  initValue() &#123;</span><br><span class="line">    this.PromiseResult &#x3D; null &#x2F;&#x2F; 终值</span><br><span class="line">    this.PromiseState &#x3D; &#39;pending&#39; &#x2F;&#x2F; 状态</span><br><span class="line">    this.onFulfilledCallbacks &#x3D; [] &#x2F;&#x2F; 保存成功回调</span><br><span class="line">    this.onRejectedCallbacks &#x3D; [] &#x2F;&#x2F; 保存失败回调</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 初始化this</span><br><span class="line">  initBind() &#123;</span><br><span class="line">    this.resolve &#x3D; this.resolve.bind(this)</span><br><span class="line">    this.reject &#x3D; this.reject.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  resolve(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; state是不可变的</span><br><span class="line">    if (this.PromiseState !&#x3D;&#x3D; &#39;pending&#39;) return</span><br><span class="line">    &#x2F;&#x2F; 如果执行resolve，状态变为fulfilled</span><br><span class="line">    this.PromiseState &#x3D; &#39;fulfilled&#39;</span><br><span class="line">    &#x2F;&#x2F; 终值为传进来的值</span><br><span class="line">    this.PromiseResult &#x3D; value</span><br><span class="line">    &#x2F;&#x2F; 执行保存的成功回调</span><br><span class="line">    while (this.onFulfilledCallbacks.length) &#123;</span><br><span class="line">      this.onFulfilledCallbacks.shift()(this.PromiseResult)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    &#x2F;&#x2F; state是不可变的</span><br><span class="line">    if (this.PromiseState !&#x3D;&#x3D; &#39;pending&#39;) return</span><br><span class="line">    &#x2F;&#x2F; 如果执行reject，状态变为rejected</span><br><span class="line">    this.PromiseState &#x3D; &#39;rejected&#39;</span><br><span class="line">    &#x2F;&#x2F; 终值为传进来的reason</span><br><span class="line">    this.PromiseResult &#x3D; reason</span><br><span class="line">    &#x2F;&#x2F; 执行保存的失败回调</span><br><span class="line">    while (this.onRejectedCallbacks.length) &#123;</span><br><span class="line">      this.onRejectedCallbacks.shift()(this.PromiseResult)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    &#x2F;&#x2F; 接收两个回调 onFulfilled, onRejected</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 参数校验，确保一定是函数</span><br><span class="line">    onFulfilled &#x3D; typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : val &#x3D;&gt; val</span><br><span class="line">    onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onRejected : reason &#x3D;&gt; &#123; throw reason &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 新建一个thenPromise并返回，实现then的链式操作</span><br><span class="line">    var thenPromise &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      const resolvePromise &#x3D; cb &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; then是微任务，让resolvePromise异步执行</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            const x &#x3D; cb(this.PromiseResult)</span><br><span class="line">            if (x &#x3D;&#x3D;&#x3D; thenPromise) &#123;</span><br><span class="line">              &#x2F;&#x2F; 不能返回自身</span><br><span class="line">              throw new Error(&#39;不能返回自身。。。&#39;)</span><br><span class="line">            &#125;</span><br><span class="line">            if (x instanceof MyPromise) &#123;</span><br><span class="line">              &#x2F;&#x2F; 如果返回值是Promise</span><br><span class="line">              &#x2F;&#x2F; 如果返回值是promise对象，返回值为成功，新promise就是成功</span><br><span class="line">              &#x2F;&#x2F; 如果返回值是promise对象，返回值为失败，新promise就是失败</span><br><span class="line">              &#x2F;&#x2F; 谁知道返回的promise是失败成功？只有then知道</span><br><span class="line">              x.then(resolve, reject)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              &#x2F;&#x2F; 非Promise就直接成功</span><br><span class="line">              resolve(x)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; catch (err) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理报错</span><br><span class="line">            reject(err)</span><br><span class="line">            throw new Error(err)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      if (this.PromiseState &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果当前为成功状态，执行第一个回调</span><br><span class="line">        resolvePromise(onFulfilled)</span><br><span class="line">      &#125; else if (this.PromiseState &#x3D;&#x3D;&#x3D; &#39;rejected&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果当前为失败状态，执行第二个回调</span><br><span class="line">        resolvePromise(onRejected)</span><br><span class="line">      &#125; else if (this.PromiseState &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果状态为待定状态，暂时保存两个回调</span><br><span class="line">        this.onFulfilledCallbacks.push(onFulfilled.bind(this))</span><br><span class="line">        this.onRejectedCallbacks.push(onRejected.bind(this))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回这个包装的Promise</span><br><span class="line">    return thenPromise</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h1><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p><code>async/await</code>的用处就是：<strong>用同步方式，执行异步操作</strong>，比如回调地狱，Promise 虽然可以解决，但是 then 的链式会很长，Generator 函数也可以解决，但是<code>async/await</code>比星号和<code>yield</code>更加语义化。</p>
<p><code>async/await</code>是 Generator 的语法糖，是使用 Promise + Generator 的 next传参实现的。</p>
<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>async 函数返回一个 promise 对象，可以使用 then 方法添加回调函数，函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。</p>
<p>async 函数返回的 Promise 对象，必须等所有的 await 异步操作完成后才会进入 fulfilled 状态，只要有一个 await 语句后面的 Promise 对象变为 reject 状态，那么整个async函数都会中断执行。如果想要 await 的 Promise reject 之后继续执行下面的代码，可以将 await 的 Promise 放在<code>try...catch</code>里面或者后面跟着<code>catch()</code>方法。</p>
<h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>await 命令后面跟着 Promise 对象，返回该对象的结果，如果不是，就直接返回对应的值。</p>
<p>如果 await 后面的异步操作出错，那么等同于 async 函数返回的 Promise 对象被reject。防止出错的方法，也是将其放在<code>try...catch</code>代码块之中，多个 await 可以统一放在该结构中。</p>
]]></content>
      <categories>
        <category>Web</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础进阶(一)</title>
    <url>/2021/03/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%B8%80)/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2021/09/23/05/27/butterflies-6648681_960_720.jpg" alt=""></p>
<a id="more"></a>
<h1 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h1><h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><ul>
<li>基本数据类型：number string boolean null undefined symbol；</li>
<li>引用数据类型：数组 对象 函数。</li>
</ul>
<p>两种数据类型的区别：</p>
<ul>
<li>基本数据类型保存在栈内存中，引用数据类型的变量名是保存在栈内存中，变量值保存在堆内存中；</li>
<li>基本数据类型如果定义在函数中，函数执行完毕这个变量就会自动销毁，而引用数据类型的变量只有在没有引用的时候，垃圾回收机制回收；</li>
<li>基本数据类型的赋值不会相互影响，而引用数据类型会；</li>
<li>基本数据类型无法添加属性和方法，引用数据类型可以。</li>
</ul>
<h2 id="栈、堆、队列"><a href="#栈、堆、队列" class="headerlink" title="栈、堆、队列"></a>栈、堆、队列</h2><ul>
<li>栈内存：先进后出；</li>
<li>堆内存：对数据结构是树状结构，存取很方便，但是JS不允许直接访问堆内存中的数据，在操作对象的时候，实际上操作的是对象的引用，而不是实际的对象。这里的引用，可以理解为保存在变量对象中的一个地址，这个地址与堆内存的实际值相关联；</li>
<li>队列：先进先出。</li>
</ul>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>程序的运行需要内存，只要程序提出要求，操作系统或者运行是就必须供给内存。对于持续运行的服务进程，必须及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏。但是现在大多数语言都提供了内存的自动管理，就像JS有垃圾回收机制，减轻程序员的负担。</p>
<p>V8垃圾回收机制会将内存分成新生代空间和老生代空间：</p>
<ul>
<li>新生代空间：用于存放存活时间较短的对象</li>
<li>老生代空间：用于存放存活时间较长的对象</li>
</ul>
<p>常见的内存泄漏：</p>
<ol>
<li>全局变量的声明：如果有可能尽可能使用var、let、const声明变量，如果不得不使用全局变量的话，使用完要手动置为null释放内存；</li>
<li>setInterval或者setTimeout：定义定时器或者计时器，如果不使用clearInterval或者clearTimeout清除的话，这些变量和对象会一直保存在内存里面；</li>
<li>监听scroll、resize等频繁操作节点的事件没有用removeEvenetListener清除；</li>
<li>闭包的滥用。</li>
</ol>
<h2 id="内存管理-垃圾回收"><a href="#内存管理-垃圾回收" class="headerlink" title="内存管理-垃圾回收"></a>内存管理-垃圾回收</h2><p>原理：垃圾收集器每隔固定时间找到那些不再继续使用的值，然后释放它占用的内存。<br>常用算法：<br>&emsp;&emsp;<strong>标记-清除</strong> </p>
<ul>
<li>从根集合出发，将所有活动对象及其子对象打上标记；</li>
<li>遍历堆，将未打上标记的链接到空的链表上释放；</li>
<li>实现简单，容易和其他算法组合；但是太碎片化，导致无数小分块散布在堆的各处。</li>
</ul>
<p>&emsp;&emsp;<strong>标记-压缩</strong> </p>
<ul>
<li>从根集合出发，将所有活动对象及其子对象打上标记</li>
<li>遍历堆，将打上标记的对象紧密的排在堆的一侧（压缩）；</li>
<li>消除了碎片化；但是压缩过程需要多次遍历堆，开销大。</li>
</ul>
<p>&emsp;&emsp;<strong>引用-计数</strong></p>
<ul>
<li>每次新建和操作对象的同时更新计数器；</li>
<li>计数器为0的直接回收内存；</li>
</ul>
<p>另外还有其他的几种回收算法：三色标记法、GC复制算法等。</p>
<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>执行上下文可以理解为代码的执行环境，分为全局环境和函数环境。</p>
<h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2><p>在JS程序中，必定会产生多个上下文，JS引擎会以栈的方式处理它们，叫做函数调用栈，栈底永远是全局上下文，栈顶是当前正在执行的上下文。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var color &#x3D; &#39;blue&#39;;</span><br><span class="line"></span><br><span class="line">function changeColor() &#123;</span><br><span class="line">  var anotherColor &#x3D; &#39;red&#39;;</span><br><span class="line"></span><br><span class="line">  function swapColors() &#123;</span><br><span class="line">    var tempColor &#x3D; anotherColor;</span><br><span class="line">    anotherColor &#x3D; color;</span><br><span class="line">    color &#x3D; tempColor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  swapColors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
<p>根据以上JS执行顺序举例说明：</p>
<ul>
<li>全局上下文入栈；</li>
<li>可执行代码开始执行，遇到<code>changeColor()</code>，激活该函数创建自己的上下文，因此changeColor的执行上下文入栈；</li>
<li>changeColor的执行上下文入栈后，控制器开始执行changeColor中的可执行代码，遇到<code>swapColors()</code>，激活swapColors函数创建自己的上下文并且入栈；</li>
<li>swapColors的可执行代码中没有遇到其他能生成执行上下文的情况，因此这段代码执行完毕，swapColors执行上下文从栈中弹出；</li>
<li>swapColors的执行上下文弹出之后，继续执行changeColor的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出；</li>
<li>最后只剩下全局上下文，全局上下文在浏览器窗口关闭后出栈。<br><img src="https://s2.loli.net/2022/03/08/bYjZUtNoI9p2J5L.png" alt=""></li>
</ul>
<p><strong>注意</strong>：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。以闭包为例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var n &#x3D; 999;</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    alert(n);</span><br><span class="line">  &#125;</span><br><span class="line">  return f2;</span><br><span class="line">&#125;</span><br><span class="line">var result &#x3D; f1();</span><br><span class="line">result(); &#x2F;&#x2F; 999</span><br></pre></td></tr></table></figure>
<p>具体上下文执行如下：<br><img src="https://s2.loli.net/2022/03/08/VltD9umQ6BzAyNn.png" alt=""></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>执行上下文中，除了<strong>函数调用栈</strong>这种特殊的数据结构，还有另外一个特殊的队列结构，页面中所有由setTimeout回调、Promise的then定义的操作，都将放在同一个队列中依次执行。</p>
<blockquote>
<p><strong>队列执行的时间，需要等待到函数调用栈清空之后才开始执行。即所有可执行代码执行完毕之后，才会开始执行由setTimeout定义的操作。而这些操作进入队列的顺序，则由设定的延迟时间来决定。</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">  setTimeout(function timer() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, i * 1000);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 输出结果6 6 6 6 6</span><br><span class="line">for (let i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">  setTimeout(function timer() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, i * 1000);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 输出结果 1 2 3 4 5</span><br><span class="line">for (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">  (function (i) &#123;</span><br><span class="line">    setTimeout(function timer() &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;, i * 1000);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 输出结果 1 2 3 4 5</span><br></pre></td></tr></table></figure>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>当调用一个函数时（激活），一个新的执行上下文就会被创建，一个执行上下文的生命周期如下：</p>
<ul>
<li>创建阶段：执行上下文会生成变量对象，建立作用域链，确定this的指向；</li>
<li>代码执行阶段：创建完成后开始执行代码，变量赋值，函数引用，执行其他的代码；</li>
<li>销毁阶段：可执行代码执行完毕后，执行上下文出栈，对应的内存空间失去引用，等待回收。</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/12/U2YOV3mZPy5XxQi.png" alt=""><br>下面依次介绍变量对象的生成、作用域链的建立、this指向的确定。</p>
<h1 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h1><blockquote>
<p>变量对象在新版本中叫做环境记录对象<br>环境记录对象有分为词法环境对象和变量环境对象<br>为了方便理解，这里统一采用变量对象的说法</p>
</blockquote>
<h2 id="创建执行过程"><a href="#创建执行过程" class="headerlink" title="创建执行过程"></a>创建执行过程</h2><ol>
<li><strong>创建</strong></li>
</ol>
<ul>
<li>检查当前上下文，生成变量对象，建立该对象下的属性与属性值；</li>
<li>检查当前上下文的函数声明，在变量对象中以函数名建立一个属性，属性值指向该函数的内存地址引用；</li>
<li>检查当前上下文的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined，<strong>如果是const/let 声明的变量没有赋值，不能提前使用</strong>。</li>
</ul>
<ol start="2">
<li><strong>执行</strong><br>变量对象创建完成之后，<strong>未进入执行阶段之前，变量对象中的属性都不能访问！</strong>进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作，就是给变量对象里面的声明赋值。</li>
</ol>
<p><strong>注意</strong>：如果var声明的变量和函数同名，以函数为准。<br><img src="https://s2.loli.net/2022/03/09/bvMy12akwufzi56.png" alt=""><br>根据这个规则，理解变量提升就变得十分简单了，可以用变量对象的创建过程来解释变量提升，看以下示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(foo); &#x2F;&#x2F; function foo</span><br><span class="line">function foo() &#123; console.log(&#39;function foo&#39;) &#125;</span><br><span class="line">var foo &#x3D; 20;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上例的执行顺序为</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 首先将所有函数声明放入变量对象中</span><br><span class="line">function foo() &#123; console.log(&#39;function foo&#39;) &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，此时以函数值为准，而不会被undefined覆盖</span><br><span class="line">&#x2F;&#x2F; var foo &#x3D; undefined;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后开始执行阶段代码的执行</span><br><span class="line">console.log(foo); &#x2F;&#x2F; function foo</span><br><span class="line">foo &#x3D; 20;</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; demo01</span><br><span class="line">function test() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(foo());</span><br><span class="line"></span><br><span class="line">    var a &#x3D; 1;</span><br><span class="line">    function foo() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>创建test执行上下文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建过程</span><br><span class="line">&#x2F;&#x2F; 创建执行上下文</span><br><span class="line">testEC &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 变量对象</span><br><span class="line">    VO: &#123;&#125;,</span><br><span class="line">    scopeChain: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; VO 为 Variable Object的缩写，即变量对象</span><br><span class="line">VO &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理</span><br><span class="line">  arguments: &#123;...&#125;,  </span><br><span class="line">  foo: &lt;foo reference&gt;  &#x2F;&#x2F; 表示foo的地址引用</span><br><span class="line">  a: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p>
<blockquote>
<p>变量对象和活动对象<br>他们其实都是同一个对象，只是处于执行上下文的不同生命周期。<br>不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行阶段</span><br><span class="line">VO -&gt;  AO   &#x2F;&#x2F; Active Object</span><br><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;...&#125;,</span><br><span class="line">    foo: &lt;foo reference&gt;,</span><br><span class="line">    a: 1,</span><br><span class="line">    this: Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    console.log(foo);</span><br><span class="line">    console.log(bar);</span><br><span class="line"></span><br><span class="line">    var foo &#x3D; &#39;Hello&#39;;</span><br><span class="line">    console.log(foo);</span><br><span class="line">    var bar &#x3D; function () &#123;</span><br><span class="line">        return &#39;world&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function foo() &#123;</span><br><span class="line">        return &#39;hello&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建阶段</span><br><span class="line">VO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;...&#125;,</span><br><span class="line">    foo: &lt;foo reference&gt;,</span><br><span class="line">    bar: undefined</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这里有一个需要注意的地方，var声明的变量与函数同名，以函数为准</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行阶段</span><br><span class="line">VO -&gt; AO</span><br><span class="line">VO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;...&#125;,</span><br><span class="line">    foo: &#39;Hello&#39;,</span><br><span class="line">    bar: &lt;bar reference&gt;,</span><br><span class="line">    this: Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="var-const-let"><a href="#var-const-let" class="headerlink" title="var const let"></a>var const let</h2><ol>
<li>var</li>
</ol>
<ul>
<li>var声明的变量，如果在函数内就属于当前函数作用域，如果在函数外的顶层，那么这个变量就属于全局作用域；</li>
<li>var 声明的变量存在提升</li>
</ul>
<ol start="2">
<li>let</li>
</ol>
<ul>
<li>let 声明的变量属于块作用域；</li>
<li>在同一个块级作用域，不能重复声明变量；</li>
<li>let 声明的变量不存在变量提升，换一种说法，就是 let 声明存在暂时性死区。</li>
</ul>
<ol start="3">
<li>const</li>
</ol>
<ul>
<li>const 声明的变量属于块作用域；</li>
<li>在同一个块级作用域，不能重复声明变量；</li>
<li>const 声明的变量不存在变量提升，换一种说法，就是 const 声明存在暂时性死区；</li>
<li>const 声明的变量值不可更改，也就是说是一个常量。</li>
<li>一旦声明必须赋值,不能使用null占位；如果声明的是复合类型数据，可以修改其属性。</li>
</ul>
<p>总结如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; var 声明的变量属于函数作用域，let 和 const 声明的变量属于块级作用域</span><br><span class="line">if(1)&#123;</span><br><span class="line">    var a &#x3D; 100;</span><br><span class="line">    let b &#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); &#x2F;&#x2F; 100</span><br><span class="line">console.log(b)  &#x2F;&#x2F; 报错：b is not defined  &#x3D;&#x3D;&#x3D;&gt; 找不到b这个变量</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; var声明变量存在变量提升，let和const不存在变量提升</span><br><span class="line">console.log(a); &#x2F;&#x2F; undefined  &#x3D;&#x3D;&#x3D;&gt;  a已声明还没赋值，默认得到undefined值</span><br><span class="line">var a &#x3D; 100;</span><br><span class="line">console.log(b); &#x2F;&#x2F; 报错：b is not defined  &#x3D;&#x3D;&#x3D;&gt; 找不到b这个变量</span><br><span class="line">let b &#x3D; 10;</span><br><span class="line">console.log(c); &#x2F;&#x2F; 报错：c is not defined  &#x3D;&#x3D;&#x3D;&gt; 找不到c这个变量</span><br><span class="line">const c &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; var 变量可以重复声明，而在同一个块级作用域，let 变量不能重新声明，const 变量不能修改</span><br><span class="line">var a &#x3D; 100;</span><br><span class="line">console.log(a); &#x2F;&#x2F; 100</span><br><span class="line">var a &#x3D; 10;</span><br><span class="line">console.log(a); &#x2F;&#x2F; 10</span><br><span class="line">let b &#x3D; 100;</span><br><span class="line">let b &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F; 控制台报错：Identifier &#39;b&#39; has already been declared </span><br><span class="line">&#x2F;&#x2F; 标识符b已经被声明了。</span><br></pre></td></tr></table></figure>
<h2 id="变量提升-函数提升"><a href="#变量提升-函数提升" class="headerlink" title="变量提升 函数提升"></a>变量提升 函数提升</h2><ol>
<li><strong>变量提升</strong><br>在JS中，变量提升只是提升变量的声明，并不会把变量赋值也提升上来。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 1</span><br><span class="line">(</span><br><span class="line">  function()&#123;</span><br><span class="line">    console.log(a) &#x2F;&#x2F; undefined &#x3D;&#x3D;&#x3D;&gt;  a已声明还没赋值，默认得到undefined值</span><br><span class="line">    var a &#x3D; 2</span><br><span class="line">  &#125;</span><br><span class="line">)()</span><br><span class="line">&#x2F;&#x2F; 变量提升为以下内容：   </span><br><span class="line">var a &#x3D; 1</span><br><span class="line">(</span><br><span class="line">  function()&#123;</span><br><span class="line">    var a</span><br><span class="line">    console.log(a)</span><br><span class="line">    a &#x3D; 2</span><br><span class="line">  &#125;</span><br><span class="line">)()</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>总结</strong>：当一个函数被调用（激活）的时候，会创建一个执行上下文，执行上下文会生成变量对象，建立变量对象下的属性；然后检查上下文的函数声明，在变量对象中以函数名建立一个属性，属性值指向该函数的内存地址引用；然后检查当前上下文的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined，比如<code>console.log(a);var a = 1</code>就会创建一个属性为a，属性值为undefined的属性，当变量对象创建完成后会去执行代码，这个时候才会把属性a赋值为1，也就是说先声明，后赋值，那么刚刚那段代码就是被解析成<code>var a;console.log(a);a=1</code>，这就是变量提升。</p>
<ol start="2">
<li><strong>函数提升</strong><br>在JS中，函数的写法与两种，一种是函数声明，一种是函数表达式，函数提升只对函数声明式的函数有效。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数声明</span><br><span class="line">function myTest()&#123;</span><br><span class="line">  foo();</span><br><span class="line">  function foo()&#123;</span><br><span class="line">    alert(&quot;我来自 foo&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myTest();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数表达式的提升会报错：foo is not a function</span><br><span class="line">function myTest()&#123;</span><br><span class="line">  foo();</span><br><span class="line">  &#x2F;&#x2F; 函数表达式</span><br><span class="line">  var foo &#x3D;function foo()&#123;</span><br><span class="line">    alert(&quot;我来自 foo&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myTest();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="作用域-作用域链"><a href="#作用域-作用域链" class="headerlink" title="作用域 作用域链"></a>作用域 作用域链</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域是JS的一套规则，可以理解成上下文中声明的函数和变量的作用范围。分为全局作用域、函数作用域、块作用域。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链是作用域的具体实现，是由当前环境和上层环境的变量对象组成的，所以我们能通过作用域链访问到父级里声明的变量或者函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 20;</span><br><span class="line">function test() &#123;</span><br><span class="line">  var b &#x3D; a + 10;</span><br><span class="line">  function innerTest() &#123;</span><br><span class="line">    var c &#x3D; 10;</span><br><span class="line">    return b + c;</span><br><span class="line">  &#125;</span><br><span class="line">  return innerTest();</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">&#x2F;&#x2F; 以上，全局、函数test、函数innerTest的执行上下文会依次创建；</span><br><span class="line">&#x2F;&#x2F; 我们设定他们的变量对象分别为VO(global)，VO(test), VO(innerTest)；</span><br><span class="line">&#x2F;&#x2F; 而innerTest的作用域链，则同时包含了这三个变量对象，所以innerTest的执行上下文可如下表示。</span><br><span class="line">innerTestEC &#x3D; &#123;</span><br><span class="line">  VO: &#123;...&#125;,  &#x2F;&#x2F; 变量对象</span><br><span class="line">  scopeChain: [VO(innerTest), VO(test), VO(global)], &#x2F;&#x2F; 作用域链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们这里使用一个数组来模拟作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。</p>
<h1 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h1><blockquote>
<p><strong>this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。</strong><br><strong>在函数执行过程中，this一旦被确定，就不可更改了。</strong></p>
</blockquote>
<h2 id="全局this"><a href="#全局this" class="headerlink" title="全局this"></a>全局this</h2><p>全局环境中的this，指向它本身。因此，这也相对简单，没有那么多复杂的情况需要考虑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过this绑定到全局对象</span><br><span class="line">this.a2 &#x3D; 20;</span><br><span class="line">&#x2F;&#x2F; 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身</span><br><span class="line">var a1 &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F; 仅仅只有赋值操作，标识符会隐式绑定到全局对象</span><br><span class="line">a3 &#x3D; 30;</span><br><span class="line">&#x2F;&#x2F; 输出结果会全部符合预期</span><br><span class="line">console.log(a1);</span><br><span class="line">console.log(a2);</span><br><span class="line">console.log(a3);</span><br></pre></td></tr></table></figure>

<h2 id="普通函数中的this"><a href="#普通函数中的this" class="headerlink" title="普通函数中的this"></a>普通函数中的this</h2><p>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。</p>
<ol>
<li>如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。</li>
<li>如果函数独立调用，严格模式下，该函数内部的this，指向undefined；在非严格模式中，当this指向undefined时，它会被自动指向全局对象。目前基本已经全部采用严格模式。</li>
<li>单独的{}不会形成新的作用域，因此对象属性中的this仍然处于全局作用域之中，所以这里的this是指向全局对象。</li>
</ol>
<p>所以，如果想要准确确定this指向，就要找到函数的<strong>调用者</strong>以及区分他<strong>是否独立调用</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;</span><br><span class="line">&#x2F;&#x2F; demo01</span><br><span class="line">var a &#x3D; 20;</span><br><span class="line">function fn() &#123;</span><br><span class="line">  console.log(this.a); </span><br><span class="line">&#125;</span><br><span class="line">fn(); &#x2F;&#x2F; 调用者是fn，独立调用，严格模式，this是undefined</span><br><span class="line">window.fn();  &#x2F;&#x2F; 调用者是fn，被window所拥有，this指向window</span><br><span class="line">&#x2F;&#x2F; demo02</span><br><span class="line">var a &#x3D; 20;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  c: this.a + 20,</span><br><span class="line">  fn: function () &#123;</span><br><span class="line">    return this.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.c); &#x2F;&#x2F; 40 对象属性中的this指向全局 </span><br><span class="line">console.log(obj.fn()); &#x2F;&#x2F; 10 调用者fn被对象拥有，this指向对象</span><br><span class="line">&#x2F;&#x2F; demo03</span><br><span class="line">var a &#x3D; 20;</span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  getA: function () &#123;</span><br><span class="line">    return this.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo.getA()); &#x2F;&#x2F; 10 调用者getA被对象拥有，this指向对象</span><br><span class="line">var test &#x3D; foo.getA;</span><br><span class="line">console.log(test());  &#x2F;&#x2F; 报错 调用者test，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h2><p><strong>箭头函数没有自己的this，它会捕获所在上下文的this作为自己的this值。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person() &#123;  </span><br><span class="line">    this.age &#x3D; 0;  </span><br><span class="line">    setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 回调里面的 &#96;this&#96; 变量就指向了期望的那个对象了</span><br><span class="line">        this.age++;</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line">var p &#x3D; new Person();</span><br></pre></td></tr></table></figure>

<h2 id="构造函数和原型方法上的this"><a href="#构造函数和原型方法上的this" class="headerlink" title="构造函数和原型方法上的this"></a>构造函数和原型方法上的this</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里的this指向了谁?</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;   </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里的this又指向了谁？</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 上面的2个this，是同一个吗，他们是否指向了原型对象？</span><br><span class="line">var p1 &#x3D; new Person(&#39;Nick&#39;, 20);</span><br><span class="line">p1.getName();</span><br></pre></td></tr></table></figure>
<p>通过new操作符调用构造函数，会经历以下4个阶段：</p>
<ol>
<li>创建一个新的对象；</li>
<li>将构造函数的this指向这个新对象；</li>
<li>指向构造函数的代码，为这个对象添加属性，方法等；</li>
<li>返回新对象。</li>
</ol>
<p>因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象：p1。</p>
<p>而原型方法上的this就好理解多了，根据上边对函数中this的定义，p1.getName()中的getName为调用者，他被p1所拥有，因此getName中的this，也是指向了p1。</p>
<h2 id="call-apply-bind-指定-this"><a href="#call-apply-bind-指定-this" class="headerlink" title="call apply bind 指定 this"></a>call apply bind 指定 this</h2><p>call apply bind都是用来指定this，第一个入参是this的指向对象（如果此参数是null或者undefined，this指向全局），差别在于后面的入参：</p>
<ol>
<li>call后面的入参是多个参数，一个一个传递；</li>
<li>appy后面的入参是数组；</li>
<li>bind后面的入参和call一样，但是bind返回的是函数，并没有立即执行。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn(b,c) &#123;</span><br><span class="line">  console.log(this.a+&#39;-&#39;+b+&#39;-&#39;+c);</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: 20</span><br><span class="line">&#125;</span><br><span class="line">fn.call(obj,1,2);</span><br><span class="line">fn.apply(obj,[1,2]);</span><br><span class="line">fn.bind(obj,1,2)();</span><br></pre></td></tr></table></figure>
<p>常用做法：当匿名函数的存在导致this指向丢失时，确保this的指向不变，也可以使用箭头函数来代替。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: 20,</span><br><span class="line">  getA: function () &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(this.a)</span><br><span class="line">    &#125;.bind(this), 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure>

<h2 id="手动实现call-apply-bind"><a href="#手动实现call-apply-bind" class="headerlink" title="手动实现call apply bind"></a>手动实现call apply bind</h2><ol>
<li>call</li>
</ol>
<ul>
<li>判断当前this是否为函数，防止Function.prototype.myCall() 直接调用</li>
<li>context 为可选参数，如果不传的话默认上下文为 window</li>
<li>为 context 创建一个 Symbol（保证不会重名）属性，将当前函数赋值给这个属性</li>
<li>处理参数，传入第一个参数后的其余参数</li>
<li>调用函数后即删除该Symbol属性<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.myCall &#x3D; function (context &#x3D; window, ...args) &#123;</span><br><span class="line">  if (this &#x3D;&#x3D;&#x3D; Function.prototype) &#123;</span><br><span class="line">    return undefined; &#x2F;&#x2F; 用于防止 Function.prototype.myCall() 直接调用</span><br><span class="line">  &#125;</span><br><span class="line">  const fn &#x3D; Symbol();</span><br><span class="line">  context[fn] &#x3D; this;</span><br><span class="line">  const result &#x3D; context[fn](...args);</span><br><span class="line">  delete context[fn];</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>apply<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.myApply &#x3D; function (context &#x3D; window, args) &#123;</span><br><span class="line">  if (this &#x3D;&#x3D;&#x3D; Function.prototype) &#123;</span><br><span class="line">    return undefined; &#x2F;&#x2F; 用于防止 Function.prototype.myCall() 直接调用</span><br><span class="line">  &#125;</span><br><span class="line">  const fn &#x3D; Symbol();</span><br><span class="line">  context[fn] &#x3D; this;</span><br><span class="line">  let result;</span><br><span class="line">  if (Array.isArray(args)) &#123;</span><br><span class="line">    result &#x3D; context[fn](...args);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result &#x3D; context[fn]();</span><br><span class="line">  &#125;</span><br><span class="line">  delete context[fn];</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>bind</li>
</ol>
<ul>
<li>处理参数，返回一个闭包</li>
<li>判断是否为构造函数调用，如果是则使用new调用当前函数</li>
<li>如果不是，使用apply，将context和处理好的参数传入<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.myBind &#x3D; function (context,...args1) &#123;</span><br><span class="line">  if (this &#x3D;&#x3D;&#x3D; Function.prototype) &#123;</span><br><span class="line">    throw new TypeError(&#39;Error&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  const _this &#x3D; this</span><br><span class="line">  return function F(...args2) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断是否用于构造函数</span><br><span class="line">    if (this instanceof F) &#123;</span><br><span class="line">      return new _this(...args1, ...args2)</span><br><span class="line">    &#125;</span><br><span class="line">    return _this.apply(context, args1.concat(args2))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h1><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>事件循环机制(Event Loop)从整体上的告诉了我们所写的JavaScript代码的执行顺序。需要理解以下几个知识点：</p>
<ul>
<li>堆、栈、队列等数据结构</li>
<li>执行上下文(Execution context)</li>
<li>函数调用栈(call stack)</li>
<li>队列数据结构(queue)</li>
</ul>
<p>JavaScript的一大特点就是单线程，而这个线程中拥有唯一的一个事件循环。</p>
<p>JavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行。</p>
<ul>
<li>一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。</li>
<li>任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。</li>
<li>宏任务大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。</li>
<li>微任务大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)</li>
<li>setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。所以setTimeout中的回调函数是进入任务队列的任务，而Promise进入任务队列的是then。</li>
<li><strong>async/await情况特殊：</strong>遇到async函数和普通函数一样执行就可以了，特殊的是await，await会先等后面跟着的内容执行并返回结果，然后<strong>中断async函数</strong>，先执行async外的代码，等到执行完之后返回async内部执行剩下的代码，最后执行队列。</li>
<li>来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。</li>
<li>事件循环的顺序，决定了JavaScript代码的执行顺序。</li>
<li>每一个任务的执行，无论是宏任务还是微任务，都是借助函数调用栈来完成。</li>
</ul>
<span style="color: #409eff;">
事件循环它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的微任务。当所有可执行的微任务执行完毕之后。循环再次从宏任务开始，找到其中一个任务队列执行完毕，然后再执行所有的微任务，这样一直循环下去。
</span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#39;timeout1&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">setImmediate(function() &#123;</span><br><span class="line">    console.log(&#39;immediate1&#39;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&#39;immediate1_nextTick&#39;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#39;immediate1_promise&#39;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#39;immediate1_then&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&#39;promise1&#39;);</span><br><span class="line">    for(var i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        i &#x3D;&#x3D; 99 &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#39;promise2&#39;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#39;then1&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;global1&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;结果：</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">global1</span><br><span class="line">then1</span><br><span class="line"></span><br><span class="line">timeout1</span><br><span class="line">immediate1</span><br><span class="line">immediate1_promise</span><br><span class="line">immediate1_nextTick</span><br><span class="line">immediate1_then</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解析</span><br><span class="line">1.从上往下依次执行，script(整体代码)宏任务进入，全局global入栈。</span><br><span class="line">2.遇到setTimeout，setTimeout作为任务分发器，将任务分发到对应的宏任务队列中。</span><br><span class="line">3.遇到setImmediate，是一个宏任务分发器，将任务分发到对应的任务队列。setImmediate的任务队列会在setTimeout队列的后面执行。</span><br><span class="line">4.遇到Promise，Promise的then方法会将任务分发到对应的微任务队列中，但是它构造函数中的方法会直接执行。</span><br><span class="line">  promise1打印，resolve入栈，then进入微任务队列，promise2打印。</span><br><span class="line">5.global1打印，script(整体代码)宏任务结束，执行所有微任务队列。当前微任务队列有then,打印then1。</span><br><span class="line">6.循环结束，进行下次循环。执行setTimeout,打印timeout1。当前微任务队列为空。执行下一次循环。</span><br><span class="line">7.执行setImmediate，打印immediate1。</span><br><span class="line">8.执行遇到nextTick，process.nextTick是一个微任务分发器，它会将任务分发到对应的微任务队列中去。</span><br><span class="line">9.执行遇到Promise。Promise的then方法会将任务分发到对应的微任务队列中，但是它构造函数中的方法会直接执行。</span><br><span class="line">  所以打印immediate1_promise。</span><br><span class="line">10.当前宏任务执行完毕，再执行所有微任务nextTick和Promise。打印immediate1_nextTick，打印immediate1_then。</span><br><span class="line">全部任务执行完毕，global出栈。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">    console.log(&quot;async1 start&quot;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&quot;async1 end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">    console.log(&quot;async2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;script start&quot;);</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&quot;setTimeout&quot;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">async1();</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&quot;promise1&quot;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&quot;promise2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;script end&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行结果如下：</span><br><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解析</span><br><span class="line">1.从上往下依次执行，script(整体代码)宏任务进入，全局global入栈。</span><br><span class="line">2.遇到console.log(&quot;script start&quot;);打印script start。</span><br><span class="line">3.遇到setTimeout，进入宏观任务的timeout队列。</span><br><span class="line">4.执行async1，先直接打印async1 start，遇到await，执行async2，打印async2。</span><br><span class="line">5.await会中断async函数，继续往下执行其他的同步代码。</span><br><span class="line">6.遇到Promise，先执行回调函数，打印promise1，then方法进入微任务的then队列。</span><br><span class="line">7.遇到console.log(&quot;script end&quot;);打印script end。</span><br><span class="line">8.代码执行完毕，回去执行async剩下的代码，打印async1 end。</span><br><span class="line">9.执行微任务队列，打印promise2。</span><br><span class="line">10.执行宏任务队列，打印setTimeout。</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.jianshu.com/p/12b9f73c5a4f" target="_blank" rel="noopener"><strong>深入核心，详解事件循环机制</strong></a></p>
<h2 id="为什么要分宏任务和微任务"><a href="#为什么要分宏任务和微任务" class="headerlink" title="为什么要分宏任务和微任务"></a>为什么要分宏任务和微任务</h2><p>事件循环中的任务分宏任务和微任务，是为了给高优先级任务一个插队的机会，微任务比宏任务有更高的优先级。</p>
]]></content>
      <categories>
        <category>Web</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + GitHub 创建个人博客</title>
    <url>/2019/01/12/Hexo%20+%20GitHub%20%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2020/06/03/15/20/landscape-5255326_960_720.jpg" alt=""></p>
<a id="more"></a>

<h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><p>Hexo是一个快速，简单和强大的博客框架，它支持Markdown等多种方式编写博客；Github Pages是用户编写的、托管在github上的静态网页，在github上新建仓库名为<strong>用户名.github.io</strong>的仓库，进行一系列的配置，我们就可以通过用户名.github.io访问你的博客。</p>
<p>搭建博客需要了解以下几点：</p>
<ul>
<li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git</a></li>
<li><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a></li>
<li><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Page</a></li>
<li><a href="http://nodejs.cn/" target="_blank" rel="noopener">Node.js</a></li>
<li><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a></li>
<li><a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">Markdown</a></li>
</ul>
<p>注意：博客搭建全程使用的是windows系统。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><p>安装Node：<a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">安装教程</a><br>这里我是安装了<a href="https://www.runoob.com/w3cnote/nvm-manager-node-versions.html" target="_blank" rel="noopener"><strong>nvm</strong></a>来管理不同版本的 node 和 npm。node安装完成后，打开cmd（快捷键win+r,输入cmd回车），输入以下命令查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装Git：<a href="https://www.runoob.com/git/git-install-setup.html" target="_blank" rel="noopener">安装教程</a><br>安装完成后做的第一件事情就是设置用户名称和邮件地址，每一个Git的提交将这些信息写入，不可更改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot; </span><br><span class="line">git config --global user.email &quot;username@example.com&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>GitHub配置<br>git是一个版本控制的工具，而github有点类似于远程仓库，用于存放用git管理的各种项目。那么为了能够在本地使用git管理github上的项目，首先需要去<a href="https://github.com/" target="_blank" rel="noopener"><strong>GitHub官网</strong></a>注册一个账号，然后配置SSH key。<br>（1）打开cmd，检测电脑上是否有SSH keys；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh 或 cd .ssh (当前路径在c盘)</span><br><span class="line">如果提示：No such file or directory 说明你是第一次使用git。</span><br></pre></td></tr></table></figure>
<p>（2）如果没有SSH key，则生成新的SSH key。如果有则直接进入第三步；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</span><br><span class="line"> 出现结果：</span><br><span class="line"> Generating public&#x2F;private rsa key pair.</span><br><span class="line"> Enter file in which to save the key (&#x2F;Users&#x2F;your_user_directory&#x2F;.ssh&#x2F;id_rsa):&lt;回车就好&gt;</span><br><span class="line"></span><br><span class="line"> Enter后会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话则表示你提交项目时则不用输入密码。</span><br><span class="line"> 成功后的信息里面会有.ssh文件的路径</span><br></pre></td></tr></table></figure>
<p>（3）添加SSH Key到GitHub。<br>在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。<br>1.根据上面生成的密钥路径去打开.ssh\id_rsa.pub文件。(本地密匙文件)；<br>2.登陆你的github账户,点击右上角的 Account Settings → SSH Public keys → add another public keys；<br>3.把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了。<br><strong>注意</strong>：当你换一台电脑操作你的博客的话，这里的SSH key需要重新配置。</p>
</li>
<li><p>安装Hexo：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener"><strong>Hexo官网</strong></a><br>安装Hexo之前要确保已经安装了Git和Node。</p>
<p><strong>踩坑1</strong>：Hexo安装完成之后会自动配置环境变量，如果没有说明安装过程中出了差错。</p>
<p><strong>踩坑2</strong>：如果安装好了之后cmd无法执行hexo指令，报错无法加载，系统禁止运行脚本，就需要打开电脑设置 → 更新和安全 → 针对开发者 → 找到更改执行策略，以允许本地powershell脚本在未签名的情况下运行……勾选并应用就可以了。</p>
<ul>
<li>打开cmd全局安装hexo-cli：npm install -g hexo-cli;</li>
<li>安装完Hexo后，在你喜欢的文件夹（如D:\myBlog）内打开git bash，执行 hexo init 下载所需文件；</li>
<li>执行npm install 安装依赖；</li>
<li>执行以下两个命令之后，本地的Hexo博客就准备好了，然后在浏览器输入localhost:4000查看。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹</span><br><span class="line">hexo server  启动本地web服务，用于博客的预览</span><br></pre></td></tr></table></figure>
这个blog只是本地的，之后还要部署到GitHub上。<br><strong>注意</strong>：如果4000的端口号被占用，有两种解决方法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种：使用其他端口号打开博客</span><br><span class="line">hexo server -p 4001 使用4001端口号打开博客</span><br><span class="line">第二种：关闭4000端口的占用</span><br><span class="line">netstat -ano|findstr 4000      查看4000端口号被哪些进程占用</span><br><span class="line">taskkill &#x2F;f &#x2F;t &#x2F;im （进程号）   关闭占用4000端口号的进程</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><p>在上面我们已经成功地搭建了一个本地Hexo博客。现在，需要使用GitHub搭建一个别人能够访问的Hexo博客。</p>
<ol>
<li>在Github创建仓库,仓库名为username.github.io (username是你的账户名)；</li>
<li>在本地博客源文件夹中配置仓库地址：<br> 源文件夹中有一个站点配置文件_config.yml，找到deploy并编辑它为下列所示： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: git@github.com:username&#x2F;username.github.io.git  对应仓库的SSH地址（可以在GitHub对应的仓库中复制）  </span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>
 为了能够使Hexo部署到GitHub上，需要安装一个插件： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
 然后，执行下列指令即可完成部署： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post &lt;title&gt;       新建一篇文章</span><br><span class="line">hexo new draft &lt;title&gt;      新建一篇草稿</span><br><span class="line">hexo server --draft         运行浏览博客（包括草稿）</span><br><span class="line">hexo publish post &lt;title&gt;   将草稿移动到_post文件夹下</span><br><span class="line">hexo new page &lt;title&gt;       新建文件夹</span><br><span class="line">hexo generate               生成静态文件</span><br><span class="line">hexo deploy                 发布</span><br><span class="line">hexo server                 启动服务器：-p重设端口，-s只是用静态文件</span><br><span class="line">hexo clean                  清除缓存文件</span><br></pre></td></tr></table></figure>

<h1 id="nextT主题个性化设置"><a href="#nextT主题个性化设置" class="headerlink" title="nextT主题个性化设置"></a>nextT主题个性化设置</h1><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">nextT初始化配置</a>，这里我选用的是V7.8.0版本，并且主题命名为nextT，以下内容如果涉及到目录部分需要根据自己定义的主题名进行修改。</p>
<h2 id="DaoVoice在线联系功能"><a href="#DaoVoice在线联系功能" class="headerlink" title="DaoVoice在线联系功能"></a>DaoVoice在线联系功能</h2><p><img src="https://i.loli.net/2020/05/15/6alKCh2sgQq37EO.png" alt="DaoVoice.png"></p>
<ol>
<li>先注册<a href="http://dashboard.daovoice.io/get-started?invite_code=4b921942" target="_blank" rel="noopener">DaoVoice</a> 账号，邀请码：4b921942；</li>
<li>进入DaoVoice→应用设置→安装到网站→获取APPID；</li>
<li>打开主题配置文件，添加如下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Online contact </span><br><span class="line">daovoice: true</span><br><span class="line">daovoice_app_id: 这里填你的刚才获得的 app_id</span><br></pre></td></tr></table></figure></li>
<li>打开/themes/next/layout/_partials/head.swig,写下如下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.daovoice %&#125;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]&#x3D;r;i[r]&#x3D;i[r]||function()&#123;(i[r].q&#x3D;i[r].q||[]).push(arguments)&#125;,i[r].l&#x3D;1*new Date();a&#x3D;s.createElement(o),m&#x3D;s.getElementsByTagName(o)[0];a.async&#x3D;1;a.src&#x3D;g;a.charset&#x3D;&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&#39;https:&#39; &#x3D;&#x3D; document.location.protocol ? &#39;https:&#39; : &#39;http:&#39;) + &quot;&#x2F;&#x2F;widget.daovoice.io&#x2F;widget&#x2F;0f81ff2f.js&quot;,&quot;daovoice&quot;)</span><br><span class="line">  daovoice(&#39;init&#39;, &#123;</span><br><span class="line">      app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">  daovoice(&#39;update&#39;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
<li>重新打包部署，启动服务后就可以看到效果了；</li>
<li>DaoVoice→应用设置→聊天设置，这里可以设置聊天窗口样式；</li>
<li>DaoVoice右上角管理员点击绑定微信号，这样就可以用微信接受消息了。</li>
</ol>
<h2 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h2><p><img src="https://i.loli.net/2020/05/14/A8FIEcwK5iNxXtp.png" alt="topping.png"></p>
<ol>
<li>安装插件：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure></li>
<li>在需要置顶的博文的Front-matter中加上top: true</li>
<li>要想让博文加上置顶标志，则需要进入theme/next/layout/＿macro/post.swig文件，找到 class=”post-meta”的div.添加如下字段：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125; </span><br><span class="line">    &lt;i class&#x3D;&quot;fa fa-thumbtack&quot;&gt;&lt;&#x2F;i&gt;&lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt; &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
<li>重启查看效果。</li>
</ol>
<h2 id="自定义404页面"><a href="#自定义404页面" class="headerlink" title="自定义404页面"></a>自定义404页面</h2><p><img src="https://i.loli.net/2020/05/13/tSVg8DwGCHBrmxs.png" alt="404"><br>通常，只需在所用主题的source文件夹下新建一个404.html文件，再生成部署到云端，即可生成博客404页面。但这种方法生成的页面是孤立的，下面介绍一种生成匹配主题的404页面的方法。</p>
<ol>
<li>启动 Git Bash，进入博客所在文件夹，输入 hexo new page 404 ；</li>
<li>打开刚新建的页面文件，默认在博客文件夹根目录下 /source/404/index.md；</li>
<li>在顶部插入一行，写上permalink: /404，这表示指定该页固定链接为 http://“主页”/404.html ；</li>
<li>在/source/404/index.md该文件里面编写自己想要的页面内容即可。</li>
</ol>
<h2 id="添加评论功能——来必力"><a href="#添加评论功能——来必力" class="headerlink" title="添加评论功能——来必力"></a>添加评论功能——来必力</h2><p><img src="https://i.loli.net/2020/05/15/ut59nWV8hAoGT7U.png" alt="livere.png"><br>我觉得使用valine比较好，但是valine从19年开始就需要用姓名和身份证号进行实名认证，我觉得太麻烦了，就使用了来必力。</p>
<ol>
<li>去<a href="https://livere.com/login_form" target="_blank" rel="noopener">来必力官网</a>注册账号；</li>
<li>点击上方的安装，选择免费的city版本，点击现在安装→申请获取代码→在出现的界面里面复制data_uid；</li>
<li>在主题配置文件里面修改 livere_uid 配置。</li>
</ol>
<h2 id="图片放大功能"><a href="#图片放大功能" class="headerlink" title="图片放大功能"></a>图片放大功能</h2><ol>
<li>安装 fancybox 插件，在站点的根目录下执行以下命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-fancybox3 themes&#x2F;nextT&#x2F;source&#x2F;lib&#x2F;fancybox</span><br></pre></td></tr></table></figure></li>
<li>在主题配置文件修改如下配置：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images.</span><br><span class="line"># For more information: https:&#x2F;&#x2F;fancyapps.com&#x2F;fancybox</span><br><span class="line">fancybox: true</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h2><p><img src="https://i.loli.net/2020/05/13/blAkD2fuNHZjd7W.png" alt="localSearch.png"></p>
<ol>
<li>安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li>
<li>编辑站点配置文件，启用本地搜索功能：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="添加文章字数统计和阅读时长"><a href="#添加文章字数统计和阅读时长" class="headerlink" title="添加文章字数统计和阅读时长"></a>添加文章字数统计和阅读时长</h2><p><img src="https://i.loli.net/2020/05/13/rRDTF5cbMaPIV6y.png" alt="countTime.png"></p>
<ol>
<li>安装 hexo-symbols-count-time，在站点的根目录下执行以下命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure></li>
<li>在站点配置文件添加如下配置：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 字数统计和阅读时长</span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true                # 文章字数统计</span><br><span class="line">  time: true                   # 文章阅读时长</span><br><span class="line">  total_symbols: true          # 站点总字数统计</span><br><span class="line">  total_time: true             # 站点总阅读时长</span><br><span class="line">  exclude_codeblock: false     # 排除代码字数统计</span><br></pre></td></tr></table></figure></li>
<li>在主题配置文件修改如下配置：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: false        # 是否另起一行（true的话不和发表时间等同一行）</span><br><span class="line">  item_text_post: true        # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span><br><span class="line">  item_text_total: true      # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span><br><span class="line">  awl: 4                      # Average Word Length</span><br><span class="line">  wpm: 275                    # Words Per Minute（每分钟阅读词数）</span><br><span class="line">  suffix: mins</span><br></pre></td></tr></table></figure></li>
<li>如果页面显示的是NAN，进行如下操作：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="添加背景粒子动画特效canvas-nest"><a href="#添加背景粒子动画特效canvas-nest" class="headerlink" title="添加背景粒子动画特效canvas-nest"></a>添加背景粒子动画特效canvas-nest</h2><p><img src="https://i.loli.net/2020/05/14/WHBL3CxJvIRpGl1.png" alt="canvas-nest.png"></p>
<ol>
<li>安装 canvas-nest，在站点的根目录下执行以下命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest themes&#x2F;nextT&#x2F;source&#x2F;lib&#x2F;canvas-nest</span><br></pre></td></tr></table></figure></li>
<li>在主题配置文件添加如下配置：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Canvas-nest 背景动画特效：粒子背景</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest</span><br><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true</span><br><span class="line">  color: 34,34,34</span><br><span class="line">  opacity: 0.5</span><br><span class="line">  z-index: -1</span><br><span class="line">  count: 99</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="添加版本声明"><a href="#添加版本声明" class="headerlink" title="添加版本声明"></a>添加版本声明</h2><p><img src="https://i.loli.net/2020/05/14/xWtHMyOr4R1cFD2.png" alt="creative-commons.png"></p>
<ol>
<li>在主题配置文件修改如下配置：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: false</span><br><span class="line">  post: true</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure></li>
<li>如果本文链接是yoursite.com，需要去站点配置文件将URL修改成你的网站地址，然后重新部署运行就可以了。</li>
</ol>
<h2 id="在博客底部添加访问量-卜算子统计"><a href="#在博客底部添加访问量-卜算子统计" class="headerlink" title="在博客底部添加访问量-卜算子统计"></a>在博客底部添加访问量-卜算子统计</h2><p><img src="https://i.loli.net/2020/05/14/RpiGgUFPSOcmbVu.png" alt="busuanzi_count.png"><br>在主题配置文件修改如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: false</span><br><span class="line">  post_views_icon: fa fa-eye</span><br></pre></td></tr></table></figure>

<h2 id="在文章底部添加结束标记"><a href="#在文章底部添加结束标记" class="headerlink" title="在文章底部添加结束标记"></a>在文章底部添加结束标记</h2><p><img src="https://i.loli.net/2020/05/14/mCOSTLjGN5DlPYx.png" alt="endFlag.png"></p>
<ol>
<li>在路径 \themes\next\layout\ _macro 中新建 passage-end-tag.swig 文件,并添加以下内容：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style&#x3D;&quot;text-align:center;color: #666;font-size:14px;&quot;&gt;-------------本文结束　&lt;i class&#x3D;&quot;fa fa-hourglass-end&quot; style&#x3D;&quot;color:rgb(90,85,85)&quot;&gt;&lt;&#x2F;i&gt;　感谢阅读-------------&lt;&#x2F;div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
fa 图标可以去 <a href="http://www.fontawesome.com.cn/faicons/" target="_blank" rel="noopener">Font Awesome 图标</a> 选取一个修改，我这里是一个沙漏。</li>
<li>打开 \themes\next\layout_macro\post.swig 文件， 搜索 END POST BODY，添加如下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if not is_index %&#125;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">    	&#123;% include &#39;passage-end-tag.swig&#39; %&#125;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
<li>打开主题配置文件，在最后加上以下内容：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 文章末尾添加&quot;本文结束&quot;标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure></li>
<li>需要重启才可以看到效果</li>
</ol>
<h2 id="修改底部标签图标"><a href="#修改底部标签图标" class="headerlink" title="修改底部标签图标"></a>修改底部标签图标</h2><p><img src="https://i.loli.net/2020/05/14/BsSTj8WGM6JbynX.png" alt="bottomLabel.png"><br>打开主题配置文件修改内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Use icon instead of the symbol # to indicate the tag at the bottom of the post   底部标签替换</span><br><span class="line">tag_icon: true</span><br></pre></td></tr></table></figure>

<h1 id="写文章注意点"><a href="#写文章注意点" class="headerlink" title="写文章注意点"></a>写文章注意点</h1><h2 id="对-md文章进行分类"><a href="#对-md文章进行分类" class="headerlink" title="对.md文章进行分类"></a>对.md文章进行分类</h2><ul>
<li>起因<br>  在默认配置下，我们使用<code>hexo new post [title]</code>会在source/_post目录下生成对应的Markdown文件，而使用<code>hexo g</code>生成的HTML文件路径是:year/:month/:day/:title.html。当我们写的博客越来越多的时候，会发现，所有文章都是在source/_post/下，查找起来会不大方便，而希望对它进行一个分类，但是在生成的文章链接上保持不变。</li>
<li>解决方法<br>  可以根据年月日来归档分类，但是这样分类太细，一个月也写不了多少文章，所以我是按年份归档的。<ol>
<li>在站点配置文件_config.yml中修改如下配置： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_post_name: :year&#x2F;:title</span><br></pre></td></tr></table></figure></li>
<li>修改scaffolds/post.md文章模版，增加permalink，内容修改如下： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">permalink: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="博客引入图片"><a href="#博客引入图片" class="headerlink" title="博客引入图片"></a>博客引入图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一：Markdown语法，不可以改变图片大小</span><br><span class="line">![图片名称](图片地址)</span><br><span class="line">方法二：使用img标签，可以改变图片的大小</span><br><span class="line">&lt;img src&#x3D;&quot;图片地址&quot; width&#x3D;&quot;50%&quot; height&#x3D;&quot;50%&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>对于文章中要引入的图片，可以使用本地图片和网络图片，但是我个人觉得用本地图片不太方便，因为我对文章按照年份进行了归档，使用本地图片会出现找不到图片的问题，所以我都是使用图床，将本地图片上传得到链接使用。我使用的图床是<a href="https://sm.ms/" target="_blank" rel="noopener"><strong>sm.ms</strong></a>。</p>
<h1 id="可视化管理博客（hexo-admin）"><a href="#可视化管理博客（hexo-admin）" class="headerlink" title="可视化管理博客（hexo-admin）"></a>可视化管理博客（hexo-admin）</h1><p>出于管理博客的便利，可以安装hexo-admin插件来进行后台管理博客，可以直接在线编辑博文。他的作用就是在本地运行hexo使用hexo-admin编写文章。<br>1.安装使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-admin 安装</span><br><span class="line">hexo server -d 启动服务器</span><br><span class="line">打开 localhost:4000&#x2F;admin&#x2F; 就可在线编辑博文</span><br></pre></td></tr></table></figure>
<p>2.密码保护 登录hexo-admin<br>在 localhost:4000/admin/ 打开setting选项，点击Setup authentification here输入用户名，密码，密钥，下面会自动生成配置文件，复制加在hexo根目录下的_config.yml中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin:</span><br><span class="line">  username: myfavoritename</span><br><span class="line">  password_hash: be121740bf988b2225a313fa1f107ca1</span><br><span class="line">  secret: a secret something</span><br><span class="line">  </span><br><span class="line">  提示：密码栏最好是字符串，防止报错，亲试。</span><br></pre></td></tr></table></figure>
<p>3.发布文章 也可在deploy配置<br>在博客根目录下新建个目录admin_script，然后在目录中新建一个脚本hexo-g.sh，在脚本写上你的发布命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>然后在_config.yml中的admin下添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin:</span><br><span class="line">  username: myfavoritename</span><br><span class="line">  password_hash: be121740bf988b2225a313fa1f107ca1</span><br><span class="line">  secret: a secret something</span><br><span class="line">  deployCommand: .&#x2F;admin_script&#x2F;hexo-d.sh</span><br></pre></td></tr></table></figure>
<p>最后就是在后台的deploy点发布就行了，不过我一般不这样做，都是直接敲命令发布博客。<br>4.Hexo Admin插入图片问题<br>由于hexo admin复制粘贴图片的时候会多两个斜杠，最简单的方式去掉就行，如果嫌麻烦可以改源码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](&#x2F;&#x2F;images&#x2F;post.png&#x2F;) 粘贴结果</span><br><span class="line"></span><br><span class="line">![](&#x2F;images&#x2F;post.png) 去除斜杠图片即可出现</span><br></pre></td></tr></table></figure>

<h1 id="Gitee托管博客代码"><a href="#Gitee托管博客代码" class="headerlink" title="Gitee托管博客代码"></a>Gitee托管博客代码</h1><p><a href="https://gitee.com/" target="_blank" rel="noopener"><strong>Gitee</strong></a>是基于Git的代码托管平台，和GitHub用法相似，先去官网GitHub授权然后注册账号登录，配置本机SSH key，新建一个仓库专门用来存储博客的代码。<br>仓库建好后将本地代码提交上去，首次提交执行以下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#39;init&#39;</span><br><span class="line">git remote add origin git@gitee.com:(仓库名)</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h1 id="GitHub博客打开网页速度慢问题解决"><a href="#GitHub博客打开网页速度慢问题解决" class="headerlink" title="GitHub博客打开网页速度慢问题解决"></a>GitHub博客打开网页速度慢问题解决</h1><p>Hexo + GitHub 访问速度很慢，因为 GitHub 是外网。<br>解决方法：使用码云(Gitee.com)，将 GitHub Pages 项目部署到码云的 Pages。<br>过程：</p>
<ul>
<li>在 Gitee 里新建仓库；</li>
<li>点击导入已有仓库；</li>
<li>输入GitHub仓库地址导入；</li>
<li>将仓库名称改成 gitee 的<strong>用户名</strong>，记住这里只需要用户名，不需要其他东西；</li>
<li>选择公开，点击创建；</li>
<li>服务→选择Gitee Pages→点击启动（如果按钮置灰则需要绑定手机号）→出现的网站地址就是你的博客地址了。</li>
</ul>
<p><img src="https://static.oschina.net/uploads/img/201806/26175333_xxzm.png" alt=""><br>缺点：每次部署代码的时候，企业版的Gitee可以自动更新，个人版的Gitee必须手动点击更新。<br>参考链接：<a href="http://git.mydoc.io/?t=154714" target="_blank" rel="noopener">码云（Gitee.com）帮助文档</a>；</p>
]]></content>
      <categories>
        <category>Other</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Element Plus</title>
    <url>/2022/05/21/Element%20Plus/</url>
    <content><![CDATA[<style>
  .border{
    padding: 10px;
    border: 1px solid #ebebeb;
    border-radius: 4px;
    margin-bottom: 20px;
  }
  .border .title{
    font-size: 16px;
    font-weight: 500;
  }
  .border .content-solve{
    text-indent: 20px;
  }
</style>

<p><img src="https://cdn.pixabay.com/photo/2023/02/09/16/36/bridge-7779222_1280.jpg" alt=""></p>
<a id="more"></a>
<p><a href="https://element-plus.gitee.io/zh-CN/" target="_blank" rel="noopener"><strong>Element Plus</strong></a>，基于 Vue 3，面向设计师和开发者的组件库。这里记录了工作中遇到的常用操作和踩坑。</p>
<h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><h3 id="form表单无法输入"><a href="#form表单无法输入" class="headerlink" title="form表单无法输入"></a>form表单无法输入</h3><div class="border">
    <div class="title">form表单输入框能聚焦但是无法输入。</div>
    <div class="content-solve">解决：ref 和 mode 定义为不同的变量。</div>
</div>

<h3 id="dialog嵌套form回显数据问题"><a href="#dialog嵌套form回显数据问题" class="headerlink" title="dialog嵌套form回显数据问题"></a>dialog嵌套form回显数据问题</h3><div class="border">
    <div class="title">el-dialog里嵌套form表单，打开dialog后表单数组循环回显上一次编辑时的数据。</div>
    <div class="content-solve">原因：第一次打开dialog给表单的model赋值，这个时候model的初始值就是赋的值，第二次打开dialog使用resetFields的时候，会将model重置到初始值，也就是赋的值。详情请参考：<a href="https://github.com/ElemeFE/element/issues/1871" target="_blank" rel="noopener">form resetFields并没有清空表单 #1871</a></div>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打开dialog</span><br><span class="line">const open&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F; 重置数据</span><br><span class="line">    reset()</span><br><span class="line">    show.value &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 解决方法1：先resetFields，后重置数据</span><br><span class="line">const reset &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    proxy.$refs[&#39;formRef&#39;].resetFields();</span><br><span class="line">    for (let item in form.value) &#123;</span><br><span class="line">        form.value[item] &#x3D; undefined;</span><br><span class="line">    &#125;</span><br><span class="line">    form.value.spuList &#x3D; [&#123;</span><br><span class="line">        spuId: undefined,</span><br><span class="line">        spuName: undefined,</span><br><span class="line">        settlePrice: undefined,</span><br><span class="line">        retailPrice: undefined,</span><br><span class="line">        saleNum: undefined,</span><br><span class="line">        totalAmount: undefined,</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解决方法2： 等dialog初始化mounted之后再给model赋值，也就是使用nextTick</span><br><span class="line">const reset &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    proxy.$nextTick(()&#x3D;&gt;&#123;</span><br><span class="line">        for (let item in form.value) &#123;</span><br><span class="line">            form.value[item] &#x3D; undefined;</span><br><span class="line">        &#125;</span><br><span class="line">        form.value.spuList &#x3D; [&#123;</span><br><span class="line">            spuId: undefined,</span><br><span class="line">            spuName: undefined,</span><br><span class="line">            settlePrice: undefined,</span><br><span class="line">            retailPrice: undefined,</span><br><span class="line">            saleNum: undefined,</span><br><span class="line">            totalAmount: undefined,</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">    proxy.$refs[&#39;formRef&#39;].resetFields();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UI</category>
        <category>Element</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>Element</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3 - monorepo</title>
    <url>/2022/03/28/Vue3%20-%20monorepo/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2022/09/07/17/26/vintage-pocket-watch-7439233_1280.jpg" alt=""></p>
<a id="more"></a>

<h1 id="Vue2-和-Vue3-的区别"><a href="#Vue2-和-Vue3-的区别" class="headerlink" title="Vue2 和 Vue3 的区别"></a>Vue2 和 Vue3 的区别</h1><ul>
<li>vue2 对 typescript 不友好。</li>
<li>vue2是选项API - options，逻辑过于分散，Vue3采用组合式API - setup，代码更简洁。</li>
<li>vue2大量的API挂载到vue对象的原型上，难以实现treeShaking，vue3做了性能上的优化，没有用到的方法，打包的时候将不会对其进行打包。</li>
<li>vue3对虚拟dom进行了重写，对模版的编译进行了优化。</li>
</ul>
<h1 id="monorepo"><a href="#monorepo" class="headerlink" title="monorepo"></a>monorepo</h1><p>monorepo 是将多个项目代码存储到一个仓库里的代码管理模式，一个项目一个包，每个包独立发布且互不干扰（mono：单一，repo：仓库）。<br>代码复用和重构变得简单，跨组合作更方便，但是每个项目缺少了权限的控制，随着整体代码量的变多，构建的时间也会变得更长。</p>
<h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>新建vue3文件夹，使用<code>yarn init -y</code>初始化项目，出来一个对应的package.json文件，在里面加上配置项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 私有化</span><br><span class="line">    &quot;private&quot;: true,</span><br><span class="line">    &#x2F;&#x2F; 利用 workspace 特性复用 package，内部代码可以彼此相互引用；</span><br><span class="line">    &quot;workspaces&quot;:[</span><br><span class="line">        &quot;packages&#x2F;*&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建子包"><a href="#创建子包" class="headerlink" title="创建子包"></a>创建子包</h2><ul>
<li><p>vue3文件夹下新建packages文件夹，里面存放所有的包，新建reactivity-响应式原理，shared-公共方法两个包，分别在两个包下面执行<code>yarn init -y</code>进行初始化操作，各出现一个package.json文件，在里面修改name配置项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 在原有的名称之前加上@vue&#x2F;，包之间的相互引用就是根据这个name引用的</span><br><span class="line">    &quot;name&quot;:&quot;@vue&#x2F;reactivity&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在每个包下面新建src文件夹，src下新建index.ts文件，之后monorepo打包，会把所有的东西放在这个index.ts文件里面</p>
</li>
<li><p>既然使用到了ts,那么就需要安装ts，由于每个包都需要用到ts，所以在根目录下执行命令<code>yarn add typescript -D -W</code>安装ts，注意：这个项目由于使用了workspace，所以安装插件需要加上-W。</p>
</li>
<li><p>安装完ts后，需要对ts进行配置，可以使用tsc自动生成一个ts配置文件tsconfig.json。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在vue3文件夹下执行此命令</span><br><span class="line">npx tsc --init</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="安装rollup打包相关的依赖"><a href="#安装rollup打包相关的依赖" class="headerlink" title="安装rollup打包相关的依赖"></a>安装rollup打包相关的依赖</h2><p>在根目录vue3下面执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; rollup-plugin-typescript2 解析ts</span><br><span class="line">&#x2F;&#x2F; @rollup&#x2F;plugin-node-resolve 处理解析第三方插件</span><br><span class="line">&#x2F;&#x2F; @rollup&#x2F;plugin-json 解析json</span><br><span class="line">&#x2F;&#x2F; execa 开启子进程，用来将packages下面所有的包一起进行打包</span><br><span class="line">yarn add rollup rollup-plugin-typescript2 @rollup&#x2F;plugin-node-resolve @rollup&#x2F;plugin-json execa -D -W</span><br></pre></td></tr></table></figure>

<h2 id="配置rollup打包配置文件"><a href="#配置rollup打包配置文件" class="headerlink" title="配置rollup打包配置文件"></a>配置rollup打包配置文件</h2><h3 id="配置build-js"><a href="#配置build-js" class="headerlink" title="配置build.js"></a>配置build.js</h3><ul>
<li><p>创建打包脚本命令<br>在根目录的package.json里面配置打包命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;build&quot;: &quot;node scripts&#x2F;build.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建scripts文件夹，新建build.js文件，里面配置打包的具体操作。<br>在终端执行npm run build，相当于通过node 执行build.js文件。</p>
</li>
<li><p>配置包的打包格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; reactivity 下的 package.json 配置自定义打包项</span><br><span class="line">&#123;</span><br><span class="line">    &quot;buildOptions&quot;:&#123;</span><br><span class="line">        &quot;name&quot;:&quot;VueReactivity&quot;,</span><br><span class="line">        &quot;formats&quot;:[</span><br><span class="line">            &quot;esm-bundler&quot;,  &#x2F;&#x2F; 将es6变成es5，处理js</span><br><span class="line">            &quot;cjs&quot;,          &#x2F;&#x2F; 处理common.js，node</span><br><span class="line">            &quot;global&quot;        &#x2F;&#x2F; 处理全局的方法，比如window</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; shared 下的 package.json 配置自定义打包项</span><br><span class="line">&#123;</span><br><span class="line">    &quot;buildOptions&quot;:&#123;</span><br><span class="line">        &quot;name&quot;:&quot;VueShared&quot;,</span><br><span class="line">        &quot;formats&quot;:[</span><br><span class="line">            &quot;esm-bundler&quot;,</span><br><span class="line">            &quot;cjs&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进行打包<br>通过monorepo打包，对packages下面的每个文件进行打包，在build.js配置打包的具体操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 读取需要打包的文件目录</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;)</span><br><span class="line"></span><br><span class="line">const dirs &#x3D; fs.readdirSync(&#39;packages&#39;).filter(p&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F; 打包只针对packages下面的文件夹，如果是其他的单文件，将不进行打包</span><br><span class="line">    if(!fs.statSync(&#96;packages&#x2F;$&#123;p&#125;&#96;).isDirectory())&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(dirs) &#x2F;&#x2F; [&#39;reactivity&#39;,&#39;shared&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 并行打包 使用promise对所有的包进行打包</span><br><span class="line">import execa from &#39;execa&#39;</span><br><span class="line">&#x2F;&#x2F; target - 要打包的包名称</span><br><span class="line">async function build(target)&#123;</span><br><span class="line">    console.log(target)</span><br><span class="line">    &#x2F;&#x2F; execa开启子进程，所有的包一起打包，eseca返回promise</span><br><span class="line">    &#x2F;&#x2F; rollup-打包方式 -c-执行rollup配置 --env-环境变量  stdio: &#39;inherit&#39;-子进程的输出在父包中可以输出看到</span><br><span class="line">    await return execa(&#39;rollup&#39;,[&#39;-c&#39;,&#39;--environment&#39;,&#96;TARGET:$&#123;target&#125;&#96;],&#123;stdio: &#39;inherit&#39;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; dirs-需要打包的包的文件名数组 build-单个包打包的方法</span><br><span class="line">function runParallel(dirs,build)&#123;</span><br><span class="line">    let result &#x3D; []</span><br><span class="line">    for(let item of dirs)&#123;</span><br><span class="line">        result.push(build(item))</span><br><span class="line">    &#125;</span><br><span class="line">    return Promise.all(result)</span><br><span class="line">&#125;</span><br><span class="line">runParallel(dirs,build).then(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;打包成功&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>打印target时能打印出来的，但是最后会报错，因为rollup配置还没有添加</p>
</li>
</ul>
<h3 id="配置rollup-config-js"><a href="#配置rollup-config-js" class="headerlink" title="配置rollup.config.js"></a>配置rollup.config.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 引入相关依赖</span><br><span class="line">import ts from &quot;rollup-plugin-typescript2&quot; &#x2F;&#x2F; 解析ts </span><br><span class="line">import json from &#39;@rollup&#x2F;plugin-json&#39;</span><br><span class="line">import resolvePlugin from &#39;@rollup&#x2F;plugin-node-resolve&#39;</span><br><span class="line">import path from &#39;path&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 获取文件路径</span><br><span class="line">&#x2F;&#x2F; 2.1 packages文件夹路径</span><br><span class="line">const packagesDir &#x3D; path.resolve(__dirname, &#39;packages&#39;)</span><br><span class="line">console.log(packagesDir) &#x2F;&#x2F; 打印出来的是packages文件夹在系统中的文件路径</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.2 packages下各个包的文件路径</span><br><span class="line">const packageDir &#x3D; path.resolve(packagesDir, process.env.TARGET)</span><br><span class="line">console.log(packageDir) &#x2F;&#x2F; 打印出来的是packages下的各个包的文件路径</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.3 获取各个包下面的打包输出配置 buildOptions</span><br><span class="line">const resolve &#x3D; p &#x3D;&gt; path.resolve(packageDir, p)</span><br><span class="line">const pkg &#x3D; require(resolve(&#96;package.json&#96;))</span><br><span class="line">const packageOptions &#x3D; pkg.buildOptions || &#123;&#125;</span><br><span class="line">const name &#x3D; path.basename(packageDir) &#x2F;&#x2F; 包名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 创建一个打包输出配置项输出文件的映射表</span><br><span class="line">const outputConfigs &#x3D; &#123;</span><br><span class="line">  &#39;esm-bundler&#39;: &#123;</span><br><span class="line">    file: resolve(&#96;dist&#x2F;$&#123;name&#125;.esm-bundler.js&#96;), &#x2F;&#x2F; 打包输出的文件路径</span><br><span class="line">    format: &#96;es&#96;</span><br><span class="line">  &#125;,</span><br><span class="line">  cjs: &#123;</span><br><span class="line">    file: resolve(&#96;dist&#x2F;$&#123;name&#125;.cjs.js&#96;),</span><br><span class="line">    format: &#96;cjs&#96;</span><br><span class="line">  &#125;,</span><br><span class="line">  global: &#123;</span><br><span class="line">    file: resolve(&#96;dist&#x2F;$&#123;name&#125;.global.js&#96;),</span><br><span class="line">    format: &#96;iife&#96;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4. 导出一个rollup配置</span><br><span class="line">function createConfig(format,output)&#123;</span><br><span class="line">    output.name &#x3D; packageOptions.name</span><br><span class="line">    output.sourcemap &#x3D; true</span><br><span class="line">    return &#123;</span><br><span class="line">        input:path.resolve(&#39;src&#x2F;index.ts&#39;), &#x2F;&#x2F; 导入</span><br><span class="line">        output,</span><br><span class="line">        plugins:[ &#x2F;&#x2F; 插件，即上面引入的rollup需要用到的插件</span><br><span class="line">            json(),</span><br><span class="line">            ts(&#123; &#x2F;&#x2F; 解析ts</span><br><span class="line">                tsconfig:path.resolve(__dirname,&#39;tsconfig.json&#39;)</span><br><span class="line">            &#125;),</span><br><span class="line">            resolvePlugin() &#x2F;&#x2F; 解析第三方插件</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export packageOptions.formats.map(format&#x3D;&gt;&#123;</span><br><span class="line">    createConfig(format,outputConfigs)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>到这里就可以执行<code>npm run build</code>进行打包了，报错的话一般都是tsconfig.json里面的配置有问题，如module值需要改成esnext，sourcemap需要打开等等，配置成功后进行打包，各个包下面就会生成dist文件夹，下面是各种格式的打包文件。</p>
<h2 id="开发环境自动打包"><a href="#开发环境自动打包" class="headerlink" title="开发环境自动打包"></a>开发环境自动打包</h2><p>上面打包是所有的包全部并行，但是在开发过程中，如果只修改了一个包的某个文件，那么我们就需要进行自动打包，方便操作。<br>打包方法和build中的方法类似，只是去掉了并行打包，改成单包打包，并将rollup的配置<code>-c</code>换成<code>-cw</code>，这样修改代码后就会自动打包了。如果不换的话就需要手动执行命令打包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 在根目录的package.json里面添加dev命令</span><br><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;dev&quot;: &quot;node scripts&#x2F;dev.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 在script文件夹下面新增dev.js文件，内容如下</span><br><span class="line">import execa from &#39;execa&#39;</span><br><span class="line">&#x2F;&#x2F; target - 要打包的包名称</span><br><span class="line">async function build(target)&#123;</span><br><span class="line">    &#x2F;&#x2F; execa开启子进程，所有的包一起打包，eseca返回promise</span><br><span class="line">    &#x2F;&#x2F; rollup-打包方式 -c-执行rollup配置 --env-环境变量  stdio: &#39;inherit&#39;-子进程的输出在父包中可以输出看到</span><br><span class="line">    await return execa(&#39;rollup&#39;,[&#39;-cw&#39;,&#39;--environment&#39;,&#96;TARGET:$&#123;target&#125;&#96;],&#123;stdio: &#39;inherit&#39;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build(&#39;reactivity&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="包的相互引用"><a href="#包的相互引用" class="headerlink" title="包的相互引用"></a>包的相互引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在reactivity&#x2F;index.ts里面引入shared包里面的方法或者变量</span><br><span class="line">import &#123;&#125; from &#39;@vue&#x2F;shared&#39;</span><br><span class="line">&#x2F;&#x2F; 这里引入的包名就是子包初始化的时候修改的name，在node_modules里面也会有相对的链接</span><br><span class="line">&#x2F;&#x2F; 但是这里会报错：@vue&#x2F;shared找不到，这个tsconfig.json缺少配置，添加如下配置：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;baseUrl&quot;: &quot;.&quot;,</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,</span><br><span class="line">    &quot;paths&quot;: &#123;</span><br><span class="line">      &quot;@vue&#x2F;*&quot;: [&quot;packages&#x2F;*&#x2F;src&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-pnpm"><a href="#优化-pnpm" class="headerlink" title="优化-pnpm"></a>优化-pnpm</h2><p>将 yarn 替换成 pnpm，解决依赖平铺等问题，但是 pnpm 的 workspace 不是配置在 package.json 文件中，而是新建 pnpm-workspace.yaml 来定义工作空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">packages:</span><br><span class="line">  - &#39;packages&#x2F;*&#39;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
        <category>原理</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>图片懒加载</title>
    <url>/2021/09/18/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2019/09/16/06/26/fog-4479936_960_720.jpg" alt=""></p>
<a id="more"></a>

<h1 id="HTML-原生实现"><a href="#HTML-原生实现" class="headerlink" title="HTML 原生实现"></a>HTML 原生实现</h1><p>HTML 中的<code>&lt;img&gt;</code>标签支持<code>loading</code>属性，可以使用该属性设置图片是否懒加载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;URL&quot; loading&#x3D;&quot;eager|lazy&quot;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; eager 	默认，图像立即加载</span><br><span class="line">&#x2F;&#x2F; lazy  	图像延迟加载，只有鼠标滚动到该图片所在位置才会显示</span><br></pre></td></tr></table></figure>
<p>根据demo测试发现该属性有以下5种行为特性：</p>
<ol>
<li>Lazy loading加载数量与屏幕高度有关，高度越小加载数量越少，但并不是线性关系。<br>demo中垂直展示了30张图片，屏幕上只显示了4张，但是控制台第一次加载显示加载了17张，将页面屏幕显示高度变小，再刷新发现加载了13张。</li>
<li>Lazy loading加载数量与网速有关，网速越慢，加载数量越多，但并不是线性关系。<br>浏览器设置成<code>Slow 3G</code>模式，控制台显示加载29张，<code>Fast 3G</code>模式，加载20张。</li>
<li>Lazy loading加载没有缓冲，滚动即会触发新的图片资源加载。</li>
<li>Lazy loading加载在窗口resize尺寸变化时候也会触发，例如屏幕高度从小变大的时候。</li>
<li>Lazy loading加载也有可能会先加载后面的图片资源，例如页面加载时滚动高度很高的时候。</li>
</ol>
<p>在使用时，需要考虑浏览器兼容性问题，所以需要判断浏览器是否支持该属性，不支持的话需要使用 JavaScript 来实现图片的懒加载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 有三种方法判断浏览器是否支持loading属性</span><br><span class="line">var isSupportLoading &#x3D; &#39;loading&#39; in document.createElement(&#39;img&#39;);</span><br><span class="line">var isSupportLoading &#x3D; &#39;loading&#39; in new Image();</span><br><span class="line">var isSupportLoading &#x3D; &#39;loading&#39; in HTMLImageElement.prototype;</span><br></pre></td></tr></table></figure>

<h1 id="JS-实现原理"><a href="#JS-实现原理" class="headerlink" title="JS 实现原理"></a>JS 实现原理</h1><p>一张图片就是一个 img 标签，浏览器是否发起请求图片是根据 img 的 src 属性，所以实现懒加载的关键就是，在图片没有进入可视区域时，先不给 img 的 src 赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给 src 赋值。</p>
<h1 id="JS-实现步骤"><a href="#JS-实现步骤" class="headerlink" title="JS 实现步骤"></a>JS 实现步骤</h1><ol>
<li>加载loading图片</li>
<li>判断图片是否在可视区</li>
<li>替换真图片</li>
<li>优化-函数节流</li>
</ol>
<h2 id="加载loading图片"><a href="#加载loading图片" class="headerlink" title="加载loading图片"></a>加载loading图片</h2><p>将 img 的 src 传入一张表示加载中的图片路径，将真正要展示的图片路径保存在 img 的自定义属性如 data-src 上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;加载中图片路径&quot; data-src&#x3D;&quot;真正图片路径&quot; alt&#x3D;&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="判断图片是否在可视区"><a href="#判断图片是否在可视区" class="headerlink" title="判断图片是否在可视区"></a>判断图片是否在可视区</h2><p>通过 img 的 offsetTop、window 或者div 的 innerHeight 和 scrollTop 判断图片是否在可视区域内。如果<code>offsetTop &lt; scrollTop+innerHeight</code>，就表示当前图片在可视区域内。</p>
<blockquote>
<p>document.body.scrollWidth/scrollHeight 网页正文全文宽/高<br>document.body.offsetWidth/offsetHeight 网页可见区域宽/高(包含border和滚动条的宽高)<br>document.body.clientWidth/clientHeight 网页可见区域宽/高(不包含border和滚动条的宽高)<br>offsetTop 当前元素<strong>上边框外边缘</strong>到最近的已定位父级<strong>上边框内边缘</strong>的距离。如果父级都没有定位，则是到body顶部的距离<br>innerheight 显示区的高度，包括滚动条的高度<br>clientWidth = width  + 左右padding<br>clientTop = boder.top(上边框的宽度)<br>offsetWidth = width + 左右padding  + 左右border</p>
</blockquote>
<h2 id="替换真图片"><a href="#替换真图片" class="headerlink" title="替换真图片"></a>替换真图片</h2><p>如果图片已经在可视区域内，将真正图片的地址赋值给 src，替换掉加载中图片。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">img.src &#x3D; img.getAttribute(&quot;data-src&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="优化-函数节流"><a href="#优化-函数节流" class="headerlink" title="优化-函数节流"></a>优化-函数节流</h2><p>使用节流函数让滚动事件在固定的时间之后再执行，避免重复加载，浪费资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 节流函数，保证每200ms触发一次</span><br><span class="line">function throttle(event, time) &#123;</span><br><span class="line">  let pre &#x3D; 0;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if (Date.now() - pre &gt; time) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer &#x3D; null;</span><br><span class="line">      pre &#x3D; Date.now();</span><br><span class="line">      event.apply(this, args);</span><br><span class="line">    &#125; else if (!timer) &#123;</span><br><span class="line">      timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        event.apply(this, args);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var img &#x3D; document.getElementsByTagName(&quot;img&quot;);</span><br><span class="line">var n &#x3D; 0; &#x2F;&#x2F;存储图片加载到的位置，避免每次都从第一张图片开始遍历</span><br><span class="line">lazyload(); &#x2F;&#x2F;页面载入完毕加载可视区域内的图片</span><br><span class="line">&#x2F;&#x2F; 节流函数，保证每200ms触发一次</span><br><span class="line">function throttle(event, time) &#123;</span><br><span class="line">  let pre &#x3D; 0;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if (Date.now() - pre &gt; time) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer &#x3D; null;</span><br><span class="line">      pre &#x3D; Date.now();</span><br><span class="line">      event.apply(this, args);</span><br><span class="line">    &#125; else if (!timer) &#123;</span><br><span class="line">      timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        event.apply(this, args);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&#39;scroll&#39;, throttle(lazyload, 200))</span><br><span class="line">function lazyload() &#123; &#x2F;&#x2F;监听页面滚动事件</span><br><span class="line">  var seeHeight &#x3D; window.innerHeight; &#x2F;&#x2F;可见区域高度</span><br><span class="line">  var scrollTop &#x3D; document.documentElement.scrollTop || document.body.scrollTop; &#x2F;&#x2F;滚动条距离顶部高度</span><br><span class="line">  for (var i &#x3D; n; i &lt; img.length; i++) &#123;</span><br><span class="line">    console.log(img[i].offsetTop, seeHeight, scrollTop);</span><br><span class="line">    if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123;</span><br><span class="line">      if (img[i].getAttribute(&quot;src&quot;) &#x3D;&#x3D; &quot;加载中图片路径&quot;) &#123;</span><br><span class="line">        img[i].src &#x3D; img[i].getAttribute(&quot;data-src&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      n &#x3D; i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h1><p>getBoundingClientRect() – 返回元素的大小及其相对于视口的位置，常用来判断元素是否出现在可视区域内。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var divBox &#x3D; dovument.getElementById(&#39;#div-box&#39;)</span><br><span class="line">const rectDiv &#x3D; divBox.getBoundingClientRect()</span><br><span class="line">&#x2F;&#x2F; rectDiv.width 元素自身的宽度</span><br><span class="line">&#x2F;&#x2F; rectDiv.height 元素自身的高度</span><br><span class="line">&#x2F;&#x2F; rectDiv.top 元素上边到视窗上边的距离</span><br><span class="line">&#x2F;&#x2F; rectDiv.left 元素左边到视窗左边的距离</span><br><span class="line">&#x2F;&#x2F; rectDiv.right 元素右边到视窗左边的距离 (注意，这里没有写错)</span><br><span class="line">&#x2F;&#x2F; rectDiv.bottom 元素下边到视窗上边的距离 (注意，这里没有写错)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断元素是否在可视区域内</span><br><span class="line">function isInView(el,offset &#x3D; 0)&#123;</span><br><span class="line">  const rectDiv &#x3D; el.getBoundingClientRect()</span><br><span class="line"></span><br><span class="line">  const top &#x3D; rectDiv.top &gt;&#x3D; 0</span><br><span class="line"></span><br><span class="line">  const right &#x3D; rectDiv.right &lt;&#x3D; (window.innerWidth || document.element.clientWidth) + offset</span><br><span class="line"></span><br><span class="line">  const bottom &#x3D; rectDiv.bottom &lt;&#x3D; (window.innerHeight || document.element.clientHeight) + offset</span><br><span class="line"></span><br><span class="line">  const left  &#x3D; rectDiv.left &gt;&#x3D; 0</span><br><span class="line"></span><br><span class="line">  return top &amp;&amp; right &amp;&amp; bottom &amp;&amp; left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上述的lazyload可以进行如下修改</span><br><span class="line">function lazyload() &#123;</span><br><span class="line">  for (var i &#x3D; n; i &lt; img.length; i++) &#123;</span><br><span class="line">    if(isInView(img[i]))&#123;</span><br><span class="line">      if (img[i].getAttribute(&quot;src&quot;) &#x3D;&#x3D; &quot;加载中图片路径&quot;) &#123;</span><br><span class="line">        img[i].src &#x3D; img[i].getAttribute(&quot;data-src&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      n &#x3D; i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IntersectionObserver-交叉观察器"><a href="#IntersectionObserver-交叉观察器" class="headerlink" title="IntersectionObserver(交叉观察器)"></a>IntersectionObserver(交叉观察器)</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver" target="_blank" rel="noopener"><strong>IntersectionObserver</strong></a> 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法，即用来判断当前目标元素是否可见。传统实现方法就是监听 scroll 事件，但是由于scroll事件密集发生，计算量很大，容易造成性能问题。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var io &#x3D; new IntersectionObserver(callback, option);</span><br><span class="line">&#x2F;&#x2F; callback：可见性变化时的回调函数</span><br><span class="line">&#x2F;&#x2F; option：配置对象（可选）</span><br></pre></td></tr></table></figure>
<ol>
<li>callback：目标元素的可见性变化时，就会调用观察器的回调函数callback，一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。callback函数的参数（entries）是一个数组，举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。</li>
<li>option：</li>
</ol>
<ul>
<li>threshold：默认为[0]，即交叉比例（entries[i].intersectionRatio）达到0时触发回调函数。用户可以自定义这个数组。比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。</li>
<li>root、rootMargin：很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在iframe窗口里滚动）。容器内滚动也会影响目标元素的可见性。root属性指定目标元素所在的容器节点（即根元素）。rootMargin属性。后者定义根元素的margin，用来扩展或缩小rootBounds这个矩形的大小，从而影响intersectionRect交叉区域的大小。它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom 和 left 四个方向的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 开始观察</span><br><span class="line">io.observe(document.getElementById(&#39;example1&#39;));</span><br><span class="line">io.observe(document.getElementById(&#39;example2&#39;));</span><br><span class="line">&#x2F;&#x2F; 停止观察</span><br><span class="line">io.unobserve(element);</span><br><span class="line">&#x2F;&#x2F; 关闭观察器</span><br><span class="line">io.disconnect();</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>监听滚动事件实现图片懒加载的方法就可以使用交叉观察器实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var img &#x3D; document.getElementsByTagName(&quot;img&quot;);</span><br><span class="line">if (IntersectionObserver) &#123;</span><br><span class="line">  let lazyImageObserver &#x3D; new IntersectionObserver((entries, observer) &#x3D;&gt; &#123;</span><br><span class="line">    entries.forEach((entry, index) &#x3D;&gt; &#123;</span><br><span class="line">      let lazyImage &#x3D; entry.target;</span><br><span class="line">      &#x2F;&#x2F; 如果元素可见            </span><br><span class="line">      if (entry.intersectionRatio &gt; 0) &#123;</span><br><span class="line">        if (lazyImage.getAttribute(&quot;src&quot;) &#x3D;&#x3D; &quot;加载中图片路径&quot;) &#123;</span><br><span class="line">          lazyImage.src &#x3D; lazyImage.getAttribute(&quot;data-src&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        lazyImageObserver.unobserve(lazyImage)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  for (let i &#x3D; 0; i &lt; img.length; i++) &#123;</span><br><span class="line">    lazyImageObserver.observe(img[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发踩坑</title>
    <url>/2021/02/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/11/16/12/55/winter-1828779_960_720.jpg" alt=""></p>
<a id="more"></a>

<style>
  .border{
    padding: 10px;
    border: 1px solid #ebebeb;
    border-radius: 4px;
    margin-bottom: 20px;
  }
  .border .title{
    font-size: 16px;
    font-weight: 500;
  }
  .border .content-slove{
    text-indent: 20px;
  }
</style>

<h3 id="钉钉小程序，线上环境有的组件失效"><a href="#钉钉小程序，线上环境有的组件失效" class="headerlink" title="钉钉小程序，线上环境有的组件失效"></a>钉钉小程序，线上环境有的组件失效</h3><div class="border">
    <div class="title">uni-app + uView 开发钉钉小程序，线上环境有的组件失效问题。</div>
    <div class="content-slove">开发钉钉小程序，实际上和开发支付宝小程序一样，uView 必须开启 component2 模式才能支持支付宝小程序的开发，详情请查看：<a href="https://www.uviewui.com/components/feature.html" target="_blank" rel="noopener">uView 开发注意事项</a></div>
</div>

<h3 id="小程序配置安全域名无效问题"><a href="#小程序配置安全域名无效问题" class="headerlink" title="小程序配置安全域名无效问题"></a>小程序配置安全域名无效问题</h3><div class="border">
    <div class="title">小程序配置安全域名无效问题。</div>
    <div class="content-slove">在后台系统配置安全域名必须要在发布版本之前，否则接口不同，如果对安全域名进行了修改，必须要重新发布版本。</div>
</div>

<h3 id="开发工具预览问题"><a href="#开发工具预览问题" class="headerlink" title="开发工具预览问题"></a>开发工具预览问题</h3><div class="border">
    <div class="title">开发钉钉小程序，在开发工具中预览问题。</div>
    <div class="content-slove">开发工具预览功能，只能当前用户自己预览，即使其他用户已经加入开发者名单中，扫码依然预览不了。</div>
</div>

<h3 id="钉钉小程序页面禁止下拽"><a href="#钉钉小程序页面禁止下拽" class="headerlink" title="钉钉小程序页面禁止下拽"></a>钉钉小程序页面禁止下拽</h3><div class="border">
    <div class="title">钉钉小程序页面禁止下拽。</div>
    <div class="content-slove">开发完小程序之后，下拉页面发现页面会被下拽拖动，需要禁止这一操作，可以使用 "allowsBounceVertical": "NO" 来禁止下拽行为，但是该属性只只对支付宝、钉钉小程序。</div>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在page.json里面的globalStyle里面配置</span><br><span class="line">&quot;globalStyle&quot;: &#123;</span><br><span class="line">  &quot;mp-alipay&quot;:&#123;</span><br><span class="line">    &quot;allowsBounceVertical&quot;: &quot;NO&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小程序缓存问题"><a href="#小程序缓存问题" class="headerlink" title="小程序缓存问题"></a>小程序缓存问题</h3><div class="border">
    <div class="title">小程序缓存问题。</div>
    <div class="content-slove">小程序发布版本之后，再去打开小程序还是之前的样子，这个时候是热启动，这个过程只是将后台的小程序切换到前台，并不会重新加载或者启动小程序。只有小程序进入后台超过一定时间（一般5分钟）或者小程序被销毁之后，打开小程序才会冷启动，重新加载小程序。</div>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; uni-app 强制更新代码</span><br><span class="line">onLaunch: function() &#123;</span><br><span class="line">  &#x2F;&#x2F; 管理小程序更新</span><br><span class="line">  const updateManager &#x3D; uni.getUpdateManager();</span><br><span class="line">  updateManager.onCheckForUpdate(function(res) &#123;</span><br><span class="line">    if (res.hasUpdate) &#123;</span><br><span class="line">      updateManager.onUpdateReady(function(res) &#123;</span><br><span class="line">        uni.showModal(&#123;</span><br><span class="line">          title: &#39;更新提示&#39;,</span><br><span class="line">          content: &#39;新版本已经准备好，是否重启应用？&#39;,</span><br><span class="line">          showCancel: false,</span><br><span class="line">          success(res) &#123;</span><br><span class="line">            if (res.confirm) &#123;</span><br><span class="line">              updateManager.applyUpdate();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="uView-折叠面板展开内容显示不全"><a href="#uView-折叠面板展开内容显示不全" class="headerlink" title="uView 折叠面板展开内容显示不全"></a>uView 折叠面板展开内容显示不全</h3><div class="border">
    <div class="title">uni-app + uView 开发钉钉应用，折叠面板组件展开后显示的内容不全。</div>
    <div class="content-slove">由于数据(无论是名称还是对应的值)是从后台接口查回来的，然后通过 v-for 循环展示在面板里面，但是打开面板之后发现显示的内容不全，原因可能是面板计算高度的时候接口数据还未返回或者数据还未渲染完成，查看了面板组件的源码之后，使用组件内部的计算高度的方法解决问题。</div>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;u-collapse ref&#x3D;&quot;uCollapse&quot;&gt;</span><br><span class="line">  &lt;u-collapse-item v-for&#x3D;&quot;(item, index) in monthlyWorkTargetList&quot; :key&#x3D;&quot;index&quot; :index&#x3D;&quot;index&quot;</span><br><span class="line">    ref&#x3D;&quot;collapseMonth&quot; @change&#x3D;&quot;handleOpenChange(index)&quot;&gt;</span><br><span class="line">    ......</span><br><span class="line">  &lt;&#x2F;u-collapse-item&gt;</span><br><span class="line">&lt;&#x2F;u-collapse&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解决打开面板内容显示不全问题  使用 $nextTick 也无法解决问题，之后用了 setTimeout</span><br><span class="line">handleOpenChange()&#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 重新计算面板的高度</span><br><span class="line">    this.$refs.collapseMonth[index].queryRect()</span><br><span class="line">  &#125;, 20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="按钮-disabled-依然触发-touchstart"><a href="#按钮-disabled-依然触发-touchstart" class="headerlink" title="按钮 disabled 依然触发 touchstart"></a>按钮 disabled 依然触发 touchstart</h3><div class="border">
    <div class="title">移动端开发，按钮设置 disabled 之后，touchstart 事件依然被触发问题</div>
    <div style='text-indent: 30px;'>为了消除 click 带来的 300 毫秒的延迟，我们用 touchstart 事件来模拟 tab 代替 click 事件，但是按钮 disabled 之后，touchstart 事件依然会被触发。可能是因为 disabled 只对 click 事件有效。为了解决这一问题，让元素不能点击触摸的方法很简单，使用 <code>pointer-events: none;</code> 这个 css3 属性就行，IE9 和以下不支持，想让 disabled 的东西不能点击触摸就这样写 <code>[disabled]{pointer-events: none;}</code>。</div>
</div>

<h3 id="页面改变title"><a href="#页面改变title" class="headerlink" title="页面改变title"></a>页面改变title</h3><div class="border">
    <div class="title">开发浙政钉遇到的问题：Vue 路由跳转的时候想改变页面 title，但是 title 不变，必须刷新之后才会改变</div>
    <div class="content-slove">解决方法：引入钉钉 API，具体方法如下：</div>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.引入 js</span><br><span class="line">&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;g.alicdn.com&#x2F;dingding&#x2F;dingtalk-jsapi&#x2F;2.3.0&#x2F;dingtalk.open.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F; 或者查看钉钉开发手册，里面有一个包</span><br><span class="line">npm install dingtalk-jsapi --save </span><br><span class="line">import * as dd from &#39;dingtalk-jsapi&#39;; &#x2F;&#x2F; 此方式为整体加载，也可按需进行加载</span><br><span class="line">&#x2F;&#x2F; 2.改变 title</span><br><span class="line">dd.ready(function() &#123;</span><br><span class="line">    dd.biz.navigation.setTitle(&#123;</span><br><span class="line">      title: &quot;123&quot;, </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Vant-步骤条切换值消失"><a href="#Vant-步骤条切换值消失" class="headerlink" title="Vant 步骤条切换值消失"></a>Vant 步骤条切换值消失</h3><div class="border">
    <div class="title">Vant 步骤条组件，切换步骤，页面输入框填写的值消失问题。</div>
    <div class="content-slove">使用 van-steps 来实现分步骤表单填写，每个步骤 div 里有会上一页和下一页按钮，由于表单里面的按钮自带 submit 属性，所以在切换步骤的时候会自动对表单进行校验，这不是想要的结果，所以将按钮的 native-type 的值改成 reset，这样虽然在切换的时候不会校验了，但是在安卓手机上，来回切换步骤会导致页面表单输入的内容消失，但是苹果手机上没有这个问题，最终的解决方法是将 native-type 的值改成 button。</div>
</div>

<h3 id="微信公众平台的图片显示失败"><a href="#微信公众平台的图片显示失败" class="headerlink" title="微信公众平台的图片显示失败"></a>微信公众平台的图片显示失败</h3><div class="border">
    <div class="title">微信公众平台的图片显示失败。</div>
    <div class="content-slove">解决：在index.html页面加上标签 meta name="referrer" content="never"。</div>
</div>

]]></content>
      <categories>
        <category>uni-app</category>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>uni-app</tag>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器输入URL之后发生了什么</title>
    <url>/2021/01/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/02/19/11/47/flowers-1209948_960_720.jpg" alt=""></p>
<a id="more"></a>

<p>从输入url到页面展示大概经过下面这些过程：</p>
<ul>
<li>DNS域名解析</li>
<li>建立TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP响应</li>
<li>浏览器渲染页面</li>
<li>关闭TCP连接</li>
</ul>
<p>在浏览器地址栏里面输入url，在没有 enter 搜索之前，会先从历史记录、书签或者缓存中查找地址，如果没找到就按照上面的步骤执行，如果找到了会直接从缓存中调出页面显示。</p>
<h1 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h1><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p><strong>URL</strong>：(Uniform Resource Locator)统一资源定位符，是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。</p>
<p><strong>IP地址</strong>：(Internet Protocol Address)网际协议地址，一种在internet上某一台计算机或计算机组的名称，是分配给网上使用网际协议（英语：Internet Protocol, IP）的设备的数字标签。常见的IP地址分为IPv4与IPv6两大类，但是也有其他不常用的小分类。</p>
<p>每个IP可唯一标识一台主机，但是IP地址是一个32位的数字，为了便于记忆，我们通常把按每字节(8位)划分，然后用10进制表示出来，即我们通常说的点分十进制（在IPV6的中采用的是冒号分十六进制）。<br>比如192.168.144.1用二进制表示就是：11000000 10101000 10010000 00000001</p>
<p><strong>域名</strong>：(Domain Name)，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。<br>以 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> 为例，http是通信使用的协议，baidu.com是域名，www是提供服务的机器的名字（计算机名），计算机名+域名才是主机名，即 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 是主机名（hostname）。</p>
<p><strong>DNS</strong>：(Domain Name System)，因特网上域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。</p>
<p><strong>Hosts文件</strong>：系统文件，将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。<br>Hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。</p>
<h2 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h2><p>以 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> 为例，事实上真正的网址是 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>. ，这里多了一个点，这个点对应的就是根域名服务器，默认情况下所有的网址的最后一位都是点，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上。网址的解析是一个从右向左的过程，所有网址真正的解析过程为: . -&gt; .com -&gt; baidu.com。</p>
<ol>
<li><p><strong>从缓存中寻找域名对应的IP</strong>：(浏览器缓存-&gt; 本地Hosts文件-&gt;路由器缓存) 先在浏览器的缓存里面查找是否有该域名对应的IP地址，如果有，则直接返回该IP地址；如果没有，则查找本地的Hosts文件中是否有，如果有，则返回对应的IP地址；如果没有，则查找路由器缓存中是否有对应的IP地址，如果有，则返回，如果没有，向本地域名服务器进行查询；</p>
</li>
<li><p><strong>本地域名服务器递归查询</strong>：如果在浏览器缓存中、hosts文件中、路由器缓存中都没有找到IP地址，浏览器会发出一个 DNS请求到本地域名服务器（本地域名服务器一般都是你的网络接入服务器商提供，比如中国电信等）；DNS请求到达本地域名服务器之后，本地域名服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是以递归方式进行查询。如果没有，本地域名服务器还要向根域名服务器进行查询。</p>
</li>
<li><p><strong>根域名服务器迭代查询</strong>：本地域名服务器向根域名服务器发送一个DNS请求，根域名服务器没有记录域名和IP的对应关系，会告诉本地域名服务器，可以到顶级域名服务器上去继续查询，并给出顶级域名服务器的地址。这种过程是迭代的过程。</p>
</li>
<li><p><strong>.com顶级域名服务器迭代查询</strong>：本地域名服务器向顶级域名服务器发送一个DNS请求，.com顶级域名服务器也没有记录域名和IP的对应关系，会告诉本地域名服务器，可以到域名解析服务器上去继续查询，并给出域名解析服务器的地址。</p>
</li>
<li><p><strong>baidu.com域名解析服务器查询</strong>：本地域名服务器向域名解析服务器发送一个DNS请求，本地域名服务器就能收到一个域名和IP的对应关系，本地域名服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/23/OfHzkyctmES8eDv.png" alt=""></p>
<h2 id="DNS查询方式：递归查询-迭代查询"><a href="#DNS查询方式：递归查询-迭代查询" class="headerlink" title="DNS查询方式：递归查询 迭代查询"></a>DNS查询方式：递归查询 迭代查询</h2><ol>
<li><p>递归查询<br>局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。<br><img src="https://s2.loli.net/2022/03/23/Jw4hqoCa581IBNF.png" alt=""><br>比如DNS解析过程中，客户端向本地域名服务器发出查询请求就属于递归查询，因为本地域名服务器没有一级一级往下查询，查到结果后告诉客户端。</p>
</li>
<li><p>迭代查询<br>局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。<br>也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。<br><img src="https://s2.loli.net/2022/03/23/yfLOr7x89CwiSoz.png" alt=""><br>比如DNS解析过程中，本地域名服务器向根域名服务器、顶级域名服务器、域名解析器发出的查询请求就属于迭代查询。</p>
</li>
</ol>
<h1 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h1><p>浏览器拿到IP后，会向服务端发送TCP连接请求，客户端和服务器经过三次握手，建立TCP连接。</p>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p><strong>协议</strong>：协议就是计算机与计算机之间通过网络通信时，事先达成的一种 “约定”。这种“约定”使不同厂商的设备、不同的CPU以及不同操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。</p>
<p><strong>TCP/IP协议</strong>：TCP/IP协议是用于因特网 (Internet) 的通信协议。TCP/IP 通信协议是对计算机必须遵守的规则的描述，只有遵守这些规则，计算机之间才能进行通信。<br>TCP/IP是基于TCP和IP这两个最初的协议之上的不同的通信协议的大集合。</p>
<p><strong>TCP/IP五层模型的协议</strong>：应用层(HTTP)、传输层(TCP/UDP)、网络层(IP)、数据链路层、物理层</p>
<p><strong>TCP/IP的数据包</strong>结构如下：<br><img src="https://s2.loli.net/2022/03/25/XeEwJBjr7tS1C4L.png" alt=""><br>TCP首部最小为20字节，这20字节分为5行，每行4个字节也就是32个位。</p>
<ol>
<li>源端口号 目标端口号<ul>
<li>源端口号：包含初始化通信的端口，源端口和源IP地址的作用是标识报文的返回地址。</li>
<li>目标端口号：定义传输的目的，指明报文接收计算机上的应用程序地址接口。</li>
</ul>
</li>
<li>序列号seq：用于标记客户端和服务器发送的数据包的序号。</li>
<li>确认号ack：客户端或者服务端收到对方的报文之后，会返回一个对应的确认报文来表示确认收到，确认报文包含确认号，确认号<strong>ack=seq+1</strong>。</li>
<li>6个标志位<br>每一个标志位的值只有 0 和 1，分别表达不同意思。<ul>
<li>URG：<strong>紧急指针</strong>，当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据；</li>
<li>ACK：<strong>确认</strong>，当ACK=0时，表示这是发送报文，没有包含确认信息；当ACK=1时，表示接收到报文，并且返回确认报文表示收到；</li>
<li>PSH：<strong>推送</strong>，当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序；</li>
<li>RST：<strong>复位</strong>，当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接；</li>
<li>SYN：<strong>同步</strong>，当 SYN = 1 的时候，表明这是一个请求连接报文段，对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1；</li>
<li>FIN：<strong>终止</strong>，当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。</li>
</ul>
</li>
</ol>
<p>关于TCP/IP的具体内容，可以查看<a href="https://zhuanlan.zhihu.com/p/33889997" target="_blank" rel="noopener">TCP/IP协议详解</a>这篇文章。</p>
<h2 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h2><p><img src="https://s2.loli.net/2022/03/25/hokNgveHSDC89PW.png" alt=""><br>客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求。<br>这个时候，客户端开始发起请求：</p>
<ul>
<li><p>第一次握手：客户端调用connect()函数，将标志位SYN置为1，请求建立连接，并随机产生一个序列号seq为J的数据包发送到服务器，客户端进入SYN_SENT状态，等待服务端确认；</p>
</li>
<li><p>第二次握手：服务端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和ACK都置为1，ACK=1表示确认收到，生成确认号ack=seq+1=J+1，然后随机产生一个序列号seq为K的数据包，将该数据包发送给客户端以确认连接请求，服务端进入SYN_RCVD状态；</p>
</li>
<li><p>第三次握手：客户端收到确认后，检查确认号ack是否为J+1，标志位ACK是否为1，如果正确则将标志位ACK置为1表示收到，并将确认号ack置为K+1，并将该数据包发送给服务端，服务端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务端进入ESTABLISHED(established)状态，完成三次握手，随后客户端与服务端之间就可以开始传输数据了。</p>
</li>
</ul>
<h2 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h2><p>三次握手的关键是确认对方收到了自己的数据包，目的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
<p>已失效的连接请求报文段的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。</p>
<p>假设不是三次握手，已失效的请求报文突然发送到服务端，服务端就直接建立连接，但是客户端并没有发出建立连接的请求，也不会向服务端发送数据，但是服务端以为新的连接已经建立，就会一直等待客户端发送数据过来，这样就会浪费资源。也可以说三次握手的主要目的就是防止服务端一直等待，浪费资源。</p>
<h1 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h1><p>客户端和服务端建立TCP安全连接之后，就可以进行HTTP请求，发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口。</p>
<p>HTTP请求报文构成：请求行、请求头、空行、请求正文<br><img src="https://s2.loli.net/2022/03/25/GCtJkL6D4F2Qoic.png" alt=""></p>
<ul>
<li>请求行：请求方法 URI协议 版本<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET&#x2F;sample.jsp HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure></li>
<li>请求头：包含许多有关的客户端环境和请求正文的有用信息，常用的Accept，Content-Type……<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept: application&#x2F;json, text&#x2F;plain, *&#x2F;*</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 179</span><br><span class="line">Content-Type: application&#x2F;json;charset&#x3D;UTF-8</span><br><span class="line">Host: localhost:1001</span><br><span class="line">Origin: http:&#x2F;&#x2F;localhost:1001</span><br><span class="line">sec-ch-ua: &quot; Not A;Brand&quot;;v&#x3D;&quot;99&quot;, &quot;Chromium&quot;;v&#x3D;&quot;99&quot;, &quot;Google Chrome&quot;;v&#x3D;&quot;99&quot;</span><br><span class="line">sec-ch-ua-mobile: ?0</span><br><span class="line">sec-ch-ua-platform: &quot;Windows&quot;</span><br><span class="line">Sec-Fetch-Dest: empty</span><br><span class="line">Sec-Fetch-Mode: cors</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;99.0.4844.51 Safari&#x2F;537.36</span><br></pre></td></tr></table></figure></li>
<li>空行：表示请求头已经结束；</li>
<li>请求正文：请求正文包含客户提交的查询字符串信息。</li>
</ul>
<p>HTTP协议的详情，可以查看阮一峰老师的网络日志：<a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门</a></p>
<h1 id="服务器处理请求并返回HTTP响应"><a href="#服务器处理请求并返回HTTP响应" class="headerlink" title="服务器处理请求并返回HTTP响应"></a>服务器处理请求并返回HTTP响应</h1><p>服务端接收到请求报文后，会对请求报文进行解析，然后返回响应报文。</p>
<p>HTTP响应报文由三部分构成：状态行、响应头、空行、响应正文。<br><img src="https://s2.loli.net/2022/03/25/9z53cBkH6lWAoMs.png" alt=""></p>
<ul>
<li>状态行：协议版本、状态码、状态描述，各部分用空格分隔开。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.0 200 OK \r\n</span><br></pre></td></tr></table></figure></li>
<li>响应头：包含服务端有用信息。</li>
<li>空行：表示响应头结束。</li>
<li>响应正文：包含客户端需要的具体信息，比如页面需要的HTML、CSS、JS、图片等等。</li>
</ul>
<h1 id="浏览器渲染页面"><a href="#浏览器渲染页面" class="headerlink" title="浏览器渲染页面"></a>浏览器渲染页面</h1><h2 id="页面渲染过程"><a href="#页面渲染过程" class="headerlink" title="页面渲染过程"></a>页面渲染过程</h2><p>浏览器接收到服务端的响应报文后，开始渲染页面，具体过程如下：</p>
<ul>
<li><p><strong>解析HTML文件构建文档对象模型(DOM树)</strong>：浏览器从上到下读取标签，把他们分解成节点，从而创建 DOM 树。</p>
</li>
<li><p><strong>解析CSS文件构建CSS对象模型(CSSOM树)</strong>：当浏览器发现任何与节点相关的样式时，比如：外部，内部，或行内样式，立即停止渲染 DOM ，并利用这些节点创建 CSSOM。这就是 CSS “渲染阻塞“ 的由来。</p>
</li>
<li><p><strong>基于DOM和CSSOM执行脚本(Scripts)</strong>：浏览器不断构建 DOM / CSSOM 节点，直到发现外部或者行内的脚本，脚本需要等到CSS解析完才能执行，所以浏览器会停下对节点的解析，按成构建CSSOM，然后执行脚本，然后再继续解析节点，解析CSS。</p>
</li>
<li><p><strong>合并DOM树和CSSOM树合并形成渲染树(Render Tree)</strong>：所有的节点被解析完后，DOM 树和 CSSOM 树合并，形成渲染树。</p>
</li>
<li><p><strong>使用渲染树布局(Layout)所有元素</strong>：确定元素的位置和大小等。</p>
</li>
<li><p><strong>渲染(Paint)所有元素</strong>：调用 GPU 绘制所有元素，合成图层，显示在屏幕上。</p>
</li>
</ul>
<p>具体的浏览器渲染页面过程，请查看<a href="http://jinlong.github.io/2017/05/08/optimising-the-front-end-for-the-browser/" target="_blank" rel="noopener">浏览器前端优化</a></p>
<h2 id="回流-重绘"><a href="#回流-重绘" class="headerlink" title="回流 重绘"></a>回流 重绘</h2><ol>
<li>回流(reflow)<br>当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。<br>会触发回流的操作:<ul>
<li>页面初次渲染</li>
<li>浏览器窗口大小改变</li>
<li>元素尺寸、位置、内容发生改变</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的 dom 元素</li>
<li>激活 CSS 伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法：<ul>
<li>clientWidth、clientHeight、clientTop、clientLeft</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect() </li>
<li>scrollTo()</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li>重绘(repaint)<br>当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此损耗较少。</li>
</ol>
<p>总结：回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。</p>
<p><strong>如何减少回流和重绘</strong></p>
<ul>
<li>CSS<ul>
<li>避免使用 table 布局；</li>
<li>将动画效果应用到 position 属性为 absolute 或 fixed 的元素上；</li>
</ul>
</li>
<li>JavaScript<ul>
<li>避免频繁操作样式，如果真的要操作样式的话，汇总之后一一修改；</li>
<li>尽量使用 class 修改样式；</li>
<li>减少 dom 的增删次数，可使用<strong>字符串</strong>或者 documentFragment 一次性插入；</li>
<li>避免多次触发上面提到的那些会触发回流的属性或者方法，可以的话尽量用变量保存下来。</li>
</ul>
</li>
</ul>
<h1 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h1><h2 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h2><p><img src="https://s2.loli.net/2022/03/26/wDtTLEcHveudXpC.png" alt=""></p>
<ul>
<li><p>第一次挥手：客户端调用close()函数，发送请求关闭连接数据包给服务端，FIN=1,seq=u，客户端进入FIN_WAIT_1状态；</p>
</li>
<li><p>第二次挥手：服务端接收到数据包后，发送确认报文给客户端，ACK=1,ack=u+1,seq=v，告知客户端已收到关闭连接的请求，准备一下之后再关闭连接，服务端进入CLOSE_WAIT状态；</p>
<p>  客户端收到来自服务端的确认报文后，客户端就进入FIN_WAIT_2状态，等待服务端发送关闭连接的数据包。</p>
</li>
<li><p>第三次挥手：服务端做好准备之后(保证所有的数据都发送完毕)，发送关闭连接数据包给客户端，FIN=1,ACK=1,seq=w,ack=u+1，服务端进入LAST_ACK状态；</p>
</li>
<li><p>第四次挥手：客户端收到关闭连接数据包后，向服务端发送确认报文，ACK=1,seq=u+1,ack=w+1，客户端进入TIME_WAIT状态，服务端接收到确认报文会立刻进入CLOSE状态，但是客户端此时并没有关闭连接，需要等待2MSL之后，才会进入CLOSE状态。</p>
</li>
</ul>
<h2 id="为什么客户端在-TIME-WAIT-阶段要等2MSL才会关闭连接？"><a href="#为什么客户端在-TIME-WAIT-阶段要等2MSL才会关闭连接？" class="headerlink" title="为什么客户端在 TIME-WAIT 阶段要等2MSL才会关闭连接？"></a>为什么客户端在 TIME-WAIT 阶段要等2MSL才会关闭连接？</h2><p>为的是确认服务端是否收到客户端发送的确认关闭连接的报文。</p>
<p>当客户端发出最后的确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL(最大报文段生存时间)的计时器。</p>
<p>如果服务器端在1MSL内没有收到客户端发出的确认关闭连接的报文，就会再次向客户端发出关闭连接的报文；</p>
<p>也就是说客户端如果在2MSL内，再次收到了来自服务器端的关闭连接报文，说明服务端由于各种原因没有接收到客户端发出的确认报文；</p>
<p>客户端再次向服务器端发出确认报文，计时器重置，重新开始2MSL的计时；否则的话说明服务端已经收到确认报文，客户端进入CLOSE状态，完成四次挥手。</p>
<h2 id="为什么建立连接是三次握手，而关闭连接却是四次挥手？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手？</h2><p>这是因为服务端在LISTEN状态下，收到建立连接的SYN报文后，可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送给客户端。</p>
<p>但关闭连接时，当收到对方的FIN报文时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭连接,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://chensanr.gitee.io/2019/02/23/url-opeation/" target="_blank" rel="noopener">浏览器输入url发生了什么？</a><br><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">前端经典面试题: 从输入URL到页面加载发生了什么？</a><br><a href="https://xianyulaodi.github.io/2017/03/22/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88-%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">老生常谈-从输入url到页面展示到底发生了什么</a><br><a href="https://www.cnblogs.com/bj-mr-li/p/11106390.html" target="_blank" rel="noopener">TCP的三次握手与四次挥手</a></p>
]]></content>
      <categories>
        <category>Web</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA</title>
    <url>/2020/12/20/RSA/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/03/17/23/07/abstract-1264071_960_720.png" alt=""></p>
<a id="more"></a>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;RSA加密算法是一种非对称加密算法，非对称加密算法指加密和解密采用不同的密钥（加密用公钥，解密用私钥），是可逆的。详细的算法原理可以参考这两篇文章：</p>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener"><strong>阮一峰网络日志-RSA算法原理（一）</strong></a></li>
<li><a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener"><strong>阮一峰网络日志-RSA算法原理（二）</strong></a></li>
</ul>
<h1 id="密钥对生成"><a href="#密钥对生成" class="headerlink" title="密钥对生成"></a>密钥对生成</h1><ol>
<li>MAC系统内置OpenSSL(开源加密库),所以可以直接在终端上使用命令；</li>
<li>Windows系统可以使用Git命令行工具；</li>
<li>在线生成密钥对：<a href="http://web.chacuo.net/netrsakeypair" target="_blank" rel="noopener"><strong>http://web.chacuo.net/netrsakeypair</strong></a>。</li>
</ol>
<h1 id="jsencrypt-基于RSA加解密的JS库"><a href="#jsencrypt-基于RSA加解密的JS库" class="headerlink" title="jsencrypt-基于RSA加解密的JS库"></a>jsencrypt-基于RSA加解密的JS库</h1><p>&emsp;&emsp;目前最常用的场景就是前端记住密码的操作，将密码加密保存在cookie中，比如若依前端。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 安装</span><br><span class="line">npm install jsencrypt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 引入</span><br><span class="line">import JSEncrypt from &#39;jsencrypt&#x2F;bin&#x2F;jsencrypt.min&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 具体使用</span><br><span class="line">const publicKey &#x3D; &#39;...........&#39;</span><br><span class="line">const privateKey &#x3D; &#39;...........&#39;</span><br><span class="line">&#x2F;&#x2F; 加密</span><br><span class="line">export function encrypt(txt) &#123;</span><br><span class="line">  const encryptor &#x3D; new JSEncrypt()</span><br><span class="line">  encryptor.setPublicKey(publicKey) &#x2F;&#x2F; 设置公钥</span><br><span class="line">  return encryptor.encrypt(txt) &#x2F;&#x2F; 对数据进行加密</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解密</span><br><span class="line">export function decrypt(txt) &#123;</span><br><span class="line">  const encryptor &#x3D; new JSEncrypt()</span><br><span class="line">  encryptor.setPrivateKey(privateKey) &#x2F;&#x2F; 设置私钥</span><br><span class="line">  return encryptor.decrypt(txt) &#x2F;&#x2F; 对数据进行解密</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web</category>
        <category>加密算法</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>加密算法</tag>
      </tags>
  </entry>
  <entry>
    <title>工具函数</title>
    <url>/2020/11/22/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2019/03/12/17/18/the-night-sky-4051288_960_720.jpg" alt=""></p>
<a id="more"></a>

<h1 id="桌面通知"><a href="#桌面通知" class="headerlink" title="桌面通知"></a>桌面通知</h1><p><img src="https://i.loli.net/2021/07/23/mDxVtl9zJSAjrcd.png" alt=""><br>&emsp;&emsp;具体代码请查看：<a href="https://gitee.com/crystalSummer/record-code/blob/master/JS/notify.js" target="_blank" rel="noopener"><strong>桌面通知方法封装</strong></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、创建公共方法：新建notify.js文件</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 创建通知</span><br><span class="line"> * @param &#123;string&#125; title 一定会被显示的通知标题</span><br><span class="line"> * @param &#123;object&#125; options 一个被允许用来设置通知的对象。它包含以下属性：</span><br><span class="line"> * @param &#123;object&#125; events 4个事件 </span><br><span class="line"> *&#x2F;</span><br><span class="line">const doNotify &#x3D; (title, options &#x3D; &#123;&#125;, events &#x3D; &#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">  const notification &#x3D; new Notification(title, options);</span><br><span class="line">  for (let event in events) &#123;</span><br><span class="line">      notification[event] &#x3D; events[event];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 通知创建前的校验</span><br><span class="line"> * @param &#123;string&#125; title 一定会被显示的通知标题</span><br><span class="line"> * @param &#123;object&#125; options 一个被允许用来设置通知的对象。它包含以下属性：</span><br><span class="line"> *        dir : 文字的方向；它的值可以是 auto（自动）, ltr（从左到右）, or rtl（从右到左），但是好像没有作用</span><br><span class="line"> *        lang: 指定通知中所使用的语言。这个字符串必须在 BCP 47 language tag 文档中是有效的。</span><br><span class="line"> *        body: 通知中额外显示的字符串</span><br><span class="line"> *        tag: 赋予通知一个ID，以便在必要的时候对通知进行刷新、替换或移除，常用于处理重复的通知。</span><br><span class="line"> *        icon: 一个图片的URL，将被用于显示通知的图标，如果是本地图标的话，请使用require引入图标。</span><br><span class="line"> *        image：要在通知中显示的图像的URL，图片显示在通知的最下方。</span><br><span class="line"> *        requireInteraction：通知保持有效不自动关闭，默认为false。</span><br><span class="line"> *        data：想要和通知关联的任务类型的数据。</span><br><span class="line"> * @param &#123;object&#125; events 4个事件 </span><br><span class="line"> *        onshow：通知显示时触发</span><br><span class="line"> *        onclick：用户点击通知时触发</span><br><span class="line"> *        onclose：通知关闭时触发</span><br><span class="line"> *        onerror：通知发生错误的时候触发</span><br><span class="line"> *&#x2F;</span><br><span class="line">const notify &#x3D; (title, options &#x3D; &#123;&#125;, events &#x3D; &#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">  if (!(&quot;Notification&quot; in window)) &#123; &#x2F;&#x2F; 不支持Notifications功能</span><br><span class="line">      return console.error(&quot;This browser does not support desktop notification&quot;);</span><br><span class="line">  &#125;else if (Notification.permission &#x3D;&#x3D;&#x3D; &quot;granted&quot;) &#123;&#x2F;&#x2F; 查看是否已经有权限-之前已经询问过用户，并且用户已经授予了显示通知的权限</span><br><span class="line">      doNotify(title, options, events) &#x2F;&#x2F; 弹出通知</span><br><span class="line">  &#125; else if (Notification.permission !&#x3D;&#x3D; &quot;denied&quot;) &#123;&#x2F;&#x2F; 查看是否已经有权限-未授权</span><br><span class="line">      &#x2F;&#x2F; 向客户发起授权选择</span><br><span class="line">      Notification.requestPermission().then(function (permission) &#123;           </span><br><span class="line">          if (permission &#x3D;&#x3D;&#x3D; &quot;granted&quot;) &#123; &#x2F;&#x2F; 客户授权</span><br><span class="line">              doNotify(title, options, events);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default notify</span><br><span class="line"></span><br><span class="line">2、引入方法并使用</span><br><span class="line">&lt;el-button @click&#x3D;&quot;sendNotify&quot;&gt;发送通知&lt;&#x2F;el-button&gt;</span><br><span class="line"></span><br><span class="line">import notify from &#39;@&#x2F;utils&#x2F;notify.js&#39;</span><br><span class="line"></span><br><span class="line">sendNotify()&#123;</span><br><span class="line">  notify(&quot;中奖提示&quot;, &#123;</span><br><span class="line">      icon: &#39;https:&#x2F;&#x2F;source.unsplash.com&#x2F;user&#x2F;erondu&#x2F;80x80&#39;,</span><br><span class="line">      image: &#39;https:&#x2F;&#x2F;source.unsplash.com&#x2F;user&#x2F;erondu&#x2F;1600x900&#39;,</span><br><span class="line">      body: &#96;恭喜你，你中了一等奖&#96;,</span><br><span class="line">      tag: &quot;prize&quot;,</span><br><span class="line">      requireInteraction:true,</span><br><span class="line">      data:&#123;</span><br><span class="line">        entName:&#39;公司名称&#39;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">      onshow(ev) &#123;</span><br><span class="line">          console.log(&#39;通知显示&#39;)</span><br><span class="line">      &#125;,</span><br><span class="line">      onclick(ev) &#123;</span><br><span class="line">          &#x2F;&#x2F; ev.target.close()</span><br><span class="line">          console.log(&#39;通知被点击&#39;)</span><br><span class="line">          &#x2F;&#x2F; 可以定位到有消息的窗口</span><br><span class="line">          window.focus()</span><br><span class="line">          &#x2F;&#x2F; 获取定义的data</span><br><span class="line">          console.log(ev)</span><br><span class="line">          console.log(ev.target.data)</span><br><span class="line">      &#125;,</span><br><span class="line">      onclose(ev) &#123;</span><br><span class="line">        console.log(&#39;通知关闭&#39;)</span><br><span class="line">      &#125;,</span><br><span class="line">      onerror(ev) &#123;</span><br><span class="line">        console.log(&#39;通知出错&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="无插件原生base64编码和解码"><a href="#无插件原生base64编码和解码" class="headerlink" title="无插件原生base64编码和解码"></a>无插件原生base64编码和解码</h1><p>&emsp;&emsp;浏览器内置了base64编码和解码的能力，不需要第三方库。<br>&emsp;&emsp;CanIUse兼容性:<a href="https://caniuse.com/?search=btoa" target="_blank" rel="noopener"><strong>btoa 99.68%</strong></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function utf8_to_b64( str ) &#123;</span><br><span class="line">  return window.btoa(unescape(encodeURIComponent( str )));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b64_to_utf8( str ) &#123;</span><br><span class="line">  return decodeURIComponent(escape(window.atob( str )));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">utf8_to_b64(&#39;✓ à la mode&#39;); &#x2F;&#x2F; &quot;4pyTIMOgIGxhIG1vZGU&#x3D;&quot;</span><br><span class="line">b64_to_utf8(&#39;4pyTIMOgIGxhIG1vZGU&#x3D;&#39;); &#x2F;&#x2F; &quot;✓ à la mode&quot;</span><br></pre></td></tr></table></figure>

<h1 id="基于Array-from的序列生成器"><a href="#基于Array-from的序列生成器" class="headerlink" title="基于Array.from的序列生成器"></a>基于Array.from的序列生成器</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const range &#x3D; (start, stop, step) &#x3D;&gt; Array.from(</span><br><span class="line">    &#123; length: (stop - start) &#x2F; step + 1&#125;, </span><br><span class="line">    (_, i) &#x3D;&gt; start + (i * step)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">range(0, 4, 1); &#x2F;&#x2F; [0, 1, 2, 3, 4]</span><br><span class="line">range(0, 9, 3); &#x2F;&#x2F; [0, 3, 6, 9]</span><br><span class="line">range(0, 8, 2.5) &#x2F;&#x2F; [0, 2.5, 5, 7.5]</span><br></pre></td></tr></table></figure>

<h1 id="基于toLocaleString千分位"><a href="#基于toLocaleString千分位" class="headerlink" title="基于toLocaleString千分位"></a>基于toLocaleString千分位</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const formatMoney &#x3D; (num) &#x3D;&gt; &#123;</span><br><span class="line">    return (+num).toLocaleString(&quot;en-US&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(formatMoney(123456789));  &#x2F;&#x2F; 123,456,789</span><br><span class="line">console.log(formatMoney(6781)) &#x2F;&#x2F; 6,781</span><br><span class="line">console.log(formatMoney(5)) &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">超大的数</span><br><span class="line">formatMoney(19999999933333333333333) &#x2F;&#x2F; 19,999,999,933,333,333,000,000</span><br></pre></td></tr></table></figure>

<h1 id="禁止选择和赋值"><a href="#禁止选择和赋值" class="headerlink" title="禁止选择和赋值"></a>禁止选择和赋值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、JS方案</span><br><span class="line">[&#39;contextmenu&#39;, &#39;selectstart&#39;, &#39;copy&#39;].forEach(function(ev)&#123;</span><br><span class="line">    document.addEventListener(ev, function(ev)&#123;</span><br><span class="line">        ev.preventDefault();</span><br><span class="line">        ev.returnValue &#x3D; false;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">2、CSS方案</span><br><span class="line">body &#123;</span><br><span class="line">    -moz-user-select: none;</span><br><span class="line">    -webkit-user-select: none;</span><br><span class="line">    -ms-user-select: none;</span><br><span class="line">    -khtml-user-select: none;</span><br><span class="line">    user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Data-URLs-gt-Blob转换"><a href="#Data-URLs-gt-Blob转换" class="headerlink" title="Data URLs =&gt; Blob转换"></a>Data URLs =&gt; Blob转换</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dataUrlToBlob(base64, mimeType) &#123;</span><br><span class="line">  let bytes &#x3D; window.atob(base64.split(&quot;,&quot;)[1]);</span><br><span class="line">  let ab &#x3D; new ArrayBuffer(bytes.length);</span><br><span class="line">  let ia &#x3D; new Uint8Array(ab);</span><br><span class="line">  for (let i &#x3D; 0; i &lt; bytes.length; i++) &#123;</span><br><span class="line">    ia[i] &#x3D; bytes.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return new Blob([ab], &#123; type: mimeType &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一键复制"><a href="#一键复制" class="headerlink" title="一键复制"></a>一键复制</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  一键复制</span><br><span class="line"> *  @param &#123;id&#125; string 要复制内容的Dom节点的id，如：#copyDiv</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function copyById(id) &#123;</span><br><span class="line">  let target &#x3D; null</span><br><span class="line">  target &#x3D; document.querySelector(id)</span><br><span class="line">  const range &#x3D; document.createRange()</span><br><span class="line">  range.selectNode(target)</span><br><span class="line">  window.getSelection().removeAllRanges()</span><br><span class="line">  window.getSelection().addRange(range)</span><br><span class="line">  document.execCommand(&#39;copy&#39;)</span><br><span class="line">  window.getSelection().removeAllRanges()</span><br><span class="line">  console.log(&#39;复制成功&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="简易版深度拷贝"><a href="#简易版深度拷贝" class="headerlink" title="简易版深度拷贝"></a>简易版深度拷贝</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * This is just a simple version of deep copy</span><br><span class="line"> * Has a lot of edge cases bug</span><br><span class="line"> * If you want to use a perfect deep copy, use lodash&#39;s _.cloneDeep</span><br><span class="line"> * @param &#123;Object&#125; source</span><br><span class="line"> * @returns &#123;Object&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function deepClone(source) &#123;</span><br><span class="line">  if (!source &amp;&amp; typeof source !&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">    throw new Error(&#39;error arguments&#39;, &#39;deepClone&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  const targetObj &#x3D; source.constructor &#x3D;&#x3D;&#x3D; Array ? [] : &#123;&#125;</span><br><span class="line">  Object.keys(source).forEach(keys &#x3D;&gt; &#123;</span><br><span class="line">    if (source[keys] &amp;&amp; typeof source[keys] &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">      targetObj[keys] &#x3D; deepClone(source[keys])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      targetObj[keys] &#x3D; source[keys]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return targetObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="通用下载回调"><a href="#通用下载回调" class="headerlink" title="通用下载回调"></a>通用下载回调</h1><p>&emsp;&emsp;以下是a标签下载文件的函数，在该函数内部，我们使用了 <code>HTMLAnchorElement.download</code> 属性，该属性值表示下载文件的名称。如果该名称不是操作系统的有效文件名，浏览器将会对其进行调整。此外，该属性的作用是表明链接的资源将被下载，而不是显示在浏览器中。当设置好 a 元素的 download 属性之后，我们会调用 <code>URL.createObjectURL</code> 方法来创建 <code>Object URL</code>，并把返回的 URL 赋值给 a 元素的 href 属性。接着通过调用 a 元素的 click 方法来触发文件的下载操作，最后还会调用一次 <code>URL.revokeObjectURL</code> 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">downLoadFile(res, fileName) &#123;</span><br><span class="line">  const blob &#x3D; new Blob([res])</span><br><span class="line">  const eLink &#x3D; document.createElement(&#39;a&#39;)</span><br><span class="line">  eLink.download &#x3D; fileName</span><br><span class="line">  eLink.style.display &#x3D; &#39;none&#39;</span><br><span class="line">  eLink.href &#x3D; URL.createObjectURL(blob)</span><br><span class="line">  document.body.appendChild(eLink)</span><br><span class="line">  eLink.click()</span><br><span class="line">  URL.revokeObjectURL(eLink.href) &#x2F;&#x2F; 释放URL 对象</span><br><span class="line">  document.body.removeChild(eLink)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>网络与安全</title>
    <url>/2020/10/17/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2020/08/06/20/18/wheat-5469124_960_720.jpg" alt=""></p>
<a id="more"></a>

<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>HTTP协议是超文本传输协议的缩写，用于从万维网服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP协议是基于TCP/IP通信协议来传递数据（HTML文件、图片文件、查询结果）的。</p>
<p>HTTP协议与TCP协议不冲突，HTTP协议定义在七层协议的应用层，TCP解决的是传输层逻辑。</p>
<p>HTTP使用TCP而不用UDP是因为网页传送的数据很多，而TCP协议提供传输控制，按顺序组织数据和错误纠正。</p>
<h2 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h2><ul>
<li><strong>TCP面向连接，UDP无连接</strong><br>TCP需要经过三次握手建立连接，而UDP不需要，想发送数据就可以直接发送。</li>
<li><strong>TCP可靠传输，提供流量控制和拥塞控制，UDP不可靠传输，不提供流量控制和拥塞控制</strong><br>由于TCP需要经过三次握手建立连接，所以TCP属于可靠传输，当网络出现堵塞的时候，TCP会减小向网络注入数据的数量和速率，缓解堵塞情况，但是UDP完全相反，UDP一直以恒定的速度发送数据，不管网络条件是好是坏。</li>
<li><strong>TCP一对一，UDP支持一对一，一对多，多对一和多对多的交互通信</strong></li>
<li><strong>TCP面向字节流，UDP面向报文</strong></li>
<li><strong>TCP首部最小为20字节，最大60字节，而UDP仅有8字节</strong></li>
<li><strong>TCP适用于可靠传输，如文件传输，UDP适用于实时应用，如电话、视频、直播</strong></li>
</ul>
<h2 id="HTTP版本区别"><a href="#HTTP版本区别" class="headerlink" title="HTTP版本区别"></a>HTTP版本区别</h2><h3 id="HTTP0-9"><a href="#HTTP0-9" class="headerlink" title="HTTP0.9"></a>HTTP0.9</h3><p>最早的版本，只能发送GET请求，返回的数据只能是HTML格式。</p>
<h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><p>优点：</p>
<ul>
<li>第一个在通讯中指定版本号的HTTP协议版本；</li>
<li>任何格式的内容都可以发送，除文字外，增加了视频、图像、二进制文件；</li>
<li>除了GET命令，还引入了POST和HEAD命令；</li>
<li>请求和回应格式发生改变：<br>  请求格式：第一行是请求命令，尾部跟着协议版本号，后面是多行头信息，描述客户端情况。<br>  回应格式：头信息（ASCII码）+空行+数据（任何数据），其中第一行是协议版本号+状态码+状态描述。</li>
</ul>
<p>缺点：</p>
<ul>
<li>连接无法复用：每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</li>
<li>性能差：TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</li>
</ul>
<p>解决连接无法复用的方法：<br>请求时声明一个非标准字段Connection:keep-alive，这个字段要求服务器不关闭TCP连接，服务器同样返回这个字段。但这不是根本的解决之法。</p>
<h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><p>优点：</p>
<ul>
<li><strong>持久连接</strong><br>TCP连接默认不关闭，可以被多个请求复用，不用声明Connection:keep-alive，客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。大多数浏览器允许同时建立6个长久连接。</li>
<li><strong>管道机制</strong><br>同一个TCP连接里，可以同时发送多个请求，提高了传输速度。举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</li>
<li><strong>新增了许多动词方法</strong><br>PUT、PATCH、HEAD、 OPTIONS、DELETE。</li>
<li><strong>客户端请求的头信息新增了Host字段，用来指定服务器的域名</strong>。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>队头堵塞</strong><br>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。</li>
</ul>
<h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><p>优点：</p>
<ul>
<li><strong>二进制协议</strong><br>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。<br>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</li>
<li><strong>多工</strong><br>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。<br>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。<br>这样双向的、实时的通信，就叫做多工（Multiplexing）。</li>
<li><strong>数据流</strong><br>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<br>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。<br>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。<br>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</li>
<li><strong>头信息压缩</strong><br>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。<br>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</li>
<li><strong>服务器推送</strong><br>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。<br>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>往返时延</strong><br>信号传播延迟(光在光纤和铜介质导线中传播速度是不同的)、网络服务器端以及用户端路由器跨越的数量、路由器是否拥堵以及路由器自身容量等。</li>
<li><strong>多工导致服务器压力上升，容易TimeOut</strong><br>多工没有限制同时请求的数量，大批量的请求同时发送，由于服务器资源有限，有可能导致超时。</li>
</ul>
<h3 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h3><p>HTTP3在2022年6月官宣，实现了巨大的改革，底层支撑协议由TCP换成UDP。该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。</p>
<ul>
<li><strong>实现快速握手功能</strong><br>由于UDP是无连接的，这意味着可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</li>
<li><strong>实现了类似TCP的可靠传输、流量控制和拥塞控制</strong></li>
</ul>
<h2 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h2><p>HTTP协议工作于客户端-服务端架构上，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。WEB服务器根据接收到的请求，向客户端发送响应信息。</p>
<p>HTTP默认端口号是80，也可以改成8080或者其他。</p>
<p>HTTP工作流程：</p>
<ul>
<li>客户端与服务端通过三次握手建立TCP连接；</li>
<li>客户端发送HTTP请求；</li>
<li>服务端解析请求并返回响应；</li>
<li>客户端与服务端通过四次挥手关闭TCP连接。</li>
</ul>
<p>详情请查看 <a href="https://crystalsummer.gitee.io/2021/01/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/#%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5"><strong>浏览器输入URL之后发生了什么</strong></a>，里面详细介绍了建立TCP连接的三次握手和关闭TCP连接的四次挥手过程。</p>
<h2 id="HTTP消息结构"><a href="#HTTP消息结构" class="headerlink" title="HTTP消息结构"></a>HTTP消息结构</h2><h3 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h3><p>HTTP请求报文构成：请求行、请求头、空行、请求正文<br><img src="https://s2.loli.net/2022/03/25/GCtJkL6D4F2Qoic.png" alt=""></p>
<ul>
<li>请求行：请求方法 URI协议 版本<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET&#x2F;sample.jsp HTTP&#x2F;1.1 \r\n</span><br></pre></td></tr></table></figure></li>
<li>请求头：包含客户端环境和请求正文的有用信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 浏览器可接受的MIME类型</span><br><span class="line">Accept: application&#x2F;json, text&#x2F;plain, *&#x2F;*</span><br><span class="line">&#x2F;&#x2F; 浏览器能够进行解码的数据编码方式</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">&#x2F;&#x2F; 浏览器所希望的语言种类</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">&#x2F;&#x2F; 表示是否需要持久连接</span><br><span class="line">Connection: keep-alive</span><br><span class="line">&#x2F;&#x2F; 表示请求消息正文的长度</span><br><span class="line">Content-Length: 179</span><br><span class="line">&#x2F;&#x2F; 文档支持的MIME类型</span><br><span class="line">Content-Type: application&#x2F;json;charset&#x3D;UTF-8</span><br><span class="line">&#x2F;&#x2F; Host头域指定请求资源的主机和端口号。</span><br><span class="line">Host: localhost:1001</span><br><span class="line">Origin: http:&#x2F;&#x2F;localhost:1001</span><br><span class="line">&#x2F;&#x2F; 浏览器类型</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;99.0.4844.51 Safari&#x2F;537.36</span><br><span class="line">&#x2F;&#x2F; Referer 设置响应体的过期时间</span><br><span class="line">&#x2F;&#x2F; Last-Modified的值</span><br><span class="line">if-Modified-Since</span><br><span class="line">&#x2F;&#x2F; Etag的值</span><br><span class="line">if-None-Match</span><br></pre></td></tr></table></figure></li>
<li>空行：表示请求头已经结束；</li>
<li>请求正文：请求正文包含客户提交的查询字符串信息。</li>
</ul>
<h3 id="服务器响应消息"><a href="#服务器响应消息" class="headerlink" title="服务器响应消息"></a>服务器响应消息</h3><p>HTTP响应报文由三部分构成：状态行、响应头、空行、响应正文。<br><img src="https://s2.loli.net/2022/03/25/9z53cBkH6lWAoMs.png" alt=""></p>
<ul>
<li>状态行：协议版本、状态码、状态描述，各部分用空格分隔开。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.0 200 OK \r\n</span><br></pre></td></tr></table></figure></li>
<li>响应头：包含服务端有用信息。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Expires 设置响应体的过期时间</span><br><span class="line">&#x2F;&#x2F; 跨域资源设置</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;wxdev9.600280.com</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">&#x2F;&#x2F; 设置请求响应链上所有的缓存机制必须遵守的指令</span><br><span class="line">Cache-Control: no-cache, no-store</span><br><span class="line">Express</span><br><span class="line">&#x2F;&#x2F; 表示是否需要持久连接</span><br><span class="line">Connection: keep-alive</span><br><span class="line">&#x2F;&#x2F; 文档支持的MIME类型</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">&#x2F;&#x2F; 当前的GMT时间</span><br><span class="line">Date: Sun, 27 Mar 2022 12:23:20 GMT</span><br><span class="line">&#x2F;&#x2F; 服务器名称</span><br><span class="line">Server: nginx&#x2F;1.11.6</span><br><span class="line">&#x2F;&#x2F; 设置传输实体的编码格式，目前支持的格式： chunked, compress, deflate, gzip, identity</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Etag 资源文件的一个唯一标识</span><br></pre></td></tr></table></figure></li>
<li>空行：表示响应头已经结束；</li>
<li>响应正文：包含客户端需要的具体信息，比如页面需要的HTML、CSS、JS、图片等等。</li>
</ul>
<h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD等等。<br><img src="https://s2.loli.net/2022/03/25/YtJpXx6LfGiz3QM.png" alt=""></p>
<p><strong>GET和POST有什么区别？</strong></p>
<ul>
<li>GET：可被缓存，会被历史记录保存，请求长度受限</li>
<li>POST：安全，大数据，更多编码类型<br><img src="https://s2.loli.net/2022/03/25/1XLcMgeAVusUGra.png" alt=""></li>
</ul>
<p><strong>fetch()请求两次的原因？</strong><br>当使用fetch发送POST请求时，会先发送一个OPTION请求进行预检查，用来获知服务端是否允许该跨域请求，服务器确认允许之后会返回204状态码，表示允许该跨域请求，这时才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）</p>
<ul>
<li><strong>状态码204</strong>：当服务器返回这个状态码时，就表示服务器已经成功收到请求，但是没有数据。对应到浏览器，不会刷新界面，也不会导向新界面。当我们只关注于请求是否成功，而无所谓返回数据时，就可以借助204状态码，省掉了多余的数据传输，从而节省开销。</li>
<li><strong>OPTION请求</strong>：属于请求中的复杂请求，该类请求有一个特点，在正式发送请求之前，都会先发送一个请求，进行一个预检查，简称：预检请求。</li>
<li><strong>预检请求</strong>：可以向服务器请求权限信息，也可以获取目的资源所支持的通信选项（例如：检查HTTP请求方法），还可以用来检查服务器性能。</li>
</ul>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><ul>
<li><p>1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。</p>
</li>
<li><p>2xx：成功状态码，表示服务器已成功接收到请求并进行处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200: 请求成功。一般用于GET与POST请求</span><br><span class="line">201: 已创建。成功请求并创建了新的资源</span><br><span class="line">202: 已接受。已经接受请求，但未处理完成</span><br><span class="line">203: 成为，但未授权</span><br><span class="line">204: 成功，无内容</span><br><span class="line">205: 成功，重置内容</span><br><span class="line">206: 成功，部分内容</span><br></pre></td></tr></table></figure>
</li>
<li><p>3xx：重定向状态码，表示服务器要求客户端重定向。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">301: 永久移动，重定向</span><br><span class="line">302: 临时移动，可使用原有URI</span><br><span class="line">303：请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源</span><br><span class="line">304: 资源未修改，可使用缓存</span><br><span class="line">305: 需代理访问</span><br></pre></td></tr></table></figure>
</li>
<li><p>4xx：客户端错误状态码，表示客户端的请求有非法内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400: 请求语法错误</span><br><span class="line">401: 要求身份认证</span><br><span class="line">403: 拒绝请求，通常会在响应正文中给出拒绝的原因</span><br><span class="line">404: 资源不存在</span><br></pre></td></tr></table></figure>
</li>
<li><p>5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">500: 服务器未知错误</span><br><span class="line">503：服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</span><br><span class="line">505：服务器不支持请求的HTTP协议的版本，无法完成处理</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="HTTPS简介"><a href="#HTTPS简介" class="headerlink" title="HTTPS简介"></a>HTTPS简介</h2><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。现在的HTTPS都是用的TLS(SSL3.0)协议，但是由于SSL出现的时间比较早，并且依旧被现在浏览器所支持，因此SSL依然是HTTPS的代名词。</p>
<p>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，TLS/SSL中使用了 非对称加密，对称加密以及HASH算法。</p>
<p><strong>对称加密算法</strong>：使用同一个密钥对数据进行加密和解密，速度快，但是密钥明文传输存在安全隐患，如DES，AES，3DES，RC2，RC4；</p>
<p><strong>非对称加密算法</strong>：使用不同的密钥（公钥、私钥）对数据进行加密和解密，公钥和算法都是公开的，私钥是保密的，安全性强，但是性能低，耗时长，如RSA，DSA、ECDSA、 DH、ECDHE；</p>
<p><strong>哈希算法</strong>：将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆，如MD5，SHA-1，SHA-2(SHA-224 SHA-256 SHA-384 SHA-512)；</p>
<h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><ul>
<li><p>HTTPS协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p>
</li>
<li><p>HTTP是超文本传输协议，信息是明文传输，安全性差，HTTPS则是具有安全性的SSL加密传输协议，安全性好；</p>
</li>
<li><p>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
</li>
<li><p>HTTP页面响应速度比HTTPS快，主要是因为HTTP使用TCP三次握手建立连接，客户端和服务器需要交换3个包，而HTTPS除了TCP的三个包，还要加上SSL握手需要的9个包，所以一共是12个包。</p>
</li>
<li><p>HTTPS其实就是建构在SSL/TLS之上的HTTP协议，所以HTTPS比HTTP要更耗费服务器资源。</p>
</li>
</ul>
<h2 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h2><p>HTTPS的工作原理和HTTP类似，只是在通过三次握手建立TCP连接后，再建立SSL会话：</p>
<ul>
<li>客户端与服务端通过三次握手建立TCP连接；</li>
<li><strong>客户端与服务端建立SSL会话</strong>；</li>
<li>客户端发送HTTP请求；</li>
<li>服务端解析请求并返回响应；</li>
<li>客户端与服务端通过四次挥手关闭TCP连接。</li>
</ul>
<p>客户端与服务端建立SSL会话具体过程如下：<br><img src="https://s2.loli.net/2022/03/29/TNw4K2vd1JzYXhQ.png" alt=""></p>
<ul>
<li>浏览器将自己支持的一套加密规则发送给服务端；<ul>
<li>SSL/TLS协议版本号</li>
<li>支持的加密算法种类</li>
<li>支持的HASH算法种类</li>
<li>session ID</li>
<li>握手消息</li>
</ul>
</li>
</ul>
<ul>
<li>服务端从中选出一组加密算法和HASH算法，并将证书返回给客户端；<ul>
<li>证书包含了网站信息、加密公钥、证书签名、证书的颁发机构和过期时间等等。</li>
</ul>
</li>
</ul>
<ul>
<li>客户端接收到证书之后对其进行解析，这一过程由浏览器内置的TSL完成：<ul>
<li>验证证书的合法性：<strong>验证签名</strong>是否一致，证书颁发机构是否合法，证书的网站地址是否和正在访问的地址一致，证书有没有过期等等，如果证书可以信任，浏览器的地址栏前面就会出现一个锁；</li>
<li>如果证书合法，客户端产生一个随机数 R，并用证书的公钥对随机数进行加密，生成<strong>对称密码</strong>；</li>
<li>根据服务端指定的HASH算法（如SHA1）计算握手消息，并使用生成的对称密码对握手消息进行加密；</li>
</ul>
</li>
</ul>
<ul>
<li><p>客户端将握手消息、对称密码和加密的握手消息发送给服务端；</p>
</li>
<li><p>服务端接收到数据后对数据进行解析：</p>
<ul>
<li>用私钥对对称密码进行解密，获取随机数R；</li>
<li>将随机数R保存在客户端对应的session ID下面，这样的话就不需要每次请求都要建立握手传输密钥了；</li>
<li>用随机数R对加密后的握手消息进行解密得到hash1；</li>
<li>使用指定的HASH算法计算握手消息得到hash2;</li>
<li>判断hash1和hash2是否一致；</li>
</ul>
</li>
</ul>
<ul>
<li><p>服务端使用随机数加密握手信息，发送给客户端；</p>
</li>
<li><p>客户端使用随机数解密握手消息，并比较服务端发送的hash是否一致；一致此时握手结束，以后的通讯都是使用这个随机数加密。</p>
</li>
</ul>
<p>总结：</p>
<ul>
<li>使用服务端的公钥和密钥对客户端产生的随机数进行加密和解密，这一过程是非对称加密；</li>
<li>使用随机数对客户端和服务端的数据进行加密和解密，这一过程是对称加密；</li>
<li>使用HASH算法将数据转换为较短的固定长度的值。</li>
</ul>
<h2 id="只用对称加密可行吗？"><a href="#只用对称加密可行吗？" class="headerlink" title="只用对称加密可行吗？"></a>只用对称加密可行吗？</h2><p>不可行，因为密钥在传输过程中会被别人劫持，然后去解密客户端和服务端传输的数据，不安全。</p>
<h2 id="只用非对称加密可行吗？"><a href="#只用非对称加密可行吗？" class="headerlink" title="只用非对称加密可行吗？"></a>只用非对称加密可行吗？</h2><p>不可行，服务端将公钥传给客户端，客户端用公钥对数据进行加密传给服务端，服务端在用私钥解密，客户端到服务端的单向传输过程是安全的。</p>
<p>但是如果公钥被人劫持，服务端发送用私钥数据加密的数据给客户端，那么劫持者就可以用劫持的公钥解密数据，服务端到客户端的单向传输就存在安全问题。</p>
<p>除非客户端有自己的公钥和私钥，服务端也有自己的公钥和私钥，双方交换公钥，然后用公钥加密传输数据，用私钥解密数据，这样的话双向传输都是安全的。但是<strong>非对称加密算法非常复杂，耗时长</strong>。</p>
<p>所以就需要对称加密 + 非对称机密的结合，既可以保证安全，又可以节省时间。但是使用此方法依然有安全漏洞，那就是<strong>中间人攻击</strong>。</p>
<h2 id="数字证书的作用"><a href="#数字证书的作用" class="headerlink" title="数字证书的作用"></a>数字证书的作用</h2><p>只采用对称加密 + 非对称加密的算法，但是没有数字证书传输数据的时候，还是存在安全漏洞–<strong>中间人攻击</strong>。</p>
<p>中间人攻击：中间人劫持服务端的公钥A，并将数据包中的公钥A换成自己的公钥B，然后客户端使用公钥B加密数据并传送给服务端，中间人就可以劫持数据并用私钥B对数据进行解密，得到客户端生成的随机数R，中间人再使用公钥A加密后传输给服务端。这样在客户端和服务端不知情的情况下，调包了服务端的公钥，并且得到了随机数R，<strong>根本原因是浏览器无法确认收到的公钥是不是网站自己的，因为公钥本身是明文传输的。</strong></p>
<p>为了解决中间人攻击的问题，CA机构给网站办法身份证明–数字证书。服务端把证书传输给客户端，客户端从证书里获取公钥就可以完美的解决中间人攻击的问题。</p>
<h2 id="如何防止证书被篡改-数字签名"><a href="#如何防止证书被篡改-数字签名" class="headerlink" title="如何防止证书被篡改 - 数字签名"></a>如何防止证书被篡改 - 数字签名</h2><p>数字签名的制作过程：</p>
<ul>
<li>CA机构拥有非对称加密的私钥和公钥；</li>
<li>CA机构对证书明文数据T进行hash；</li>
<li>对hash后的值用私钥加密，得到数字签名S；</li>
</ul>
<p>客户端验证数字签名的过程：</p>
<ul>
<li>拿到证书，得到明文数据T和数字签名S；</li>
<li>使用公钥对数字签名S进行解密，得到S’；</li>
<li>用证书中指明的HASH算法对明文数据T进行hash，得到T’；</li>
<li>判断S’和T’是否相等，相等说明证书可信，不相等说明证书被篡改。</li>
</ul>
<p>如果中间人篡改证书，但是由于拿不到CA机构的私钥，就无法篡改相对应的数字签名S。</p>
<p>如果中间人掉包整个证书也不会发生问题，因为证书包含了网站的信息，包括域名，浏览器把自己的域名和证书中的域名一比对就知道证书有没有被调包。</p>
<h2 id="为什么制作数字签名需要hash一下？"><a href="#为什么制作数字签名需要hash一下？" class="headerlink" title="为什么制作数字签名需要hash一下？"></a>为什么制作数字签名需要hash一下？</h2><p>如果把数字签名过程中的hash步骤省略，在安全方面也是没有问题的，但是会有性能问题。</p>
<p>证书的明文数据一般都很长，如果直接用非对称加密算法加密或者解密的话，会非常耗时，但是证书明文经过hash之后得到固定长度的信息，比如用md5算法hash后可以得到固定的128位的值，这样加密解密过程就会快很多。</p>
<h2 id="每次进行HTTPS请求时都必须在SSL-TLS层进行握手传输密钥吗？"><a href="#每次进行HTTPS请求时都必须在SSL-TLS层进行握手传输密钥吗？" class="headerlink" title="每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗？"></a>每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗？</h2><p>不是。服务端会为每个客户端维护一个 <strong>session ID</strong>，在建立SSL会话阶段传给客户端，客户端把生成好的对称密码发送个服务端后，服务端会把对称密码保存到对应的session ID下面，之后客户端每次请求都会携带session ID，服务端根据session ID去找到对称密码进行加密和解密，这样就不必要每次重新制作、传输密钥了！</p>
<h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><h2 id="缓存定义"><a href="#缓存定义" class="headerlink" title="缓存定义"></a>缓存定义</h2><p>浏览器缓存机制，也叫HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的。</p>
<p>浏览器缓存就是把一个已经请求过的资源（如html页面，图片，JS，数据）拷贝一份放在浏览器中。当下一个请求到来的时候，如果是相同的URL，浏览器会根据缓存机制决定是直接从缓存中获取资源还是向服务器再次发起请求。</p>
<p>使用浏览器缓存的原因：</p>
<ul>
<li>减少网络延迟：缓存的使用可以明显加快页面打开速度，达到更好的用户体验。</li>
<li>减少网络带宽消耗：从缓存中获取资源只会产生极小的网络流量，可以有效降低运营成本。</li>
<li>降低服务器压力：缓存可以减少对服务器的请求</li>
</ul>
<h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>缓存位置有以下四种，按照顺序查找缓存：</p>
<ul>
<li><p><strong>Service Worker</strong>：Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。Service Worker可以自由的控制哪些文件可以缓存，如何读取缓存，缓存的持续时间等等；</p>
</li>
<li><p><strong>Memory Cache</strong>：将资源缓存到内存中，读取速度快，但是容量小，并且持续性短，当页面关闭的时候内存就会被释放。当刷新页面的时候，很多资源都是来自内存。一般脚本、字体、图片会存在内存当中。</p>
</li>
<li><p><strong>Disk Cache</strong>：将资源缓存到磁盘中，读取速度慢，但是容量大，持续时间长，一般非脚本会存在磁盘当中，如css等。</p>
</li>
<li><p><strong>Push Cache</strong>：推送缓存，只在会话(session)中存在，一旦会话结束就会释放。</p>
</li>
</ul>
<p>如果以上四种缓存都没有找到的话，那么只能发起请求来获取资源了。</p>
<h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><p>浏览器在第一次请求资源后，会获取到请求的结果以及缓存规则。接下来，浏览器会根据第一次请求返回的响应头来确定缓存处理的方式，分别是强缓存和协商缓存。</p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存：不会向服务端发送请求，直接从缓存中读取资源，但是会返回200状态码。</p>
<p>我们第一次进入页面，请求服务器，然后服务器进行应答，浏览器会根据response Header来判断是否对资源进行缓存，如果响应头中有Expires或者Cache-Control字段，代表这是强缓存，浏览器就会把资源缓存下来。</p>
<ul>
<li><p><strong>Expires</strong><br>  服务器响应消息头字段，HTTP1.0的规范，指明缓存失效时间，是一个绝对时间。<br>  <strong>缺点</strong>：由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。</p>
</li>
<li><p><strong>Cache-Control</strong><br>服务器响应消息头字段，HTTP1.1的规范，指明缓存失效时间，是一个相对时间。</p>
<ul>
<li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）；</li>
<li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值；</li>
<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存；</li>
<li>no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。</li>
<li>max-age=N：缓存内容将在N秒后失效；</li>
</ul>
</li>
</ul>
<p><strong>Expires和Cache-Control两者对比</strong><br>两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来决定是否使用缓存的过程。<br><strong>Etag 的优先级高于 Last-Modified。</strong></p>
<ul>
<li><p><strong>Last-Modified / If-Modified-Since</strong><br>  Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。</p>
<p>  If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。</p>
<p>  服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件。</p>
<p>  <strong>缺点</strong>：最小粒度只到 s， s 以内的改动无法检测到；周期性变化，如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为，因此便有了 ETag。</p>
</li>
<li><p><strong>Etag / If-None-Match</strong><br>  Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)。</p>
<p>  If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。</p>
<p>  服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://s2.loli.net/2022/04/08/r3aKd8AXDskNhUQ.jpg" alt=""></p>
<h2 id="缓存实践"><a href="#缓存实践" class="headerlink" title="缓存实践"></a>缓存实践</h2><ul>
<li><p><strong>频繁变动的资源</strong>：使用 Cache-Control:no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p>
</li>
<li><p><strong>不常变化的资源</strong>：给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。</p>
</li>
</ul>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>浏览器有一个同源策略的安全功能，若协议、域名(主域名+子域名)和端口号都相同才属于同源，当不同源的客户端脚本在没有明确授权的情况下读写对方的资源，就会产生跨域问题。<br><img src="https://s2.loli.net/2022/03/30/WBnX4xbrh2tGCwg.png" alt=""></p>
<p>注意：<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> = <a href="http://www.baidu.com:80" target="_blank" rel="noopener">http://www.baidu.com:80</a> ，http协议默认端口号就是80，https默认端口号是443.</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>以下是解决跨域的方法，前四种是最常用的方法，后面的方法了解即可。</p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p><strong>CORS</strong>：跨域资源分享的缩写，是解决跨域的根本方法，支持任何类型的请求，需要服务端和浏览器同时支持。</p>
<p><strong>CORS方法</strong>：<br>普通跨域请求 —— 服务端在响应头上添加<code>Access-Control-Allow-Origin</code>属性，指定同源策略的地址，可以使用通配符  *；</p>
<p>带cookie的跨域请求 —— 前后端都需要设置，前端设置<code>widthCredentials</code>是否带cookie，服务端设置<code>Access-Control-Allow-Origin</code>，这里不可以使用通配符 *，必须指定同源策略的地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; axios</span><br><span class="line">axios.default.widthCredentials &#x3D; true</span><br></pre></td></tr></table></figure>

<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<ul>
<li><strong>简单请求</strong>：只要同时满足以下两大条件，就属于简单请求：<br>条件一：请求方法为 GET POST HEAD 三个之一；<br>条件二：HTTP的头信息不超出以下几种字段：<ul>
<li>Accept  </li>
<li>Accept-Language  </li>
<li>Content-Language  </li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
</li>
</ul>
<p>对于简单请求，浏览器直接发出CORS请求，就是在头信息之中，增加一个Origin字段。Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">&#x2F;&#x2F; 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。</span><br><span class="line">&#x2F;&#x2F; 设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。</span><br><span class="line">&#x2F;&#x2F; 这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">&#x2F;&#x2F; 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：</span><br><span class="line">&#x2F;&#x2F; Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma</span><br><span class="line">&#x2F;&#x2F; 如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>非简单请求</strong>：不满足简单请求条件的都是非简单请求。<br>对于非简单请求，会在正式通信之前，增加一次HTTP查询请求，称为<strong>“预检”请求</strong>（preflight）。</li>
</ul>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<h3 id="Node中间件代理"><a href="#Node中间件代理" class="headerlink" title="Node中间件代理"></a>Node中间件代理</h3><p>node中间件实现跨域代理，是通过启动一个代理服务器，实现数据的转发。<br>实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</p>
<ul>
<li>非Vue框架<br>使用 node + express + http-proxy-middleware 搭建一个proxy服务器</li>
<li>Vue框架<br>使用 node + webpack + webpack-dev-server 代理接口跨域<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack vec-cli 配置proxy代理如下：</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        host: &#39;0.0.0.0&#39;,</span><br><span class="line">        port: 8000,</span><br><span class="line">        open: true,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            &#39;&#x2F;market&#39;: &#123;</span><br><span class="line">                target: &#96;http:&#x2F;&#x2F;wxdev6.600280.com&#96;,</span><br><span class="line">                changeOrigin: true,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    &#39;^&#x2F;market&#39;: &#39;&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        disableHostCheck: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Nignx反向代理"><a href="#Nignx反向代理" class="headerlink" title="Nignx反向代理"></a>Nignx反向代理</h3><p>实现原理类似于Node中间件代理，需要搭建一个中转nginx服务器，用于转发请求。</p>
<p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP，填充式JSON，适合老版本的浏览器，只支持get请求。</p>
<p><strong>JSONP原理</strong>：利用 script 标签没有跨域限制的漏洞，通过script标签引入JS文件，这个JS文件载入成功后会执行我们在url参数中指定的函数，并且把需要的json数据作为入参传入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 原生实现</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var sc &#x3D; document.createElement(&#39;script&#39;)</span><br><span class="line">    sc.type &#x3D; &#39;text&#x2F;javascript&#39;</span><br><span class="line">    sc.src &#x3D; &#39;http:&#x2F;&#x2F;www.domain.com:8080&#x2F;login?user&#x3D;admin&amp;callback&#x3D;onBack&#39;</span><br><span class="line">    document.head.appendChild(sc)</span><br><span class="line">    &#x2F;&#x2F; 回调函数执行</span><br><span class="line">    function onBack(res)&#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F; 封装成功公共方法</span><br><span class="line">function jsonp(url, params, jsonpCallback) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        const script &#x3D; document.createElement(&#39;script&#39;)</span><br><span class="line">        let arrs &#x3D; []</span><br><span class="line">        for (let key in params) &#123;</span><br><span class="line">            arrs.push(&#96;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;)</span><br><span class="line">        &#125;</span><br><span class="line">        script.src &#x3D; &#96;$&#123;url&#125;?$&#123;arrs.join(&#39;&amp;&#39;)&#125;&#96;</span><br><span class="line">        script.async &#x3D; true</span><br><span class="line">        script.type &#x3D; &#39;text&#x2F;javascript&#39;</span><br><span class="line">        window[jsonpCallback] &#x3D; function(data) &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">            document.body.removeChild(script)</span><br><span class="line">        &#125;</span><br><span class="line">        document.body.appendChild(script)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 公共方法使用</span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;say&#39;,</span><br><span class="line">  params: &#123; wd: &#39;Iloveyou&#39; &#125;,</span><br><span class="line">  callback: &#39;show&#39;</span><br><span class="line">&#125;).then(data &#x3D;&gt; &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="WebScoket"><a href="#WebScoket" class="headerlink" title="WebScoket"></a>WebScoket</h3><p>WebSocket 协议是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯。</p>
<h3 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain+iframe"></a>document.domain+iframe</h3><p>这个方案仅限于主域相同，子域不同的跨域场景。</p>
<p>实现原理：两个页面都通过JS强制设置document.domain为基础主域，就实现了同域。</p>
<p>注意：子窗口只能获取父窗口的cookie和iframe数据，localstorage和indexDB的数据获取不到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父窗口</span><br><span class="line">&lt;iframe id&#x3D;&quot;iframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;child.domain.com&#x2F;b.html&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.domain &#x3D; &#39;domain.com&#39;</span><br><span class="line">var user &#x3D; &#39;admin&#39;</span><br><span class="line">document.cookie&#x3D;&quot;userId&#x3D;0001&quot;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子窗口</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.domain &#x3D; &#39;domain.com&#39;</span><br><span class="line">&#x2F;&#x2F; 获取父窗口的数据</span><br><span class="line">cosole.log(window.parent.user)</span><br><span class="line">cosole.log(document.cookie)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>还有 postMessage、window.name+iframe、document.hash+iframe等方法，这里不再一一赘述，平时开发用不到。</p>
<h1 id="安全-XSS-CSRF"><a href="#安全-XSS-CSRF" class="headerlink" title="安全(XSS CSRF)"></a>安全(XSS CSRF)</h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>XSS(Cross-Site Scripting)，跨站脚本攻击，是一种代码注入攻击，攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p>
<p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p>
<p><strong>任何可以输入的地方都有可能引起XSS，包括URL！</strong></p>
<p>为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li><strong>存储型XSS</strong></li>
</ol>
<ul>
<li>攻击者将恶意代码提交到目标网站的数据库中。</li>
<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ul>
<ol start="2">
<li><strong>反射型XSS</strong></li>
</ol>
<ul>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ul>
<ol start="3">
<li><strong>DOM型XSS</strong></li>
</ol>
<ul>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li>用户打开带有恶意代码的 URL。</li>
<li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ul>
<p>三种XSS对比：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">存储区</th>
<th align="center">插入点</th>
<th align="center">常见操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储型XSS</td>
<td align="center">后端数据库</td>
<td align="center">响应HTML</td>
<td align="center">常见于带有用户保存数据的功能的网站</td>
</tr>
<tr>
<td align="center">反射型XSS</td>
<td align="center">URL</td>
<td align="center">响应HTML</td>
<td align="center">常见于通过URL传递参数，如网站搜索、跳转等</td>
</tr>
<tr>
<td align="center">DOM型XSS</td>
<td align="center">后端数据库/前端存储/URL</td>
<td align="center">前端JavaScript</td>
<td align="center">常见于前端从浏览器某个地方直接获取内容中包含恶意代码</td>
</tr>
</tbody></table>
<h3 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h3><ol>
<li><strong>cookie设置HttpOnly属性</strong><br>后台在响应的头部设置HttpOnly属性，如果浏览器支持该属性的话，客户端就无法读取cookie的信息。</li>
<li><strong>输入过滤</strong><br>对于要输入的内容进行格式校验，比如手机号、邮箱等等，不仅前端要这么做，后端也需要，防止攻击者绕过正常的输入流程，直接利用接口向服务器发送相关配置。</li>
<li><strong>转义页面上的输入和输出内容</strong><br>如果前端需要拼接HTML，可以使用转义库将尖括号、引号、斜杠等进行转义，可以看一下这个<a href="https://jsxss.com/zh/index.html" target="_blank" rel="noopener"><strong>转义库</strong></a>。</li>
</ol>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>CSRF(Cross-site request forgery)，跨站请求伪造，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。如:攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ol>
<li><strong>get类型的CSRF</strong><br>用户访问某个页面中包含一张第三方网站的图片，浏览器会自动发送一个get请求给第三方网站。</li>
<li><strong>post类型的CSRF</strong><br>用户访问某个页面的时候，自动提交表单，模拟用户完成一次post操作。</li>
<li><strong>链接类型的CSRF</strong><br>这种CSRF并不常见，需要用户主动点击链接才会触发，常见的是以广告的形式引导用户点击。</li>
</ol>
<h3 id="防范方法-1"><a href="#防范方法-1" class="headerlink" title="防范方法"></a>防范方法</h3><ol>
<li><strong>验证码</strong><br>强制用户必须与应用进行交互，才能完成最终请求，但是用户体验差。</li>
<li><strong>请求校验</strong><br>在接口请求中都上token，<strong>token 验证的 CSRF 防御机制是公认最合适的方案</strong>。</li>
<li><strong>阻止外域访问</strong><br>同源检测，根据请求的Referer判断请求的来源。</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门</a><br><a href="https://zhuanlan.zhihu.com/p/43789231" target="_blank" rel="noopener">彻底搞懂HTTPS的加密原理</a><br><a href="https://juejin.cn/post/6947936223126093861" target="_blank" rel="noopener">前端浏览器缓存知识梳理</a><br><a href="https://blog.csdn.net/csdnnews/article/details/89324384" target="_blank" rel="noopener">彻底吃透浏览器的缓存机制！</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a><br><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">前端常见跨域解决方案（全）</a><br><a href="https://juejin.cn/post/6844903781704925191" target="_blank" rel="noopener">XSS攻击与CSRF攻击</a></p>
]]></content>
      <categories>
        <category>Web</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>大屏可视化开发</title>
    <url>/2020/09/10/%E5%A4%A7%E5%B1%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/07/28/00/57/bank-2547356_960_720.jpg" alt=""></p>
<a id="more"></a>

<h1 id="常用技术库"><a href="#常用技术库" class="headerlink" title="常用技术库"></a>常用技术库</h1><ul>
<li><a href="http://datav.jiaminghi.com/" target="_blank" rel="noopener"><strong>DataV</strong></a>：Vue 大屏数据展示组件库；</li>
<li><a href="https://echarts.apache.org/zh/index.html" target="_blank" rel="noopener"><strong>ECharts</strong></a>：基于JavaScript的开源可视化图标库；</li>
<li>ECharts社区Gallery：这里收录了许多很炫酷的图表示例，但是官方已经将其关闭，可以使用备份镜像；<br><a href="http://www.ppchart.com/#/" target="_blank" rel="noopener"><strong>PPChart</strong></a><br><a href="https://www.isqqw.com/#/homepage" target="_blank" rel="noopener"><strong>ECharts Demo集</strong></a></li>
<li><a href="https://lbs.amap.com/api/jsapi-v2/summary/" target="_blank" rel="noopener"><strong>高德地图开放平台API</strong></a></li>
<li><a href="https://lbsyun.baidu.com/index.php?title=jspopularGL" target="_blank" rel="noopener"><strong>百度地图开放平台API</strong></a></li>
</ul>
<h1 id="单位概念"><a href="#单位概念" class="headerlink" title="单位概念"></a>单位概念</h1><h2 id="视窗单位"><a href="#视窗单位" class="headerlink" title="视窗单位"></a>视窗单位</h2><ol>
<li>视窗单位主要包括以下4个：<ul>
<li>vw: 视窗宽度的百分比（1vw 代表视窗的宽度为 1%）；</li>
<li>vh：视窗高度的百分比；</li>
<li>vmin：当前 vw 和 vh 中较小的一个值；</li>
<li>vmax：当前 vw 和 vh 中较大的一个值。</li>
</ul>
</li>
</ol>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>
    vh 和 vw：相对于视口的高度和宽度，而不是父元素的（CSS百分比是相对于包含它的最近的父元素的高度和宽度）。1vh 等于1/100的视口高度，1vw 等于1/100的视口宽度。<br/>
    比如：浏览器高度950px，宽度为1920px, 1 vh = 950px/100 = 9.5 px，1vw = 1920px/100 =19.2 px。
</div>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>
    vmax相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmax。<br/>
    vmin相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin。<br/>
    比如：如果宽度设置为800px，高度设置为1080px，1vmin将会等于8px，而1vmax将会是10.8px。
</div>

<ol start="2">
<li>vw、vh 与 % 百分比的区别：<br>% 是相对于父元素的大小设定的比率，vw、vh 是视窗大小决定的。<br>vw、vh 优势在于能够直接获取高度，而用 % 在没有设置 body 高度的情况下，是无法正确获得可视区域的高度的。</li>
<li>vmin、vmax 用处：<br>做移动开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的。但是由于 vmin 和 vmax 是当前较小的 vw 和 vh 和当前较大的 vw 和 vh。这里就可以用到 vmin 和 vmax。使得文字大小在横竖屏下保持一致。</li>
</ol>
<h2 id="px、em、rem的区别"><a href="#px、em、rem的区别" class="headerlink" title="px、em、rem的区别"></a>px、em、rem的区别</h2><ul>
<li>px：固定长度单位，不随其它元素的变化而变化；</li>
<li>em：相对长度单位，相对于父级元素的单位，会随父级元素的属性（font-size或其它属性）变化而变化；</li>
<li>rem：是css3新增的一个相对长度单位，相对于根目录（HTML元素）的，它会随HTML元素的属性（font-size）变化而变化，一般用于自适应布局。</li>
</ul>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>
    一般来说，浏览器默认是：1em = 1rem = 16 px
</div>

<h2 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h2><ul>
<li><code>screen.width/height</code>：屏幕尺寸；</li>
<li><code>window.innerWidth/innerHeight</code>：浏览器窗口尺寸（包含滚动条）；</li>
<li><code>document.documentElement.clientWidth/clientHeight</code>：某个元素的尺寸（不包含滚动条），如果 <code>documentElement</code> 是 <code>&lt;html&gt;&lt;/html&gt;</code>，那么就是浏览器窗口尺寸（不包含滚动条）；</li>
<li><code>window.pageXOffset/pageYOffset</code>：滚动条滚出部分内容的宽高，在 IE 8 及之前版本的IE不支持，使用 <code>document.body.scrollLeft</code> 和 <code>document.body.scrollTop</code> 来取代；</li>
<li><code>viewport 视窗</code>：在桌面端，视窗指的是浏览器的可视区域，即 <code>window.innerWidth/window.innerHeight</code> 大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小；而在移动端，它涉及3个视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口），移动端指的就是Layout Viewport。</li>
</ul>
<h1 id="自适应方案-scale缩放"><a href="#自适应方案-scale缩放" class="headerlink" title="自适应方案 - scale缩放"></a>自适应方案 - scale缩放</h1><p>目前，最常见的大屏尺寸是16:9或者32:9，设计稿给出来的UI图的尺寸大多数是1920*1080（16:9）。</p>
<p>在日常开发中，如果按照设计稿的尺寸开发，16:9尺寸的大屏展示是没有问题的，但是考虑到<strong>兼容性</strong>问题，比如除了大屏之外，页面开发完成后一般需要先在笔记本上看一下效果，所以还要兼容不同尺寸的笔记本。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>以设计稿<strong>1920*1080</strong>为例，将页面容器 div 的宽高设置成 1920px 1080px；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置宽高</span><br><span class="line">setCss() &#123;</span><br><span class="line">  this.$refs.bigScreen.style.width &#x3D; &#96;1920px&#96;</span><br><span class="line">  this.$refs.bigScreen.style.height &#x3D; &#96;1080px&#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>根据屏幕尺寸大小设置缩放比例；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置缩放</span><br><span class="line">setScale() &#123;</span><br><span class="line">  const widthRadio &#x3D; document.body.clientWidth &#x2F; 1920</span><br><span class="line">  const heightRadio &#x3D; document.body.clientHeight &#x2F; 1080</span><br><span class="line">  &#x2F;&#x2F; 缩放一：取宽高最小缩放数作为缩放系数</span><br><span class="line">  &#x2F;&#x2F; 页面呈现效果：取heightRadio上下两侧出现留白，取widthRadio左右两侧出现留白</span><br><span class="line">  this.$refs.bigScreen.style.transform &#x3D; &#96;scale($&#123;Math.min(widthRadio,heightRadio)&#125;) translateX(-50%) translateY(-50%)&#96;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 缩放二：取widthRadio作为X轴的缩放系数，取heightRadio作为Y轴缩放系数</span><br><span class="line">  &#x2F;&#x2F; 页面呈现效果：不留白，平铺整个屏幕</span><br><span class="line">  this.$refs.bigScreen.style.transform &#x3D; &#96;scale($&#123;widthRadio&#125;,$&#123;heightRadio&#125;) translateX(-50%) translateY(-50%)&#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>防抖监听窗口大小变化，重新设置缩放比例。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&quot;resize&quot;,()&#x3D;&gt;&#123;</span><br><span class="line">  this.setScale()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>DataV中已经封装了一个全屏容器组件——<code>dv-full-screen-container</code>，里面已经实现了缩放的功能，但是该缩放不支持PC端，查看源码后，定义公共组件-<code>CustomerDiv</code>，重写缩放逻辑实现尺寸的兼容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref&#x3D;&quot;customer&quot; class&#x3D;&quot;customer-div&quot;&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;dv-full-screen-container&quot; :ref&#x3D;&quot;ref&quot;&gt;</span><br><span class="line">      &lt;template v-if&#x3D;&quot;ready&quot;&gt;</span><br><span class="line">        &lt;slot &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import autoResize from &#39;@jiaminghi&#x2F;data-view&#x2F;src&#x2F;mixin&#x2F;autoResize.js&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;CustomerDiv&#39;,</span><br><span class="line">  mixins: [autoResize],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      ref: &#39;full-screen-container&#39;,</span><br><span class="line">      allWidth: 0,</span><br><span class="line">      scale: 0,</span><br><span class="line">      datavRoot: &#39;&#39;,</span><br><span class="line">      ready: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    afterAutoResizeMixinInit() &#123;</span><br><span class="line">      const &#123; initConfig, setAppScale &#125; &#x3D; this</span><br><span class="line">      initConfig()</span><br><span class="line">      setAppScale()</span><br><span class="line">      this.ready &#x3D; true</span><br><span class="line">    &#125;,</span><br><span class="line">    initConfig() &#123;</span><br><span class="line">      const &#123; dom &#125; &#x3D; this</span><br><span class="line">      this.allWidth &#x3D; 1920</span><br><span class="line">      dom.style.width &#x3D; &#96;1920px&#96;</span><br><span class="line">      dom.style.height &#x3D; &#96;1080px&#96;</span><br><span class="line">    &#125;,</span><br><span class="line">    setAppScale() &#123;</span><br><span class="line">      const &#123; allWidth, dom &#125; &#x3D; this</span><br><span class="line">      const widthRadio &#x3D; document.body.clientWidth &#x2F; allWidth</span><br><span class="line">      const heightRadio &#x3D; document.body.clientHeight &#x2F; 1080</span><br><span class="line">      console.log(widthRadio, heightRadio)</span><br><span class="line">      &#x2F;&#x2F; 缩放一</span><br><span class="line">      dom.style.transform &#x3D; &#96;scale($&#123;Math.min(widthRadio,heightRadio)&#125;) translateX(-50%) translateY(-50%)&#96;</span><br><span class="line">      &#x2F;&#x2F; 缩放二</span><br><span class="line">      &#x2F;&#x2F; dom.style.transform &#x3D; &#96;scale($&#123;widthRadio&#125;,$&#123;heightRadio&#125;) translateX(-50%) translateY(-50%)&#96;</span><br><span class="line">    &#125;,</span><br><span class="line">    onResize() &#123;</span><br><span class="line">      const &#123; setAppScale &#125; &#x3D; this</span><br><span class="line">      setAppScale()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">.customer-div &#123;</span><br><span class="line">  width: 100vw;</span><br><span class="line">  height: 100vh;</span><br><span class="line">  background: #000;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">#dv-full-screen-container &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  transform-origin: left top;</span><br><span class="line">  z-index: 999;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h1 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h1><ul>
<li>通过meta标签，设置设备宽度以及缩放比例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1, minimum-scale&#x3D;1, user-scalable&#x3D;no&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li>安装 amfe-flexible<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm  install -S amfe-flexible &#x2F;&#x2F; 用于给根元素设置字体大小</span><br></pre></td></tr></table></figure></li>
<li>在 main.js 中引入 amfe-flexible<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;amfe-flexible&#x2F;index.js&#39;</span><br></pre></td></tr></table></figure></li>
<li>安装 postcss-pxtorem<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install postcss-pxtorem &#x2F;&#x2F; 用于将 px 转化为 rem</span><br></pre></td></tr></table></figure>

</li>
</ul>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>
    对于移动端来说，字体大小不需要使用 rem 来适配，使用 px 即可，在大屏手机上查看的时候显示更多的文本就可以了。
</div>

<h2 id="flexible-rem"><a href="#flexible-rem" class="headerlink" title="flexible+rem"></a>flexible+rem</h2><p>　　在项目根目录下的 postcss.config.js 文件里配置如下（1rem = 37.5px）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    autoprefixer: &#123;</span><br><span class="line">      overrideBrowserslist: [&#39;Android 4.1&#39;, &#39;iOS 7.1&#39;, &#39;Chrome &gt; 31&#39;, &#39;ff &gt; 31&#39;, &#39;ie &gt;&#x3D; 8&#39;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#39;postcss-pxtorem&#39;: &#123;</span><br><span class="line">      rootValue: 37.5,&#x2F;&#x2F;vant-UI的官方根字体大小是37.5</span><br><span class="line">      unitPrecision: 5,</span><br><span class="line">      propList: [&#39;*&#39;, &#39;!font-size&#39;, &#39;!border&#39;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>
    rootValue这个配置项, 通常根据ui图尺寸来定这个值。假如ui图尺寸给的宽度是750，我们通常就会把rootValue设置为75，这样我们写样式时，可以直接按照ui图尺寸标注的宽高来1:1还原开发。<br/>
    但是在此设为37.5，是为了引用vant、mint-ui等第三方UI框架，因为第三方框架没有兼容rem，用的是px单位，将rootValue的值设置为设计图宽度（这里为750px）75的一半，即可以1:1还原vant、mint-ui的组件，否则会样式会有变化，例如按钮会变小。<br/>
    设置成了37.5后，我们在根据ui图设置样式时要将值改为设计图的一半。
</div>

<h2 id="amfe-flexible-和-lib-flexible"><a href="#amfe-flexible-和-lib-flexible" class="headerlink" title="amfe-flexible 和 lib-flexible"></a>amfe-flexible 和 lib-flexible</h2><p>　　amfe-flexible 是在 lib-flexible 的基础上进行开发，lib-flexible 目前已经不再维护，所以选择使用 amfe-flexible。该组件中有一个 index.js 文件，通过 js 动态修改 body 的font-size，然后 postcss-pxtorem 将 px 转换成 rem ，rem 的值根据 body 的 font-size 改变，以此来实现屏幕适配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function flexible (window, document) &#123;</span><br><span class="line">  var docEl &#x3D; document.documentElement</span><br><span class="line">  var dpr &#x3D; window.devicePixelRatio || 1</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; adjust body font size</span><br><span class="line">  function setBodyFontSize () &#123;</span><br><span class="line">    if (document.body) &#123;</span><br><span class="line">      document.body.style.fontSize &#x3D; (12 * dpr) + &#39;px&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      document.addEventListener(&#39;DOMContentLoaded&#39;, setBodyFontSize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setBodyFontSize();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; set 1rem &#x3D; viewWidth &#x2F; 10</span><br><span class="line">  function setRemUnit () &#123;</span><br><span class="line">    var rem &#x3D; docEl.clientWidth &#x2F; 10</span><br><span class="line">    docEl.style.fontSize &#x3D; rem + &#39;px&#39;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setRemUnit()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; reset rem unit on page resize</span><br><span class="line">  window.addEventListener(&#39;resize&#39;, setRemUnit)</span><br><span class="line">  window.addEventListener(&#39;pageshow&#39;, function (e) &#123;</span><br><span class="line">    if (e.persisted) &#123;</span><br><span class="line">      setRemUnit()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; detect 0.5px supports</span><br><span class="line">  if (dpr &gt;&#x3D; 2) &#123;</span><br><span class="line">    var fakeBody &#x3D; document.createElement(&#39;body&#39;)</span><br><span class="line">    var testElement &#x3D; document.createElement(&#39;div&#39;)</span><br><span class="line">    testElement.style.border &#x3D; &#39;.5px solid transparent&#39;</span><br><span class="line">    fakeBody.appendChild(testElement)</span><br><span class="line">    docEl.appendChild(fakeBody)</span><br><span class="line">    if (testElement.offsetHeight &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">      docEl.classList.add(&#39;hairlines&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    docEl.removeChild(fakeBody)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(window, document))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>钉钉免登录</title>
    <url>/2020/08/26/%E9%92%89%E9%92%89%E5%85%8D%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2020/03/25/14/57/orbs-4967554_960_720.jpg" alt=""></p>
<a id="more"></a>

<h1 id="钉钉内部微应用免登"><a href="#钉钉内部微应用免登" class="headerlink" title="钉钉内部微应用免登"></a>钉钉内部微应用免登</h1><p>　　具体官方文档查看<a href="https://ding-doc.dingtalk.com/doc#/dev/ep7bpq" target="_blank" rel="noopener"><strong>H5微应用免登流程</strong></a></p>
<ol>
<li>安装钉钉 API<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install dingtalk-jsapi –save</span><br></pre></td></tr></table></figure></li>
<li>引入钉钉 API<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as dd from &#39;dingtalk-jsapi&#39;;</span><br></pre></td></tr></table></figure></li>
<li>获取微应用免登授权码，再根据免登授权码 code 登录应用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const ddLogin &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">        axios.post(&#39;&#x2F;api&#x2F;dtalk&#x2F;getDingParam&#39;).then((res)&#x3D;&gt;&#123;</span><br><span class="line">            if (res.data.code &#x3D;&#x3D; &#39;0000&#39;) &#123;</span><br><span class="line">                let corpId &#x3D; res.data.data.corpId;&#x2F;&#x2F; 公司的 corpId</span><br><span class="line">                dd.ready(function() &#123;</span><br><span class="line">                    &#x2F;&#x2F; 获取微应用免登授权码</span><br><span class="line">                    dd.runtime.permission.requestAuthCode(&#123;</span><br><span class="line">                        corpId: corpId, &#x2F;&#x2F; 企业id</span><br><span class="line">                        onSuccess: function (info) &#123;</span><br><span class="line">                            let code &#x3D; info.code; &#x2F;&#x2F; 通过该免登授权码可以获取用户身份</span><br><span class="line">                            axios(&#123;</span><br><span class="line">                                method: &#39;post&#39;,</span><br><span class="line">                                url: &#39;&#x2F;api&#x2F;dtalkLogin&#39;, &#x2F;&#x2F; 路径</span><br><span class="line">                                data: &#123;</span><br><span class="line">                                    code</span><br><span class="line">                                &#125;,</span><br><span class="line">                                transformRequest: [function (data) &#123;</span><br><span class="line">                                    let ret &#x3D; &#39;&#39;;</span><br><span class="line">                                    ret &#x3D; qs.stringify(data);</span><br><span class="line">                                    return ret;</span><br><span class="line">                                &#125;],</span><br><span class="line">                                headers: &#123;</span><br><span class="line">                                    &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;).then(res&#x3D;&gt;&#123;</span><br><span class="line">                                if(res.data.code &#x3D;&#x3D; &#39;0000&#39;)&#123;</span><br><span class="line">                                    setLocalStorage(&#39;token&#39;,res.data.data.token.token);</span><br><span class="line">                                    setLocalStorage(&quot;curl&quot;, res.data.data.permission);</span><br><span class="line">                                    setLocalStorage(&quot;grider&quot;, res.data.data.grider);</span><br><span class="line">                                    setLocalStorage(&quot;permissionDing&quot;, res.data.data.permissionDing);</span><br><span class="line">                                    setLocalStorage(&quot;level&quot;, res.data.data.level);</span><br><span class="line">                                    resolve(res.data);</span><br><span class="line">                                &#125;else&#123;</span><br><span class="line">                                    Toast(&#39;登录失败&#39;);</span><br><span class="line">                                    location.href &#x3D; localStorage.getItem(&quot;loginUrl&quot;);&#x2F;&#x2F;登录页</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125;,</span><br><span class="line">                        onFail: function (err) &#123;</span><br><span class="line">                            Toast(err.errorMessage);</span><br><span class="line">                            location.href &#x3D; localStorage.getItem(&quot;loginUrl&quot;);&#x2F;&#x2F;登录页</span><br><span class="line">                            reject();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Toast(&#39;登录失败&#39;);</span><br><span class="line">                location.href &#x3D; localStorage.getItem(&quot;loginUrl&quot;);&#x2F;&#x2F;登录页</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="钉钉扫码登录第三方网站"><a href="#钉钉扫码登录第三方网站" class="headerlink" title="钉钉扫码登录第三方网站"></a>钉钉扫码登录第三方网站</h1><p>　　具体官方文档查看<a href="https://ding-doc.dingtalk.com/doc#/serverapi2/kymkv6/jfDu3" target="_blank" rel="noopener"><strong>身份验证-扫码登录第三方网站</strong></a>，这里采用了官网中的方法二：支持网站将钉钉登录二维码内嵌到自己页面中。用户使用钉钉扫码登录后 JS 会将 loginTmpCode 返回给网站。JS 钉钉登录主要用途：网站希望用户在网站内就能完成登录，无需跳转到钉钉域下登录后再返回，提升钉钉登录的流畅性与成功率。<br>　　项目地址：<a href="http://lylobsysc.cet0570.com/gov/login.html#/" target="_blank" rel="noopener"><strong>龙游企情通登录页</strong></a><br><img src="https://i.loli.net/2020/08/26/TjmEkMUcNy5LSaR.gif" alt=""></p>
<ol>
<li>创建一个div，用于显示钉钉带过来的二维码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;scan_box&quot; id&#x3D;&quot;scan_box&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>
<li>通过公司的 appid 拿到二维码，用户扫码-扫码成功-跳转 ddLogin 页面登录应用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 重定向地址</span><br><span class="line">redirect_uri:window.location.href +&#39;ddLogin&#39;</span><br><span class="line">mounted()&#123;</span><br><span class="line">	this.codeLogin();</span><br><span class="line">&#125;,</span><br><span class="line">codeLogin()&#123;</span><br><span class="line">    let that &#x3D; this;</span><br><span class="line">    api.getQrDingParam().then(res&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F; console.log(res);</span><br><span class="line">        if(res.code &#x3D;&#x3D; &#39;0000&#39;)&#123;</span><br><span class="line">            &#x2F;&#x2F; 1.调用后台接口拿到公司的 appid</span><br><span class="line">            this.appid &#x3D; res.data.appId;</span><br><span class="line">            &#x2F;&#x2F; 2.在需要使用钉钉登录的地方实例以下 JS 对象</span><br><span class="line">            let obj &#x3D; DDLogin(&#123;</span><br><span class="line">                id: &#39;scan_box&#39;, &#x2F;&#x2F; 这里的 id 就是上面定义的用来存放二维码 div 的 id</span><br><span class="line">                goto: encodeURIComponent(&#39;https:&#x2F;&#x2F;oapi.dingtalk.com&#x2F;connect&#x2F;oauth2&#x2F;sns_authorize?appid&#x3D;&#39; + this.appid + &#39;&amp;response_type&#x3D;code&amp;scope&#x3D;snsapi_login&amp;state&#x3D;STATE&amp;redirect_uri&#x3D;&#39; + this.redirect_uri + &#39;&#39;),</span><br><span class="line">                style: &#39;border:none;background-color:#FFFFFF;&#39;,</span><br><span class="line">                &#x2F;&#x2F; 表示显示二维码的区域的宽、高，width 和 height 不代表二维码的大小，二维码大小是固定的210px*210px</span><br><span class="line">                width: &#39;220&#39;,</span><br><span class="line">                height: &#39;300&#39;</span><br><span class="line">            &#125;)</span><br><span class="line">            let hanndleMessage &#x3D; function (event) &#123;</span><br><span class="line">                let origin &#x3D; event.origin;</span><br><span class="line">                &#x2F;&#x2F; 判断是否来自 ddLogin 扫码事件</span><br><span class="line">                if (origin &#x3D;&#x3D;&#x3D; &#39;https:&#x2F;&#x2F;login.dingtalk.com&#39;) &#123;</span><br><span class="line">                    let loginTmpCode &#x3D; event.data;</span><br><span class="line">                    &#x2F;&#x2F; 这里 url 不用进行 urlencode 编码</span><br><span class="line">                    let url &#x3D; &#39;https:&#x2F;&#x2F;oapi.dingtalk.com&#x2F;connect&#x2F;oauth2&#x2F;sns_authorize?appid&#x3D;&#39; + that.appid + &#39;&amp;response_type&#x3D;code&amp;scope&#x3D;snsapi_login&amp;state&#x3D;STATE&amp;redirect_uri&#x3D;&#39; + that.redirect_uri + &#39;&amp;loginTmpCode&#x3D;&#39; + loginTmpCode;</span><br><span class="line">                    &#x2F;&#x2F; 跳转链接到新页面</span><br><span class="line">                    window.location.href &#x3D; url;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            if (typeof window.addEventListener !&#x3D;&#x3D; &#39;undefined&#39;) &#123; &#x2F;&#x2F; 添加事件</span><br><span class="line">                window.addEventListener(&#39;message&#39;, hanndleMessage, false)</span><br><span class="line">            &#125; else if (typeof window.attachEvent !&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">                window.attachEvent(&#39;onmessage&#39;, hanndleMessage)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return this.$message.error(res.msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>跳转到 ddLogin 页面后，后台会在新页面带上 code，根据 code 进行登录<br>　　此页面和登录页面相似，只是一个过渡页面，在二维码显示上面加了一个遮罩层，显示登录中，请稍后。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">    &#x2F;&#x2F; 由于该页面带上了后台返回的 code 和 state，所以重定向地址需要重写</span><br><span class="line">    this.redirect_uri &#x3D; location.origin + location.pathname ;</span><br><span class="line">    &#x2F;&#x2F; 获取后台返回的 code</span><br><span class="line">    this.code &#x3D; location.query.code;</span><br><span class="line">    if(this.code)&#123;</span><br><span class="line">        this.getdd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    this.codeLogin(); &#x2F;&#x2F; 和上面第二步同样的方法</span><br><span class="line">&#125;,</span><br><span class="line">getdd()&#123;</span><br><span class="line">    api.dtalkPcQrLogin(&#123;code:this.code&#125;).then(res&#x3D;&gt;&#123;</span><br><span class="line">        if (res.code &#x3D;&#x3D; &quot;0000&quot;) &#123;</span><br><span class="line">            setLocalStorage(&quot;token&quot;, res.data.token.token);</span><br><span class="line">            setLocalStorage(&quot;curl&quot;, res.data.permission);</span><br><span class="line">            setLocalStorage(&quot;department&quot;, res.data.department);</span><br><span class="line">            setLocalStorage(&quot;level&quot;, res.data.level);</span><br><span class="line">            setLocalStorage(&quot;grider&quot;, res.data.grider);</span><br><span class="line">            setLocalStorage(&quot;username&quot;, res.data.username);</span><br><span class="line">            setLocalStorage(&quot;name&quot;, res.data.realName);</span><br><span class="line">            setLocalStorage(&quot;permissionDing&quot;, res.data.permissionDing);</span><br><span class="line">            document.cookie &#x3D; &quot;token&#x3D;&quot; + res.data.token.token;</span><br><span class="line">            let arr &#x3D; JSON.parse(res.data.permission);</span><br><span class="line">            let item &#x3D; arr[0];</span><br><span class="line">            let child &#x3D; item.child[0];</span><br><span class="line">            &#x2F;&#x2F; 根据权限登录对应页面</span><br><span class="line">            if (item.url &amp;&amp; item.child.length&#x3D;&#x3D;0) &#123;</span><br><span class="line">                gotoGovURL(&#96;$&#123;item.url&#125;&#96;);</span><br><span class="line">            &#125; else if (child) &#123;</span><br><span class="line">                gotoGovURL(&#96;$&#123;item.url&#125;#&#x2F;$&#123;child.url&#125;&#96;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.$message(&#123;</span><br><span class="line">                message: res.msg,</span><br><span class="line">                type: &#39;warning&#39;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="钉钉免登2-0版本（专有钉钉）"><a href="#钉钉免登2-0版本（专有钉钉）" class="headerlink" title="钉钉免登2.0版本（专有钉钉）"></a>钉钉免登2.0版本（专有钉钉）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML文件引入api</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;g.alicdn.com&#x2F;gdt&#x2F;jsapi&#x2F;1.3.5&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接口</span><br><span class="line">&#x2F;&#x2F; 免登接口 authCode</span><br><span class="line">export const autoLogin &#x3D; (params) &#x3D;&gt; request.get(&#39;&#x2F;dtalk&#x2F;autoLogin&#39;, &#123; params &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 绑定用户</span><br><span class="line">export const loginAndBind &#x3D; (params) &#x3D;&gt; request.get(&#39;&#x2F;dtalk&#x2F;loginAndBind&#39;, &#123; params &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 退出登录-解绑</span><br><span class="line">export const exitAndRemove &#x3D; (params) &#x3D;&gt; request.get(&#39;&#x2F;dtalkExit&#x2F;exitAndRemove&#39;, &#123; params &#125;)</span><br><span class="line"></span><br><span class="line">**</span><br><span class="line"> * @description: 政务钉钉2.0版本迭代 api修改dd.runtime.permission.requestAuthCode-》dd.getAuthCode 接口修改&#x2F;api&#x2F;dtalkLogin -》&#x2F;api&#x2F;dtalkLoginV2</span><br><span class="line"> *               流程：dd.getAuthCode 钉钉api 获取钉钉免登授权码》》》&#x2F;dtalk&#x2F;user&#x2F;dtalkLogin通过免登授权码获取用户信息</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const ddLoginV2 &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; console.log(&#39;ddLoginV2&#39;);</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; console.log(&#39;ddV2&#39;)</span><br><span class="line">    dd.ready(function() &#123;</span><br><span class="line">      &#x2F;&#x2F; console.log(&#39;ddV2 进&#39;)</span><br><span class="line">      dd.getAuthCode().then((result) &#x3D;&gt; &#123;</span><br><span class="line">        let authCode &#x3D; result.code</span><br><span class="line">        console.log(result)</span><br><span class="line">        &#x2F;&#x2F; 通过该免登授权码可以获取用户身份</span><br><span class="line">        autoLogin(&#123; authCode &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; console.log(&#39;dtalkLoginV2接口返回信息&#39;,res)</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125;).catch(() &#x3D;&gt; &#123;</span><br><span class="line">          Toast(&#39;免登失败，请重新登录绑定&#39;)</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            location.href &#x3D; &#39;&#x2F;dd.html#&#x2F;login&#39;&#x2F;&#x2F; 登录页</span><br><span class="line">          &#125;, 1500)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      return false</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">&#x2F;&#x2F; 1. 默认进入首页</span><br><span class="line">mounted() &#123;</span><br><span class="line">    &#x2F;&#x2F; 免登</span><br><span class="line">    ddLoginV2().then(res &#x3D;&gt; &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">      setLocalStorage(&#39;token&#39;, res.access_token)</span><br><span class="line">      setLocalStorage(&#39;nickNameCn&#39;, res.dtalkUserInfo)</span><br><span class="line">      setLocalStorage(&#39;accountId&#39;, res.dtalkId)</span><br><span class="line">      setLocalStorage(&#39;clientId&#39;, res.clientId)</span><br><span class="line">      setLocalStorage(&#39;lastName&#39;, res.lastName)</span><br><span class="line">      setToken(res.access_token)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; 退出登录</span><br><span class="line">    logout() &#123;</span><br><span class="line">      this.$dialog.confirm(&#123;</span><br><span class="line">        title: &#39;提示&#39;,</span><br><span class="line">        message: &#39;是否确定退出登录？&#39;</span><br><span class="line">      &#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 接除绑定</span><br><span class="line">        exitAndRemove().then(res &#x3D;&gt; &#123;</span><br><span class="line">          this.$router.push(&#39;login&#39;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;).catch(() &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; on cancel</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.登录</span><br><span class="line">methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; 登录</span><br><span class="line">    login() &#123;</span><br><span class="line">      if (!this.username || !this.password) return</span><br><span class="line">      login(&#123;</span><br><span class="line">        username: this.username,</span><br><span class="line">        password: this.password,</span><br><span class="line">        source: 1</span><br><span class="line">      &#125;).then(response &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 重新获取免登授权码</span><br><span class="line">        dd.getAuthCode().then((result) &#x3D;&gt; &#123;</span><br><span class="line">          let code &#x3D; result.code</span><br><span class="line">          let pwd &#x3D; this.password</span><br><span class="line">          loginAndBind(&#123;</span><br><span class="line">            userName: this.username,</span><br><span class="line">            password: md5(pwd),</span><br><span class="line">            authCode: code</span><br><span class="line">          &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">            setLocalStorage(&#39;token&#39;, res.access_token)</span><br><span class="line">            setLocalStorage(&#39;nickNameCn&#39;, res.dtalkUserInfo)</span><br><span class="line">            setLocalStorage(&#39;accountId&#39;, res.dtalkId)</span><br><span class="line">            setLocalStorage(&#39;clientId&#39;, res.clientId)</span><br><span class="line">            setLocalStorage(&#39;lastName&#39;, res.lastName)</span><br><span class="line">            setToken(res.access_token)</span><br><span class="line">            this.$notify(&#123; type: &#39;success&#39;, message: &#39;绑定成功&#39; &#125;)</span><br><span class="line">            this.$router.push(&#39;dashboard&#39;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>代码地址：<a href="https://gitee.com/crystalSummer/record-code/tree/master/ddAutoLogin" target="_blank" rel="noopener"><strong>钉钉免登2.0版本（专有钉钉）</strong></a></p>
]]></content>
      <categories>
        <category>H5</category>
        <category>钉钉</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>钉钉</tag>
      </tags>
  </entry>
  <entry>
    <title>常用工具库记录</title>
    <url>/2020/07/02/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/11/04/11/25/fog-2917232_960_720.jpg" alt=""></p>
<a id="more"></a>

<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ol>
<li><p>地图综合神器：<a href="https://mapshaper.org/" target="_blank" rel="noopener"><strong>https://mapshaper.org/</strong></a><br>对地图数据进行简化和格式转换，目前支持Shapefile、GeoJSON、TopoJSON三种数据格式。</p>
</li>
<li><p>地图拾取器：<br><a href="http://datav.aliyun.com/tools/atlas/#&lat=30.332329214580188&lng=106.72278672066881&zoom=3.5" target="_blank" rel="noopener"><strong>http://datav.aliyun.com/tools/atlas/#&amp;lat=30.332329214580188&amp;lng=106.72278672066881&amp;zoom=3.5</strong></a><br>用于获取国、省、市、区的经纬度数据，但是获取不到镇街的经纬度数据，经纬度数据来源于高德地图。</p>
</li>
<li><p>geojson.io：<a href="http://geojson.io/" target="_blank" rel="noopener"><strong>http://geojson.io/</strong></a><br>在线生成地图 GeoJSON 数据。</p>
</li>
<li><p>bigemap：<a href="http://www.bigemap.com/" target="_blank" rel="noopener"><strong>官网</strong></a><br>谷歌地图、高清卫星地图下载器，功能很全，但是常用于获取镇街的经纬度数据，在地图下载器-&gt;行政区划边界（省市县乡镇）里面介绍了具体的操作步骤。这个软件如果要下载地图要正版授权，但如果只是用导出选择区域 kml 文件功能是不需要授权的，可以直接免费使用，将导出的的 kml 文件导入到 <a href="http://geojson.io/" target="_blank" rel="noopener">geojson.io</a> 网站，左边就会显示地图区域，右边就是该区域的 GeoJSON 数据，多个镇街数据挨个导入就可以了。</p>
</li>
<li><p>JSON校验格式化工具：<a href="https://www.bejson.com/" target="_blank" rel="noopener"><strong>https://www.bejson.com/</strong></a><br>有JSON工具，在线加密解密、前端、后端等工具。</p>
</li>
<li><p>自制icon：<a href="https://favicon.io/" target="_blank" rel="noopener"><strong>https://favicon.io/</strong></a><br>可以将图片、文字、表情等制作成icon。</p>
</li>
<li><p>tinypng：<a href="https://tinypng.com/" target="_blank" rel="noopener"><strong>https://tinypng.com/</strong></a><br>用于将图片进行压缩。</p>
</li>
<li><p>Tampermonkey<br>&emsp;&emsp;<a href="https://www.tampermonkey.net/index.php?ext=dhdg&show=dhdg" target="_blank" rel="noopener"><strong>Tampermonkey</strong></a>，油猴，它是一款浏览器插件，它之所以强大是因为这款插件可以安装和管理各种用户脚本。用户脚本就是一段代码，可以优化你的浏览器体验，实现很多自动化的操作，让网站变得更加易用，比如广告过滤、自动翻译等等。油猴支持各大浏览器。可以去官网下载油猴插件，并添加到扩展程序中。<br>&emsp;&emsp;网上脚本有很多，但是要注意安全性，这里推荐<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener"><strong>Greasy Fork</strong></a>来下载脚本，这个网站相对来说比较安全，但是也不要乱下载脚本，脚本里面可能包含获取你用户信息的程序。</p>
</li>
</ol>
<h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><ol>
<li><p>ECharts示例库：<a href="https://www.makeapie.com/explore.html#sort=rank~timeframe=all~author=all" target="_blank" rel="noopener"><strong>ECharts gallery</strong></a></p>
</li>
<li><p>免费无版权图片素材库：<a href="https://pixabay.com/zh/" target="_blank" rel="noopener"><strong>https://pixabay.com/zh/</strong></a></p>
</li>
<li><p>不同类型的随机图片库：<br><a href="https://source.unsplash.com/" target="_blank" rel="noopener"><strong>https://source.unsplash.com/</strong></a>，<br><a href="https://picsum.photos/" target="_blank" rel="noopener"><strong>https://picsum.photos/</strong></a>，<br>以上两个图片库都可以拿到随机图片，但是第二个库要比第一个库更为强大，可以模糊图片和给图片加上灰色调。</p>
</li>
<li><p>中华珍宝馆：<a href="http://www.ltfc.net/" target="_blank" rel="noopener"><strong>http://www.ltfc.net/</strong></a><br>中国古画库。</p>
</li>
<li><p>markdown用法参考：<a href="https://www.zybuluo.com/mdeditor?url=https%3A%2F%2Fwww.zybuluo.com%2Fstatic%2Feditor%2Fmd-help.markdown#12" target="_blank" rel="noopener"><strong>Cmd Markdown 简明语法手册</strong></a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Other</category>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Other</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>Base64</title>
    <url>/2020/05/21/Base64/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2019/09/06/12/08/bridge-4456255_960_720.jpg" alt=""></p>
<a id="more"></a>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>　　Base64是一种编码算法。为什么叫做Base64呢？因为这种算法只支持64个可打印字符。ASCII码的范围是0-127，其中0-31和127这33个字符属于控制字符（Controlcharacters）。剩下32-126这95个字符属于可打印字符（Printable characters）,包含数字、大小写字母、常用符号。</p>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>
   Base64只是一种编码算法，而非加密算法。任何人都可以将Base64的编码结果解码成唯一的原文。
</div>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ol>
<li>将字节转换成ASCII码：比如<code>s</code>对应的ASCII码就是<code>115</code>；</li>
<li>将ASCII码转换成二进制：<code>115</code>的二进制数是<code>0111 0011</code>，因为一个字节占8位，所以转换成8位二进制数；</li>
<li>将二进制数按6位一个划分，不足末位补0，但是每次补0需要补八个0，所以最后的位数应该是大于等于当前二进制位数的6和8的最小公倍数。比如当前位数为8，所以补位后长度应该是24，<code>0111 0011</code>划分完成后就是<code>011100 110000 000000 000000</code>；</li>
<li>将划分后的二进制数进行转换：非末位补位转换成十进制，末位补位转换成=；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">011100 110000 000000 000000</span><br><span class="line">  28     48     &#x3D;      &#x3D;</span><br></pre></td></tr></table></figure></li>
<li>将转换后的十进制数按照数据字典找到对应的字符，如下表格所示，28对应c，48对应w，所以s进行base64编码后就是cw==。<table>
<thead>
<tr>
<th align="center">索引</th>
<th align="center">对应字符</th>
<th align="center">索引</th>
<th align="center">对应字符</th>
<th align="center">索引</th>
<th align="center">对应字符</th>
<th align="center">索引</th>
<th align="center">对应字符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">A</td>
<td align="center">16</td>
<td align="center">Q</td>
<td align="center">32</td>
<td align="center">g</td>
<td align="center">48</td>
<td align="center">w</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">B</td>
<td align="center">17</td>
<td align="center">R</td>
<td align="center">33</td>
<td align="center">h</td>
<td align="center">49</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">C</td>
<td align="center">18</td>
<td align="center">S</td>
<td align="center">34</td>
<td align="center">i</td>
<td align="center">50</td>
<td align="center">y</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">D</td>
<td align="center">19</td>
<td align="center">T</td>
<td align="center">35</td>
<td align="center">j</td>
<td align="center">51</td>
<td align="center">z</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">E</td>
<td align="center">20</td>
<td align="center">U</td>
<td align="center">36</td>
<td align="center">k</td>
<td align="center">52</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">F</td>
<td align="center">21</td>
<td align="center">V</td>
<td align="center">37</td>
<td align="center">l</td>
<td align="center">53</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">G</td>
<td align="center">22</td>
<td align="center">W</td>
<td align="center">38</td>
<td align="center">m</td>
<td align="center">54</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">H</td>
<td align="center">23</td>
<td align="center">X</td>
<td align="center">39</td>
<td align="center">n</td>
<td align="center">55</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">I</td>
<td align="center">24</td>
<td align="center">Y</td>
<td align="center">40</td>
<td align="center">o</td>
<td align="center">56</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">J</td>
<td align="center">25</td>
<td align="center">Z</td>
<td align="center">41</td>
<td align="center">p</td>
<td align="center">57</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">K</td>
<td align="center">26</td>
<td align="center">a</td>
<td align="center">42</td>
<td align="center">q</td>
<td align="center">58</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">L</td>
<td align="center">27</td>
<td align="center">b</td>
<td align="center">43</td>
<td align="center">r</td>
<td align="center">59</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">M</td>
<td align="center">28</td>
<td align="center">c</td>
<td align="center">44</td>
<td align="center">s</td>
<td align="center">60</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">N</td>
<td align="center">29</td>
<td align="center">d</td>
<td align="center">45</td>
<td align="center">t</td>
<td align="center">61</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">O</td>
<td align="center">30</td>
<td align="center">e</td>
<td align="center">46</td>
<td align="center">u</td>
<td align="center">62</td>
<td align="center">+</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">P</td>
<td align="center">31</td>
<td align="center">f</td>
<td align="center">47</td>
<td align="center">v</td>
<td align="center">63</td>
<td align="center">/</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol>
<li>安装 <code>js-base64</code>:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save js-base64</span><br></pre></td></tr></table></figure></li>
<li>单独使用：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Base64 &#125; from &#39;js-base64&#39;</span><br><span class="line">&#x2F;&#x2F; 编码</span><br><span class="line">Base64.encode(&#39;123456&#39;) &#x2F;&#x2F; MTIzNDU2</span><br></pre></td></tr></table></figure></li>
<li>全局使用：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在main.js里面</span><br><span class="line">import base64 from &#39;js-base64&#39;;</span><br><span class="line">Vue.prototype.$base64 &#x3D; base64;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 编码</span><br><span class="line">this.$base64.encode(&#39;123456&#39;) &#x2F;&#x2F; MTIzNDU2</span><br></pre></td></tr></table></figure></li>
<li>常用方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Base64.encode(&#39;123456&#39;); &#x2F;&#x2F; 编码</span><br><span class="line">Base64.decode(&#39;MTIzNDU2&#39;); &#x2F;&#x2F; 解码</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Web</category>
        <category>编码算法</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>编码算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MD5</title>
    <url>/2020/05/15/MD5/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2019/10/14/20/09/nature-4549913_960_720.jpg" alt=""></p>
<a id="more"></a>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>　　MD5是哈希散列算法，对于MD5而言，有三个特性是很重要的：</p>
<ul>
<li>明文数据经过散列以后的值是定长的，32位；（MD5算法对输入任意长度的消息进行运行，产生一个128位的消息摘要，换算成十六进制，128/4=32位，对于网上说的16位等等，只是在32位的基础上进行字符串截取。）</li>
<li>任意一段明文数据，经过散列以后，其结果必须永远是不变的；（也就是一个原始数据，只对应一个MD5值；但是一个MD5值，可能对应多个原始数据。）</li>
<li>不可逆性保证了信息的安全性。（知道了MD5值后，是无法解密出原始数据的，只能用穷举法，把可能出现的明文，用MD5算法散列之后，把得到的散列值和原始的数据形成一个一对一的映射表，通过匹配从映射表中找出破解密码所对应的原始明文，还有就是暴力破解。）</li>
</ul>
<h1 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h1><p>　　MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由4个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p>
<ol>
<li>数据填充：<br>先对信息进行填充，使其字节长度对512求余数的结果等于448。设消息长度为X，即满足X mod 512=448，如果不满足，就对信息进行填充。填充的方法：在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。<br>因此，信息的字节长度将被扩展至<code>N*512+448</code>，即<code>N*64+56</code>个字节，N为整数。</li>
<li>添加信息长度：<br>将第一步得到的结果后面，附加一个值，这个值是以64位二进制表示的填充前的信息长度。此时<code>信息字节长度=N*512+448+64=(N+1)*512</code>，即长度恰好是512的整数倍数。这样做的原因是为满足后面处理中对信息长度的要求。</li>
<li>数据处理：<br>把消息以512位为一组进行分组处理，每一个分组进行4轮循环，以下面所说4个链接变量常数为起始变量进行计算，每次操作对A、B、C、D中的其中三个作一次非线性函数（即下面提到的四个函数）运算，然后将所得结果加上第四个变量，重新输出4个变量，以这4个变量再进行下一分组的运算，如果已经是最后一个分组，则这4个变量A、B、C、D为最后的结果，A是低位，D为高位，DCBA组成128位输出结果，换算成十六进制就是MD5值。需要用到的数据如下：<ul>
<li>4个链接变量常数：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &#x3D; 0x67452301</span><br><span class="line">B &#x3D; 0x0EFCDAB89</span><br><span class="line">C &#x3D; 0x98BADCFE</span><br><span class="line">D &#x3D; 0x10325476</span><br></pre></td></tr></table></figure></li>
<li>4个函数：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(X,Y,Z)&#x3D;(X &amp; Y) | ((~X) &amp; Z)</span><br><span class="line">G(X,Y,Z)&#x3D;(X &amp; Z) | (Y &amp; (~Z))</span><br><span class="line">H(X,Y,Z)&#x3D;X ^ Y ^ Z</span><br><span class="line">I(X,Y,Z)&#x3D;Y ^ (X | (~Z))</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><img src="https://i.loli.net/2020/08/15/DUK1XpoNeTBxMHt.png" alt=""></p>
<ol>
<li>安装 <code>js-md5</code>：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save js-md5</span><br></pre></td></tr></table></figure></li>
<li>单独使用：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import md5 from &#39;js-md5&#39;;</span><br><span class="line">md5(&#39;123456&#39;)  &#x2F;&#x2F; aac5f0d28478d9ea5ee6af4bba68c3bb</span><br></pre></td></tr></table></figure></li>
<li>全局使用：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在main.js里面</span><br><span class="line">import md5 from &#39;js-md5&#39;;</span><br><span class="line">Vue.prototype.$md5 &#x3D; md5;</span><br><span class="line"></span><br><span class="line">this.$md5(&#39;123456&#39;)  &#x2F;&#x2F; aac5f0d28478d9ea5ee6af4bba68c3bb</span><br></pre></td></tr></table></figure></li>
<li>常用方法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">md5(&#39;123456&#39;) &#x2F;&#x2F; aac5f0d28478d9ea5ee6af4bba68c3bb</span><br><span class="line">md5.hex(&#39;123456&#39;) &#x2F;&#x2F; aac5f0d28478d9ea5ee6af4bba68c3bb</span><br><span class="line">md5.array(&#39;123456&#39;) &#x2F;&#x2F; [170, 197, 240, 210, 132, 120, 217, 234, 94, 230, 175, 75, 186, 104, 195, 187]</span><br><span class="line">md5.digest(&#39;123456&#39;) &#x2F;&#x2F; [170, 197, 240, 210, 132, 120, 217, 234, 94, 230, 175, 75, 186, 104, 195, 187]</span><br><span class="line">md5.arrayBuffer(&#39;123456&#39;) &#x2F;&#x2F; ArrayBuffer(16) &#123;&#125;</span><br><span class="line">md5.buffer(&#39;123456&#39;) &#x2F;&#x2F; ArrayBuffer(16) &#123;&#125;</span><br><span class="line">md5.base64(&#39;123456&#39;) &#x2F;&#x2F; qsXw0oR42epe5q9LumjDuw&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><p>　　在目前的信息系统中，对MD5加密方法的利用主要通过在脚本页面中引用包含MD5加密函数代码的文件，如果将加密的MD5值直接保存在数据库，当网站存在注入或者其它漏洞时，入侵者极有可能获取用户的MD5值，通过MD5在线查询或者暴力破解可以得到明文。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ol>
<li>附加字符串：<br>在对明文进行加密之前，给明文附加一个内容确定的字符串（比如说用户名），然后再对明文进行加密，这样就可以针对性的防止穷举法破译MD5值。但是不可以用随机字串，因为这样会使原算法无法重现。</li>
<li>字符串次序干涉：<br>将明文的顺序按照统一的约定进行调转，然后在对明文加密。</li>
<li>签名验证：<br>安全性比较高的系统，都会对每个接口都进行了签名验证，防止被别人恶意攻击，频繁调用接口。这个需要前后端配合，商量出一套统一的方案，之前在做银行后台系统的时候，是将参数（除了接口的参数外还有几个固定的参数）按照字母从小到大的顺序拼接，然后在最后面加一个固定的字符串，最后将整个字符串进行MD5加密生成的就是签名，后台也会用同样的方法生成签名进行比对，来验证接口是否属于该平台。</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://github.com/emn178/js-md5" target="_blank" rel="noopener"><strong>js-md5 github</strong></a></li>
</ul>
]]></content>
      <categories>
        <category>Web</category>
        <category>加密算法</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>加密算法</tag>
      </tags>
  </entry>
  <entry>
    <title>高德地图常用操作</title>
    <url>/2020/03/02/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2019/05/14/21/50/storytelling-4203628_960_720.jpg" alt=""></p>
<a id="more"></a>
<h1 id="初始化地图"><a href="#初始化地图" class="headerlink" title="初始化地图"></a>初始化地图</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let amap &#x3D; null</span><br><span class="line">export const initAmap &#x3D; (id, opt)&#x3D;&gt; &#123;</span><br><span class="line">  amap &#x3D; new AMap.Map(</span><br><span class="line">    id,</span><br><span class="line">    Object.assign(</span><br><span class="line">      &#123;</span><br><span class="line">        resizeEnable: true,</span><br><span class="line">        center: [119.891, 28.3299], &#x2F;&#x2F; 中心点坐标</span><br><span class="line">        mapStyle: &#39;amap:&#x2F;&#x2F;styles&#x2F;d5364a675861fbc8e08d91b93773a5d5&#39;,</span><br><span class="line">        viewMode: &#39;3D&#39;,</span><br><span class="line">        zoom: 11,</span><br><span class="line">        pitch: 50</span><br><span class="line">      &#125;,</span><br><span class="line">      opt</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  return amap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3D楼宇"><a href="#3D楼宇" class="headerlink" title="3D楼宇"></a>3D楼宇</h1><p><img src="https://i.loli.net/2021/01/07/xV7iFSN4PWgLKEd.gif" alt=""></p>
<h2 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h2><ol>
<li><a href="https://lbs.amap.com/api/javascript-api/guide/object3d/mesh" target="_blank" rel="noopener"><strong>网格Mesh</strong></a></li>
<li><a href="https://lbs.amap.com/api/javascript-api/example/object3d-base/event" target="_blank" rel="noopener"><strong>Object3D 的拾取</strong></a></li>
<li><a href="https://lbs.amap.com/api/javascript-api/example/mesh/mesh-texture" target="_blank" rel="noopener"><strong>给 Mesh 添加纹理</strong></a></li>
</ol>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><ol>
<li><p>获取楼宇信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、初始化地图</span><br><span class="line">this.map &#x3D; initAmap(&#39;bigScreen&#39;, &#123;</span><br><span class="line">    resizeEnable: true,</span><br><span class="line">    center: [119.865674, 28.448911],</span><br><span class="line">    zoom: 16.5,</span><br><span class="line">    pitch: 90,</span><br><span class="line">    viewMode: &#39;3D&#39;,</span><br><span class="line">    mapStyle: &#39;amap:&#x2F;&#x2F;styles&#x2F;fc35552908a5c4f34b7330621230b0bd&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、获取楼宇信息并渲染楼宇</span><br><span class="line">getFloorInfo() &#123;</span><br><span class="line">    getLayoutList(&#123; parkId: this.parkId &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">        this.floorInfo &#x3D; res || []</span><br><span class="line">        &#x2F;&#x2F; 创建楼宇</span><br><span class="line">        this.buildingInfo &#x3D; newBuildings(this.floorInfo)</span><br><span class="line">        &#x2F;&#x2F; 选中楼层更换图片</span><br><span class="line">        this.map.on(&#39;click&#39;, (ev) &#x3D;&gt; &#123;</span><br><span class="line">            let pixel &#x3D; ev.pixel</span><br><span class="line">            let px &#x3D; new AMap.Pixel(pixel.x, pixel.y)</span><br><span class="line">            let obj &#x3D; this.map.getObject3DByContainerPos(px, [this.buildingInfo.floor3Dlayer], false) || &#123;&#125;</span><br><span class="line">            let object &#x3D; obj.object</span><br><span class="line">            let covering &#x3D; this.buildingInfo.coverings.find((cu) &#x3D;&gt; &#123;</span><br><span class="line">                return cu &#x3D;&#x3D;&#x3D; object</span><br><span class="line">            &#125;)</span><br><span class="line">            if (covering) &#123;</span><br><span class="line">                updateCovering(covering)</span><br><span class="line">                this.entParam.parkLayoutId &#x3D; covering.dataInfo.areaInfo.id</span><br><span class="line">                this.entParam.floorIds &#x3D; covering.dataInfo.floorInfo.id</span><br><span class="line">                this.floorName &#x3D; covering.dataInfo.buildingInfo.name + &#39; &gt; &#39; + covering.dataInfo.areaInfo.name + &#39; &gt; &#39; + covering.dataInfo.floorInfo.name</span><br><span class="line">                this.geEntData(1)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                updateCovering()</span><br><span class="line">                this.entParam.parkLayoutId &#x3D; null</span><br><span class="line">                this.entParam.floorIds &#x3D; null</span><br><span class="line">                this.floorName &#x3D; null</span><br><span class="line">                this.geEntData(1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 楼宇信息</span><br><span class="line">this.floorInfo &#x3D; [</span><br><span class="line">    id:41,name:&quot;1区&quot;,</span><br><span class="line">    children:[</span><br><span class="line">        &#123;</span><br><span class="line">            id:42,name:&quot;3号楼&quot;,</span><br><span class="line">            children:[</span><br><span class="line">                &#123;id:29,name:&quot;1楼&quot;&#125;,</span><br><span class="line">                &#123;id:30,name:&quot;2楼&quot;&#125;,</span><br><span class="line">                &#123;id:31,name:&quot;3楼&quot;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            id:43,name:&quot;5号楼&quot;,</span><br><span class="line">            children:[</span><br><span class="line">                &#123;id:32,name:&quot;1楼&quot;&#125;,</span><br><span class="line">                &#123;id:33,name:&quot;2楼&quot;&#125;,</span><br><span class="line">                &#123;id:34,name:&quot;3楼&quot;&#125;,</span><br><span class="line">                &#123;id:35,name:&quot;4楼&quot;&#125;,</span><br><span class="line">                &#123;id:36,name:&quot;5楼&quot;&#125;,</span><br><span class="line">                &#123;id:37,name:&quot;6楼&quot;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建楼宇方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 电子商务园经纬度数据</span><br><span class="line">const buildingPloyline &#x3D; [</span><br><span class="line">  [[119.864169, 28.437501], [119.864508, 28.438084], [119.865504, 28.437583], [119.865206, 28.436992], [119.864171, 28.437514]],</span><br><span class="line">  [[119.863916, 28.437046], [119.864156, 28.437453], [119.865163, 28.436957], [119.864896, 28.43653], [119.863916, 28.437046]]]</span><br><span class="line">let floor3Dlayer &#x3D; null  &#x2F;&#x2F; 3d图层</span><br><span class="line">let coverings &#x3D; [] &#x2F;&#x2F; 楼层集合</span><br><span class="line">import floorImg from &#39;@&#x2F;assets&#x2F;images&#x2F;map-floor-unchoose.png&#39; &#x2F;&#x2F; 楼层贴图</span><br><span class="line">import floorChoosedImg  from &#39;@&#x2F;assets&#x2F;images&#x2F;map-floor-choosed.png&#39; &#x2F;&#x2F; 选中楼层贴图</span><br><span class="line">import mapLight from &#39;@&#x2F;assets&#x2F;images&#x2F;map-floor-light.png&#39; &#x2F;&#x2F; 楼顶光照贴图</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 创建楼宇</span><br><span class="line"> * @param &#123;Array&#125; floorInfo 楼层数据</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const newBuildings &#x3D; (floorInfo &#x3D; []) &#x3D;&gt; &#123;</span><br><span class="line">  floor3Dlayer &#x3D; new AMap.Object3DLayer()</span><br><span class="line">  amap.add(floor3Dlayer)</span><br><span class="line">  if (floorInfo &amp;&amp; floorInfo.length &gt; 0) &#123;</span><br><span class="line">    let area &#x3D; floorInfo[0].children || []</span><br><span class="line">    area.map((curr, index) &#x3D;&gt; &#123;</span><br><span class="line">      let path &#x3D; buildingPloyline[index]</span><br><span class="line">      let floor &#x3D; curr.children || []</span><br><span class="line">      if (index &lt;&#x3D; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 加一层高度为0的楼宇作为底层</span><br><span class="line">        addFloorCoverings(path, 0, 0, false)</span><br><span class="line">        floor.map((cu, i) &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; 各层楼宇-只设置侧面</span><br><span class="line">          addFloorCoverings(path, 300, i, true, &#123; buildingInfo: floorInfo[0], areaInfo: curr, floorInfo: cu &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; 加一层高度为0的楼宇作为顶层</span><br><span class="line">        addFloorCoverings(path, 0, floor.length, true, &#123; buildingInfo: floorInfo[0], areaInfo: curr, floorInfo: curr[floor.length - 1] &#125;)</span><br><span class="line">        &#x2F;&#x2F; 在顶楼加上光图</span><br><span class="line">        if (floor.length &gt;&#x3D; 4) &#123;</span><br><span class="line">          addFloorLight(path, 500, floor.length + 1)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123; floor3Dlayer, coverings &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 创建楼层</span><br><span class="line"> * @param &#123;Array&#125; path 楼层坐标范围</span><br><span class="line"> * @param &#123;Number&#125; height 楼层高度（大于0）</span><br><span class="line"> * @param &#123;Number&#125; floorIndex 第几层</span><br><span class="line"> * @param &#123;Bollean&#125; pushFlag 是否将当前对象推进coverings</span><br><span class="line"> * @param &#123;Object&#125; data 当前幢、楼层数据</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const addFloorCoverings &#x3D; (path, height &#x3D; 200, floorIndex, pushFlag, data &#x3D; &#123; buildingInfo: &#123;&#125;, areaInfo: &#123;&#125;, floorInfo: &#123;&#125;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">  var bounds &#x3D; path.map(function(p) &#123;</span><br><span class="line">    return new AMap.LngLat(p[0], p[1])</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; 创建 Object3D.Mesh 对象</span><br><span class="line">  var covering &#x3D; new AMap.Object3D.Mesh()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 楼层贴图</span><br><span class="line">  covering.textures.push(floorImg)</span><br><span class="line"></span><br><span class="line">  covering.dataInfo &#x3D; &#123; ...data &#125;</span><br><span class="line"></span><br><span class="line">  if (pushFlag) &#123;</span><br><span class="line">    coverings.push(covering)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var geometry &#x3D; covering.geometry</span><br><span class="line">  var vertices &#x3D; geometry.vertices</span><br><span class="line">  var vertexColors &#x3D; geometry.vertexColors</span><br><span class="line">  var faces &#x3D; geometry.faces</span><br><span class="line">  var vertexLength &#x3D; bounds.length * 2</span><br><span class="line"></span><br><span class="line">  var verArr &#x3D; []</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; var color &#x3D; [0 &#x2F; 255, 224 &#x2F; 255, 220 &#x2F; 255, 0.1]</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 设置侧面</span><br><span class="line">  bounds.forEach((lngLat, index) &#x3D;&gt; &#123;</span><br><span class="line">    var g20 &#x3D; amap.lngLatToGeodeticCoord(lngLat)</span><br><span class="line">    verArr.push([g20.x, g20.y])</span><br><span class="line">    if (height &gt; 0) &#123;</span><br><span class="line">      &#x2F;&#x2F; 构建顶点-底面顶点</span><br><span class="line">      vertices.push(g20.x, g20.y, -floorIndex * height)</span><br><span class="line">      &#x2F;&#x2F; 构建顶点-顶面顶点</span><br><span class="line">      vertices.push(g20.x, g20.y, -(floorIndex + 1) * height)</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 楼宇底层和顶层</span><br><span class="line">      &#x2F;&#x2F; 构建顶点-底面顶点</span><br><span class="line">      vertices.push(g20.x, g20.y, floorIndex &#x3D;&#x3D; 0 ? 0 : -floorIndex * 300)</span><br><span class="line">      &#x2F;&#x2F; 构建顶点-顶面顶点</span><br><span class="line">      vertices.push(g20.x, g20.y, floorIndex &#x3D;&#x3D; 0 ? 0 : -floorIndex * 300)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置底面顶点颜色</span><br><span class="line">    &#x2F;&#x2F; vertexColors.push.apply(vertexColors, color)</span><br><span class="line">    &#x2F;&#x2F; 设置顶面顶点颜色</span><br><span class="line">    &#x2F;&#x2F; vertexColors.push.apply(vertexColors, color)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 四个顶点的纹理坐标</span><br><span class="line">    geometry.vertexUVs.push(0, 1)</span><br><span class="line">    geometry.vertexUVs.push(0, 0)</span><br><span class="line">    geometry.vertexUVs.push(1, 1)</span><br><span class="line">    geometry.vertexUVs.push(1, 0)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置三角形面</span><br><span class="line">    var bottomIndex &#x3D; index * 2</span><br><span class="line">    var topIndex &#x3D; bottomIndex + 1</span><br><span class="line">    var nextBottomIndex &#x3D; (bottomIndex + 2) % vertexLength</span><br><span class="line">    var nextTopIndex &#x3D; (bottomIndex + 3) % vertexLength</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 侧面三角形1</span><br><span class="line">    faces.push(bottomIndex, topIndex, nextTopIndex)</span><br><span class="line">    &#x2F;&#x2F; 侧面三角形2</span><br><span class="line">    faces.push(bottomIndex, nextTopIndex, nextBottomIndex)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 设置顶面，根据顶点拆分三角形   楼宇底层和顶层的时候才会设置顶面</span><br><span class="line">  if (height &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    var triangles &#x3D; AMap.GeometryUtil.triangulateShape(verArr)</span><br><span class="line">    for (var v &#x3D; 0; v &lt; triangles.length; v +&#x3D; 3) &#123;</span><br><span class="line">      var a &#x3D; triangles[v]</span><br><span class="line">      var b &#x3D; triangles[v + 2]</span><br><span class="line">      var c &#x3D; triangles[v + 1]</span><br><span class="line">      faces.push(a * 2 + 1, b * 2 + 1, c * 2 + 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 开启透明度支持</span><br><span class="line">  covering.transparent &#x3D; true</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; backOrFront属性来控制显示正反面，这里我们开启两面</span><br><span class="line">  covering.backOrFront &#x3D; &#39;both&#39;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 添加至 3D 图层</span><br><span class="line">  floor3Dlayer.add(covering)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 更新楼层</span><br><span class="line"> * @param &#123;Object&#125; covering 楼层对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const updateCovering &#x3D; (covering) &#x3D;&gt; &#123;</span><br><span class="line">  coverings.forEach(function(cu) &#123;</span><br><span class="line">    updateCoveringImg(cu, floorImg)</span><br><span class="line">  &#125;)</span><br><span class="line">  if (covering) &#123;</span><br><span class="line">    updateCoveringImg(covering, floorChoosedImg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 更新楼层贴图</span><br><span class="line"> * @param &#123;Object&#125; covering 楼层对象</span><br><span class="line"> * @param &#123;Obect&#125; img 要更新的楼层的贴图</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const updateCoveringImg &#x3D; (covering, img) &#x3D;&gt; &#123;</span><br><span class="line">  covering.textures.splice(0, 1, img)</span><br><span class="line">  covering.needUpdate &#x3D; true</span><br><span class="line">  covering.reDraw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 创建楼宇顶楼的光照</span><br><span class="line"> * @param &#123;Array&#125; path 楼层坐标范围</span><br><span class="line"> * @param &#123;Number&#125; height 楼层高度（大于0）</span><br><span class="line"> * @param &#123;Number&#125; floorIndex  第几层</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const addFloorLight &#x3D; (path, height, floorIndex) &#x3D;&gt; &#123;</span><br><span class="line">  var bounds &#x3D; path.map(function(p) &#123;</span><br><span class="line">    return new AMap.LngLat(p[0], p[1])</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; 创建 Object3D.Mesh 对象</span><br><span class="line">  var covering &#x3D; new AMap.Object3D.Mesh()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 楼层贴图</span><br><span class="line">  covering.textures.push(mapLight)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; coverings.push(covering)</span><br><span class="line"></span><br><span class="line">  var geometry &#x3D; covering.geometry</span><br><span class="line">  var vertices &#x3D; geometry.vertices</span><br><span class="line">  var vertexColors &#x3D; geometry.vertexColors</span><br><span class="line">  var faces &#x3D; geometry.faces</span><br><span class="line">  var vertexLength &#x3D; bounds.length * 2</span><br><span class="line"></span><br><span class="line">  var verArr &#x3D; []</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 设置侧面</span><br><span class="line">  bounds.forEach((lngLat, index) &#x3D;&gt; &#123;</span><br><span class="line">    var g20 &#x3D; amap.lngLatToGeodeticCoord(lngLat)</span><br><span class="line">    verArr.push([g20.x, g20.y])</span><br><span class="line">    &#x2F;&#x2F; 构建顶点-底面顶点</span><br><span class="line">    vertices.push(g20.x, g20.y, -(floorIndex - 1) * 300)</span><br><span class="line">    &#x2F;&#x2F; 构建顶点-顶面顶点-向外扩</span><br><span class="line">    let x &#x3D; g20.x; let y &#x3D; g20.y</span><br><span class="line">    if (index &#x3D;&#x3D; 0 || index &#x3D;&#x3D; 1 || index &#x3D;&#x3D; 4) &#123;</span><br><span class="line">      x &#x3D; x - 300</span><br><span class="line">    &#125;</span><br><span class="line">    if (index &#x3D;&#x3D; 2 || index &#x3D;&#x3D; 3) &#123;</span><br><span class="line">      x &#x3D; x + 300</span><br><span class="line">    &#125;</span><br><span class="line">    vertices.push(x, y, -(floorIndex + 1) * height)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 四个顶点的纹理坐标</span><br><span class="line">    geometry.vertexUVs.push(0, 1)</span><br><span class="line">    geometry.vertexUVs.push(0, 0)</span><br><span class="line">    geometry.vertexUVs.push(1, 1)</span><br><span class="line">    geometry.vertexUVs.push(1, 0)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置三角形面</span><br><span class="line">    var bottomIndex &#x3D; index * 2</span><br><span class="line">    var topIndex &#x3D; bottomIndex + 1</span><br><span class="line">    var nextBottomIndex &#x3D; (bottomIndex + 2) % vertexLength</span><br><span class="line">    var nextTopIndex &#x3D; (bottomIndex + 3) % vertexLength</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 侧面三角形1</span><br><span class="line">    faces.push(bottomIndex, topIndex, nextTopIndex)</span><br><span class="line">    &#x2F;&#x2F; 侧面三角形2</span><br><span class="line">    faces.push(bottomIndex, nextTopIndex, nextBottomIndex)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 开启透明度支持</span><br><span class="line">  covering.transparent &#x3D; true</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; backOrFront属性来控制显示正反面，这里我们开启两面</span><br><span class="line">  covering.backOrFront &#x3D; &#39;both&#39;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 添加至 3D 图层</span><br><span class="line">  floor3Dlayer.add(covering)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 清空3d图层</span><br><span class="line">export const clearFloor3Dlayer &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  floor3Dlayer.clear()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>代码地址：<a href="https://gitee.com/crystalSummer/record-code/blob/master/largeVisualScreen/liandu/map/index.js" target="_blank" rel="noopener"><strong>3D贴图楼宇</strong></a></p>
<h1 id="绘制行政区"><a href="#绘制行政区" class="headerlink" title="绘制行政区"></a>绘制行政区</h1><h2 id="省市区县的行政区"><a href="#省市区县的行政区" class="headerlink" title="省市区县的行政区"></a>省市区县的行政区</h2><p><img src="https://i.loli.net/2021/03/25/xLJhy7smC3znqac.gif" alt=""><br>官网示例：</p>
<ol>
<li><a href="https://lbs.amap.com/demo/javascript-api/example/district-search/draw-district-boundaries" target="_blank" rel="noopener"><strong>行政区边界查询</strong></a></li>
<li><a href="https://lbs.amap.com/demo/javascript-api/example/mesh/obj3d-wall" target="_blank" rel="noopener"><strong>垂面 Wall</strong></a></li>
<li><a href="https://lbs.amap.com/demo/javascript-api/example/line/meshline" target="_blank" rel="noopener"><strong>MeshLine 高度线</strong></a></li>
<li><a href="https://lbs.amap.com/demo/javascript-api/example/object3d-base/event" target="_blank" rel="noopener"><strong>Object3D 的拾取</strong></a></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 地图对象</span><br><span class="line">let amap &#x3D; null</span><br><span class="line">&#x2F;&#x2F; 行政查询对象</span><br><span class="line">let district &#x3D; null</span><br><span class="line">&#x2F;&#x2F; Object3D对象</span><br><span class="line">let object3Dlayer &#x3D; null</span><br><span class="line">&#x2F;&#x2F; 区域覆盖物数组</span><br><span class="line">let meshes &#x3D; []</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 初始化地图</span><br><span class="line">*&#x2F;</span><br><span class="line">export  const  initAmap &#x3D; function(id) &#123;</span><br><span class="line">    amap &#x3D; new AMap.Map(id, &#123;</span><br><span class="line">        resizeEnable: true,</span><br><span class="line">        center: [119.822398, 30.507198], &#x2F;&#x2F; 中心点坐标</span><br><span class="line">        mapStyle: &#39;amap:&#x2F;&#x2F;styles&#x2F;bc02739e6d7d7bb66dcb092afb438175&#39;,</span><br><span class="line">        viewMode: &#39;3D&#39;,</span><br><span class="line">        zoom: 9.8,</span><br><span class="line">        pitch: 40</span><br><span class="line">    &#125;)</span><br><span class="line">    return amap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 创建行政查询对象 和 Object3D对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const createDistrict &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    district &#x3D; new AMap.DistrictSearch(&#123;</span><br><span class="line">        level: &#39;district&#39;,</span><br><span class="line">        showbiz: false,</span><br><span class="line">        extensions: &#39;all&#39;,</span><br><span class="line">        subdistrict: 1</span><br><span class="line">    &#125;)</span><br><span class="line">    if (amap &amp;&amp; Object.keys(amap).length &gt; 0) &#123;</span><br><span class="line">        object3Dlayer &#x3D; new AMap.Object3DLayer()</span><br><span class="line">        amap.add(object3Dlayer)</span><br><span class="line">        return object3Dlayer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 获取当前行政区的信息（经纬度，中心点等）</span><br><span class="line"> * @param &#123;*&#125; name 行政地区</span><br><span class="line"> * @param &#123;*&#125; opt 行政查询对象的配置项</span><br><span class="line"> * @param &#123;*&#125; wallOpts 外围立体阴影效果配置项</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const getAreaInfo &#x3D; (name, opts, wallOpts) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 修改行政查询对象的配置项</span><br><span class="line">    if (opts &amp;&amp; Object.keys(opts).length &gt; 0) &#123;</span><br><span class="line">        opts.level &amp;&amp; district.setLevel(opts.level)</span><br><span class="line">        opts.subdistrict &amp;&amp; district.setSubdistrict(opts.subdistrict)</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据名字查询经纬度数据</span><br><span class="line">        district.search(name, function(status, result) &#123;</span><br><span class="line">            console.log(result)</span><br><span class="line">            if (status &#x3D;&#x3D; &#39;complete&#39;) &#123;</span><br><span class="line">                if (name &#x3D;&#x3D; &#39;湖州市&#39;) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 立体阴影效果</span><br><span class="line">                    var wall &#x3D; new AMap.Object3D.Wall(&#123;</span><br><span class="line">                        path: result.districtList[0].boundaries,</span><br><span class="line">                        height: wallOpts.height ? wallOpts.height : 5000,</span><br><span class="line">                        color: wallOpts.color ? wallOpts.color : &#39;#12413A&#39;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    wall.backOrFront &#x3D; &#39;back&#39;</span><br><span class="line">                    &#x2F;&#x2F; wall.transparent &#x3D; true</span><br><span class="line">                    object3Dlayer.add(wall)</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(result.districtList[0])</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                reject(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;*&#125; citys 需要渲染的区域列表</span><br><span class="line"> * @param &#123;*&#125; disOpts 行政对象的配置项</span><br><span class="line"> * @param &#123;*&#125; priOpts 棱柱体对象的配置项</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const rendPolygon &#x3D; (citys, disOpts, priOpts) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(citys)</span><br><span class="line">    meshes &#x3D; []</span><br><span class="line">    Promise.all(citys.map(v &#x3D;&gt; &#123;</span><br><span class="line">        return getAreaInfo(v.name, disOpts)</span><br><span class="line">    &#125;)).then(res &#x3D;&gt; &#123; &#x2F;&#x2F; 绘制polygon和polyline</span><br><span class="line">        res.map(item &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 区域覆盖物-不规则棱形-此方法没有办法改变棱柱体的颜色</span><br><span class="line">            &#x2F;&#x2F; var prism &#x3D; new AMap.Object3D.Prism(&#123;</span><br><span class="line">            &#x2F;&#x2F;     path: item.boundaries,</span><br><span class="line">            &#x2F;&#x2F;     height: priOpts.height ? priOpts.height : 5000,</span><br><span class="line">            &#x2F;&#x2F;     color: priOpts.color ? priOpts.color : &#39;#0088ffcc&#39;,</span><br><span class="line">            &#x2F;&#x2F;     extData: &#123;</span><br><span class="line">            &#x2F;&#x2F;         name: item.name,</span><br><span class="line">            &#x2F;&#x2F;         center: item.center</span><br><span class="line">            &#x2F;&#x2F;     &#125;</span><br><span class="line">            &#x2F;&#x2F; &#125;)</span><br><span class="line">            &#x2F;&#x2F; prism.transparent &#x3D; true</span><br><span class="line">            &#x2F;&#x2F; object3Dlayer.add(prism)</span><br><span class="line">            &#x2F;&#x2F; prisms.push(prism)</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 区域覆盖物-网格</span><br><span class="line">            let paths &#x3D; JSON.parse(JSON.stringify(item.boundaries[0])).map(cu &#x3D;&gt; &#123;</span><br><span class="line">                return cu instanceof Array ? new AMap.LngLat(cu[0], cu[1]) : cu</span><br><span class="line">            &#125;)</span><br><span class="line">            var mesh &#x3D; new AMap.Object3D.Mesh()</span><br><span class="line">            meshes.push(mesh)</span><br><span class="line">            var geometry &#x3D; mesh.geometry</span><br><span class="line">            var vertices &#x3D; geometry.vertices</span><br><span class="line">            var vertexColors &#x3D; geometry.vertexColors</span><br><span class="line">            var faces &#x3D; geometry.faces</span><br><span class="line">            var vertexLength &#x3D; paths.length*2</span><br><span class="line">            var verArr &#x3D; []</span><br><span class="line">            &#x2F;&#x2F; 设置侧面</span><br><span class="line">            paths.forEach(function(lngLat, index) &#123;</span><br><span class="line">                var g20 &#x3D; amap.lngLatToGeodeticCoord(lngLat)</span><br><span class="line">                verArr.push([g20.x, g20.y])</span><br><span class="line">                &#x2F;&#x2F; 构建顶点-底面顶点</span><br><span class="line">                vertices.push(g20.x, g20.y, 0)</span><br><span class="line">                &#x2F;&#x2F; 构建顶点-顶面顶点</span><br><span class="line">                &#x2F;&#x2F; vertices.push(g20.x, g20.y, -1000)</span><br><span class="line">                vertices.push(g20.x, g20.y, -1000)</span><br><span class="line">                &#x2F;&#x2F; 设置底面顶点颜色</span><br><span class="line">                vertexColors.push.apply(vertexColors,  priOpts.color ? priOpts.color : [100 &#x2F; 255, 150 &#x2F; 255, 230 &#x2F; 255, 0.9])</span><br><span class="line">                &#x2F;&#x2F; 设置顶面顶点颜色</span><br><span class="line">                vertexColors.push.apply(vertexColors,  priOpts.color ? priOpts.color : [100 &#x2F; 255, 150 &#x2F; 255, 230 &#x2F; 255, 0.9])</span><br><span class="line">                &#x2F;&#x2F; 设置三角形面</span><br><span class="line">                var bottomIndex &#x3D; index * 2</span><br><span class="line">                var topIndex &#x3D; bottomIndex + 1</span><br><span class="line">                var nextBottomIndex &#x3D; (bottomIndex + 2) % vertexLength</span><br><span class="line">                var nextTopIndex &#x3D; (bottomIndex + 3) % vertexLength</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 侧面三角形1</span><br><span class="line">                faces.push(bottomIndex, topIndex, nextTopIndex)</span><br><span class="line">                &#x2F;&#x2F; 侧面三角形2</span><br><span class="line">                faces.push(bottomIndex, nextTopIndex, nextBottomIndex)</span><br><span class="line">            &#125;)</span><br><span class="line">            &#x2F;&#x2F; 设置顶面，根据顶点拆分三角形</span><br><span class="line">            var triangles &#x3D; AMap.GeometryUtil.triangulateShape(verArr)</span><br><span class="line">            for (var v &#x3D; 0; v &lt; triangles.length; v +&#x3D; 3) &#123;</span><br><span class="line">                var a &#x3D; triangles[v]</span><br><span class="line">                var b &#x3D; triangles[v + 2]</span><br><span class="line">                var c &#x3D; triangles[v + 1]</span><br><span class="line">                faces.push(a * 2 + 1, b * 2 + 1, c * 2 + 1)</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 绑定额外的参数</span><br><span class="line">            mesh.extData &#x3D; &#123;</span><br><span class="line">                name: item.name,</span><br><span class="line">                center: item.center</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 添加至 3D 图层</span><br><span class="line">            object3Dlayer.add(mesh)</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 设置文字</span><br><span class="line">            &#x2F;&#x2F; var text &#x3D; new AMap.Text(&#123;</span><br><span class="line">            &#x2F;&#x2F;     text: item.name,</span><br><span class="line">            &#x2F;&#x2F;     &#x2F;&#x2F; verticalAlign: &#39;bottom&#39;,</span><br><span class="line">            &#x2F;&#x2F;     position: [item.center.lng, item.center.lat],</span><br><span class="line">            &#x2F;&#x2F;     &#x2F;&#x2F; height: 5000,</span><br><span class="line">            &#x2F;&#x2F;     style: &#123;</span><br><span class="line">            &#x2F;&#x2F;         &#39;background-color&#39;: &#39;transparent&#39;,</span><br><span class="line">            &#x2F;&#x2F;         &#39;border&#39;: &#39;none&#39;,</span><br><span class="line">            &#x2F;&#x2F;         &#39;color&#39;: &#39;white&#39;,</span><br><span class="line">            &#x2F;&#x2F;         &#39;font-size&#39;: &#39;0.14rem&#39;,</span><br><span class="line">            &#x2F;&#x2F;         &#39;font-weight&#39;: 600</span><br><span class="line">            &#x2F;&#x2F;     &#125;</span><br><span class="line">            &#x2F;&#x2F; &#125;)</span><br><span class="line">            &#x2F;&#x2F; text.setMap(amap)</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 添加高度线</span><br><span class="line">            var meshLine &#x3D; new AMap.Object3D.MeshLine(&#123;</span><br><span class="line">                path: item.boundaries[0],</span><br><span class="line">                height: 1000,</span><br><span class="line">                color: &#39;#12413A&#39;,</span><br><span class="line">                width: 1</span><br><span class="line">            &#125;)</span><br><span class="line">            meshLine[&#39;backOrFront&#39;] &#x3D; &#39;front&#39;</span><br><span class="line">            &#x2F;&#x2F; meshLine.transparent &#x3D; true</span><br><span class="line">            object3Dlayer.add(meshLine)</span><br><span class="line">        &#125;)</span><br><span class="line">        return meshes</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 点图添加点击事件-高亮当前网格</span><br><span class="line"> * @param &#123;Array&#125; orColor 网格原有颜色</span><br><span class="line"> * @param &#123;Array&#125; upColor 网格高亮颜色</span><br><span class="line"> * @param &#123;String&#125; name 地图当前区域</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const findMesh &#x3D; (orColor, upColor, name) &#x3D;&gt; &#123;</span><br><span class="line">    if (name) &#123;</span><br><span class="line">        &#x2F;&#x2F; 清空之前的高亮</span><br><span class="line">        clearHighLight(orColor)</span><br><span class="line">        var meshe &#x3D; meshes.filter(function(cu) &#123;</span><br><span class="line">            return cu.extData.name &#x3D;&#x3D; name</span><br><span class="line">        &#125;) || []</span><br><span class="line">        &#x2F;&#x2F; 重置颜色</span><br><span class="line">        let extData &#x3D; null</span><br><span class="line">        meshe.forEach(function(item) &#123;</span><br><span class="line">            var vertexColors &#x3D; item.geometry.vertexColors</span><br><span class="line">            var len &#x3D; vertexColors.length</span><br><span class="line">            for (var i &#x3D; 0; i &lt; len &#x2F; 4; i++) &#123;</span><br><span class="line">                var r &#x3D; upColor[0]</span><br><span class="line">                var g &#x3D; upColor[1]</span><br><span class="line">                var b &#x3D; upColor[2]</span><br><span class="line">                var a &#x3D; upColor[3]</span><br><span class="line">                &#x2F;&#x2F; 不能重新赋值，只允许修改内容</span><br><span class="line">                vertexColors.splice(i * 4, 4, r, g, b, a)</span><br><span class="line">            &#125;</span><br><span class="line">            item.needUpdate &#x3D; true</span><br><span class="line">            item.reDraw()</span><br><span class="line">            extData &#x3D; item.extData</span><br><span class="line">        &#125;)</span><br><span class="line">        return extData</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 清空之前的高亮</span><br><span class="line"> * @param &#123;Array&#125; orColor 网格原有颜色</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const clearHighLight &#x3D; (orColor) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 在高亮当前区域之前，先将之前高亮去掉</span><br><span class="line">    meshes.map(item &#x3D;&gt; &#123;</span><br><span class="line">        var vertexColors &#x3D; item.geometry.vertexColors</span><br><span class="line">        var len &#x3D; vertexColors.length</span><br><span class="line">        for (var i &#x3D; 0; i &lt; len &#x2F; 4; i++) &#123;</span><br><span class="line">            var r &#x3D; orColor[0]</span><br><span class="line">            var g &#x3D; orColor[1]</span><br><span class="line">            var b &#x3D; orColor[2]</span><br><span class="line">            var a &#x3D; orColor[3]</span><br><span class="line">            &#x2F;&#x2F; 不能重新赋值，只允许修改内容</span><br><span class="line">            vertexColors.splice(i * 4, 4, r, g, b, a)</span><br><span class="line">        &#125;</span><br><span class="line">        item.needUpdate &#x3D; true</span><br><span class="line">        item.reDraw()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 打开信息窗口</span><br><span class="line"> * @param &#123;Object&#125; data 信息窗口要展示的数据</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const openInfoWindow &#x3D; (data) &#x3D;&gt; &#123;</span><br><span class="line">    let content &#x3D; &#96;&lt;div class&#x3D;&quot;info-window&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;info-window-title&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;title-img&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;title-img&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;title-name&quot;&gt;&#96; + data.name + &#96;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;info-window-body&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;li&quot;&gt;</span><br><span class="line">                &lt;div&gt;贷款户数&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div&gt;&lt;span&gt;&#96; + (data.countyEnt || 0) + &#96;&lt;&#x2F;span&gt;家&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;li&quot;&gt;</span><br><span class="line">                &lt;div&gt;贷款金额&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div&gt;&lt;span&gt;&#96; + (data.loanRest || 0) + &#96;&lt;&#x2F;span&gt;万元&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;li&quot;&gt;</span><br><span class="line">                &lt;div&gt;支行数量&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div&gt;&lt;span&gt;&#96; + (data.sponsorCount || 0) + &#96;&lt;&#x2F;span&gt;家&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;&#96;</span><br><span class="line">    var infoWindow &#x3D; new AMap.InfoWindow(&#123;</span><br><span class="line">        isCustom: true,  &#x2F;&#x2F; 使用自定义窗体</span><br><span class="line">        content: content,</span><br><span class="line">        offset: new AMap.Pixel(-200, 40)</span><br><span class="line">    &#125;)</span><br><span class="line">    infoWindow.open(amap, data.center)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 关闭信息窗口</span><br><span class="line">export const closeInfoWindow &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    amap.clearInfoWindow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 清空地图上的所有</span><br><span class="line">export const clearMap &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    amap.clearInfoWindow()</span><br><span class="line">    amap.clearMap()</span><br><span class="line">    object3Dlayer.clear(meshes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码地址：<a href="https://gitee.com/crystalSummer/record-code/blob/master/largeVisualScreen/huzhouBank/map/index.js" target="_blank" rel="noopener"><strong>3d 立体 区县 地图</strong></a></p>
<h2 id="区县级以下（街道）的行政区"><a href="#区县级以下（街道）的行政区" class="headerlink" title="区县级以下（街道）的行政区"></a>区县级以下（街道）的行政区</h2><p><img src="https://i.loli.net/2021/03/29/Huj3wtYGFhx7f16.png" alt=""><br>    街道的经纬度数据从官方地图没有办法获取，我这边是产品提供json数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; regionJson &#125; from &#39;..&#x2F;..&#x2F;..&#x2F;static&#x2F;region&#x2F;amap.haining&#39;</span><br><span class="line">import entSelectIcon from &#39;..&#x2F;..&#x2F;assets&#x2F;ent_select_icon.png&#39;</span><br><span class="line"></span><br><span class="line">let amap &#x3D; null</span><br><span class="line">let polygons &#x3D; []</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @description 初始化地图</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const initAmap &#x3D; (id, opt) &#x3D;&gt; &#123;</span><br><span class="line">  amap &#x3D; new AMap.Map(</span><br><span class="line">    id,</span><br><span class="line">    Object.assign(</span><br><span class="line">      &#123;</span><br><span class="line">        resizeEnable: true,</span><br><span class="line">        center: [120.611735528, 30.3497873], &#x2F;&#x2F; 中心点坐标</span><br><span class="line">        mapStyle: &#39;amap:&#x2F;&#x2F;styles&#x2F;4129d18680c75412409bf8e4de8ecc81&#39;,</span><br><span class="line">        viewMode: &#39;3D&#39;,</span><br><span class="line">        zoom: 10.99,</span><br><span class="line">        pitch: 30,</span><br><span class="line">        features: [&#39;bg&#39;, &#39;road&#39;, &#39;building&#39;]</span><br><span class="line">      &#125;,</span><br><span class="line">      opt</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  return amap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 渲染区域--渲染所有区域或者单独渲染某个区域（下钻）</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const rendPolygon &#x3D; (name) &#x3D;&gt; &#123;</span><br><span class="line">  polygons &#x3D; []</span><br><span class="line">  if (name) &#123;</span><br><span class="line">    let center &#x3D; null; let path &#x3D; null</span><br><span class="line">    regionJson.districts.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">      if (item.name &#x3D;&#x3D;&#x3D; name) &#123;</span><br><span class="line">        center &#x3D; item.center</span><br><span class="line">        path &#x3D; item.polyline</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    const polygon &#x3D; new AMap.Polygon(&#123;</span><br><span class="line">      path: JSON.parse(path),</span><br><span class="line">      fillColor: &#39;rgba(26, 142, 255, 0.3)&#39;,</span><br><span class="line">      cursor: &#39;pointer&#39;,</span><br><span class="line">      strokeColor: &#39;#1AFFF0&#39;,</span><br><span class="line">      strokeOpacity: 1,</span><br><span class="line">      strokeWeight: 2,</span><br><span class="line">      extData: &#123;</span><br><span class="line">        town: name,</span><br><span class="line">        center: center</span><br><span class="line">      &#125;,</span><br><span class="line">      zIndex: 10</span><br><span class="line">    &#125;)</span><br><span class="line">    polygons.push(polygon)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    regionJson.districts.map((cu, index) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 生成行政区划polygon</span><br><span class="line">      const polygon &#x3D; new AMap.Polygon(&#123;</span><br><span class="line">        path: JSON.parse(cu.polyline),</span><br><span class="line">        fillColor: &#39;rgba(26, 142, 255, 0.3)&#39;,</span><br><span class="line">        cursor: &#39;pointer&#39;,</span><br><span class="line">        strokeColor: &#39;#1AFFF0&#39;,</span><br><span class="line">        strokeOpacity: 1,</span><br><span class="line">        strokeWeight: 2,</span><br><span class="line">        extData: &#123;</span><br><span class="line">          town: cu.name,</span><br><span class="line">          center: cu.center</span><br><span class="line">        &#125;,</span><br><span class="line">        zIndex: 10</span><br><span class="line">      &#125;)</span><br><span class="line">      polygons.push(polygon)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  amap.add(polygons)</span><br><span class="line">  return polygons</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 渲染城市名--渲染所有城市名和单独渲染某一个城市名</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const rendCityName &#x3D; (name) &#x3D;&gt; &#123;</span><br><span class="line">  const textLayer &#x3D; new AMap.LabelsLayer(&#123;</span><br><span class="line">    rejectMapMask: true,</span><br><span class="line">    collision: true,</span><br><span class="line">    animation: true,</span><br><span class="line">    zIndex: 120</span><br><span class="line">  &#125;)</span><br><span class="line">  amap.add(textLayer)</span><br><span class="line">  if (name) &#123;</span><br><span class="line">    let center &#x3D; &#39;&#39;</span><br><span class="line">    regionJson.districts.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">      if (item.name &#x3D;&#x3D;&#x3D; name) &#123;</span><br><span class="line">        center &#x3D; item.center</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    const labelsMarker &#x3D; new AMap.LabelMarker(&#123;</span><br><span class="line">      zooms: [3, 20],</span><br><span class="line">      position: center,</span><br><span class="line">      text: &#123;</span><br><span class="line">        content: name,</span><br><span class="line">        style: &#123;</span><br><span class="line">          fillColor: &#39;white&#39;,</span><br><span class="line">          fontWeight: &#39;normal&#39;,</span><br><span class="line">          fontSize: 14,</span><br><span class="line">          zooms: [3, 20]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    textLayer.add(labelsMarker)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    regionJson.districts.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">      const labelsMarker &#x3D; new AMap.LabelMarker(&#123;</span><br><span class="line">        zooms: [3, 20],</span><br><span class="line">        position: item.center,</span><br><span class="line">        text: &#123;</span><br><span class="line">          content: item.name,</span><br><span class="line">          style: &#123;</span><br><span class="line">            fillColor: &#39;white&#39;,</span><br><span class="line">            fontWeight: &#39;normal&#39;,</span><br><span class="line">            fontSize: 14,</span><br><span class="line">            zooms: [3, 20]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      textLayer.add(labelsMarker)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  return textLayer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码地址：<a href="https://gitee.com/crystalSummer/record-code/blob/master/largeVisualScreen/haining/map/index.js" target="_blank" rel="noopener"><strong>镇街 区域 地图</strong></a></p>
<h1 id="涟漪散点"><a href="#涟漪散点" class="headerlink" title="涟漪散点"></a>涟漪散点</h1><p><img src="https://i.loli.net/2020/12/21/Izk5a9ycxuCEVtZ.gif" alt=""></p>
<p>实现原理：使用 AMap.Text 渲染散点，然后给散点添加涟漪样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 散点数据</span><br><span class="line">circleData&#x3D;[</span><br><span class="line">  &#123;</span><br><span class="line">    creditCode: &quot;913300001429396622&quot;,</span><br><span class="line">    entName: &quot;浙江钱江生物化学股份有限公司&quot;,</span><br><span class="line">    lat: &quot;30.5070225407221800&quot;,</span><br><span class="line">    lng: &quot;120.6849546605598100&quot;,</span><br><span class="line">    town: &quot;海洲街道&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    creditCode: &quot;91330000146719376J&quot;</span><br><span class="line">    entName: &quot;宏达高科控股股份有限公司&quot;</span><br><span class="line">    lat: &quot;30.4440248163964960&quot;</span><br><span class="line">    lng: &quot;120.3764044023183000&quot;</span><br><span class="line">    town: &quot;许村镇&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  ......</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 渲染散点</span><br><span class="line"> *&#x2F;</span><br><span class="line">let circles &#x3D; []</span><br><span class="line">export const renderCircle &#x3D; (circleData) &#x3D;&gt; &#123;</span><br><span class="line">  const circles &#x3D; []</span><br><span class="line">  if (circleData &amp;&amp; circleData.length &gt; 0) &#123;</span><br><span class="line">    circleData.map(cu &#x3D;&gt; &#123;</span><br><span class="line">      if (cu.lng &amp;&amp; cu.lat) &#123;</span><br><span class="line">        var text &#x3D; new AMap.Text(&#123;</span><br><span class="line">          text: &#39;&#39;,</span><br><span class="line">          cursor: &#39;pointer&#39;,</span><br><span class="line">          style: &#123;</span><br><span class="line">            background: &#39;rgba(26, 255, 240, 0.7)&#39;,</span><br><span class="line">            display: &#39;inline-block&#39;,</span><br><span class="line">            width: &#39;0.05rem&#39;,</span><br><span class="line">            height: &#39;0.05rem&#39;,</span><br><span class="line">            borderRadius: &#39;50%&#39;,</span><br><span class="line">            border: &#39;1px solid rgba(26, 255, 240, 1)&#39;</span><br><span class="line">          &#125;,</span><br><span class="line">          position: [cu.lng, cu.lat]</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; 给每个散点添加信息窗口</span><br><span class="line">        var infoWindow &#x3D; null</span><br><span class="line">        text.on(&#39;mouseover&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">          infoWindow &#x3D; new AMap.InfoWindow(&#123;</span><br><span class="line">            isCustom: true,</span><br><span class="line">            content: &#39;&lt;div class&#x3D;&quot;circles-info-window&quot;&gt;&#39; + cu.entName + &#39;&lt;&#x2F;div&gt;&#39;,</span><br><span class="line">            offset: new AMap.Pixel(16, -10)</span><br><span class="line">          &#125;)</span><br><span class="line">          infoWindow.open(amap, [cu.lng, cu.lat])</span><br><span class="line">        &#125;)</span><br><span class="line">        text.on(&#39;mouseout&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">          amap.clearInfoWindow()</span><br><span class="line">        &#125;)</span><br><span class="line">        circles.push(text)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    amap.add(circles)</span><br><span class="line">    return circles</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 散点动画样式</span><br><span class="line">@keyframes warn &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">      transform: scale(1);</span><br><span class="line">      opacity: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    25% &#123;</span><br><span class="line">      transform: scale(1.2);</span><br><span class="line">      opacity: 0.3;</span><br><span class="line">    &#125;</span><br><span class="line">    50% &#123;</span><br><span class="line">      transform: scale(1.7);</span><br><span class="line">      opacity: 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">      transform: scale(2);</span><br><span class="line">      opacity: 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 散点样式</span><br><span class="line">&#x2F;deep&#x2F;#big-screen-map&#123;</span><br><span class="line">  .amap-marker&#123;</span><br><span class="line">    &amp;-content&#123;</span><br><span class="line">      .amap-overlay-text-container&#123;</span><br><span class="line">        &amp;::before&#123;</span><br><span class="line">          content:&#39;&#39;;</span><br><span class="line">          position: absolute;</span><br><span class="line">          left:0;</span><br><span class="line">          top:0.03rem;</span><br><span class="line">          width: 0.11rem;</span><br><span class="line">          height: 0.11rem;</span><br><span class="line">          border: 1px solid rgba(26, 255, 240, 1);</span><br><span class="line">          border-radius: 50%;</span><br><span class="line">          animation: warn 2s ease-out infinite;</span><br><span class="line">          z-index:99;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码地址：<a href="https://gitee.com/crystalSummer/record-code/blob/master/largeVisualScreen/haining/map/index.js" target="_blank" rel="noopener"><strong>涟漪散点</strong></a></p>
<h1 id="点聚合"><a href="#点聚合" class="headerlink" title="点聚合"></a>点聚合</h1><p><img src="https://i.loli.net/2020/12/21/RdhqOuo1GbyC8FN.gif" alt=""></p>
<p>当散点数据过多时，如果页面需要渲染全部的散点，页面就会出现卡顿现像，这个时候就需要先展示聚合点，然后点击查看某个区域的时候再展示当前区域的散点。</p>
<p>官方示例：</p>
<ol>
<li><a href="https://lbs.amap.com/api/javascript-api/guide/overlays/marker" target="_blank" rel="noopener"><strong>点标记</strong></a></li>
<li><a href="https://lbs.amap.com/api/javascript-api/reference/plugin#AMap.MarkerClusterer" target="_blank" rel="noopener"><strong>点聚合</strong></a></li>
<li><a href="https://lbs.amap.com/api/javascript-api/example/marker/markerclusterer" target="_blank" rel="noopener"><strong>点聚合示例</strong></a></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pointData&#x3D;[</span><br><span class="line">  &#123;town: &#39;许村镇&#39;, center: &#39;120.36694046348333,30.43513907843635&#39;, count: 218&#125;,</span><br><span class="line">  &#123;town: &quot;长安镇&quot;, center: [], count: 249&#125;,</span><br><span class="line">  ......</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 渲染聚合点</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const renderAggregationPoint &#x3D; (data) &#x3D;&gt; &#123;</span><br><span class="line">  if (data &amp;&amp; data.length &gt; 0) &#123;</span><br><span class="line">    const markers &#x3D; []</span><br><span class="line">    data.map(cu &#x3D;&gt; &#123;</span><br><span class="line">      markers.push(</span><br><span class="line">        new AMap.Marker(&#123;</span><br><span class="line">          position: cu.center.split(&#39;,&#39;),</span><br><span class="line">          content: &#39;&lt;div class&#x3D;&quot;aggregation-point-div&quot;&gt;&lt;div&gt;&#39; + cu.town + &#39;&lt;&#x2F;div&gt;&lt;div&gt;&#39; + cu.count + &#39;&lt;span&gt;家&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&#39;,</span><br><span class="line">          offset: new AMap.Pixel(-40, -30),</span><br><span class="line">          extData: &#123;</span><br><span class="line">            town: cu.town,</span><br><span class="line">            count: cu.count</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">    const cluster &#x3D; new AMap.MarkerClusterer(amap, markers, &#123;</span><br><span class="line">      gridSize: 60</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123; markers, cluster &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码地址：<a href="https://gitee.com/crystalSummer/record-code/blob/master/largeVisualScreen/haining/map/index.js" target="_blank" rel="noopener"><strong>点聚合</strong></a></p>
<h1 id="SVG实现地图操作"><a href="#SVG实现地图操作" class="headerlink" title="SVG实现地图操作"></a>SVG实现地图操作</h1><p><img src="https://i.loli.net/2021/01/07/6TNkfWmRaUX1biz.gif" alt=""><br>对于真实地图上不存在的区域，我们可以利用 SVG 来实现地图的交互，如上图所示。给每个区域添加点击事件，更换当前选中区域的颜色，更换企业名单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&#39;floorSvg&#39; @click&#x3D;&quot;initSvg&quot;&gt;</span><br><span class="line">        &lt;svg</span><br><span class="line">            version&#x3D;&quot;1.1&quot;</span><br><span class="line">            id&#x3D;&quot;svg&quot;</span><br><span class="line">            xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;</span><br><span class="line">            xmlns:xlink&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xlink&quot;</span><br><span class="line">            x&#x3D;&quot;0px&quot;</span><br><span class="line">            y&#x3D;&quot;0px&quot;</span><br><span class="line">            viewBox &#x3D; &quot;0 0 1920 1080&quot;</span><br><span class="line">            style&#x3D;&quot;enable-background:new 0 0 1920 1080;&quot;</span><br><span class="line">            xml:space&#x3D;&quot;preserve&quot;&gt;</span><br><span class="line">            &lt;g&gt;</span><br><span class="line">                &lt;defs&gt;</span><br><span class="line">                    &lt;path</span><br><span class="line">                        id&#x3D;&quot;SVGID_1_&quot;</span><br><span class="line">                        d&#x3D;&quot;M127.6,755.4l-86.5-26.5L8.8,828.7l54.5,25.3c0,0,6.4,20.3,22.8,23.2s31,13.5,35.1,19.9s36.9,31,36.9,31</span><br><span class="line">                        l48.6-27.5c0,0,35.7,9.8,40.4,18.9c4.7,9.2,39.8,40.2,39.8,40.2l8.8-2c4.8-1.1,9.3,2.6,9.3,7.5v28.5h212.6l1070.8-0.6l25.2,0.6</span><br><span class="line">                        l38.7,6.4h248.9c0,0-14.1-47.4-21.1-56.2c0,0,12.3-29.3-0.6-52.7c-12.9-23.4-48.6-26.7-48.6-26.7l-9.4-7.3</span><br><span class="line">                        c0,0-11.8-20.8-12.6-28.9c-0.8-8.1,7.5-21.4,0.3-27.6c-7.3-6.2-31.2,3.1-31.2,3.1l-8.3-7c0,0,1-13.5-3.9-20s-27.3-16.1-27.3-16.1</span><br><span class="line">                        l-13.3-4.9l-4.2-10.9l-25.8-22.4l-7.5-49.5l-12-3.4l-18,4.2l-12.2,6.7l2.6-18.4l6.2-6.8l43-5.5l16.7-5.2l0.8-18.5l-26.6-2.3</span><br><span class="line">                        l-12.5-6.2l-13.5-7.5c0,0-8.3-0.3-10.4-3.4c-2.1-3.1-8.9-11.7-8.9-11.7l-8.6,6.2l-7.5,0.5l-7.5,6.2c0,0,11.2,30.2-2.3,44.5</span><br><span class="line">                        c-13.5,14.3-15.1,16.4-15.1,16.4l-18.5-14.1l18.7-35.4l-7.5-15.1c0,0-18.5-21.4-23.4-34.7s-24.5-20.5-24.5-20.5l-19-15.1</span><br><span class="line">                        l-75.8,19.5l-185.4-140.8c0,0,9.1-0.8,6.5-14.8s-9.4-44.5-4.7-54.2c4.7-9.6,2.6-16.9-1.6-17.4c-4.2-0.5-24.5,1.8-24.5,1.8</span><br><span class="line">                        s-6,0.8-8.3-5.2c-2.3-6-2.9-19,0.8-25.3c3.6-6.2,13.5-14.6,13.5-14.6h7.8l13-2.1l6.5,1.3l10.2-14.1l-18.7-19.3</span><br><span class="line">                        c0,0,1.3-17.2,2.9-25c1.6-7.8,0.3-10.4-6.5-11.2c-6.8-0.8-26.8,0-26.8,0l-4.9-14.6l1.6-24.5c0,0,6.8-5.5,1-14.1</span><br><span class="line">                        c-5.7-8.6-17.7-14.1-17.7-14.1s-5.5-12.7-23.4-7l-8.6,3.6l6.2,10.7l-0.3,14.6l-11.5,18.5l0.5,35.7l-16.1,19.8c0,0,8.3,11.7,7,16.7</span><br><span class="line">                        c-1.3,4.9-11.7,16.1-11.7,16.1l-7.3,13.5l-19,5.2l1.3,3.1l21.9,21.1l1.8,11.5l-65.6-49.2c0,0,3.6-20.8-5.5-33.8</span><br><span class="line">                        c-9.1-13-31-12.2-31-12.2l-21.6-6l-13-8.6l7-22.9c0,0,9.4-3.9,10.2-8.6s18.5-29.4,18.5-29.4s3.9-8.1-7.8-6</span><br><span class="line">                        c-11.7,2.1-25,5.5-25,5.5l-14.8,6.2c0,0-15.9,2.1-18,0.5c-2.1-1.6,2.1-9.6,2.1-9.6l-12-17.4L962.3,123l-3.6-15.1l-5.9-4.7</span><br><span class="line">                        l-1.9-6.2l4.3-3.4l-5.8-4.3l-4.9,7.6l-19.8-11.7l-19.8-16.7l-23.4,17.2c0,0-37.5-2.6-45-0.8l-6-3.1c0,0-14.3-29.9-14.6-30.7</span><br><span class="line">                        c-0.3-0.8-24.5-10.4-28.9-9.9l-13.8-9.6l-15.6-3.1l-31.8,9.6l-15.4-0.5l-14.1,8.6l-15.9,5.7L663,64.7l-10.2,6l-18,22.9l-3.4,22.1</span><br><span class="line">                        l0.5,7.5l-3.9,14.6l-7.8,24l-1.3,18l-1.8,2.3L604.6,155l-3.6-3.4l1-7.3l-39.6-0.8l-11.2,14.6l1,5.7l-6.5-2.1l-18.7-2.6v7.5</span><br><span class="line">                        l11.7,24.3l2.6,4.1l-2.6,16.1l-4.7,3.1l-14.8-1l0.8,3.6l4.7,6.2l5.2,3.9l7.8,3.4l5.7,8.9l0.3,19l-8.3,15.1l1.3,10.4l-5.2,5.5</span><br><span class="line">                        l-13-9.6l-16.4-17.2l-19.3-3.4l-28.9,37l19,28.1l-4.7,6l11.5,21.1l-7.5,8.1l1,3.4l-4.4,7.5h-7.5l-2.6,4.2l3.1,4.2L449,395.1</span><br><span class="line">                        c0,0-15.6-8.3-20.3-4.7c-4.7,3.6-7.5,7.3-5.7,14.8s2.9,19.8,2.9,19.8l-6.8,9.9l-32-16.1h-7.5l-6.2-4.7c0,0-13.3,12.2-17.2,10.4</span><br><span class="line">                        c-3.9-1.8-18.7,3.6-34.6-20.6l-2.3-3.4l-9.6-0.5c0,0,7,19.8,18,29.7c10.9,9.9,26.8,19.8,26.8,19.8l11.5,7l22.4,4.7l3.1,5.2l1,7.3</span><br><span class="line">                        l-7,10.2l-18.5,13.8l-8.6,2.6l-0.3,8.3l7.3,15.4l-6,16.1l-14.4,4.9l-1.4,5.7l6,14.6l-16,56.2l-38.9-3.4L214.9,712l-50.5-19.4</span><br><span class="line">                        L127.6,755.4z&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;defs&gt;</span><br><span class="line">                &lt;clipPath id&#x3D;&quot;SVGID_2_&quot;&gt;</span><br><span class="line">                    &lt;use xlink:href&#x3D;&quot;#SVGID_1_&quot;  style&#x3D;&quot;overflow:visible;&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;clipPath&gt;</span><br><span class="line">                &lt;g style&#x3D;&quot;clip-path:url(#SVGID_2_);&quot;&gt;</span><br><span class="line">                    &lt;image style&#x3D;&quot;overflow:visible;&quot; width&#x3D;&quot;6800&quot; height&#x3D;&quot;3700&quot; xlink:href&#x3D;&quot;..&#x2F;..&#x2F;..&#x2F;assets&#x2F;images&#x2F;lowCarbonSmartTown-floor.png&quot;  transform&#x3D;&quot;matrix(0.2824 0 0 0.2852 -6.5484 11.0756)&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">                &lt;&#x2F;g&gt;</span><br><span class="line">            &lt;&#x2F;g&gt;</span><br><span class="line">            &lt;!-- 文字添加背景色 --&gt;</span><br><span class="line">            &lt;defs&gt;</span><br><span class="line">                &lt;filter id&#x3D;&quot;filter&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot; width&#x3D;&quot;100%&quot; height&#x3D;&quot;100%&quot;&gt;</span><br><span class="line">                    &lt;feFlood flood-color&#x3D;&quot;#000000&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;feBlend in&#x3D;&quot;SourceGraphic&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;filter&gt;</span><br><span class="line">            &lt;&#x2F;defs&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;1区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;1区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M234.5,748.7v-12.6l-6.1-10l-11.1,3.4L166.7,712l-24.9,48l-1-0.3l-1.2,9.9l-12.1,37.5l31.2,11.9l0.8,24.4</span><br><span class="line">                l-8.2,50.8l3.6,14.7c13.8-0.8,30.2-6.2,50.7-19.3c0,0,47.4,10,56.8,31c7.2,16.1,29,22.6,38.9,24.8l17.9-10.2l7.9-183.5L234.5,748.7z</span><br><span class="line">                &quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;230&quot; y&#x3D;&quot;830&quot; class&#x3D;&quot;st2&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;1区&#39;&quot;&gt;1&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;2区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;2区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M244.7,692.6l-8.4,16.5c-1.1,2.1-1,4.7,0.3,6.7l4,6.5c0.7,1.1,1,2.3,1,3.6l0,0c0,3.7,2.9,6.7,6.6,6.8l73.6,2.3</span><br><span class="line">                c3.8,0.1,6.9-2.8,7.1-6.6l2.1-49.6c0.2-4.5-3.9-7.9-8.3-7l-20.2,4.4L249.2,689C247.3,689.5,245.6,690.8,244.7,692.6z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;280&quot; y&#x3D;&quot;720&quot; class&#x3D;&quot;st3&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;2区&#39;&quot;&gt;2&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;3区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;3区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M336.1,852.1l-2.9,72c0,0,0.3,17.3,18.7,17.4c18.5,0.1,167-3.5,167-3.5s9.2,0.8,9.4-12.8s3-142.3,3-142.3</span><br><span class="line">                s2.1-15.9-14.8-16.8c-16.9-0.9-155.3-9.9-155.3-9.9s-20.6-6.4-21.6,16S336.1,852.1,336.1,852.1z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;420&quot; y&#x3D;&quot;860&quot; class&#x3D;&quot;st2&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;3区&#39;&quot;&gt;3&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;9区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;9区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M597.3,771.5c0,0-34.8-6.2-41,0c-6.2,6.2-4.7,142.9-3.9,152.7c0.8,9.8,3.9,15.6,22.1,14.4s126.7,0.1,126.7,0.1</span><br><span class="line">                s16.8,4.1,18-16.5c1.2-20.7,0-125.7,0-125.7s3.5-19.1-16.8-19.9S597.3,771.5,597.3,771.5z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;620&quot; y&#x3D;&quot;870&quot; class&#x3D;&quot;st2&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;9区&#39;&quot;&gt;9&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;4区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;4区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M342,696.1l-2.3,35.1c0,0-2,10.5,12.1,11.7c14.1,1.2,164,12.4,164,12.4s12.5,0.4,13.7-11.7</span><br><span class="line">                c1.2-12.1,0-25.4,0-25.4s0.4-5.8-15.2-6.4s-160.9-12.3-160.9-12.3L342,696.1z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;420&quot; y&#x3D;&quot;740&quot; class&#x3D;&quot;st3&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;4区&#39;&quot;&gt;4&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;5区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;5区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M384,563c-3.9-1.1-7.9,1-9.1,4.8c-6.6,20.6-25.8,81.3-27.5,94.3c-0.9,7.4-1.6,12.3-2,15.5</span><br><span class="line">                c-0.4,2.9,5.7,8.6,5.7,8.6c1,0.6,2,0.9,3.1,1l167.5,15.5c4.4,0.4,8.2-3.1,8.1-7.5c-0.4-19.3-1-66.1,1.7-74.1</span><br><span class="line">                c3.4-10.2,3-13.3-4.8-15.6C519.9,603.4,412.6,571.5,384,563z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;420&quot; y&#x3D;&quot;650&quot; class&#x3D;&quot;st2&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;5区&#39;&quot;&gt;5&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;6区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;6区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M466.9,399c0,0-77.7,121.1-82,133.9c-4.3,12.9-3.1,14.8,3.5,18.7s145.1,45.7,145.1,45.7s23.2-61.3,48.6-90.2</span><br><span class="line">                c25.4-28.9,25.8-35.1,25.8-35.1s5.9-9.8-6.2-15.6s-115.2-67.9-115.2-67.9S477.4,382.6,466.9,399z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;480&quot; y&#x3D;&quot;500&quot; class&#x3D;&quot;st2&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;6区&#39;&quot;&gt;6&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;7区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;7区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M609.3,220.1L495.8,364.6c0,0-9.8,9.8,2.3,19.1c12.1,9.4,113.2,65.6,113.2,65.6s9.4,7.8,17.6-5.1</span><br><span class="line">                S727.4,317,727.4,317s3.5-9-6.2-16.4c-9.8-7.4-100.8-77.3-100.8-77.3S613.1,215.3,609.3,220.1z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;600&quot; y&#x3D;&quot;350&quot; class&#x3D;&quot;st2&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;7区&#39;&quot;&gt;7&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;8区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;8区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M633.7,218.6l97.2,73c0,0,11.7,5.9,21.5-8.6c9.8-14.4,111.7-145.7,111.7-145.7s6.2-8.2,0-17.2</span><br><span class="line">                c-6.2-9-79.7-51.2-133.2-18.7s-104.7,94.5-104.7,94.5s-7.4,7,0,14.8S633.7,218.6,633.7,218.6z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;720&quot; y&#x3D;&quot;200&quot; class&#x3D;&quot;st2&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;8区&#39;&quot;&gt;8&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;12区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;12区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M880.3,150.9L767.9,298.7c0,0-12,12,1.8,22.1s291.1,222.6,291.1,222.6s16.1,15.9,27.6,3.6</span><br><span class="line">                c11.5-12.2,97.9-127.8,97.9-127.8s8.3-12.5-9.1-16.9c-17.4-4.4-86.2,2.3-111.2-16.7c-25-19-63.1-90.8-75.4-121.3</span><br><span class="line">                s-46.9-99.6-92-116.6C898.6,147.9,888.2,140.6,880.3,150.9z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;950&quot; y&#x3D;&quot;380&quot; class&#x3D;&quot;st2&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;12区&#39;&quot;&gt;12&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;11区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;11区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M742.2,327.1l-94.9,129.6c0,0-7.4,9,3.9,17.2c11.3,8.2,335.1,196.8,335.1,196.8s11.3,7,17.2-4.3</span><br><span class="line">                c5.9-11.3,50.4-74.6,55.8-80.1c5.5-5.5,10.5-16.8,3.9-23.4c-6.6-6.6-308.9-235.9-308.9-235.9S747,320.6,742.2,327.1z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;850&quot; y&#x3D;&quot;530&quot; class&#x3D;&quot;st2&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;11区&#39;&quot;&gt;11&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;10（C）区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;10（C）区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M563.6,609.5c0,0,36.3-104.3,63.3-124.8c0,0,6.4-12.1,35.1,7.7s121.8,72.9,121.8,72.9s11.1,6.6,2.3,17.8</span><br><span class="line">                c-8.8,11.1-36.8,53.9-41.3,62.1c-4.4,8.2-7.9,17.6-33.1,7.6C686.6,642.8,563.6,609.5,563.6,609.5z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;650&quot; y&#x3D;&quot;580&quot; class&#x3D;&quot;st3&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;10（C）区&#39;&quot;&gt;10C&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;10（B）区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;10（B）区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M560.2,622.3c0,0-13.2,78.5-8.6,123.4c0,0-0.4,10.2,17.6,12.5c18,2.3,64.8,3.1,64.8,3.1l13.3-115.6L570,620</span><br><span class="line">                C570,620,564.2,617.7,560.2,622.3z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;565&quot; y&#x3D;&quot;720&quot; class&#x3D;&quot;st3&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;10（B）区&#39;&quot;&gt;10B&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;10（A）区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;10（A）区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M654,647.3l74,23.4c0,0,5.2-0.4,4.5,7.8s-12.8,75.4-12.8,75.4s-0.1,6.2-6.8,7.4c-6.6,1.2-61.3-3.1-61.3-3.1</span><br><span class="line">                s-11.3-0.4-10.2-9.4S654,647.3,654,647.3z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;660&quot; y&#x3D;&quot;720&quot; class&#x3D;&quot;st3&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;10（A）区&#39;&quot;&gt;10A&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;13区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;13区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M765.5,667.9c5.9-16.8,21.8-58.3,37.6-74.4c0.4-0.4,0.7-0.9,1.1-1.4c0.6-0.9,2.8-2.4,10.7,0.5</span><br><span class="line">                c9.9,3.7,149.2,82.7,166.9,92.7c0.8,0.5,1.8,0.7,2.7,0.8c1,0.1,2,1.9-0.9,12c-2.9,10.1-8,25.3-11,34c-1.3,3.7-5.3,5.7-9,4.6</span><br><span class="line">                l-193.3-59.4C766.3,676.1,764.1,671.8,765.5,667.9z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;870&quot; y&#x3D;&quot;680&quot; class&#x3D;&quot;st3&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;13区&#39;&quot;&gt;13&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;14区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;14区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M773.2,693.5l188,57.2c4.7,1.4,7.4,6.2,6.4,10.9c-4,18.2-12.8,62.1-12.5,95.4c0.4,43-2.2,50.4-2.2,50.4</span><br><span class="line">                s-0.1,12.5-12.6,12.1s-160.5-19.9-160.5-19.9s-15.4,1.2-16.7-12.9c-1.3-14.1-9.9-125-8.3-141c1-10.8,4.4-32,6.6-44.9</span><br><span class="line">                C762.2,695.3,767.8,691.8,773.2,693.5z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;840&quot; y&#x3D;&quot;820&quot; class&#x3D;&quot;st2&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;14区&#39;&quot;&gt;14&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;16（A）区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;16（A）区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M1095.6,558.7l54.2-70.4l154.9,118.2l-46.3,60.4c0,0-6.5,8.3-16.7,1.6c-10.2-6.8-146.1-98.4-146.1-98.4</span><br><span class="line">                S1089.1,564.5,1095.6,558.7z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;1180&quot; y&#x3D;&quot;600&quot; class&#x3D;&quot;st3&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;16（A）区&#39;&quot;&gt;16A&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;16（B）区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;16（B）区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M1155,480.2l46.9-58.8c0,0,5.7-6,11.7-2.6c6,3.4,139.3,122.1,139.3,122.1l-43.2,56.2L1155,480.2z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;1240&quot; y&#x3D;&quot;520&quot; class&#x3D;&quot;st3&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;16（B）区&#39;&quot;&gt;16B&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;15区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;15区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M991,919.5c0,0-10.5-106.6,0-167.5c10.5-60.9,43.5-117.9,64.6-141.7c21.1-23.8,29.5-29,32.2-25.9</span><br><span class="line">                s126.9,114.8,126.9,114.8s10.2,5.5,3.9,18.4c-6.2,12.9-21.5,55.1-25.4,116c-3.9,60.9-7,69.1-7,69.1s-6.6,12.1-11.7,12.1</span><br><span class="line">                c-5.1,0-175.1,11.5-175.1,11.5S989.8,925.4,991,919.5z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;1080&quot; y&#x3D;&quot;790&quot; class&#x3D;&quot;st2&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;15区&#39;&quot;&gt;15&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;18区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;18区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M1372.5,571.2L1301,689.9c0,0-8.6,8.6,0,16.4s102.7,79.3,102.7,79.3s10.2,11.7,21.1,1.6</span><br><span class="line">                c10.9-10.2,94.1-104.3,94.1-104.3s-59.7-30.9-80.8-56.6c-21.1-25.8-53.9-55.1-53.9-55.1S1378,567.3,1372.5,571.2z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;1380&quot; y&#x3D;&quot;700&quot; class&#x3D;&quot;st2&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;18区&#39;&quot;&gt;18&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;17区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;17区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M1248.7,906.2c0,0-2.3,21.1,12.9,20.1s133.9,6.1,133.9,6.1s11.3,2.4,10.9-12.9c-0.4-15.2,6.2-75.8,6.2-75.8</span><br><span class="line">                s2.3-10.5-8.6-19.1c-10.9-8.6-132.4-99.2-132.4-99.2s-10.5-5.5-14.8,5.5c-4.3,10.9-16.8,53.9-12.1,89</span><br><span class="line">                C1249.5,855.1,1248.7,906.2,1248.7,906.2z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;1300&quot; y&#x3D;&quot;870&quot; class&#x3D;&quot;st2&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;17区&#39;&quot;&gt;17&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;19区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;19区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M1428.2,830.9l110.1-148l66.8,14.4l89,71.4c0,0,2.9,5.9,0,11.8c-2.9,5.9-103.1,145.9-103.1,145.9</span><br><span class="line">                s-5.9,14.4-21.1,12.8s-121.3-12.8-121.3-12.8s-14.6,2.3-15.2-11.7C1432.8,900.6,1428.2,830.9,1428.2,830.9z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;1530&quot; y&#x3D;&quot;840&quot; class&#x3D;&quot;st2&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;19区&#39;&quot;&gt;19&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                @click.stop&#x3D;&quot;areaClick(&#39;20区&#39;)&quot;</span><br><span class="line">                :class&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;20区&#39;?&#39;active&#39;:&#39;&#39;&quot;</span><br><span class="line">                class&#x3D;&quot;st0&quot;</span><br><span class="line">                d&#x3D;&quot;M1716.9,787.5l-106.6,138.8c0,0-8.5,9,1.6,9s173.9,0,173.9,0l35.7-5.6c0,0,12-4.9,9.4-20.8s-46.3-70-50.2-73.4</span><br><span class="line">                c-3.9-3.4-51.8-49.7-51.8-49.7S1721.8,781.2,1716.9,787.5z&quot;&#x2F;&gt;</span><br><span class="line">            &lt;text fill&#x3D;&quot;#ffffff&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;1710&quot; y&#x3D;&quot;900&quot; class&#x3D;&quot;st2&quot; filter&#x3D;&quot;url(#filter)&quot; v-if&#x3D;&quot;currentArea&#x3D;&#x3D;&#39;20区&#39;&quot;&gt;20&lt;&#x2F;text&gt;</span><br><span class="line">            &lt;path</span><br><span class="line">                class&#x3D;&quot;st1&quot;</span><br><span class="line">                d&#x3D;&quot;M127.6,755.4l-86.5-26.5L8.8,828.7l54.5,25.3c0,0,6.4,20.3,22.8,23.2s31,13.5,35.1,19.9s36.9,31,36.9,31</span><br><span class="line">                l48.6-27.5c0,0,35.7,9.8,40.4,18.9c4.7,9.2,39.8,40.2,39.8,40.2l8.8-2c4.8-1.1,9.3,2.6,9.3,7.5v28.5h212.6l1070.8-0.6l25.2,0.6</span><br><span class="line">                l38.7,6.4h248.9c0,0-14.1-47.4-21.1-56.2c0,0,12.3-29.3-0.6-52.7c-12.9-23.4-48.6-26.7-48.6-26.7l-9.4-7.3c0,0-11.8-20.8-12.6-28.9</span><br><span class="line">                c-0.8-8.1,7.5-21.4,0.3-27.6c-7.3-6.2-31.2,3.1-31.2,3.1l-8.3-7c0,0,1-13.5-3.9-20s-27.3-16.1-27.3-16.1l-13.3-4.9l-4.2-10.9</span><br><span class="line">                l-25.8-22.4l-7.5-49.5l-12-3.4l-18,4.2l-12.2,6.7l2.6-18.4l6.2-6.8l43-5.5l16.7-5.2l0.8-18.5l-26.6-2.3l-12.5-6.2l-13.5-7.5</span><br><span class="line">                c0,0-8.3-0.3-10.4-3.4c-2.1-3.1-8.9-11.7-8.9-11.7l-8.6,6.2l-7.5,0.5l-7.5,6.2c0,0,11.2,30.2-2.3,44.5</span><br><span class="line">                c-13.5,14.3-15.1,16.4-15.1,16.4l-18.5-14.1l18.7-35.4l-7.5-15.1c0,0-18.5-21.4-23.4-34.7s-24.5-20.5-24.5-20.5l-19-15.1l-75.8,19.5</span><br><span class="line">                l-185.4-140.8c0,0,9.1-0.8,6.5-14.8s-9.4-44.5-4.7-54.2c4.7-9.6,2.6-16.9-1.6-17.4c-4.2-0.5-24.5,1.8-24.5,1.8s-6,0.8-8.3-5.2</span><br><span class="line">                c-2.3-6-2.9-19,0.8-25.3c3.6-6.2,13.5-14.6,13.5-14.6h7.8l13-2.1l6.5,1.3l10.2-14.1l-18.7-19.3c0,0,1.3-17.2,2.9-25</span><br><span class="line">                c1.6-7.8,0.3-10.4-6.5-11.2c-6.8-0.8-26.8,0-26.8,0l-4.9-14.6l1.6-24.5c0,0,6.8-5.5,1-14.1c-5.7-8.6-17.7-14.1-17.7-14.1</span><br><span class="line">                s-5.5-12.7-23.4-7l-8.6,3.6l6.2,10.7l-0.3,14.6l-11.5,18.5l0.5,35.7l-16.1,19.8c0,0,8.3,11.7,7,16.7c-1.3,4.9-11.7,16.1-11.7,16.1</span><br><span class="line">                l-7.3,13.5l-19,5.2l1.3,3.1l21.9,21.1l1.8,11.5l-65.6-49.2c0,0,3.6-20.8-5.5-33.8c-9.1-13-31-12.2-31-12.2l-21.6-6l-13-8.6l7-22.9</span><br><span class="line">                c0,0,9.4-3.9,10.2-8.6s18.5-29.4,18.5-29.4s3.9-8.1-7.8-6c-11.7,2.1-25,5.5-25,5.5l-14.8,6.2c0,0-15.9,2.1-18,0.5</span><br><span class="line">                c-2.1-1.6,2.1-9.6,2.1-9.6l-12-17.4L962.3,123l-3.6-15.1l-5.9-4.7l-1.9-6.2l4.3-3.4l-5.8-4.3l-4.9,7.6l-19.8-11.7l-19.8-16.7</span><br><span class="line">                l-23.4,17.2c0,0-37.5-2.6-45-0.8l-6-3.1c0,0-14.3-29.9-14.6-30.7c-0.3-0.8-24.5-10.4-28.9-9.9l-13.8-9.6l-15.6-3.1l-31.8,9.6</span><br><span class="line">                l-15.4-0.5l-14.1,8.6l-15.9,5.7L663,64.7l-10.2,6l-18,22.9l-3.4,22.1l0.5,7.5l-3.9,14.6l-7.8,24l-1.3,18l-1.8,2.3L604.6,155</span><br><span class="line">                l-3.6-3.4l1-7.3l-39.6-0.8l-11.2,14.6l1,5.7l-6.5-2.1l-18.7-2.6v7.5l11.7,24.3l2.6,4.1l-2.6,16.1l-4.7,3.1l-14.8-1l0.8,3.6l4.7,6.2</span><br><span class="line">                l5.2,3.9l7.8,3.4l5.7,8.9l0.3,19l-8.3,15.1l1.3,10.4l-5.2,5.5l-13-9.6l-16.4-17.2l-19.3-3.4l-28.9,37l19,28.1l-4.7,6l11.5,21.1</span><br><span class="line">                l-7.5,8.1l1,3.4l-4.4,7.5h-7.5l-2.6,4.2l3.1,4.2L449,395.1c0,0-15.6-8.3-20.3-4.7c-4.7,3.6-7.5,7.3-5.7,14.8s2.9,19.8,2.9,19.8</span><br><span class="line">                l-6.8,9.9l-32-16.1h-7.5l-6.2-4.7c0,0-13.3,12.2-17.2,10.4c-3.9-1.8-18.7,3.6-34.6-20.6l-2.3-3.4l-9.6-0.5c0,0,7,19.8,18,29.7</span><br><span class="line">                c10.9,9.9,26.8,19.8,26.8,19.8l11.5,7l22.4,4.7l3.1,5.2l1,7.3l-7,10.2l-18.5,13.8l-8.6,2.6l-0.3,8.3l7.3,15.4l-6,16.1l-14.4,4.9</span><br><span class="line">                l-1.4,5.7l6,14.6l-16,56.2l-38.9-3.4L214.9,712l-50.5-19.4L127.6,755.4z&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;svg&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;FloorSvg&#39;,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      currentArea: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">  watch: &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; 点击区域-区域选中、更新左侧企业名单</span><br><span class="line">    areaClick(areaName) &#123;</span><br><span class="line">      this.currentArea &#x3D; areaName</span><br><span class="line">      this.$emit(&#39;areaChange&#39;, this.currentArea)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 区域恢复未点中状态</span><br><span class="line">    initSvg() &#123;</span><br><span class="line">      this.currentArea &#x3D; null</span><br><span class="line">      this.$emit(&#39;areaChange&#39;, this.currentArea)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">#floorSvg&#123;</span><br><span class="line">    width:100%;</span><br><span class="line">    height:100%;</span><br><span class="line">    background:url(&#39;~@&#x2F;assets&#x2F;images&#x2F;lowCarbonSmartTown-bg.png&#39;) no-repeat;</span><br><span class="line">    background-size:100% 100%;</span><br><span class="line">    #svg&#123;</span><br><span class="line">        margin-left:13%;</span><br><span class="line">        width:60%;</span><br><span class="line">        height:100%;</span><br><span class="line">        line-height: 1;</span><br><span class="line">        .st0&#123;</span><br><span class="line">            opacity:0.5;</span><br><span class="line">            fill:#0DFFEE;</span><br><span class="line">            stroke:#11CBD4;</span><br><span class="line">            stroke-width:4;</span><br><span class="line">            stroke-miterlimit:10;</span><br><span class="line">            cursor:pointer;</span><br><span class="line">             &amp;.active&#123;</span><br><span class="line">                fill:rgba(255, 147, 13, .4);</span><br><span class="line">                stroke:#FF930D;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .st1&#123;</span><br><span class="line">            fill:none;</span><br><span class="line">            stroke:#00553B;</span><br><span class="line">            stroke-width:4;</span><br><span class="line">            stroke-miterlimit:10;</span><br><span class="line">        &#125;</span><br><span class="line">        .st2&#123;</span><br><span class="line">            font-size:0.35rem;</span><br><span class="line">        &#125;</span><br><span class="line">        .st3&#123;</span><br><span class="line">            font-size:0.25rem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p>代码地址：<a href="https://gitee.com/crystalSummer/record-code/blob/master/largeVisualScreen/liandu/components/FloorSvg.vue" target="_blank" rel="noopener"><strong>SVG实现地图操作代码</strong></a>
　　</p>
]]></content>
      <categories>
        <category>Web</category>
        <category>map</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack</title>
    <url>/2020/02/29/Webpack/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/05/27/kqjUoceTaJlt18I.png" alt=""></p>
<a id="more"></a>

<h1 id="webpack核心概念"><a href="#webpack核心概念" class="headerlink" title="webpack核心概念"></a>webpack核心概念</h1><h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口(entry)"></a>入口(entry)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.export&#123;</span><br><span class="line">    enter:&#123;</span><br><span class="line">        main:&#39;.&#x2F;src&#x2F;index.js&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 简写如下</span><br><span class="line">    entry:&#39;.&#x2F;src&#x2F;index.js&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认值是<code>./src/index.js</code>。进入入口起点后，webpack会找到哪些依赖和库是入口起点依赖的。我们还可以配置entry属性来指定一个或者多个不同的入口，比如在vue的单页面应用中，入口被修改成<code>./src/main.js</code>，而多个不同的入口一般应用于多页面应用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack多入口写法</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    pageOne: &#39;.&#x2F;src&#x2F;pageOne&#x2F;index.js&#39;,</span><br><span class="line">    pageTwo: &#39;.&#x2F;src&#x2F;pageTwo&#x2F;index.js&#39;,</span><br><span class="line">    pageThree:&#123;</span><br><span class="line">        import:&#39;.&#x2F;src&#x2F;pageThree&#x2F;index.js&#39;,</span><br><span class="line">        &#x2F;&#x2F; 当前入口所依赖的入口。它们必须在该入口被加载前被加载。</span><br><span class="line">        dependOn:&#39;pageTwo&#39;</span><br><span class="line">        &#x2F;&#x2F; filename: 指定要输出的文件名称。</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; vue多入口写法</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 多个页面可以将这一块单独提出</span><br><span class="line">    pages:&#123;</span><br><span class="line">        login:&#123;</span><br><span class="line">            &#x2F;&#x2F; page 的入口，相当于单页面应用的 main.js ， 必需</span><br><span class="line">            entry: path.join(__dirname, &#96;.&#x2F;src&#x2F;views&#x2F;login&#x2F;login.js&#96;),</span><br><span class="line">            &#x2F;&#x2F; 模板来源，相当于单页面应用的 public&#x2F;index.html，非必需，省略时默认与模块名一致</span><br><span class="line">            template: path.join(__dirname, &#39;.&#x2F;src&#x2F;views&#x2F;login&#x2F;login.html&#39;),</span><br><span class="line">            &#x2F;&#x2F; 当使用 title 选项时，template 中的 title 标签需要是 </span><br><span class="line">            &#x2F;&#x2F; &lt;title&gt;&lt;%&#x3D; htmlWebpackPlugin.options.title %&gt;&lt;&#x2F;title&gt;</span><br><span class="line">            title: &#39;gov Page&#39;,</span><br><span class="line">            favicon: path.join(__dirname, &#39;.&#x2F;public&#x2F;favicon.ico&#39;),</span><br><span class="line">            &#x2F;&#x2F; 在这个页面中包含的块，默认情况下会包含提取出来的通用 chunk 和 vendor chunk。</span><br><span class="line">            chunks:[&#39;chunk-vendors&#39;, &#39;chunk-common&#39;, &#39;login&#39;]</span><br><span class="line">        &#125;,</span><br><span class="line">        homePage:&#123;</span><br><span class="line">            entry: path.join(__dirname, &#96;.&#x2F;src&#x2F;views&#x2F;homePage&#x2F;homePage.js&#96;),</span><br><span class="line">            template: path.join(__dirname, &#39;.&#x2F;src&#x2F;views&#x2F;homePage&#x2F;homePage.html&#39;),</span><br><span class="line">            title: &#39;gov Page&#39;,</span><br><span class="line">            favicon: path.join(__dirname, &#39;.&#x2F;public&#x2F;favicon.ico&#39;),</span><br><span class="line">            chunks:[&#39;chunk-vendors&#39;, &#39;chunk-common&#39;, &#39;homePage&#39;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出-output"><a href="#输出-output" class="headerlink" title="输出(output)"></a>输出(output)</h2><p>简单来说，输出就是告诉webpack打包的时候把打包的文件夹放在什么地方，以及文件夹如何命名，里面的文件如何命名等。在webpack中，主要输出文件的默认值是<code>./dist/main.js</code>，其他生成的文件默认放在<code>./dist</code>文件夹下面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack的输出配置</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        &#x2F;&#x2F; 打包生成目录所在位置，放在根目录下面</span><br><span class="line">        publicPath:&quot;&#x2F;&quot;,</span><br><span class="line">        &#x2F;&#x2F; 打包时生成的生产环境构建文件的目录</span><br><span class="line">        path:path.resolve(__drname,&#39;dist&#39;)</span><br><span class="line">        &#x2F;&#x2F; 入口的文件名模板</span><br><span class="line">        filename: &#39;[name].js&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; vue的输出配置</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 打包生成目录所在位置，放在根目录下面</span><br><span class="line">    publicPath: &#39;&#x2F;&#39;,</span><br><span class="line">    &#x2F;&#x2F; 打包时生成的生产环境构建文件的目录</span><br><span class="line">    outputDir: &#39;dist&#39;,</span><br><span class="line">    &#x2F;&#x2F; 打包后的 css、js 等静态文件目录名,相对于outputDir</span><br><span class="line">    assetsDir: &#39;static&#39;, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>webpack只能理解JS或者JSON类型的文件，loader的作用就是能够让webpack去处理其他类型的文件，并将它们转换为有效的模块，供应用程序使用，以及添加到依赖图中。loader执行顺序：从右向左，从下向上。</p>
<p>常见loader：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file-loader: 加载文件资源，如 字体 &#x2F; 图片 等，具有移动&#x2F;复制&#x2F;命名等功能；</span><br><span class="line">url-loader: 通常用于加载图片，可以将小图片直接转换为 Date Url，减少请求；</span><br><span class="line">babel-loader: 加载 js &#x2F; jsx 文件， 将 ES6 &#x2F; ES7 代码转换成 ES5，抹平兼容性问题；</span><br><span class="line">ts-loader: 加载 ts &#x2F; tsx 文件，编译 TypeScript；</span><br><span class="line">style-loader: 将 css 代码以&lt;style&gt;标签的形式插入到 html 中；</span><br><span class="line">css-loader: 分析@import和url()，引用 css 文件与对应的资源；</span><br><span class="line">postcss-loader: 用于 css 的兼容性处理，具有众多功能，例如 添加前缀，单位转换 等；</span><br><span class="line">less-loader &#x2F; sass-loader: css预处理器，在 css 中新增了许多语法，提高了开发效率；</span><br></pre></td></tr></table></figure>

<p>loader 解析代码，构建 AST(抽象语法树)， 遍历进行定向的修改后，再重新生成新的代码字符串。如我们常用的 babel-loader 会执行以下步骤:</p>
<ul>
<li>babylon 将 ES6/ES7 代码解析成 AST</li>
<li>babel-traverse 对 AST 进行遍历转译，得到新的 AST</li>
<li>新 AST 通过 babel-generator 转换成 ES5</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack使用loader示例 -- css-loader ts-loader 解析css和ts文件</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; test: &#x2F;\.css$&#x2F;, use: &#39;css-loader&#39; &#125;,</span><br><span class="line">      &#123; test: &#x2F;\.ts$&#x2F;, use: &#39;ts-loader&#39; &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; vue中使用loader示例 -- svg-sprit-loader 解析svg文件</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    chainWebpack(config) &#123;</span><br><span class="line">        config.module</span><br><span class="line">            .rule(&#39;svg&#39;)</span><br><span class="line">            .exclude.add(resolve(&#39;src&#x2F;assets&#x2F;icons&#39;))</span><br><span class="line">            .end()</span><br><span class="line">        config.module</span><br><span class="line">            .rule(&#39;icons&#39;)</span><br><span class="line">            .test(&#x2F;\.svg$&#x2F;)</span><br><span class="line">            .include.add(resolve(&#39;src&#x2F;assets&#x2F;icons&#39;))</span><br><span class="line">            .end()</span><br><span class="line">            .use(&#39;svg-sprite-loader&#39;)</span><br><span class="line">            .loader(&#39;svg-sprite-loader&#39;)</span><br><span class="line">            .options(&#123;</span><br><span class="line">                symbolId: &#39;icon-[name]&#39;</span><br><span class="line">            &#125;)</span><br><span class="line">            .end()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插件-plugin"><a href="#插件-plugin" class="headerlink" title="插件(plugin)"></a>插件(plugin)</h2><p>loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。</p>
<p>常用 Plugin:</p>
<ul>
<li>UglifyJsPlugin: 压缩、混淆代码；</li>
<li>CommonsChunkPlugin: 代码分割；</li>
<li>ProvidePlugin: 自动加载模块；</li>
<li>html-webpack-plugin: 加载 html 文件，并引入 css / js 文件；</li>
<li>extract-text-webpack-plugin / mini-css-extract-plugin: 抽离样式，生成 css 文件；</li>
<li>DefinePlugin: 定义全局变量；</li>
<li>optimize-css-assets-webpack-plugin: CSS 代码去重；</li>
<li>webpack-bundle-analyzer: 代码分析；</li>
<li>compression-webpack-plugin: 使用 gzip 压缩 js 和 css；</li>
<li>happypack: 使用多进程，加速代码构建；</li>
<li>EnvironmentPlugin: 定义环境变量；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack中使用插件 - html-webpack-plugin</span><br><span class="line">&#x2F;&#x2F; 该插件生成一个HTML文件，并在里面生成一个script，引入一个名为bundle的JS文件</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &#39;bundle.js&#39;,</span><br><span class="line">        path: path.resolve(__dirname, &#39;dist&#39;),</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template:&#39;.&#x2F;public&#x2F;index.html&#39;</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; vue中使用插件 - script-ext-html-webpack-plugin 增强版html-webpack-plugin</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    chainWebpack(config) &#123;</span><br><span class="line">        config.when(process.env.NODE_ENV !&#x3D;&#x3D; &#39;development&#39;,</span><br><span class="line">            config &#x3D;&gt; &#123;</span><br><span class="line">                config</span><br><span class="line">                    .plugin(&#39;ScriptExtHtmlWebpackPlugin&#39;)</span><br><span class="line">                    .after(&#39;html&#39;)</span><br><span class="line">                    .use(&#39;script-ext-html-webpack-plugin&#39;, [&#123;</span><br><span class="line">                    &#x2F;&#x2F; &#96;runtime&#96; must same as runtimeChunk name. default is &#96;runtime&#96;</span><br><span class="line">                    inline: &#x2F;runtime\..*\.js$&#x2F;</span><br><span class="line">                    &#125;])</span><br><span class="line">                    .end()</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模式-mode"><a href="#模式-mode" class="headerlink" title="模式(mode)"></a>模式(mode)</h2><p>通过选择 development, production 或 none 之中的一个，来设置 mode 参数，可以启用 webpack 内置在相应环境下的优化。其默认值为 production。</p>
<h2 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue中的devServer配置</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; webpack-dev-server 相关配置</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        host: &#39;0.0.0.0&#39;,</span><br><span class="line">        port: port,</span><br><span class="line">        open: true,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            &#39;&#x2F;market&#39;: &#123;</span><br><span class="line">                target: &#96;http:&#x2F;&#x2F;wxdev6.600280.com&#96;,</span><br><span class="line">                changeOrigin: true,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                &#39;^&#x2F;market&#39;: &#39;&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 是否关闭用于 DNS 重绑定的 HTTP 请求的 HOST 检查。常和 host: &#39;0.0.0.0&#39;,搭配使用。</span><br><span class="line">        &#x2F;&#x2F; 这是因为联调的时候想让其他人通过IP访问本地服务</span><br><span class="line">        disableHostCheck: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="webpack打包优化"><a href="#webpack打包优化" class="headerlink" title="webpack打包优化"></a>webpack打包优化</h1><h2 id="打包过程"><a href="#打包过程" class="headerlink" title="打包过程"></a>打包过程</h2><ul>
<li>开始打包，搜索所有的依赖 - <strong>优化搜索时间</strong><br>读取配置文件，按命令初始化配置参数，创建 Compiler 对象；<br>调用插件的 apply 方法 挂载插件 监听，然后从入口文件开始执行编译。</li>
<li>解析所有的依赖，将它们解析成浏览器可运行的代码 - <strong>优化解析时间</strong><br>webpack会根据loader解析相应的文件，需要使用loader对js，css，图片，字体等文件做转换操作，由于JS是单线程，这些文件必须一个一个进行处理。</li>
<li>将所有的依赖打包到一个包 - <strong>优化压缩时间</strong><br>将解析好的代码打包到一个包里，为了让浏览器加载的包更新（减少白屏时间），webpack会对代码进行优化 - 压缩(代码包分装成一个个代码块 (Chuck))。这个时候webpack会卡好一会</li>
<li>二次打包 - <strong>优化二次打包时间</strong><br>当更改项目中一个小小的文件时，我们需要重新打包，所有的文件都必须要重新打包，需要花费同初次打包相同的时间，但项目中大部分文件都没有变更，尤其是第三方库。</li>
</ul>
<h2 id="优化搜索时间"><a href="#优化搜索时间" class="headerlink" title="优化搜索时间"></a>优化搜索时间</h2><ul>
<li>loader<br>使用loader时通过test、include、exclude三个配置项来命中 Loader 要应用规则的文件。</li>
<li>resolve.alias<br>通过别名来把原导入路径映射成一个新的导入路径，减少耗时的递归解析操作。</li>
<li>resolve.modules<br><code>resolve.modules</code>用于配置 webpack 去哪些目录下寻找第三方模块，<code>resolve.modules</code> 的默认值是 [‘node_modules’] ，含义是先去当前目录下的 ./node_modules 目录下去找想找的模块，如果没找到就去上一级目录 ../node_modules 中找，再没有就去 ../../node_modules 中找，以此类推。比如在main.js里面导入element-ui，<code>import Element from &#39;element-ui&#39;</code>意思就是直接去node_modules中查找该模块。可以通过设置<code>resolve.modules</code>的其他值去寻找其他第三方模块，减少搜索时间。</li>
<li>resolve.extendtions<br>导入文件没有带文件后缀，webpack会根据<code>resolve.extendtions</code>自动带上后缀后去尝试询问文件是否存在。使用该配置需要注意：列表要尽可能小，不要出现项目中不存在的文件后缀；出现频率高的放在前面。</li>
<li>module.noParse<br>它的作用就是让webpack忽略没有采用模块化标准的文件的递归解析，比如jQuery、chartjs。</li>
</ul>
<p>详细配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    &#x2F;&#x2F; 项目中使用的 jquery 并没有采用模块化标准，webpack 忽略它</span><br><span class="line">    noParse: &#x2F;jquery&#x2F;,</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里编译 js、jsx</span><br><span class="line">        &#x2F;&#x2F; 注意：如果项目源码中没有 jsx 文件就不要写 &#x2F;\.jsx?$&#x2F;，提升正则表达式性能</span><br><span class="line">        test: &#x2F;\.(js|jsx)$&#x2F;,</span><br><span class="line">        &#x2F;&#x2F; babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启</span><br><span class="line">        use: [&#39;babel-loader?cacheDirectory&#39;],</span><br><span class="line">        &#x2F;&#x2F; 排除 node_modules 目录下的文件</span><br><span class="line">        &#x2F;&#x2F; node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换</span><br><span class="line">        exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置模块导入规则，import&#x2F;require时会直接在这些目录找文件</span><br><span class="line">    &#x2F;&#x2F; 可以指明存放第三方模块的绝对路径，以减少寻找</span><br><span class="line">    modules: [</span><br><span class="line">      path.resolve(&#96;$&#123;project&#125;&#x2F;client&#x2F;components&#96;), </span><br><span class="line">      path.resolve(&#39;h5_commonr&#x2F;components&#39;), </span><br><span class="line">      &#39;node_modules&#39;</span><br><span class="line">    ],</span><br><span class="line">    &#x2F;&#x2F; import导入时省略后缀</span><br><span class="line">    &#x2F;&#x2F; 注意：尽可能的减少后缀尝试的可能性</span><br><span class="line">    extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;.react.js&#39;, &#39;.css&#39;, &#39;.json&#39;],</span><br><span class="line">    &#x2F;&#x2F; import导入时别名，减少耗时的递归解析操作</span><br><span class="line">    alias: &#123;</span><br><span class="line">      &#39;@compontents&#39;: path.resolve(&#96;$&#123;project&#125;&#x2F;compontents&#96;),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="优化解析时间"><a href="#优化解析时间" class="headerlink" title="优化解析时间"></a>优化解析时间</h2><p>使用 thread-loader 开启<strong>多进程打包</strong>，把这个 loader 放置在其他 loader 之前， 放置在这个 loader 之后的 loader 就会在一个单独的 worker【worker pool】 池里运行。vue-cli默认集成。<br>一般只有在大型项目或者解析loader耗时时使用，小项目使用thread-loader反而会拖慢打包的时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.js$&#x2F;,</span><br><span class="line">                exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">                &#x2F;&#x2F; 创建一个 js worker 池</span><br><span class="line">                use: [ </span><br><span class="line">                    &#39;thread-loader&#39;,</span><br><span class="line">                    &#39;babel-loader&#39;</span><br><span class="line">                ] </span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化压缩时间"><a href="#优化压缩时间" class="headerlink" title="优化压缩时间"></a>优化压缩时间</h2><p>使用 terser-webpack-pluin 插件来压缩代码，这个插件使用 terser 来缩小 JavaScript 。vue-cli默认集成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const TerserPlugin &#x3D; require(&quot;terser-webpack-plugin&quot;);</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">            new TerserPlugin(&#123;</span><br><span class="line">                parallel: true, &#x2F;&#x2F; 启动多进程</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="优化二次打包时间"><a href="#优化二次打包时间" class="headerlink" title="优化二次打包时间"></a>优化二次打包时间</h2><p>使用缓存来优化二次打包的时间，但是缓存在冷启动的时候会很慢，重新运行期间会很节省时间。</p>
<ul>
<li>cache-loder - vue-cli默认集成<br>保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 loader 使用此 loader。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:&#x2F;\.ext$&#x2F;,</span><br><span class="line">                use:[&#39;cache-loader&#39;, ...loaders],</span><br><span class="line">                include: path.resolve(&#39;src&#39;),</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>hard-source-webpack-plugin<br>第一次构建将花费正常的时间，第二次构建将显着加快（大概提升90%的构建速度）。</li>
</ul>
<p>参考文章：<br><a href="https://webpack.docschina.org/concepts/" target="_blank" rel="noopener">Webpack官方网站</a><br><a href="https://juejin.cn/post/6844904071736852487" target="_blank" rel="noopener">玩转 webpack，使你的打包速度提升 90%</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>打包</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue项目框架配置</title>
    <url>/2020/01/24/Vue%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2019/08/06/02/16/mountains-4387209_960_720.jpg" alt=""></p>
<a id="more"></a>

<h1 id="知识梳理"><a href="#知识梳理" class="headerlink" title="知识梳理"></a>知识梳理</h1><h2 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h2><p>部署应用包时的基本 URL：</p>
<ul>
<li>output.publicPath:表示的是打包生成的index.html文件里面引用资源的前缀；</li>
<li>devServer.publicPath：表示的是打包生成的静态文件所在的位置（若是devServer里面的publicPath没有设置，则会认为是output里面设置的publicPath的值）。</li>
</ul>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>
默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上，例如 https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在 https://www.my-app.com/my-app/，则设置 publicPath 为 /my-app/。
</div>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>
这个值也可以被设置为空字符串 ('') 或是相对路径 ('./')，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径。
</div>

<ol>
<li>推荐写法，生产环境配置为相对路径’’,开发环境时devServer和output的publicPath设置为/：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    publicPath: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;&#39; : &#39;&#x2F;&#39;, </span><br><span class="line">    devServer:&#123;</span><br><span class="line">        &#x2F;&#x2F;不设置时取外面output的publicPath</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://i.loli.net/2020/10/29/dBwN4JReyCngUKf.png" alt=""></li>
<li>打包生成的静态文件所在位置 与 html文件引用资源的前缀 相同：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    publicPath:  &#39;&#x2F;outputdist&#x2F;&#39;,</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        &#x2F;&#x2F;不设置时取外面output的publicPath</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://user-gold-cdn.xitu.io/2018/9/30/16629bb7e0e41356?imageslim" alt=""></li>
<li>打包生成的静态文件所在位置 与 html文件引用资源的前缀 不同：控制台会提示找不到相关文件。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    publicPath: &#39;&#x2F;outputdist&#x2F;&#39;</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        publicPath: &#39;&#x2F;dist&#x2F;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://user-gold-cdn.xitu.io/2018/9/30/16629d391e7781e1?imageslim" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/9/30/16629d57bc9513fb?imageslim" alt=""></li>
</ol>
<p>参考文章：<a href="https://juejin.im/post/6844903686632636423" target="_blank" rel="noopener"><strong>webpack中的path、publicPath和contentBase</strong></a></p>
<h2 id="productionSourceMap"><a href="#productionSourceMap" class="headerlink" title="productionSourceMap"></a>productionSourceMap</h2><p>　　productionSourceMap 是用来设置生产环境的 source map 开启与关闭，source map 的作用就是定位报错或者 console 的位置。<br>比如：在 main.js 的第20行有一句 console.log(‘test’)</p>
<ul>
<li>productionSourceMap = false：打包之后的代码是经过压缩加密的，浏览器控制台会打印出 ‘test’，但是不会直接给出这句打印指令是在哪个文件的哪一行，并且打包后的文件很小；</li>
<li>productionSourceMap = true：打包之后生成 map 文件，map 文件相当于查看源码的一个东西，浏览器控制台也会打印出 ‘test’，并且会准确定位到这句打印指令是在 main.js 的第20行，但是打包之后的文件很大。</li>
</ul>
<h2 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h2><p>pages 是在 multi-page 模式下构建应用，具体内容可以查看<a href="https://cli.vuejs.org/zh/config/#pages" target="_blank" rel="noopener"><strong>官方介绍</strong></a>。在 vue-cli3 vue.config.js 中的 pages 参数是会编译到 webpack 的插件html-webpack-plugin 的配置中。即 pages 就是插件 html-webpack-plugin 对应的 pages 参数。其值应该是一个对象，对象的 key 是入口的名字，value 是：</p>
<ul>
<li>一个指定了 entry, template, filename, title 和 chunks 的对象 (除了 entry 之外都是可选的)；</li>
<li>或一个指定其 entry 的字符串。</li>
</ul>
<p>value 具体内容介绍如下：</p>
<ul>
<li>entry：每个页面的入口，相当于单页面应用的 main.js ， 必需；</li>
<li>template：模板来源，相当于单页面应用的 public/index.html，非必需，省略时默认与模块名一致；</li>
<li>filename：打包后在 dist 文件下的 HTML 文件的名称，省略时默认与 template 一致；</li>
<li>title：页面在浏览器打开时的名称，当使用 title 选项时，template 中的 title 标签需要是 <title>&lt;%= htmlWebpackPlugin.options.title %&gt;</title>；</li>
<li>favicon：页面在浏览器打开时的图标；</li>
<li>inject：注入选项，四个值：true，body，head，false；<ul>
<li>true：默认值，script 标签位于 HTML 文件的 body 底部；</li>
<li>body：同 true；</li>
<li>head：script 标签位于 HTML 文件的 head 标签内；</li>
<li>false：不插入生成的 js 文件，只是单纯的生成一个 HTML 文件。</li>
</ul>
</li>
<li>minify：是否对 HTML 文件进行压缩，两个值，false（不对生成的 HTML 文件进行压缩） 或者压缩选项；</li>
<li>catch：默认值 true，表示在内容变化时才生成一个新的文件；</li>
<li>hash：是否给生成的 js 文件独特的 hash 值，默认值 false；</li>
<li>chunks：针对多入口文件，当你有多个入口时，对应会生成多个编译后的 js 文件，chunks 选项可以决定是否都使用这些生成的 js 文件。</li>
</ul>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>
chunks 默认会在生成的 html 文件中引用所有的 js 文件，当然你可以指定引入哪些特定的文件。例如：有两个入口文件，生成了两个 js 文件，如果不指定对应的 chunks，则每个生成的 html 文件中会都引入这两个 js 文件。
</div>

<p>参考文章：<a href="https://segmentfault.com/a/1190000007294861#articleHeader9" target="_blank" rel="noopener"><strong>html-webpack-plugin用法全解</strong></a></p>
<h2 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h2><ul>
<li>devServer.index：设置开发时项目运行后默认打开的 index 页面，在多端项目里面，政务端 gov 默认打开 <a href="http://localhost:port/gov.html">http://localhost:port/gov.html</a> 页面 </li>
<li>devServer.contentBase：根据 contentBase 设置的执行目录去查找 index.html 文件，不设置默认是根目录；在多端项目中，比如政务端 gov，这里就需要将 contentBase 设置成 gov，这样浏览器在打开页面的时候会去 gov 下面找 index.html 文件。</li>
</ul>
<h2 id="涉及文档"><a href="#涉及文档" class="headerlink" title="涉及文档"></a>涉及文档</h2><ul>
<li><a href="https://cli.vuejs.org/zh/config/#%E5%85%A8%E5%B1%80-cli-%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener"><strong>vue-cli的webpack配置参考</strong></a></li>
<li><a href="https://webpack.docschina.org/configuration/dev-server/" target="_blank" rel="noopener"><strong>webpack配置-devServer</strong></a></li>
<li><a href="https://webpack.docschina.org/configuration/output/#outputpublicpath" target="_blank" rel="noopener"><strong>webpack配置-publicPath</strong></a></li>
</ul>
<h1 id="单页面应用配置"><a href="#单页面应用配置" class="headerlink" title="单页面应用配置"></a>单页面应用配置</h1><p>　　单页面应用就是使用 vue-cli 脚手架新建项目时默认的项目配置，整个项目只有一个页面组成，通过 vue-router 进行路由配置。这里做了新的配置，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;</span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  publicPath: &#39;&#x2F;&#39;,</span><br><span class="line">  outputDir: &#39;dist&#39;,&#x2F;&#x2F; 打包时生成的生产环境构建文件的目录</span><br><span class="line">  assetsDir: &#39;static&#39;, &#x2F;&#x2F;打包后的 css、js 等静态文件目录名,相对于outputDir</span><br><span class="line">  lintOnSave: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39;,&#x2F;&#x2F; 开发环境的进行 eslint 校验，线上不校验</span><br><span class="line">  productionSourceMap: false,</span><br><span class="line">  &#x2F;&#x2F; 如果前端应用和后端服务器没有运行在同一个主机上，需要在开发环境下将请求代理到服务器</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: &#39;9001&#39;, &#x2F;&#x2F; 前端打开页面的端口号 http:&#x2F;&#x2F;localhost:9001</span><br><span class="line">    open: true, &#x2F;&#x2F; 应用运行成功后，浏览器是否打开页面</span><br><span class="line">    &#x2F;&#x2F; 出现编译器错误时，在浏览器中显示全屏覆盖</span><br><span class="line">    overlay: &#123;</span><br><span class="line">      warnings: false,</span><br><span class="line">      errors: true</span><br><span class="line">    &#125;,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">        [process.env.VUE_APP_BASE_API]: &#123;</span><br><span class="line">            target: &#96;http:&#x2F;&#x2F;10.1.1.139:8444&#96;, &#x2F;&#x2F; 代理地址，这里设置的地址会代替axios中设置的baseURL</span><br><span class="line">            changeOrigin: true, &#x2F;&#x2F; 如果接口跨域，需要进行这个参数配置</span><br><span class="line">            pathRewrite: &#123; &#x2F;&#x2F; pathRewrite方法重写url</span><br><span class="line">                [&#39;^&#39; + process.env.VUE_APP_BASE_API]: &#39;&#39;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; process.env.VUE_APP_BASE_API 为 &#x2F;dev-api，请求到 &#x2F;dev-api&#x2F;XXX 的请求会被代理</span><br><span class="line">        &#x2F;&#x2F; 之前的url：http:&#x2F;&#x2F;localhost:9001&#x2F;dev-api&#x2F;XXX，重写之后的url：http:&#x2F;&#x2F;10.1.1.139:8444&#x2F;XXX</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  chainWebpack(config)&#123;&#x2F;&#x2F;把当前项目的根目录的static备份到打包目录的static目录下面</span><br><span class="line">      config</span><br><span class="line">      .plugin(&#39;copy&#39;)</span><br><span class="line">      .init((CopyWebpackPlugin) &#x3D;&gt; new CopyWebpackPlugin([&#123;</span><br><span class="line"></span><br><span class="line">        from: path.resolve(__dirname, &#39;.&#x2F;static&#39;),</span><br><span class="line">        to: path.resolve(__dirname, &#39;.&#x2F;dist&#x2F;static&#39;)</span><br><span class="line">      &#125;])).end()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/10/27/YpvfhCcOIRBHQ6G.png" alt=""><br>GitHub完整代码地址：<a href="https://github.com/crystal-summer/single-terminal-single-page" target="_blank" rel="noopener"><strong>https://github.com/crystal-summer/single-terminal-single-page</strong></a><br>gitee完整代码地址：<a href="https://gitee.com/crystalSummer/single-terminal-single-page" target="_blank" rel="noopener"><strong>https://gitee.com/crystalSummer/single-terminal-single-page</strong></a></p>
<h1 id="多页面应用配置"><a href="#多页面应用配置" class="headerlink" title="多页面应用配置"></a>多页面应用配置</h1><p>　　多页面应用配置，在这里，每个页面相当于一个单页面应用，每个页面会配置自己的入口（router，vuex）、模板等，每个页面之间的跳转可以使用 location.href，而页面内可以使用入口中的 router 跳转，所以项目本身的 APP.vue 和 main.js 文件就没有作用了，可以将其删除，配置完成后，启动项目，在浏览器打开 <a href="http://localhost:9001/login.html#/" target="_blank" rel="noopener">http://localhost:9001/login.html#/</a> 就可以访问页面了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 最终文件目录如下</span><br><span class="line">|-node_modules</span><br><span class="line">|-public</span><br><span class="line">    |-favicon.ico</span><br><span class="line">    |-index.html</span><br><span class="line">|-src</span><br><span class="line">    |-assets</span><br><span class="line">    |-components</span><br><span class="line">    |-store</span><br><span class="line">    |-views</span><br><span class="line">        |-login</span><br><span class="line">             |-index.vue</span><br><span class="line">             |-login.js</span><br><span class="line">             |-login.html</span><br><span class="line">             |-router.js</span><br><span class="line">        |-homePage</span><br><span class="line">             |-index.vue</span><br><span class="line">             |-homePage.js</span><br><span class="line">             |-homePage.html</span><br><span class="line">             |-router.js</span><br><span class="line">|-.browserslistrc</span><br><span class="line">|-.eslintrc.js</span><br><span class="line">|-.gitignore</span><br><span class="line">|-babel.config.js</span><br><span class="line">|-package.json</span><br><span class="line">|-vue.config.js</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue.config.js 配置如下</span><br><span class="line">&#39;use strict&#39;</span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    publicPath: &#39;&#x2F;&#39;,</span><br><span class="line">    outputDir: &#39;dist&#39;,</span><br><span class="line">    assetsDir: &#39;static&#39;,</span><br><span class="line">    &#x2F;&#x2F; 多个页面可以将这一块单独提出</span><br><span class="line">    pages:&#123;</span><br><span class="line">        login:&#123;</span><br><span class="line">            &#x2F;&#x2F; page 的入口，相当于单页面应用的 main.js ， 必需</span><br><span class="line">            entry: path.join(__dirname, &#96;.&#x2F;src&#x2F;views&#x2F;login&#x2F;login.js&#96;),</span><br><span class="line">            &#x2F;&#x2F; 模板来源，相当于单页面应用的 public&#x2F;index.html，非必需，省略时默认与模块名一致</span><br><span class="line">            template: path.join(__dirname, &#39;.&#x2F;src&#x2F;views&#x2F;login&#x2F;login.html&#39;),</span><br><span class="line">            &#x2F;&#x2F; 当使用 title 选项时，template 中的 title 标签需要是 &lt;title&gt;&lt;%&#x3D; htmlWebpackPlugin.options.title %&gt;&lt;&#x2F;title&gt;</span><br><span class="line">            title: &#39;gov Page&#39;,</span><br><span class="line">            favicon: path.join(__dirname, &#39;.&#x2F;public&#x2F;favicon.ico&#39;),</span><br><span class="line">            &#x2F;&#x2F; 在这个页面中包含的块，默认情况下会包含提取出来的通用 chunk 和 vendor chunk。</span><br><span class="line">            chunks:[&#39;chunk-vendors&#39;, &#39;chunk-common&#39;, &#39;login&#39;]</span><br><span class="line">          &#125;,</span><br><span class="line">        homePage:&#123;</span><br><span class="line">            entry: path.join(__dirname, &#96;.&#x2F;src&#x2F;views&#x2F;homePage&#x2F;homePage.js&#96;),</span><br><span class="line">            template: path.join(__dirname, &#39;.&#x2F;src&#x2F;views&#x2F;homePage&#x2F;homePage.html&#39;),</span><br><span class="line">            title: &#39;gov Page&#39;,</span><br><span class="line">            favicon: path.join(__dirname, &#39;.&#x2F;public&#x2F;favicon.ico&#39;),</span><br><span class="line">            chunks:[&#39;chunk-vendors&#39;, &#39;chunk-common&#39;, &#39;homePage&#39;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    lintOnSave: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39;,</span><br><span class="line">    productionSourceMap: false,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">      port: &#39;9001&#39;,</span><br><span class="line">      open: true,</span><br><span class="line">      overlay: &#123;</span><br><span class="line">        warnings: false,</span><br><span class="line">        errors: true</span><br><span class="line">      &#125;,</span><br><span class="line">      proxy: &#123;</span><br><span class="line">            [process.env.VUE_APP_BASE_API]: &#123;</span><br><span class="line">                target: &#96;http:&#x2F;&#x2F;10.1.1.139:8444&#96;,</span><br><span class="line">                changeOrigin: true, </span><br><span class="line">                pathRewrite: &#123; </span><br><span class="line">                    [&#39;^&#39; + process.env.VUE_APP_BASE_API]: &#39;&#39;  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    chainWebpack(config)&#123;</span><br><span class="line">        config</span><br><span class="line">        .plugin(&#39;copy&#39;)</span><br><span class="line">        .init((CopyWebpackPlugin) &#x3D;&gt; new CopyWebpackPlugin([&#123;</span><br><span class="line">  </span><br><span class="line">          from: path.resolve(__dirname, &#39;.&#x2F;static&#39;),</span><br><span class="line">          to: path.resolve(__dirname, &#39;.&#x2F;dist&#x2F;static&#39;)</span><br><span class="line">        &#125;])).end()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多页面应用打包后的文件如下，会出现多个 HTML 文件：<br><img src="https://i.loli.net/2020/10/30/xuTp1vNR2YCUls4.png" alt=""><br>GitHub完整代码地址：<a href="https://github.com/crystal-summer/single-terminal-multi-page" target="_blank" rel="noopener"><strong>https://github.com/crystal-summer/single-terminal-multi-page</strong></a><br>gitee完整代码地址：<a href="https://gitee.com/crystalSummer/single-terminal-multi-page" target="_blank" rel="noopener"><strong>https://gitee.com/crystalSummer/single-terminal-multi-page</strong></a></p>
<h1 id="多端应用配置"><a href="#多端应用配置" class="headerlink" title="多端应用配置"></a>多端应用配置</h1><ol>
<li>多端单页面应用和多端多页面应用获取文件方式相同：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; getCreateConfig &#125; &#x3D; require(&#39;.&#x2F;config&#x2F;config.file&#39;)</span><br><span class="line">const fileName &#x3D; require(&#39;.&#x2F;config&#x2F;fileName&#39;)</span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const isProd &#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line">function getPages () &#123;</span><br><span class="line">  let obj &#x3D; &#123;&#125;</span><br><span class="line">  let &#123; html: &#123; filename: template &#125;, js: &#123; filename: entry &#125; &#125; &#x3D; getCreateConfig(process.env.selfDirName)</span><br><span class="line">  Object.entries(fileName).forEach(([k, v]) &#x3D;&gt; &#123;</span><br><span class="line">    obj[k] &#x3D; &#123;</span><br><span class="line">      entry: entry.replace(&#x2F;\$&#123;filename&#125;&#x2F;g, k),</span><br><span class="line">      template: template.replace(&#x2F;\$&#123;filename&#125;&#x2F;g, k),</span><br><span class="line">      filename: isProd ? &#96;$&#123;k&#125;.html&#96; : &#96;$&#123;process.env.selfDirName&#125;&#x2F;$&#123;k&#125;.html&#96;,</span><br><span class="line">      title: &#39;&#39;,</span><br><span class="line">      favicon: path.join(__dirname, &#39;.&#x2F;public&#x2F;favicon.ico&#39;),</span><br><span class="line">      chunks: [&#39;chunk-vendors&#39;, &#39;chunk-common&#39;, &#96;$&#123;k&#125;&#96;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return obj</span><br><span class="line">&#125;</span><br><span class="line">let pages &#x3D; getPages()</span><br></pre></td></tr></table></figure></li>
<li>多端单页面应用和多端多页面应用区别：<ul>
<li>配置 pages 不同：多端单页面应用的 pages 拿到的是当前环境（当前端）的页面，多端多页面应用的 pages 拿到的是全部页面；</li>
<li>多端单页面应用在创建文件时在 create.js 是用的是 createProj()，而多端多页面应用用的是 createProj(pathname)。</li>
</ul>
</li>
</ol>
<h2 id="多端单页面应用配置"><a href="#多端单页面应用配置" class="headerlink" title="多端单页面应用配置"></a>多端单页面应用配置</h2><p>多端单页面应用，遵循一个端一个页面的原则创建文件，创建文件的规则写在配置文件夹config里。</p>
<ul>
<li>在 config/fileName 文件新增一个文件名(相当于新建一个端/一个页面文件)；</li>
<li>在根目录创建进程文件，规定当前进程对象(eg:.env.gov .env.govDev)；</li>
<li>在 package.json 文件创建 script 脚本命令，包括启动命令和打包命令 (eg:”vue-cli-service serve –open –mode govDev)；</li>
<li>在 config/template 创建模板文件；</li>
<li>运行 npm run create 或者 node ./create/index.js，新建的文件夹和文件即生成；</li>
</ul>
<p>文件夹 config 内部是通过 fileName 指定文件夹和文件名，然后自动生成文件夹以及文件的配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  publicPath: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;&#39; : &#39;&#x2F;&#39;,</span><br><span class="line">  outputDir: &#39;dist&#x2F;&#39; + process.env.selfDirName,</span><br><span class="line">  assetsDir: &#39;static&#39;,</span><br><span class="line">  lintOnSave: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39;,</span><br><span class="line">  &#x2F;&#x2F; 当前运行环境的入口文件的配置，只打包运行当前环境的页面（仅有一个页面）</span><br><span class="line">  pages:&#123;[process.env.selfDirName]:pages[process.env.selfDirName]&#125;, </span><br><span class="line">  productionSourceMap: false,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    index: &#96;&#x2F;$&#123;process.env.selfDirName&#125;.html&#96;,</span><br><span class="line">    contentBase: path.join(__dirname, process.env.selfDirName),</span><br><span class="line">    port: process.env.port,</span><br><span class="line">  &#125;,</span><br><span class="line">  chainWebpack(config)&#123;&#x2F;&#x2F;生产环境把当前项目的根目录的static备份到dist&#x2F;static目录下面</span><br><span class="line">    let staticPath &#x3D; &#39;&#39;</span><br><span class="line">    if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      staticPath &#x3D; path.resolve(__dirname, &#96;.&#x2F;dist&#x2F;&#96; + &#96;static&#96;)</span><br><span class="line">      &#x2F;&#x2F; staticPath &#x3D; path.resolve(__dirname, &#96;.&#x2F;dist&#x2F;&#96; + process.env.selfDirName + &#96;&#x2F;static&#96;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      staticPath &#x3D; &#39;static&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    config</span><br><span class="line">      .plugin(&#39;copy&#39;)</span><br><span class="line">      .init((CopyWebpackPlugin) &#x3D;&gt; new CopyWebpackPlugin([&#123;</span><br><span class="line">        from: path.resolve(__dirname, &#39;.&#x2F;static&#39;),</span><br><span class="line">        to: staticPath</span><br><span class="line">      &#125;])).end()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GitHub完整代码地址：<a href="https://github.com/crystal-summer/multi-terminal-single-page" target="_blank" rel="noopener"><strong>https://github.com/crystal-summer/multi-terminal-single-page</strong></a><br>gitee完整代码地址：<a href="https://gitee.com/crystalSummer/multi-terminal-single-page" target="_blank" rel="noopener"><strong>https://gitee.com/crystalSummer/multi-terminal-single-page</strong></a></p>
<h2 id="多端多页面应用配置"><a href="#多端多页面应用配置" class="headerlink" title="多端多页面应用配置"></a>多端多页面应用配置</h2><p>多端多页面应用，遵循一个端多个页面原则创建文件，创建文件的规则写在配置文件夹 config 里。</p>
<ul>
<li>在 config/fileName 文件 新增端和文件名；</li>
<li>在 config/create 文件夹下新增端文件；</li>
<li>在根目录创建进程文件，规定当前进程对象(eg:.env.gov .env.govDev)；</li>
<li>在 package.json 文件创建 script 脚本命令，包括启动命令和打包命令 (eg:”vue-cli-service serve –open –mode govDev)；</li>
<li>在 config/template 创建模板文件；</li>
<li>运行 npm run new gov ，或者可以 node createGov.js 创建某个端的多页面文件；</li>
</ul>
<p>文件夹config内部是通过fileName指定文件夹和文件名，然后自动生成文件夹以及文件的配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  publicPath: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;&#39; : &#39;&#x2F;&#39;,</span><br><span class="line">  outputDir: &#39;dist&#x2F;&#39; + process.env.selfDirName,</span><br><span class="line">  assetsDir: &#39;static&#39;,</span><br><span class="line">  lintOnSave: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39;,</span><br><span class="line">  productionSourceMap: false,</span><br><span class="line">  pages, &#x2F;&#x2F;所有页面的配置</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    index: &#39;login.html&#39;,</span><br><span class="line">    contentBase: path.join(__dirname, process.env.selfDirName),</span><br><span class="line">    port: process.env.port,</span><br><span class="line">  &#125;,</span><br><span class="line">  chainWebpack(config)&#123;</span><br><span class="line">    let staticPath &#x3D; &#39;&#39;</span><br><span class="line">    if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      config.devtool &#x3D; &#39;eval-source-map&#39;</span><br><span class="line">      staticPath &#x3D; path.resolve(__dirname, &#96;.&#x2F;dist&#x2F;&#96; + &#96;static&#96;)</span><br><span class="line">      &#x2F;&#x2F; staticPath &#x3D; path.resolve(__dirname, &#96;.&#x2F;dist&#x2F;&#96; + process.env.selfDirName + &#96;&#x2F;static&#96;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      staticPath &#x3D; &#39;static&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    config</span><br><span class="line">      .plugin(&#39;copy&#39;)</span><br><span class="line">      .init((CopyWebpackPlugin) &#x3D;&gt; new CopyWebpackPlugin([&#123;</span><br><span class="line">        from: path.resolve(__dirname, &#39;.&#x2F;static&#39;),</span><br><span class="line">        to: staticPath</span><br><span class="line">      &#125;])).end()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GitHub完整代码地址：<a href="https://github.com/crystal-summer/multi-terminal-multi-page" target="_blank" rel="noopener"><strong>https://github.com/crystal-summer/multi-terminal-multi-page</strong></a><br>gitee完整代码地址：<a href="https://gitee.com/crystalSummer/multi-terminal-multi-page" target="_blank" rel="noopener"><strong>https://gitee.com/crystalSummer/multi-terminal-multi-page</strong></a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Frame</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Frame</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2（二）</title>
    <url>/2019/11/17/Vue2%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/05/23/c2JlEHzDWafFILV.png" alt=""></p>
<a id="more"></a>
<h1 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h1><p> v-model 本质上是语法糖，在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件；</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件；</li>
<li>select 将 value 作为 prop 并将 change 作为事件。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 以 input 为例</span><br><span class="line">&lt;input v-model&#x3D;&#39;something&#39;&gt;</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line"></span><br><span class="line">&lt;input v-bind:value&#x3D;&quot;something&quot; v-on:input&#x3D;&quot;something &#x3D; $event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果是在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的emit事件实现。</p>
<h1 id="Vue-不常用指令"><a href="#Vue-不常用指令" class="headerlink" title="Vue 不常用指令"></a>Vue 不常用指令</h1><p>v-text：更新元素的 textContent，可以使用大括号（Mustache 标签）；<br>v-html：更新元素的 innerHTML；<br>v-slot：缩写#，插槽名；<br>v-once：元素和组件只渲染一次；<br>v-pre：跳过该元素的编译，如果使用了Mustache 标签，那么直接显示大括号；<br>v-cloak：和CSS的<code>[v-cloak]{display:none}</code>一起使用，用于隐藏未编译的Mustache标签直到实例准备完毕。</p>
<h1 id="Vue-修饰符"><a href="#Vue-修饰符" class="headerlink" title="Vue 修饰符"></a>Vue 修饰符</h1><h2 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h2><p>.lazy：改变输入框的值时，value不变，当光标离开输入框，value值才变(input是不变，change时才变)；<br>.number：将输入值转换成数值，先输入数字后输入字符，最后的值是先输入的数字，先输入字符后输入数字，number修饰符无效。在原生input里面，可以输入小数，但是在element UI封装的input里面，只能输入整数；<br>.trim：去除首尾空格，中间空格保留；</p>
<h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>.stop：阻止事件向外冒泡；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div @click&#x3D;&quot;testFun(1)&quot;&gt;</span><br><span class="line">    &lt;div @click.stop&#x3D;&quot;testFun(2)&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">testFun(num)&#123;</span><br><span class="line">    console.log(num)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 点击子div</span><br><span class="line">&#x2F;&#x2F; 子div未绑定stop，先输出2 后输出1</span><br><span class="line">&#x2F;&#x2F; 子div绑定stop，只输出2</span><br></pre></td></tr></table></figure>
<p>.capture：事件默认是由里往外冒泡，capture作用是反过来，由外往内捕获；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div @click.capture&#x3D;&quot;testFun(1)&quot;&gt;</span><br><span class="line">    &lt;div @click&#x3D;&quot;testFun(2)&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">testFun(num)&#123;</span><br><span class="line">    console.log(num)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 点击子div</span><br><span class="line">&#x2F;&#x2F; 父div未绑定capture，先输出2 后输出1</span><br><span class="line">&#x2F;&#x2F; 父div绑定capture，先输出1 后输出2</span><br></pre></td></tr></table></figure>
<p>.prevent：阻止默认事件，如点击a链接，正常情况下会跳转，加上prevent之后不会跳转；<br>.self：事件绑定的本身才会触发事件；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div @click.self&#x3D;&quot;testFun(1)&quot;&gt;</span><br><span class="line">    &lt;div @click&#x3D;&quot;testFun(2)&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">testFun(num)&#123;</span><br><span class="line">    console.log(num)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 点击子div</span><br><span class="line">&#x2F;&#x2F; 父div未绑定self，先输出2 后输出1</span><br><span class="line">&#x2F;&#x2F; 父div绑定self，只输出2，只有点击父div，才会输出1</span><br></pre></td></tr></table></figure>
<p>.once：事件只触发一次；<br>.native：绑定原生事件；<br>.passive：当我们在监听元素滚动事件的时候，会一直触发onscroll事件，在pc端是没啥问题的，但是在移动端，会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符；<br>.sync：对一个 prop 进行“双向绑定”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 当父组件传值进子组件，子组件想要改变这个值时，可以这么做</span><br><span class="line">&#x2F;&#x2F; 父组件里</span><br><span class="line">&lt;children :foo&#x3D;&quot;bar&quot; @update:foo&#x3D;&quot;val &#x3D;&gt; bar &#x3D; val&quot;&gt;&lt;&#x2F;children&gt;</span><br><span class="line">&#x2F;&#x2F; 子组件里</span><br><span class="line">this.$emit(&#39;update:foo&#39;, newValue)</span><br><span class="line">&#x2F;&#x2F; 父组件里</span><br><span class="line">&lt;children :foo.sync&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;children&gt;</span><br><span class="line">&#x2F;&#x2F; 子组件里</span><br><span class="line">this.$emit(&#39;update:foo&#39;, newValue)</span><br></pre></td></tr></table></figure>
<h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>普通按键修饰符：<br>.enter .tab .delete .space .esc .up .down .left .right<br>系统按键修饰符：<br>.ctrl .alt .meta .shift<br>其他常见修饰符：<br>48～57为0到9十个阿拉伯数字 65～90为26个大写英文字母，97～122号为26个小写英文字母<br>.exact：精确控制系统修饰符组合触发的事件；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@click.ctrl &#x2F;&#x2F; 点击ctrl会触发，点击shift+ctrl也会触发</span><br><span class="line">@click.ctrl.exact &#x2F;&#x2F; 只有点击ctrl时才会触发</span><br></pre></td></tr></table></figure>
<h2 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h2><p>.left .right .middle：鼠标的左右中按键触发的事件；</p>
<h1 id="v-if-和-v-show"><a href="#v-if-和-v-show" class="headerlink" title="v-if 和 v-show"></a>v-if 和 v-show</h1><p>相同点：都是动态渲染DOM元素。</p>
<p>不同点：</p>
<ul>
<li><p>v-if：初始化快，但切换代价高； 只有初始条件为真时，才渲染元素，假的时候不渲染； 可以用在template上。</p>
</li>
<li><p>v-show： 初始化慢，但切换成本低（适合频繁切换）； 不管初始条件是什么，都会渲染DOM元素，只是做CSS的简单切换； 不可以用在template上。</p>
</li>
</ul>
<h1 id="v-for-和-v-if-不建议一起使用的原因"><a href="#v-for-和-v-if-不建议一起使用的原因" class="headerlink" title="v-for 和 v-if 不建议一起使用的原因"></a>v-for 和 v-if 不建议一起使用的原因</h1><p>在Vue2中，v-for的优先级比v-if高，比如v-for循环1-4，并且v-if判断数字是否等于3，Vue会先v-for出4个节点，然后再判断是否为3，是3的话就显示节点，其他节点隐藏。<br>很明显，v-for和v-if一起使用的时候，会渲染无用节点，增加无用DOM的操作。</p>
<h1 id="class-和-style-的动态绑定"><a href="#class-和-style-的动态绑定" class="headerlink" title="class 和 style 的动态绑定"></a>class 和 style 的动态绑定</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; class - 对象语法 isActive&#x3D;true hasError&#x3D;false</span><br><span class="line">&lt;div :class&#x3D;&quot;&#123;&#39;active&#39;:isActive,&#39;danger&#39;:hasError&#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F; class - 数组语法</span><br><span class="line">&lt;div :class&#x3D;&quot;[isActive?&#39;active&#39;:&#39;&#39;,hasError?&#39;danger&#39;:&#39;&#39;]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F; style - 对象语法 activeColor&#x3D;&#39;red&#39; fontSize&#x3D;18</span><br><span class="line">&lt;div :style&#x3D;&quot;&#123;color: activeColor, fontSize: fontSize + &#39;px&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F; style - 数组语法 styleColor&#x3D;&#123;color:&#39;red&#39;&#125; styleSize&#x3D;&#123;fontSize:&#39;18px&#39;&#125;</span><br><span class="line">&lt;div :style&#x3D;&quot;[styleColor,styleSize]&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h1 id="为什么data是个函数并且返回一个对象"><a href="#为什么data是个函数并且返回一个对象" class="headerlink" title="为什么data是个函数并且返回一个对象"></a>为什么data是个函数并且返回一个对象</h1><p>对象是引用关系，如果组件中 data 是一个对象，这样作用域没有隔离，组件中的 data 属性会相互影响，但是如果是一个函数的话，组件多处调用，每一次调用就会执行data函数并返回新的数据对象，这样，可以<strong>避免多处调用造成数据污染</strong>。</p>
<h1 id="如何获取data的初始值"><a href="#如何获取data的初始值" class="headerlink" title="如何获取data的初始值"></a>如何获取data的初始值</h1><p>可以通过 this.$options.data().xxx 来获取初始值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        num:10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted()&#123;</span><br><span class="line">    this.num &#x3D; 100</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">    howMuch()&#123;</span><br><span class="line">        return this.num + this.$options.data().num </span><br><span class="line">        &#x2F;&#x2F; 100 + 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何定义不需要响应的数据"><a href="#如何定义不需要响应的数据" class="headerlink" title="如何定义不需要响应的数据"></a>如何定义不需要响应的数据</h1><p>在实际开发中，会有一些数据从未改变过，是死数据，既然没有改变，就不需要响应式处理。比如下拉框的选项。</p>
<ul>
<li>定义在data之外<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    this.list1&#x3D;[&#123;XXX&#125;......]</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用Object.freeze() - 冻结数据，冻结后不可修改、不可删除、不可新增<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        list1: Object.freeze([&#123;XXX&#125;...]),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="computed如何实现传参"><a href="#computed如何实现传参" class="headerlink" title="computed如何实现传参"></a>computed如何实现传参</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;total(3)&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">computed:&#123;</span><br><span class="line">    &#x2F;&#x2F; 使用闭包</span><br><span class="line">    total()&#123;</span><br><span class="line">        return function(n)&#123;</span><br><span class="line">            return n*2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Vue-单向数据流"><a href="#Vue-单向数据流" class="headerlink" title="Vue 单向数据流"></a>Vue 单向数据流</h1><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样可以防止子组件意外改变父级组件的状态，从而导致应用的数据流向难以理解。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p>
<h1 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h1><p>beforeCreate：实例了Vue，但是还没进行数据的初始化和响应式处理；<br>created：数据已被初始化和响应式处理，在这里可以访问和修改数据；<br>beforeMount：render函数在这里被调用，生成虚拟DOM，但是还没转换成真实的DOM替换到el；<br>mounted：真实DOM挂载完毕；<br>beforeUpdate：数据更新之后，产生新的虚拟DOM，但是还没有和旧的虚拟DOM对比打补丁；<br>updated：新旧虚拟DOM对比完成，真实DOM更新；<br>beforeDestroy：实例销毁之前的操作，在这里数据还可以访问；<br>destroyed：实例销毁之后的操作，Vue所有的指令都被解绑，所有的事件监听器被移除，所有的子实例也被销毁。</p>
<h1 id="Vue-的父组件和子组件生命周期钩子函数执行顺序"><a href="#Vue-的父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue 的父组件和子组件生命周期钩子函数执行顺序"></a>Vue 的父组件和子组件生命周期钩子函数执行顺序</h1><ul>
<li>加载渲染过程<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li>
<li>子组件更新过程<br>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li>
<li>父组件更新过程<br>父 beforeUpdate -&gt; 父 updated</li>
<li>销毁过程<br>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li>
</ul>
<h1 id="在哪个生命周期内调用异步请求"><a href="#在哪个生命周期内调用异步请求" class="headerlink" title="在哪个生命周期内调用异步请求"></a>在哪个生命周期内调用异步请求</h1><p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面 loading 时间；</li>
<li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性。</li>
</ul>
<h1 id="父组件如何监听子组件的生命周期"><a href="#父组件如何监听子组件的生命周期" class="headerlink" title="父组件如何监听子组件的生命周期"></a>父组件如何监听子组件的生命周期</h1><ul>
<li>$emit<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;child @mounted&#x3D;&quot;doSomething&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">mounted()&#123;</span><br><span class="line">    this.$emit(&#39;mounted&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>@hook<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;child @hook:mounted&#x3D;&quot;doSomething&quot;&gt;</span><br><span class="line">doSomething()&#123;</span><br><span class="line">    console.log(&#39;父组件监听到 mounted 钩子函数 ...&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">mounted()&#123;</span><br><span class="line">   console.log(&#39;子组件触发 mounted 钩子函数 ...&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 打印顺序如下：</span><br><span class="line">&#x2F;&#x2F; 子组件触发 mounted 钩子函数 ...</span><br><span class="line">&#x2F;&#x2F; 父组件监听到 mounted 钩子函数 ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Vue中hook的使用"><a href="#Vue中hook的使用" class="headerlink" title="Vue中hook的使用"></a>Vue中hook的使用</h1><p>hook可以用来监听组件的生命周期</p>
<ul>
<li>定时器<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 常用写法 - 需要定义全局变量timer</span><br><span class="line">data()&#123;</span><br><span class="line">    timer:null  </span><br><span class="line">&#125;,</span><br><span class="line">mounted()&#123;</span><br><span class="line">    this.timer &#x3D; setInterval(()&#x3D;&gt;&#123;&#125;,1000);</span><br><span class="line">&#125;</span><br><span class="line">beforeDestory()&#123;</span><br><span class="line">    clearInterval(this.timer);</span><br><span class="line">    this.timer &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 使用hook</span><br><span class="line">mounted()&#123;</span><br><span class="line">    this.timer &#x3D; setInterval(()&#x3D;&gt;&#123;&#125;,1000);</span><br><span class="line">    &#x2F;&#x2F; once - 监听事件，只触发一次</span><br><span class="line">    this.$once(&#39;hook:beforeDestroy&#39;,()&#x3D;&gt;&#123;</span><br><span class="line">        clearInterval(this.timer);</span><br><span class="line">        this.timer &#x3D; null;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>监听子组件的生命周期</li>
</ul>
<h1 id="组件通信方式"><a href="#组件通信方式" class="headerlink" title="组件通信方式"></a>组件通信方式</h1><h2 id="props-emit-父子组件"><a href="#props-emit-父子组件" class="headerlink" title="props / $emit - 父子组件"></a>props / $emit - 父子组件</h2><p>父组件通过v-bind向子组件传递数据，子组件通过props接收；<br>子组件通过$emit事件传递数据，父组件通过v-on绑定事件接收数据。</p>
<h2 id="ref-与-parent-children-父子组件"><a href="#ref-与-parent-children-父子组件" class="headerlink" title="ref 与 $parent / $children - 父子组件"></a>ref 与 $parent / $children - 父子组件</h2><p>ref：获取元素DOM，但是如果是组件的话，获取的是组件的实例，拿到子组件的数据；<br>$parent / $children：访问 父 / 子 组件实例。</p>
<h2 id="EventBus-emit-on-父子、兄弟、隔代组件"><a href="#EventBus-emit-on-父子、兄弟、隔代组件" class="headerlink" title="EventBus($emit / $on) - 父子、兄弟、隔代组件"></a>EventBus($emit / $on) - 父子、兄弟、隔代组件</h2><p>通过一个空的Vue实例作为中央事件总线实现数据通讯，$emit发送事件，$on接受监听事件，具体使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在utils文件夹下面新建一个eventBus.js文件，内容如下：</span><br><span class="line">import Vue from vue</span><br><span class="line">export default new Vue()</span><br><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">import eventVue from &#39;@&#x2F;utils&#x2F;eventBus&#39;</span><br><span class="line">eventVue.$emit(&#39;passEvent&#39;,data)</span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">import eventVue from &#39;@&#x2F;utils&#x2F;eventBus&#39;</span><br><span class="line">eventVue.$on(&#39;passEvent&#39;,(data)&#x3D;&gt;&#123;&#125;)</span><br><span class="line">&#x2F;&#x2F; 移除事件监听</span><br><span class="line">import eventVue from &#39;@&#x2F;utils&#x2F;eventBus&#39;</span><br><span class="line">eventVue.$off(&#39;passEvent&#39;, &#123;&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="provide-inject-隔代组件"><a href="#provide-inject-隔代组件" class="headerlink" title="provide / inject - 隔代组件"></a>provide / inject - 隔代组件</h2><p>父组件通过provide提供变量，子孙组件通过inject注入变量。</p>
<h2 id="attrs-listeners-隔代组件"><a href="#attrs-listeners-隔代组件" class="headerlink" title="$attrs / $listeners - 隔代组件"></a>$attrs / $listeners - 隔代组件</h2><p>父组件中通过v-bind绑定的传给子孙组件的属性，如果没有被子孙组件通过props接收，就会被绑定到$attrs上，实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;child1 :name&#x3D;&quot;name&quot; :age&#x3D;&quot;age&quot; height&#x3D;&quot;170cm&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        name:&#39;Nacy&#39;</span><br><span class="line">        age:18</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">&lt;child2 v-bind&#x3D;&quot;$attrs&quot;&gt;&lt;&#x2F;child2&gt;</span><br><span class="line">&#x2F;&#x2F; inheritAttrs:false, &#x2F;&#x2F; 没有在props声明的属性会自动挂载到组件根元素上的，设置成false可以关闭这一自动行为</span><br><span class="line">props:&#123;</span><br><span class="line">    name:String</span><br><span class="line">&#125;</span><br><span class="line">create()&#123;</span><br><span class="line">    console.log(this.$attrs)</span><br><span class="line">    &#x2F;&#x2F; &#123;age:18,height:&#39;170cm&#39;&#125; 由于name被props接收，所以这里没有name属性</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 孙组件</span><br><span class="line">&#x2F;&#x2F; inheritAttrs: false,</span><br><span class="line">props: &#123;</span><br><span class="line">    age: Number</span><br><span class="line">&#125;,</span><br><span class="line">created() &#123;</span><br><span class="line">    console.log(this.$attrs); </span><br><span class="line">    &#x2F;&#x2F; &#123; height:&#39;170cm&#39; &#125; age被props接收，所以这里没有age属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="localStorage-sessionStorage-父子、兄弟、隔代组件"><a href="#localStorage-sessionStorage-父子、兄弟、隔代组件" class="headerlink" title="localStorage / sessionStorage - 父子、兄弟、隔代组件"></a>localStorage / sessionStorage - 父子、兄弟、隔代组件</h2><p>将数据保存在浏览器中，随取随用，但是数据格式、大小等受限。</p>
<h2 id="Vuex-父子、兄弟、隔代组件"><a href="#Vuex-父子、兄弟、隔代组件" class="headerlink" title="Vuex - 父子、兄弟、隔代组件"></a>Vuex - 父子、兄弟、隔代组件</h2><p>状态管理，解决localStorage / sessionStorage的痛脚。</p>
<h1 id="provide-和-inject-的数据是响应式的吗"><a href="#provide-和-inject-的数据是响应式的吗" class="headerlink" title="provide 和 inject 的数据是响应式的吗"></a>provide 和 inject 的数据是响应式的吗</h1><p>官方解释：不是响应式的，因为使用了<code>shouldObserve = false</code>告诉defineReactive函数仅仅是把键值添加到当前实例上但是不需要将其转换成响应式。但是，要想实现响应也可以，使用对象或者函数返回值就可以实现响应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        name:&#39;XX&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">provide()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        name:this.name &#x2F;&#x2F; 基本数据类型，不会响应</span><br><span class="line">        &#x2F;&#x2F; name:() &#x3D;&gt; this.name &#x2F;&#x2F; 函数返回值，会响应</span><br><span class="line">        &#x2F;&#x2F; name:&#123;newName:this.name&#125; &#x2F;&#x2F; 对象，会响应</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">inject:[&#39;name&#39;]</span><br></pre></td></tr></table></figure>

<h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 局部注册</span><br><span class="line">directives:&#123;</span><br><span class="line">    focus:&#123;</span><br><span class="line">        &#x2F;&#x2F; 只调用一次，指令第一次绑定到元素时调用</span><br><span class="line">        bind(el,binding,vnode,oldVnode)&#123;&#125;,</span><br><span class="line">        &#x2F;&#x2F; 当被绑定的元素插入到 DOM 中时调用</span><br><span class="line">        inserted()&#123;&#125;,</span><br><span class="line">        &#x2F;&#x2F; 所在组件的 VNode 更新时调用</span><br><span class="line">        update()&#123;&#125;,</span><br><span class="line">        &#x2F;&#x2F; 指令所在组件的 VNode 及其子 VNode 全部更新后调用</span><br><span class="line">        componentUpdated()&#123;&#125;,</span><br><span class="line">        &#x2F;&#x2F; 只调用一次，指令与元素解绑时调用。</span><br><span class="line">        unbind()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 全局注册</span><br><span class="line">Vue.directive(&#39;focus&#39;, &#123;</span><br><span class="line">    inserted()&#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>el：指令所绑定的元素，可以用来直接操作 DOM；</li>
<li>binding：一个对象，包含以下 property：<ul>
<li>name：指令名，不包括 v- 前缀。</li>
<li>value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。</li>
<li>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</li>
<li>expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。</li>
<li>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。</li>
<li>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。</li>
</ul>
</li>
<li>vnode：Vue 编译生成的虚拟节点。</li>
<li>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li>
</ul>
<h2 id="v-waterMark-水印"><a href="#v-waterMark-水印" class="headerlink" title="v-waterMark - 水印"></a>v-waterMark - 水印</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 水印自定义指令</span><br><span class="line"> * v-waterMark&#x3D;&#123;text,font,textColor,canWidth,canHeight&#125;</span><br><span class="line"> * text 必须 水印文字</span><br><span class="line"> * font 非必须 水印字体样式</span><br><span class="line"> * textColor 非必须 水印颜色</span><br><span class="line"> * canWidth 非必须 画布宽度</span><br><span class="line"> * canHeight 非必须 画布高度</span><br><span class="line"> *&#x2F;</span><br><span class="line">export default const waterMark &#x3D; &#123;</span><br><span class="line">  bind: function(el, &#123; value &#125;) &#123;</span><br><span class="line">    if (!value.text) throw new Error(&#39;水印内容text必传&#39;)</span><br><span class="line">    &#x2F;&#x2F; 新建画布</span><br><span class="line">    var can &#x3D; document.createElement(&#39;canvas&#39;)</span><br><span class="line">    el.appendChild(can)</span><br><span class="line">    &#x2F;&#x2F; 画布宽高</span><br><span class="line">    can.width &#x3D; value.canWidth || 200</span><br><span class="line">    can.height &#x3D; value.canHeight || 150</span><br><span class="line">    can.style.display &#x3D; &#39;none&#39;</span><br><span class="line">    var cans &#x3D; can.getContext(&#39;2d&#39;)</span><br><span class="line">    cans.rotate((-20 * Math.PI) &#x2F; 180)</span><br><span class="line">    &#x2F;&#x2F; 水印字体样式</span><br><span class="line">    cans.font &#x3D; value.font || &#39;16px Microsoft JhengHei&#39;</span><br><span class="line">    &#x2F;&#x2F; 水印颜色</span><br><span class="line">    cans.fillStyle &#x3D; value.textColor || &#39;rgba(180, 180, 180, 0.3)&#39;</span><br><span class="line">    cans.textAlign &#x3D; &#39;left&#39;</span><br><span class="line">    cans.textBaseline &#x3D; &#39;Middle&#39;</span><br><span class="line">    cans.fillText(value.text, can.width &#x2F; 10, can.height &#x2F; 2)</span><br><span class="line">    el.style.backgroundImage &#x3D; &#39;url(&#39; + can.toDataURL(&#39;image&#x2F;png&#39;) + &#39;)&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="v-hasPermi-操作权限"><a href="#v-hasPermi-操作权限" class="headerlink" title="v-hasPermi - 操作权限"></a>v-hasPermi - 操作权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import store from &#39;@&#x2F;store&#39;</span><br><span class="line">export default const hasPermi &#x3D; &#123;</span><br><span class="line">  inserted(el, &#123; value &#125;, vnode) &#123;</span><br><span class="line">    const all_permission &#x3D; &quot;*:*:*&quot;;</span><br><span class="line">    &#x2F;&#x2F; 从Vuex中取出所有的权限，如果是管理员[&quot;*:*:*&quot;]，如果是普通用户[&quot;system:user:resetPwd&quot;,&quot;tool:gen:import&quot;......]</span><br><span class="line">    const permissions &#x3D; store.getters &amp;&amp; store.getters.permissions</span><br><span class="line"></span><br><span class="line">    if (value &amp;&amp; value instanceof Array &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">      const permissionFlag &#x3D; value</span><br><span class="line"></span><br><span class="line">      const hasPermissions &#x3D; permissions.some(permission &#x3D;&gt; &#123;</span><br><span class="line">        return all_permission &#x3D;&#x3D;&#x3D; permission || permissionFlag.includes(permission)</span><br><span class="line">      &#125;)</span><br><span class="line">      &#x2F;&#x2F; 没有权限，移除DOM</span><br><span class="line">      if (!hasPermissions) &#123;</span><br><span class="line">        el.parentNode &amp;&amp; el.parentNode.removeChild(el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new Error(&#96;请设置操作权限标签值&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">&lt;el-button v-hasPermi&#x3D;&quot;[&#39;system:menu:edit&#39;]&quot;&gt;修改&lt;&#x2F;el-button&gt;</span><br></pre></td></tr></table></figure>
<h2 id="v-hasRole-角色权限"><a href="#v-hasRole-角色权限" class="headerlink" title="v-hasRole - 角色权限"></a>v-hasRole - 角色权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import store from &#39;@&#x2F;store&#39;</span><br><span class="line">export default const hasRole &#x3D; &#123;</span><br><span class="line">  inserted(el, &#123; value &#125;, vnode) &#123;</span><br><span class="line">    const super_admin &#x3D; &quot;admin&quot;;</span><br><span class="line">    &#x2F;&#x2F; 从Vuex里面取出角色，管理员[&quot;admin&quot;]，普通用户[&quot;common&quot;]</span><br><span class="line">    const roles &#x3D; store.getters &amp;&amp; store.getters.roles</span><br><span class="line"></span><br><span class="line">    if (value &amp;&amp; value instanceof Array &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">      const roleFlag &#x3D; value</span><br><span class="line"></span><br><span class="line">      const hasRole &#x3D; roles.some(role &#x3D;&gt; &#123;</span><br><span class="line">        return super_admin &#x3D;&#x3D;&#x3D; role || roleFlag.includes(role)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      if (!hasRole) &#123;</span><br><span class="line">        el.parentNode &amp;&amp; el.parentNode.removeChild(el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new Error(&#96;请设置角色权限标签值&quot;&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">&lt;el-button v-hasRole&#x3D;&quot;[&#39;common&#39;]&quot;&gt;修改&lt;&#x2F;el-button&gt;</span><br></pre></td></tr></table></figure>

<h1 id="动态指令-amp-动态参数"><a href="#动态指令-amp-动态参数" class="headerlink" title="动态指令 &amp; 动态参数"></a>动态指令 &amp; 动态参数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button @[someEvent]&#x3D;&quot;handleSomeEvent()&quot; :[someProps]&#x3D;&quot;1000&quot; &#x2F;&gt;...</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      someEvent: someCondition ? &quot;click&quot; : &quot;dbclick&quot;,</span><br><span class="line">      someProps: someCondition ? &quot;num&quot; : &quot;price&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleSomeEvent()&#123;</span><br><span class="line">      &#x2F;&#x2F; handle some event</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>Vuex原理就是利用全局混入mixin，将所创建的store对象，混入到每一个Vue实例里面。<br>代码简单实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Vue.use(xxx)会执行xxx的install方法，方法入参就是Vue</span><br><span class="line">const install &#x3D; (vue) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 全局混入</span><br><span class="line">    vue.mixin(&#123;</span><br><span class="line">        beforeCreate() &#123;</span><br><span class="line">            if (this.$options &amp;&amp; this.$options.store) &#123;</span><br><span class="line">                &#x2F;&#x2F; 根页面，直接将身上的store赋值给自己的$store，</span><br><span class="line">                这也解释了为什么使用vuex要先把store放到入口文件main.js里的根Vue实例里</span><br><span class="line">                this.$store &#x3D; this.$options.store;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 除了根页面以外，将上级的$store赋值给自己的$store</span><br><span class="line">                this.$store &#x3D; this.$parent &amp;&amp; this.$parent.$store;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 创建类Store</span><br><span class="line">class Store &#123;</span><br><span class="line">    constructor(options) &#123; &#x2F;&#x2F; options接收传入的store对象</span><br><span class="line">        this.vm &#x3D; new Vue(&#123;</span><br><span class="line">            &#x2F;&#x2F; 确保state是响应式</span><br><span class="line">            data: &#123;</span><br><span class="line">                state: options.state</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; getter</span><br><span class="line">        let getters &#x3D; options.getters || &#123;&#125;;</span><br><span class="line">        this.getters &#x3D; &#123;&#125;;</span><br><span class="line">        console.log(Object.keys(this.getters))</span><br><span class="line">        Object.keys(getters).forEach(getterName &#x3D;&gt; &#123;</span><br><span class="line">            Object.defineProperty(this.getters, getterName, &#123;</span><br><span class="line">                get: () &#x3D;&gt; &#123;</span><br><span class="line">                    return getters[getterName](this.state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; mutation</span><br><span class="line">        let mutations &#x3D; options.mutations || &#123;&#125;;</span><br><span class="line">        this.mutations &#x3D; &#123;&#125;;</span><br><span class="line">        Object.keys(mutations).forEach(mutationName &#x3D;&gt; &#123;</span><br><span class="line">            this.mutations[mutationName] &#x3D; payload &#x3D;&gt; &#123;</span><br><span class="line">                mutations[mutationName](this.state, payload);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; action</span><br><span class="line">        let actions &#x3D; options.actions || &#123;&#125;;</span><br><span class="line">        this.actions &#x3D; &#123;&#125;;</span><br><span class="line">        Object.keys(actions).forEach(actionName &#x3D;&gt; &#123;</span><br><span class="line">            this.actions[actionName] &#x3D; payload &#x3D;&gt; &#123;</span><br><span class="line">                actions[actionName](this.state, payload);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 获取state时，直接返回</span><br><span class="line">    get state() &#123;</span><br><span class="line">        return this.vm.state;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; commit方法，执行mutations的&#39;name&#39;方法</span><br><span class="line">    commit(name, payload) &#123;</span><br><span class="line">        this.mutations[name](payload);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; dispatch方法，执行actions的&#39;name&#39;方法</span><br><span class="line">    dispatch(name, payload) &#123;</span><br><span class="line">        this.actions[name](payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 把install方法和类Store暴露出去</span><br><span class="line">export default &#123;</span><br><span class="line">    install,</span><br><span class="line">    Store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><p>vue-router使用三步骤：</p>
<ol>
<li>引入vue-router，并使用Vue.use(VueRouter)：<br>定义一个VueRouter类，并定义install方法，因为Vue.use(xxx)就是执行xxx的install方法。在install方法中，利用Vue的全局混入，将router绑定到每一个Vue实例上，并执行初始化操作。</li>
<li>定义路由数组，并将数组传入VueRouter实例，并将实例暴露出去；<br>定义路由数组的map，key是path，value是对应的组件信息；<br>定义路由模式mode，不同的模式对应不同的方法；<br>根据路由map值和理由模式进行组件渲染；<br>router-link实际上是a标签；<br>router-view使用渲染函数的h函数对组件进行渲染。</li>
<li>将VueRouter实例引入到main.js，并注册到根Vue实例上</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import VueRouter from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter) &#x2F;&#x2F; 第一步</span><br><span class="line"></span><br><span class="line">export default new VueRouter(&#123; &#x2F;&#x2F; 传入的options</span><br><span class="line">    routes &#x2F;&#x2F; 第二步</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,  &#x2F;&#x2F; 第三步</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>
<p>详情参考：<a href="https://juejin.cn/post/7012272146907037732" target="_blank" rel="noopener">7张图，从零实现一个简易版Vue-Router，太通俗易懂了！</a></p>
<h1 id="项目内存泄漏"><a href="#项目内存泄漏" class="headerlink" title="项目内存泄漏"></a>项目内存泄漏</h1><p>项目在运行或者打包的时候报错：javascript heap out of memory，即内存泄漏，为了解决这个问题，需要扩展该项目的内存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; package.json</span><br><span class="line">&quot;script&quot;:&#123;</span><br><span class="line">    &#x2F;&#x2F; &quot;dev&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">    &#x2F;&#x2F; &quot;build&quot;: &quot;vue-cli-service build&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;node --max_old_space_size&#x3D;4096 node_modules&#x2F;.bin&#x2F;vue-cli-service serve&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;node --max_old_space_size&#x3D;4096 node_modules&#x2F;.bin&#x2F;vue-cli-service build&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他解决方法：详情请看<a href="https://blog.csdn.net/lucky_Zeng/article/details/108622002" target="_blank" rel="noopener">安装插件解决内存泄漏</a></p>
<h1 id="组件的二次封装"><a href="#组件的二次封装" class="headerlink" title="组件的二次封装"></a>组件的二次封装</h1><p><strong>问题：</strong>在Vue项目中使用element UI组件，虽然组件十分便捷，但是在开发过程中往往需要对组件进行二次封装。以表格el-table组件为例，该组件属性很多，如果对其进行封装，在实际使用过程中需要将该组件的属性一个一个通过props接收，十分繁琐。</p>
<p><strong>解决方法：</strong><code>$attrs</code>和<code>$listeners</code>，通过这两个属性可以实现隔代组件的通信，父组件中传递给子孙组件的数据如果没有被</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>原理</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2（一）</title>
    <url>/2019/10/09/Vue2%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/11/22/23/49/bright-1851267_960_720.jpg" alt=""></p>
<a id="more"></a>

<h1 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC：Model（模型层）View（视图层）Controller（控制层），单向通信。  </p>
<p><strong>Model层</strong>：负责存储和处理数据；</p>
<p><strong>View层</strong>：负责展示用户看到并与之交互的界面；</p>
<p><strong>Controller层</strong>：负责连接 Model 层和 View 层，接受并处理 View 层触发的事件，并在 Model 层的数据状态变动时更新 View 层。</p>
<p><strong>流程</strong>：View 层通过事件通知到 Controller 层，Controller 层经过对事件的处理完成相关业务逻辑，要求 Model 层改变数据状态，Model 层再将新数据更新到 View层<br><img src="https://s2.loli.net/2022/04/01/4HuN5VwAYhGPRoW.jpg" alt=""></p>
<p><strong>问题</strong>：某些场景下，View 层直接采用观察者/发布订阅模式监听 Model 层的变化，这样 View层和 Model 层相互持有、相互操作，导致紧密耦合，在可维护性上有待提升。由此，MVP 模式应运而生</p>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP：Model（模型层）View（视图层）Presenter（管理层） 是从MVC模式演变而来的，是双向通信。</p>
<p><strong>Model层</strong>：只负责存储数据，与 View 呈现无关，也与 UI 处理逻辑无关，发生更新也不用主动通知 View；</p>
<p><strong>View层</strong>：负责展示用户看到并与之交互的界面；</p>
<p><strong>Presenter层</strong>：负责连接 Model 层和 View 层，处理 View 层的事件，负责获取数据并将获取的数据经过处理后更新 View。</p>
<p>MVC 模式的 View 层和 Model 层存在耦合，为了解决这个问题，MVP 模式将 View 层和 Model 层解耦，之间的交互只能通过 Presenter 层，实际上，MVP 模式的目的就是将 View 层和 Model 层完全解耦，使得对 View 层的修改不会影响到 Model 层，而对 Model 层的数据改动也不会影响到View 层。</p>
<p><strong>流程</strong>：View 层触发的事件传递到 Presenter 层中处理，Presenter 层去操作 Model 层，并且将数据返回给 View层，这个过程中，View 层和 Model 层没有直接联系。而 View 层不部署业务逻辑，除了展示数据和触发事件之外，其它时间都在等着 Presenter 层来更新自己，被称为「被动视图」。<br><img src="https://s2.loli.net/2022/04/01/mI6L1RvDfQ4splz.jpg" alt=""></p>
<p><strong>问题</strong>：更新视图需要 Presenter 层直接持有 View 层，并通过调用 View 层中的方法来实现。这是手动实现，为了能够实现自动更新视图，MVVM 模式应运而生。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM：Model（模型）View（视图）ViewModel（视图模型）。 </p>
<p>MVVM 和 MVP 类似，Model 层和 View 层也被隔离开，彻底解耦，ViewModel 层相当于 Presenter 层，负责绑定 Model 层和 View 层，相比于 MVP 增加了双向绑定机制。</p>
<p>MVVM 模式的特征是 ViewModel 层和 View 层采用双向绑定的形式（Binding），View 层的变动，将自动反映在 ViewModel 层，反之亦然。</p>
<p><img src="https://s2.loli.net/2022/04/01/upLhqPytw7BEmHi.jpg" alt=""></p>
<p><strong>Vue是否是MVVM框架</strong>：<br>Vue是MVVM框架，但是不是严格符合MVVM，因为MVVM规定Model和View不能直接通信，而Vue的ref可以做到这点。</p>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><strong>优点</strong>：</p>
<ul>
<li>渐进式框架；</li>
<li>中心思想是组件化：代码可重复利用；</li>
<li>轻量级：</li>
<li>采用虚拟dom，页面运行速度快；</li>
<li>响应式：双向数据绑定；</li>
<li>单页面路由；</li>
<li>数据与视图分开。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>不支持IE8及以下；</li>
<li>单页面不利于SEO（搜索引擎最佳化）；</li>
<li>首屏加载时间长。</li>
</ul>
<h1 id="Vue为什么说是渐进式框架"><a href="#Vue为什么说是渐进式框架" class="headerlink" title="Vue为什么说是渐进式框架"></a>Vue为什么说是渐进式框架</h1><p>渐进式就是需要使用什么由开发者自行决定，从设计角度讲，Vue涵盖了图片上所有的内容：</p>
<p><img src="https://s2.loli.net/2022/04/06/4TivdM8X3jhOB2x.jpg" alt=""><br><strong>声明式渲染——组件系统——客户端路由——状态管理——构建工具</strong><br>其中vue的核心是声明式渲染和组件系统，任何情况下核心是必需的，其他的三个是可选的，可根据需要进行选择。</p>
<h1 id="Vue与-Angular-相比"><a href="#Vue与-Angular-相比" class="headerlink" title="Vue与 Angular 相比"></a>Vue与 Angular 相比</h1><p>相同点：</p>
<ul>
<li>都支持内置指令和自定义指令；</li>
<li>都支持过滤器；</li>
<li>都支持数据双向绑定；</li>
<li>都不支持低端浏览器。</li>
</ul>
<p>不同点：</p>
<ul>
<li>AngularJS学习成本高，而Vue.js的API简单、直观、易学习；</li>
<li>AngularJS是定时检查数据是否发生变化而不是实时监听的，是依赖对数据做脏检查；Vue.js是实时监听数据变化然后重新渲染页面的。</li>
</ul>
<h1 id="Vue-与-React-相比"><a href="#Vue-与-React-相比" class="headerlink" title="Vue 与 React 相比"></a>Vue 与 React 相比</h1><p>相同点：</p>
<ul>
<li>都使用了虚拟DOM，都需要编译后使用；</li>
<li>中心思想相同：一切都是组件，组件实例之间可以嵌套；</li>
<li>都是单向数据流；</li>
<li>都提供合理的钩子函数，可以让开发者定制化地去处理需求；</li>
<li>都不内置AJAX，Route等功能到核心包，而是以插件的方式加载；</li>
<li>在组件开发中都支持mixins的特性。</li>
</ul>
<p>不同点：</p>
<ul>
<li>React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。</li>
</ul>
<h1 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h1><p><strong>SPA</strong>：单页面应用，在页面初始化的时候加载相应的HTML、CSS、JavaScript，一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载和跳转，取而代之的是利用<strong>路由机制</strong>实现HTML内容的变换（切换不同的组件），从而实现UI与用户的交互，避免页面的重新加载。</p>
<p><strong>优点</strong> ：</p>
<ul>
<li><strong>用户体验好、快</strong>：内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
<li><strong>减轻服务器压力</strong>：服务器只需要出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；</li>
<li><strong>前后端分离开发</strong>：前端进行交互逻辑，后端负责数据处理；</li>
<li><strong>共用一套后端程序代码</strong>：不用修改后端程序代码就可以同时用于 Web 界面、手机、平板等多种客户端。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>初次加载耗时长</strong>：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li>
<li><strong>前进后退路由管理</strong>：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>
<li><strong>SEO 难度较大</strong>：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。以SPA方式开发的网站不容易管理也不够安全。因为没了一页一页的网页给搜索引擎的爬虫来爬，所以，在搜索引擎最佳化（SEO）的工作上，需要花费额外的功夫。</li>
</ul>
<h1 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Vue数据双向绑定是通过<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式来实现的。</p>
<p>数据的双向绑定主要包含两个方面，一个方面是数据变化更新视图，另一方面是视图变化更新数据。</p>
<p>视图变化更新数据可以通过事件监听到，比如click,input等等，关键是数据变化之后如何更新视图。</p>
<ol>
<li>当我们new一个vue之后，vue实例会执行<code>initData函数</code>；</li>
<li>首先会将data里面的属性通过proxy进行代理，使用<code>Object.defineProperty()</code>方法将data里的属性绑定到vue的实例上，比如data里面有一个参数a，这样就可以通过this.a直接访问this._data.a；</li>
<li>设置监听器Observer，给每个传进来的数据都绑定一个__ ob __对象，表示该数据已经做了响应式处理；</li>
<li>如果数据对象的属性是<strong>对象</strong>，循环执行defineReactive函数，使用<code>Object.defineProperty()</code>对数据进行set和get劫持；当数据对象的某一个属性被用到的时候，就会触发get，这个属性的订阅者watcher就被添加到消息订阅器Dep里<code>dep.addSub(watcher)</code>，当相应的数据发生改变的时候，就会触发set，<code>dep.notify()</code>消息订阅器Dep就会通知订阅者watcher去更新视图。</li>
<li>如果数据对象的属性是<strong>数组</strong>，就重写数组原型的七种变异方法(push pop shift unshift reverse sort splice)，将数组的原型保留并且继承，在不破坏原来执行结果的基础上进行功能的动态扩展，数组执行了插入元素的操作，就调用监听器Observer的observeArray函数，对数组每一项进行响应。</li>
</ol>
<h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><p>对象新增或者删除的属性无法被 set 监听到，只有对象本身存在的属性修改才会被劫持。<br>通过数组下标修改数组中的数据、通过修改数组长度清空数组 的操作方式来修改数组也是无法侦测到的。<br>当然，Vue也注意到了这一点，为了解决这一问题，Vue增加了两个全局API:Vue.set和Vue.delete。</p>
<h2 id="为什么只对对象劫持，而要对数组进行方法重写？"><a href="#为什么只对对象劫持，而要对数组进行方法重写？" class="headerlink" title="为什么只对对象劫持，而要对数组进行方法重写？"></a>为什么只对对象劫持，而要对数组进行方法重写？</h2><p>因为对象最多也就几十个属性，拦截起来数量不多，但是数组可能会有几百几千项，拦截起来非常耗性能，所以直接重写数组原型上的方法，是比较节省性能的方案。</p>
<h2 id="直接arr-index-xxx无法更新视图"><a href="#直接arr-index-xxx无法更新视图" class="headerlink" title="直接arr[index] = xxx无法更新视图"></a>直接arr[index] = xxx无法更新视图</h2><p>原因：Vue没有对数组进行Object.defineProperty的属性劫持，所以直接通过数组下标修改数组数据是无法更新视图的。<br>解决办法：<br>使用数组的splice方法，<code>arr.splice(index, 1, item)</code><br>使用<code>Vue.$set(arr, index, value)</code></p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><ol>
<li>实现监听器Observer：用来劫持并监听所有属性，如果有变动的，就通知订阅者；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Observer &#123;</span><br><span class="line">  constructor(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 给数据绑定__ob__属性，表示数据已经响应过了</span><br><span class="line">    Object.defineProperty(value, &quot;__ob__&quot;, &#123;</span><br><span class="line">      value: this,</span><br><span class="line">      enumerable: false,</span><br><span class="line">      writable: true,</span><br><span class="line">      configurable: true,</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; 这里对数组做了额外判断</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 通过重写数组原型方法来对数组的七种方法进行拦截</span><br><span class="line">      value.__proto__ &#x3D; arrayMethods;</span><br><span class="line">      &#x2F;&#x2F; 如果数组里面还包含数组 需要递归判断</span><br><span class="line">      this.observeArray(value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  walk(data) &#123;</span><br><span class="line">    &#x2F;&#x2F; 对象上的所有属性依次进行观测</span><br><span class="line">    Object.keys(data).forEach(function(key) &#123;</span><br><span class="line">      defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function defineReactive(data, key, value) &#123;</span><br><span class="line">  observe(value); &#x2F;&#x2F; 递归关键</span><br><span class="line">  Object.defineProperty(data, key, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      console.log(&quot;获取值&quot;);</span><br><span class="line">      return value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">      if (newValue &#x3D;&#x3D;&#x3D; value) return;</span><br><span class="line">      console.log(&quot;设置值&quot;);</span><br><span class="line">      value &#x3D; newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">export function observe(value) &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果传过来的是对象或者数组 进行属性劫持</span><br><span class="line">  if (</span><br><span class="line">    Object.prototype.toString.call(value) &#x3D;&#x3D;&#x3D; &quot;[object Object]&quot; ||</span><br><span class="line">    Array.isArray(value)</span><br><span class="line">  ) &#123;</span><br><span class="line">    return new Observer(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实现消息订阅器Dep：因为订阅者Watcher有很多个，Dep用来收集订阅者，在数据变化的时候执行对应的订阅者Watcher的更新函数；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Dep &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.subs &#x3D; []; &#x2F;&#x2F; 这个是存放watcher的容器</span><br><span class="line">  &#125;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;,</span><br><span class="line">  notify() &#123;</span><br><span class="line">    this.subs.forEach(function(sub) &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 修改defineReactive函数，植入消息订阅器</span><br><span class="line">function defineReactive(data, key, value) &#123;</span><br><span class="line">  observe(value)</span><br><span class="line">  var dep &#x3D; new Dep()</span><br><span class="line">  Object.defineProperty(data, key, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      if (是否需要添加订阅者) &#123;</span><br><span class="line">        dep.addSub(watcher); &#x2F;&#x2F; 在这里添加一个订阅者</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&quot;获取值&quot;);</span><br><span class="line">      return value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">      if (newValue &#x3D;&#x3D;&#x3D; value) return;</span><br><span class="line">      console.log(&quot;设置值&quot;);</span><br><span class="line">      value &#x3D; newValue;</span><br><span class="line">      dep.notify(); &#x2F;&#x2F; 如果数据变化，通知所有订阅者</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实现订阅者Watcher：当数据被使用的时候初始化一个Watcher，并被Dep收集，当数据发生变化执行相应的函数，从而更新视图；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Watcher &#123;</span><br><span class="line">  constructor(vm, exprOrFn, cb) &#123;</span><br><span class="line">    this.vm &#x3D; vm</span><br><span class="line">    this.cb &#x3D; cb &#x2F;&#x2F;回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br><span class="line">    &#x2F;&#x2F; parsePath-将data&#123;a:&#123;b:&#123;c:&#39;&#39;&#125;&#125;&#125;转化成data.a.b.c</span><br><span class="line">    this.getter &#x3D; parsePath(exprOrFn)</span><br><span class="line">    this.value &#x3D; this.get()</span><br><span class="line">  &#125;</span><br><span class="line">  get () &#123;</span><br><span class="line">    window.target &#x3D; this; &#x2F;&#x2F; 将Watcher绑定到全局target上面</span><br><span class="line">    const vm &#x3D; this.vm</span><br><span class="line">    &#x2F;&#x2F; 取值，强制执行监听器里的get函数，get函数里面Dep会判断window.target是否有值，有值就将watcher收集起来</span><br><span class="line">    let value &#x3D; vm.data[this.getter] </span><br><span class="line">    window.target &#x3D; undefined</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line">  update () &#123;</span><br><span class="line">    const oldValue &#x3D; this.value</span><br><span class="line">    this.value &#x3D; this.get()</span><br><span class="line">    &#x2F;&#x2F; 如果数据发生变化，执行回调函数更新视图</span><br><span class="line">    if (this.value !&#x3D;&#x3D; oldVal) &#123;</span><br><span class="line">      this.value &#x3D; value;</span><br><span class="line">      this.cb.call(this.vm, this.value, oldValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 修改defineReactive函数，植入消息订阅器</span><br><span class="line">function defineReactive(data, key, value) &#123;</span><br><span class="line">  observe(value)</span><br><span class="line">  var dep &#x3D; new Dep()</span><br><span class="line">  Object.defineProperty(data, key, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      if (window.target) &#123;</span><br><span class="line">        dep.addSub(window.target); &#x2F;&#x2F; 在这里添加一个订阅者</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&quot;获取值&quot;);</span><br><span class="line">      return value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">      if (newValue &#x3D;&#x3D;&#x3D; value) return;</span><br><span class="line">      console.log(&quot;设置值&quot;);</span><br><span class="line">      value &#x3D; newValue;</span><br><span class="line">      dep.notify(); &#x2F;&#x2F; 如果数据变化，通知所有订阅者</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="https://s2.loli.net/2022/04/07/nwMZAUDzxVC7cNg.png" alt=""></p>
<h1 id="模板编译原理"><a href="#模板编译原理" class="headerlink" title="模板编译原理"></a>模板编译原理</h1><p>模板编译就是将template里面的HTML代码片段编译成渲染函数render的过程，其中代码片段里面包含了vue的指令。模板编译过程如下：</p>
<ol>
<li><strong>模板解析</strong>：将template代码用正则等方式解析成AST抽象语法树；</li>
<li><strong>优化</strong>：遍历AST抽象语法树，找出静态节点和静态根节点并打上标记；</li>
<li><strong>代码生成</strong>：将AST抽象语法树转化成渲染函数render。</li>
</ol>
<h2 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h2><p>模板解析就是调用<code>parse(html)</code>函数，利用正则匹配HTML代码的开始标签、结束标签和文本，生成对应的AST语法树，不断截取HTML代码字符串，直到HTML代码解析完毕。</p>
<p>正则表达式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 匹配标签名 形如 abc-123</span><br><span class="line">const ncname &#x3D; &#96;[a-zA-Z_][\\-\\.0-9_a-zA-Z]*&#96;</span><br><span class="line">&#x2F;&#x2F; 匹配特殊标签 形如 abc:234 前面的abc:可有可无</span><br><span class="line">const qnameCapture &#x3D; &#96;((?:$&#123;ncname&#125;\\:)?$&#123;ncname&#125;)&#96;</span><br><span class="line">&#x2F;&#x2F; 匹配标签开始 形如 &lt;abc-123 捕获里面的标签名</span><br><span class="line">const startTagOpen &#x3D; new RegExp(&#96;^&lt;$&#123;qnameCapture&#125;&#96;)</span><br><span class="line">&#x2F;&#x2F; 匹配标签结束  &gt;</span><br><span class="line">const startTagClose &#x3D; &#x2F;^\s*(\&#x2F;?)&gt;&#x2F;; </span><br><span class="line">&#x2F;&#x2F; 匹配标签结尾 如 &lt;&#x2F;abc-123&gt; 捕获里面的标签名</span><br><span class="line">const endTag &#x3D; new RegExp(&#96;^&lt;\\&#x2F;$&#123;qnameCapture&#125;[^&gt;]*&gt;&#96;, &#39;g&#39;)</span><br><span class="line">&#x2F;&#x2F; 匹配属性  形如 id&#x3D;&quot;app&quot;</span><br><span class="line">const attribute &#x3D; &#x2F;^\s*([^\s&quot;&#39;&lt;&gt;\&#x2F;&#x3D;]+)(?:\s*(&#x3D;)\s*(?:&quot;([^&quot;]*)&quot;+|&#39;([^&#39;]*)&#39;+|([^\s&quot;&#39;&#x3D;&lt;&gt;&#96;]+)))?&#x2F;</span><br></pre></td></tr></table></figure>

<p>只要html还有值就一直循环执行以下步骤：</p>
<ol>
<li>获取字符 &lt; 的位置：<code>const textEnd = html.indexOf(&#39;&lt;&#39;)</code>；</li>
<li>如果 textEnd=0，说明遇到的是开始或者结束标签，如 <code>&lt;div&gt;</code> 或者 <code>&lt;/div&gt;</code>；<ul>
<li>解析开始标签<ul>
<li>利用正则匹配开始标签，如果是的话就生成一个tagName为开始标签名的对象，然后调用advance方法截取html；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const start &#x3D; html.match(startTagOpen)</span><br><span class="line">&#x2F;&#x2F; 假设html&#x3D;&#39;&lt;div id&#x3D;&#39;aa&#39; class&#x3D;&quot;box&quot;&gt;&lt;span&gt;1234&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#x2F;&#x2F; 那么start&#x3D;[&#39;&lt;div&#39;,&#39;div&#39;]</span><br><span class="line">match &#x3D; &#123;</span><br><span class="line">  tagName:start[1],</span><br><span class="line">  attrs:[]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 截取html字符串，这个时候html&#x3D;&#39;  id&#x3D;&quot;aa&quot; class&#x3D;&quot;box&quot;&gt;&lt;span&gt;1234&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&#39;</span><br><span class="line">advance(start[0].length)</span><br><span class="line">function advance(n) &#123;</span><br><span class="line">  html &#x3D; html.substring(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>利用正则匹配开始标签的 &gt;，如果匹配成功表示该标签没有属性，直接调用advance截取html，将解析出来的match返回；如果匹配不成功的话就表示该标签有属性，利用正则匹配属性。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const end &#x3D; html.match(startTagClose)</span><br><span class="line">&#x2F;&#x2F; 有属性，end&#x3D;null attr&#x3D;[&#39;id&#x3D;&quot;aa&quot;&#39;,&#39;id&#39;,&#39;&#x3D;&#39;,undefined,&#39;aa&#39;,undefined]</span><br><span class="line">while(!end &amp;&amp; attr &#x3D; html.match(attribute))&#123; &#x2F;&#x2F; 一直循环到没有属性</span><br><span class="line">  advance(attr[0].length)</span><br><span class="line">  attr &#x3D; &#123;</span><br><span class="line">    name: attr[1],</span><br><span class="line">    value: attr[3] || attr[4] || attr[5]</span><br><span class="line">  &#125;</span><br><span class="line">  match.attrs.push(attr)</span><br><span class="line">&#125;</span><br><span class="line">if(end)&#123;</span><br><span class="line">  &#x2F;&#x2F; 没有属性，end&#x3D;[&#39;&gt;&#39;,&#39;&#39;]，直接截取字符串</span><br><span class="line">  advance(1)</span><br><span class="line">  &#x2F;&#x2F; 返回解析出来的对象match</span><br><span class="line">  return match</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将返回的match节点转换成对应的AST函数，利用continue跳过本次循环<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handleStartTag(match)</span><br><span class="line">function handleStartTag(&#123; tagName, attrs &#125;) &#123;</span><br><span class="line">  &#x2F;&#x2F; 传进来的element改成AST对象形式</span><br><span class="line">  const element &#x3D; &#123;</span><br><span class="line">    tag: tagName, &#x2F;&#x2F; 标签名</span><br><span class="line">    type: 1, &#x2F;&#x2F; 节点类型 - 元素节点</span><br><span class="line">    children: [], &#x2F;&#x2F; 子节点数组</span><br><span class="line">    attrs, &#x2F;&#x2F; 属性</span><br><span class="line">    parent: null &#x2F;&#x2F; 父节点</span><br><span class="line">  &#125;</span><br><span class="line">  if (!root) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根节点只能有一个</span><br><span class="line">    root &#x3D; element</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 临时赋值给currentParent，也就是临时当一回爸爸</span><br><span class="line">  currentParent &#x3D; element</span><br><span class="line">  stack.push(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>解析结束标签<ul>
<li>如果匹配开始标签没有返回match，就说明html可能是结束标签，也可能是带有 &lt; 的文本，利用正则匹配结束标签，如果是结束标签的话，对其进行处理，确定元素节点的父子关系。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const endTagMatch &#x3D; html.match(endTag)</span><br><span class="line">if (endTagMatch) &#123;</span><br><span class="line">  advance(endTagMatch[0].length)</span><br><span class="line">  &#x2F;&#x2F; 处理结束标签</span><br><span class="line">  handleEndTag(endTagMatch[1])</span><br><span class="line">  &#x2F;&#x2F; 跳过本次循环步骤</span><br><span class="line">  continue</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 处理结束标签</span><br><span class="line">function handleEndTag(tagName) &#123;</span><br><span class="line">    &#x2F;&#x2F; 父子节点关系对应</span><br><span class="line">    &#x2F;&#x2F; 比如 &lt;div&gt; &lt;span&gt;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt;</span><br><span class="line">    &#x2F;&#x2F; 那么stack &#x3D; [&#123; div对象 &#125;, &#123; span对象 &#125;]</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 那么element就是&#123; span对象 &#125;</span><br><span class="line">    const element &#x3D; stack.pop()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; currentParent是&#123; div对象 &#125;</span><br><span class="line">    currentParent &#x3D; stack[stack.length - 1]</span><br><span class="line"></span><br><span class="line">    if (currentParent) &#123;</span><br><span class="line">        element.parent &#x3D; currentParent</span><br><span class="line">        currentParent.children.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>如果 textEnd&gt;0，说明在标签之前有一段文本；<ul>
<li>截取文本 text=html.substring(0, textEnd)；</li>
<li>调用advance函数对html字符串进行截取 advance(text.length)；</li>
<li>对文本节点进行处理<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 去除空格</span><br><span class="line">text &#x3D; text.replace(&#x2F;\s&#x2F;g, &#39;&#39;)</span><br><span class="line">if (text) &#123;</span><br><span class="line">    currentParent.children.push(&#123;</span><br><span class="line">      type: 3, &#x2F;&#x2F; 节点类型 - 文本节点</span><br><span class="line">      text</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p>注意：</p>
<ol>
<li><strong>stack变量</strong>：这个变量用来记录层级关系，将开始节点的match转化成AST函数的时候，会往stack里面push这个开始节点的AST，并将这个开始节点的AST作为临时的父对象currentParent，当处理结束标签的时候，会将stack里面的数据pop出来定义为element，element就是结束标签对应的开始标签的AST，取出最后一个数据作为临时的父对象currentParent，那么element.parent = currentParent,currentParent.children.push(element)，这样就可以确定元素之间的父子关系了。</li>
<li><strong>节点类型type</strong>：1表示是元素节点，2表示是带变量的动态文本节点，3表示是文本节点。</li>
</ol>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>优化就是调用optimize函数，遍历AST，找到静态节点和静态根节点打上标记的过程，这样做有两个好处：</p>
<ul>
<li>生成Virtual DOM的过程中，如果发现节点是静态子树，除了首次渲染外不会生成新的子节点树，而是拷贝已存在的静态子树；</li>
<li>在 Virtual DOM 通过 patching 的过程中，如果发现节点是静态节点，就直接跳过，不进行比对。</li>
</ul>
<p><strong>标记静态节点 - markStatic(node)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function markStatic (node: ASTNode) &#123;</span><br><span class="line">  node.static &#x3D; isStatic(node)</span><br><span class="line">  if (node.type &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">    for (let i &#x3D; 0, l &#x3D; node.children.length; i &lt; l; i++) &#123;</span><br><span class="line">      const child &#x3D; node.children[i]</span><br><span class="line">      markStatic(child)</span><br><span class="line">      &#x2F;&#x2F; 子节点不是静态节点，当前节点也不是</span><br><span class="line">      if (!child.static) &#123;</span><br><span class="line">        node.static &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (node.ifConditions) &#123;</span><br><span class="line">      for (let i &#x3D; 1, l &#x3D; node.ifConditions.length; i &lt; l; i++) &#123;</span><br><span class="line">        const block &#x3D; node.ifConditions[i].block</span><br><span class="line">        markStatic(block)</span><br><span class="line">        if (!block.static) &#123;</span><br><span class="line">          node.static &#x3D; false</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用isStatic函数判断节点是否是静态节点，判断节点类型type，如果type=2，表示是包含变量的动态文本节点，返回false，如果type=3，表示是不包含变量的纯文本节点，返回true，如果type=1，表示是元素节点，就需要进一步判断。</li>
<li>如果是元素节点，遍历它的子节点判断是否是静态节点，如果子节点不是静态节点，需要将当前节点的static属性设置成false，表示当前节点也不是静态节点；</li>
<li>如果当前节点的子节点带有v-if v-else的指令，这些节点没都只渲染一个，其余没有被渲染的节点不在children中，在ifConditions里，所以还需要遍历ifConditions。</li>
</ul>
<p><strong>标记静态根节点 - markStaticRoots(node)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">markStaticRoots(node)&#123;</span><br><span class="line">  if (node.type &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 静态根节点一定是元素节点，需要成为静态根节点需要满足以下条件：</span><br><span class="line">    &#x2F;&#x2F; 节点本身必须是静态节点；</span><br><span class="line">    &#x2F;&#x2F; 必须拥有子节点 children；</span><br><span class="line">    &#x2F;&#x2F; 子节点不能只是只有一个文本节点；</span><br><span class="line">    if (node.static &amp;&amp; node.children.length &amp;&amp; !(</span><br><span class="line">      node.children.length &#x3D;&#x3D;&#x3D; 1 &amp;&amp;</span><br><span class="line">      node.children[0].type &#x3D;&#x3D;&#x3D; 3</span><br><span class="line">    )) &#123;</span><br><span class="line">      node.staticRoot &#x3D; true</span><br><span class="line">      return</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        node.staticRoot &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (node.children) &#123;</span><br><span class="line">    for (let i &#x3D; 0, l &#x3D; node.children.length; i &lt; l; i++) &#123;</span><br><span class="line">      markStaticRoots(node.children[i], isInFor || !!node.for)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (node.ifConditions) &#123;</span><br><span class="line">    for (let i &#x3D; 1, l &#x3D; node.ifConditions.length; i &lt; l; i++) &#123;</span><br><span class="line">      markStaticRoots(node.ifConditions[i].block, isInFor)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>代码生成是调用generate函数将AST语法树生成渲染函数的过程。<br>假设有一个template内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;NLRX&quot;&gt;&lt;p&gt;Hello &#123;&#123;name&#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>经过模板解析转化成AST抽象语法树结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ast &#x3D; &#123;</span><br><span class="line">  &#39;type&#39;: 1,</span><br><span class="line">  &#39;tag&#39;: &#39;div&#39;,</span><br><span class="line">  &#39;attrsList&#39;: [</span><br><span class="line">      &#123;</span><br><span class="line">          &#39;name&#39;:&#39;id&#39;,</span><br><span class="line">          &#39;value&#39;:&#39;NLRX&#39;,</span><br><span class="line">      &#125;</span><br><span class="line">  ],</span><br><span class="line">  &#39;attrsMap&#39;: &#123;</span><br><span class="line">    &#39;id&#39;: &#39;NLRX&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#39;static&#39;:false,</span><br><span class="line">  &#39;parent&#39;: undefined,</span><br><span class="line">  &#39;plain&#39;: false,</span><br><span class="line">  &#39;children&#39;: [&#123;</span><br><span class="line">    &#39;type&#39;: 1,</span><br><span class="line">    &#39;tag&#39;: &#39;p&#39;,</span><br><span class="line">    &#39;plain&#39;: false,</span><br><span class="line">    &#39;static&#39;:false,</span><br><span class="line">    &#39;children&#39;: [</span><br><span class="line">      &#123;</span><br><span class="line">          &#39;type&#39;: 2,</span><br><span class="line">          &#39;expression&#39;: &#39;&quot;Hello &quot;+_s(name)&#39;,</span><br><span class="line">          &#39;text&#39;: &#39;Hello &#123;&#123;name&#125;&#125;&#39;,</span><br><span class="line">          &#39;static&#39;:false,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上到下遍历AST的每一个节点，根据节点的类型创建不同的虚拟节点类型：</p>
<ol>
<li>根节点div是一个元素节点，创建元素型的虚拟节点<code>_c(tagName,data,children)</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_c(&#39;div&#39;,&#123;attrs:&#123;&quot;id&quot;:&quot;NLRX&quot;&#125;&#125;,[&#x2F;*子节点列表*&#x2F;])</span><br></pre></td></tr></table></figure></li>
<li>div的子节点P，元素节点，创建的VNode如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_c(&#39;div&#39;,&#123;attrs:&#123;&quot;id&quot;:&quot;NLRX&quot;&#125;&#125;,[_c(&#39;p&#39;),[&#x2F;*子节点列表*&#x2F;]])</span><br></pre></td></tr></table></figure></li>
<li>p的子节点是文本节点，创建文本节点的VNode<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_c(&#39;div&#39;,&#123;attrs:&#123;&quot;id&quot;:&quot;NLRX&quot;&#125;&#125;,[_c(&#39;p&#39;),[_v(&quot;Hello &quot;+_s(name))]])</span><br></pre></td></tr></table></figure></li>
<li>AST遍历完成，将字符串转化成渲染函数：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用with改变this指向，可以方便code里去获取this（也就是Vue实例）里的数据</span><br><span class="line">let renderFn &#x3D; new Function(&#96;with(this)&#123;return $&#123;code&#125;&#125;&#96;)</span><br><span class="line">&#x2F;&#x2F; render函数字符串</span><br><span class="line">&#96;</span><br><span class="line">with(this)&#123;</span><br><span class="line">  reurn _c(</span><br><span class="line">    &#39;div&#39;,</span><br><span class="line">    &#123;</span><br><span class="line">        attrs:&#123;&quot;id&quot;:&quot;NLRX&quot;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    [</span><br><span class="line">        _c(&#39;p&#39;),</span><br><span class="line">        [</span><br><span class="line">            _v(&quot;Hello &quot;+_s(name))</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>以下是创建不同类型虚拟dom节点的方法：<br><code>_c</code>：创建元素类型节点的createElement方法；<br><code>_v</code>：创建文本类型节点的方法；<br><code>_s</code>：返回参数中的字符串方法，如；<br><code>_e</code>: 创建注释类型节点的方法。</p>
<p><img src="https://s2.loli.net/2022/04/07/xPjwhaL3Yu6vMc2.png" alt=""></p>
<h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><h2 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h2><p>虚拟DOM就是用来描述DOM节点的一个JS对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 真实DOM节点</span><br><span class="line">&lt;div class&#x3D;&quot;a&quot; id&#x3D;&quot;b&quot;&gt;我是内容&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F; 虚拟DOM节点</span><br><span class="line">&#123;</span><br><span class="line">  tag:&#39;div&#39;,        &#x2F;&#x2F; 元素标签</span><br><span class="line">  attrs:&#123;           &#x2F;&#x2F; 属性</span><br><span class="line">    class:&#39;a&#39;,</span><br><span class="line">    id:&#39;b&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  text:&#39;我是内容&#39;,  &#x2F;&#x2F; 文本内容</span><br><span class="line">  children:[]       &#x2F;&#x2F; 子元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为什么要使用虚拟DOM"><a href="#为什么要使用虚拟DOM" class="headerlink" title="为什么要使用虚拟DOM"></a>为什么要使用虚拟DOM</h2><p>真实DOM解析渲染过程：</p>
<ul>
<li><strong>解析HTML文件构建文档对象模型(DOM树)</strong>：浏览器从上到下读取标签，把他们分解成节点，从而创建 DOM 。</li>
<li><strong>解析CSS文件构建CSS对象模型(CSSOM)</strong>：当浏览器发现任何与节点相关的样式时，比如：外部，内部，或行内样式，立即停止渲染 DOM ，并利用这些节点创建 CSSOM。这就是 CSS “渲染阻塞“ 的由来。</li>
<li><strong>基于DOM和CSSOM执行脚本(Scripts)</strong>：浏览器不断构建 DOM / CSSOM 节点，直到发现外部或者行内的脚本，脚本需要等到CSS解析完才能执行，所以浏览器会停下对节点的解析，按成构建CSSOM，然后执行脚本，然后再继续解析节点，解析CSS。</li>
<li><strong>合并DOM和CSSOM形成渲染树(Render Tree)</strong>：所有的节点被解析完后，DOM 和 CSSOM 合并，形成渲染树。</li>
<li><strong>使用渲染树布局(Layout)所有元素</strong>：确定元素的位置和大小等。</li>
<li><strong>渲染(Paint)所有元素</strong>。</li>
</ul>
<p>在传统的开发模式中，用原生JS或JQ操作DOM时，浏览器会将以上的步骤重新执行一遍，如果是频繁的操作DOM节点，代价很昂贵，会出现页面卡顿的现象，影响用户体验。</p>
<p>为了解决真实DOM操作昂贵的问题，就引入了虚拟DOM，用JS模拟DOM节点。如果数据更新，会产生一个新的虚拟DOM，通过diff算法对比两个虚拟DOM对象，找出需要更新的视图，之后使用patch方法，对发生变化的DOM节点进行更新。说白了就是以JS的计算性能来换取操作真实DOM所消耗的性能。</p>
<h2 id="虚拟DOM的实现"><a href="#虚拟DOM的实现" class="headerlink" title="虚拟DOM的实现"></a>虚拟DOM的实现</h2><p>Vue初始化完成后，会调用$mount方法进入模板编译阶段，将模板编译成渲染函数render，调用该函数就会产生虚拟DOM。<br>具体实现过程如下：</p>
<ol>
<li>执行渲染函数，渲染函数是由_c _v _s等创建不同节点类型虚拟DOM函数组成，执行渲染函数，就相当于执行这些创建不同节点类型的虚拟DOM函数；</li>
<li>Vue有一个VNode类，这个类里面记录了一个真实DOM节点所需要的一系列属性，通过给这个类传入不同的参数，就可以创建不同节点类型的虚拟DOM；</li>
<li>获取虚拟DOM，初次渲染时，通过patch函数将虚拟DOM转换成真实的DOM；</li>
<li>渲染函数执行的时候会新建一个监听器watcher，一旦数据使用到就会触发get方法，将监听器添加到Dep中，如果数据发生变更，Dep会通知监听器去更新视图，产生一个新的虚拟DOM树；</li>
<li>新的和旧的虚拟DOM树通过patch函数进行对比，找到需要更新的地方，更新视图。</li>
</ol>
<h2 id="mountComponent-渲染入口"><a href="#mountComponent-渲染入口" class="headerlink" title="mountComponent - 渲染入口"></a>mountComponent - 渲染入口</h2><p>模板编译完成后会调用mountComponent函数，执行_render获取虚拟DOM，并执行_update方法将虚拟DOM转化成真实的DOM；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function mountComponent (vm, el) &#123;</span><br><span class="line">    vm.$el &#x3D; el</span><br><span class="line">    updateComponent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 执行_render函数，来调用render函数生成虚拟DOM</span><br><span class="line">      &#x2F;&#x2F; 然后接收返回值虚拟DOM，调用_update函数把虚拟DOM转为真实DOM并渲染</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 监听器，数据get触发Dep收集，数据set触发Dep通知监听器更新视图</span><br><span class="line">    new Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">      before () &#123;</span><br><span class="line">        if (vm._isMounted) &#123;</span><br><span class="line">            callHook(vm, &#39;beforeUpdate&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, true &#x2F;* isRenderWatcher *&#x2F;)</span><br><span class="line">    return vm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function lifecycleMixin(Vue) &#123;</span><br><span class="line">  &#x2F;&#x2F; 将_update挂在Vue原型上</span><br><span class="line">  Vue.prototype._update &#x3D; function (vnode) &#123;</span><br><span class="line">    const vm &#x3D; this</span><br><span class="line">    const prevVnode &#x3D; vm._vnode; &#x2F;&#x2F; 保留上一次的vnode</span><br><span class="line">    vm._vnode &#x3D; vnode;</span><br><span class="line">    if (!prevVnode) &#123;</span><br><span class="line">      &#x2F;&#x2F; 初次渲染 vm._vnode肯定不存在 要通过虚拟节点 渲染出真实的dom 赋值给$el属性</span><br><span class="line">      vm.$el &#x3D; patch(vm.$el, vnode); </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 更新时把上次的vnode和这次更新的vnode穿进去 进行diff算法</span><br><span class="line">      vm.$el &#x3D; patch(prevVnode, vnode); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="render-获取虚拟DOM"><a href="#render-获取虚拟DOM" class="headerlink" title="_render - 获取虚拟DOM"></a>_render - 获取虚拟DOM</h2><p>_render函数获取到渲染函数之后直接执行获取到虚拟DOM并且返回。执行渲染函数就相当于执行_c _s _v等创建不同节点类型虚拟DOM的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; createElement, createTextNode &#125; &#x3D; require(&#39;.&#x2F;vdom&#x2F;index&#39;)</span><br><span class="line">function renderMixin(Vue) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将_render函数挂在Vue原型上</span><br><span class="line">    Vue.prototype._render &#x3D; function() &#123;</span><br><span class="line">      const vm &#x3D; this</span><br><span class="line">      &#x2F;&#x2F; 把上一节生成的render函数取出来</span><br><span class="line">      const &#123; render &#125; &#x3D; vm.$options</span><br><span class="line">      &#x2F;&#x2F; 执行render函数并获得虚拟DOM</span><br><span class="line">      const vnode &#x3D; render.call(vm)</span><br><span class="line">      return vnode </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 创建元素节点虚拟DOM</span><br><span class="line">    Vue.prototype._c &#x3D; function(...args) &#123;</span><br><span class="line">      return createElement(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 创建文本节点虚拟DOM</span><br><span class="line">    Vue.prototype._v &#x3D; function (text) &#123;</span><br><span class="line">      return createTextNode(text)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 对象的情况，把对象转成字符串</span><br><span class="line">    Vue.prototype._s &#x3D; function (val) &#123;</span><br><span class="line">      return val &#x3D;&#x3D;&#x3D; null ? &#39;&#39; : typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39; ? JSON.stringify(val) : val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    renderMixin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Vue中有VNode类，这个类里面记录了一个真实DOM节点所需要的一系列属性，通过给这个类传入不同的参数，就可以创建不同节点类型的虚拟DOM；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建某一个节点的虚拟DOM</span><br><span class="line">class VNode &#123;</span><br><span class="line">    constructor(tag, data, key, children, text) &#123;</span><br><span class="line">        this.tag &#x3D; tag</span><br><span class="line">        this.data &#x3D; data</span><br><span class="line">        this.key &#x3D; key</span><br><span class="line">        this.children &#x3D; children</span><br><span class="line">        this.text &#x3D; text</span><br><span class="line">        &#x2F;&#x2F; 还有很多其他的属性，这里就不一一写出来了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 创建元素节点虚拟DOM</span><br><span class="line">function createElement(tag, data&#x3D; &#123;&#125;, ...children) &#123;</span><br><span class="line">    const key &#x3D; data.key</span><br><span class="line">    return new VNode(tag, data, key, children)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 创建文本节点虚拟DOM</span><br><span class="line">function createTextNode(text) &#123;</span><br><span class="line">    return new VNode(undefined, undefined, undefined, undefined, text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="patch-diff算法"><a href="#patch-diff算法" class="headerlink" title="patch - diff算法"></a>patch - diff算法</h2><p>如果是初次渲染，patch函数会将虚拟DOM转化成真正的DOM；<br>如果不是初次渲染，patch函数回通过diff算法对新旧虚拟DOM进行对比；</p>
<p><strong>初次渲染</strong>：oldVnode是el节点，vnode是虚拟DOM</p>
<ul>
<li>调用createElm方法将虚拟DOM转化成真实的DOM：<br>判断当前节点是元素节点还是文本，如果是元素，使用<code>document.createElement</code>创建元素，并且使用<code>el.setAttribute</code>给元素绑定属性，循环子节点递归创建元素绑定属性，如果是文本，使用<code>document.createTextNode</code>创建文本。</li>
<li>将生成的DOM插入到el的后面，不能直接appendChild，因为el里面可能有同级的节点，需要使用insertBefore；</li>
<li>最后删除oldVnode。</li>
</ul>
<p>具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function patch(oldVnode, vnode) &#123;</span><br><span class="line">  &#x2F;&#x2F; 判断oldVnode的类型，如果是初次渲染，oldVnode就是el节点，非初次渲染，oldVnode就是上一次的虚拟DOM</span><br><span class="line">  const isRealElement &#x3D; oldVnode.nodeType;</span><br><span class="line">  if (isRealElement) &#123; &#x2F;&#x2F; 初次渲染</span><br><span class="line">    const oldElm &#x3D; oldVnode</span><br><span class="line">    const parentElm &#x3D; oldElm.parentNode</span><br><span class="line">    &#x2F;&#x2F; 生成真实DOM对象</span><br><span class="line">    const el &#x3D; createElm(vnode)</span><br><span class="line">    &#x2F;&#x2F; 将生成的真实DOM。插入到el的下一个节点的前面</span><br><span class="line">    &#x2F;&#x2F; 也就是插到el的后面</span><br><span class="line">    &#x2F;&#x2F; 不直接appendChild是因为可能页面中有其他el同级节点，不能破坏顺序</span><br><span class="line">    parentElm.insertBefore(el, oldElm.nextSibling)</span><br><span class="line">    &#x2F;&#x2F; 删除老el节点</span><br><span class="line">    parentElm.removeChild(oldVnode)</span><br><span class="line">    return el</span><br><span class="line">  &#125; else &#123; &#x2F;&#x2F; 非初次渲染</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 虚拟DOM生成真实DOM</span><br><span class="line">function createElm(vnode) &#123;</span><br><span class="line">  const &#123; tag, data, key, children, text &#125; &#x3D; vnode</span><br><span class="line">  &#x2F;&#x2F; 判断是元素节点还是文本节点</span><br><span class="line">  if (typeof tag &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建标签</span><br><span class="line">    vnode.el &#x3D; document.createElement(tag)</span><br><span class="line">    &#x2F;&#x2F; 解析虚拟DOM属性</span><br><span class="line">    updateProperties(vnode)</span><br><span class="line">    &#x2F;&#x2F; 递归，将子节点也生成真实DOM</span><br><span class="line">    children.forEach(child &#x3D;&gt; &#123;</span><br><span class="line">      return vnode.el.appendChild(createElm(child))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 文本节点直接创建</span><br><span class="line">    vnode.el &#x3D; document.createTextNode(text)</span><br><span class="line">  &#125;</span><br><span class="line">  return vnode.el</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 解析虚拟DOM的属性</span><br><span class="line">function updateProperties(vnode) &#123;</span><br><span class="line">  const newProps &#x3D; vnode.data || &#123;&#125;</span><br><span class="line">  const el &#x3D; vnode.el</span><br><span class="line">  for(let key in newProps) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D;&#x3D; &#39;style&#39;) &#123;</span><br><span class="line">      &#x2F;&#x2F; style的处理</span><br><span class="line">      for (let styleName in newProps.style) &#123;</span><br><span class="line">          el.style[styleName] &#x3D; newProps.style[styleName]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (key &#x3D;&#x3D;&#x3D; &#39;class&#39;) &#123;</span><br><span class="line">      &#x2F;&#x2F; class的处理</span><br><span class="line">      el.className &#x3D; newProps.class</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 调用dom的setAttribute进行属性设置</span><br><span class="line">      el.setAttribute(key, newProps[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非初次渲染</strong>：新旧虚拟DOM通过diff算法比对<br><img src="https://s2.loli.net/2022/04/15/UrabpMosut2vYXH.png" alt=""><br>注意：如果是静态节点，diff算法会自动跳过，不进行比对。</p>
<ul>
<li>判断新旧标签是否一致，不一致的话就用新的替换旧的-replaceChildren()；<br><strong>标签一致条件</strong>：key值相等，标签名相等，都是/不是注释节点，都定义/未定义data，如果是input标签type是否相等。</li>
<li>如果旧节点是文本节点，判断新旧文本内容是否一致，不一致就将旧文本修改成新文本内容oldVnode.el.textContent = vnode.text；</li>
<li>如果标签一致且不是文本节点，<strong>为了节点复用，直接将旧的虚拟DOM对应的真实DOM赋值给新的虚拟DOM的el属性</strong>；</li>
<li>更新属性：如果新的节点没有这个属性，需要把老的节点属性移除，新节点没有style，老节点style置空，遍历新节点的所有属性，旧节点setAttribute新增属性；</li>
<li>旧节点有子节点但是新节点没有，使用<code>el.innerHTML =&#39;&#39;</code>将旧节点的内容置空；</li>
<li>新节点有子节点但是老节点没有，遍历新节点的子节点，使用appendChild将子节点添加到旧节点中。</li>
<li><strong>新老节点都有子节点，对子节点进行更新updateChildren，这是diff的核心</strong>：<br>取新旧子节点的首尾节点vnode和对应下标index，只要新旧子节点的startIndex&lt;=endIndex时就一直循环对比：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let oldStartIndex &#x3D; 0; &#x2F;&#x2F;老儿子的起始下标</span><br><span class="line">let oldStartVnode &#x3D; oldCh[0]; &#x2F;&#x2F;老儿子的第一个节点</span><br><span class="line">let oldEndIndex &#x3D; oldCh.length - 1; &#x2F;&#x2F;老儿子的结束下标</span><br><span class="line">let oldEndVnode &#x3D; oldCh[oldEndIndex]; &#x2F;&#x2F;老儿子的起结束节点</span><br><span class="line"></span><br><span class="line">let newStartIndex &#x3D; 0; &#x2F;&#x2F;同上  新儿子的</span><br><span class="line">let newStartVnode &#x3D; newCh[0];</span><br><span class="line">let newEndIndex &#x3D; newCh.length - 1;</span><br><span class="line">let newEndVnode &#x3D; newCh[newEndIndex];</span><br><span class="line">while (oldStartIndex &lt;&#x3D; oldEndIndex &amp;&amp; newStartIndex &lt;&#x3D; newEndIndex) &#123;......&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>头头比较：判断新旧子节点的第一个节点是否是同一个节点，如果是的话就递归调用patch函数进行对比，新旧子节点的startIndex + 1，让第二个子节点作为第一个子节点;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (isSameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">  &#x2F;&#x2F; 头和头对比 依次向后追加</span><br><span class="line">  patch(oldStartVnode, newStartVnode); &#x2F;&#x2F;递归比较儿子以及他们的子节点</span><br><span class="line">  oldStartVnode &#x3D; oldCh[++oldStartIndex];</span><br><span class="line">  newStartVnode &#x3D; newCh[++newStartIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>尾尾比较：判断新旧子节点的最后一个节点是否是同一个节点，如果是的话就递归调用patch函数进行对比，新旧子节点的endIndex - 1，让倒数第二个子节点作为最后一个子节点;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (isSameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">  &#x2F;&#x2F;尾和尾对比 依次向前追加</span><br><span class="line">  patch(oldEndVnode, newEndVnode);</span><br><span class="line">  oldEndVnode &#x3D; oldCh[--oldEndIndex];</span><br><span class="line">  newEndVnode &#x3D; newCh[--newEndIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>旧的头和新的尾比较：判断旧的头和新的尾是否是同一个节点，如果是的话递归调用patch函数进行对比，把旧的头部移动到尾部，旧的startIndex + 1，新的endIndex - 1；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (isSameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">  &#x2F;&#x2F; 旧的头和新的尾相同 把旧的头部移动到尾部</span><br><span class="line">  patch(oldStartVnode, newEndVnode);</span><br><span class="line">  &#x2F;&#x2F;insertBefore可以移动或者插入真实dom</span><br><span class="line">  parent.insertBefore(oldStartVnode.el, oldEndVnode.el.nextSibling); </span><br><span class="line">  oldStartVnode &#x3D; oldCh[++oldStartIndex];</span><br><span class="line">  newEndVnode &#x3D; newCh[--newEndIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>旧的尾和新的头比较：判断旧的尾和新的头是否是同一个节点，如果是的话递归调用patch函数进行对比，把旧的尾部移动到头部，旧的endIndex - 1，新的startIndex + 1；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (isSameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">  &#x2F;&#x2F; 旧的尾和新的头相同 把旧的尾部移动到头部</span><br><span class="line">  patch(oldEndVnode, newStartVnode);</span><br><span class="line">  parent.insertBefore(oldEndVnode.el, oldStartVnode.el);</span><br><span class="line">  oldEndVnode &#x3D; oldCh[--oldEndIndex];</span><br><span class="line">  newStartVnode &#x3D; newCh[++newStartIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果头头、尾尾、头尾、尾头的比较都不满足的话，就<strong>暴力对比</strong>，利用旧的子节点建立key和index的映射表，然后从新的子节点的开始节点开始，在旧子节点的映射表里面找index，如果没有找到index，说明旧的子节点没有这个节点，就将这个节点插入，如果找到index，说明旧的节点有这个就饿点，将这个节点移动到前面，并递归调用patch函数。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据key来创建旧的子节点的index映射表  </span><br><span class="line">&#x2F;&#x2F; 类似 &#123;&#39;a&#39;:0,&#39;b&#39;:1&#125; 代表key为&#39;a&#39;的节点在第一个位置 key为&#39;b&#39;的节点在第二个位置</span><br><span class="line">function makeIndexByKey(children) &#123;</span><br><span class="line">  let map &#x3D; &#123;&#125;;</span><br><span class="line">  children.forEach((item, index) &#x3D;&gt; &#123;</span><br><span class="line">    map[item.key] &#x3D; index;</span><br><span class="line">  &#125;);</span><br><span class="line">  return map;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 生成的映射表</span><br><span class="line">let map &#x3D; makeIndexByKey(oldCh);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 暴力对比</span><br><span class="line">&#x2F;&#x2F; 从新的开始子节点开始，利用key查找旧子节点的映射表的index</span><br><span class="line">let moveIndex &#x3D; map[newStartVnode.key];</span><br><span class="line">if (!moveIndex) &#123;</span><br><span class="line">  &#x2F;&#x2F; 旧的节点找不到  直接插入</span><br><span class="line">  parent.insertBefore(createElm(newStartVnode), oldStartVnode.el);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F;找得到就拿到旧的节点</span><br><span class="line">  let moveVnode &#x3D; oldCh[moveIndex]; </span><br><span class="line">  &#x2F;&#x2F;这个是占位操作 避免数组塌陷  防止老节点移动走了之后破坏了初始的映射表位置</span><br><span class="line">  oldCh[moveIndex] &#x3D; undefined; </span><br><span class="line">  &#x2F;&#x2F;把找到的节点移动到最前面</span><br><span class="line">  parent.insertBefore(moveVnode.el, oldStartVnode.el); </span><br><span class="line">  patch(moveVnode, newStartVnode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果旧节点循环结束但是新节点还有，将新节点插入到旧节点的头部或者尾部：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (newStartIndex &lt;&#x3D; newEndIndex) &#123;</span><br><span class="line">  for (let i &#x3D; newStartIndex; i &lt;&#x3D; newEndIndex; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 这是一个优化写法 insertBefore的第一个参数是null等同于appendChild作用</span><br><span class="line">    const ele &#x3D; newCh[newEndIndex + 1] &#x3D;&#x3D; null ? null : newCh[newEndIndex + 1].el;</span><br><span class="line">    parent.insertBefore(createElm(newCh[i]), ele);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果新节点循环结束但是旧节点还有，将剩余的旧节点删除：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (oldStartIndex &lt;&#x3D; oldEndIndex) &#123;</span><br><span class="line">  for (let i &#x3D; oldStartIndex; i &lt;&#x3D; oldEndIndex; i++) &#123;</span><br><span class="line">    let child &#x3D; oldCh[i];</span><br><span class="line">    if (child !&#x3D; undefined) &#123;</span><br><span class="line">      parent.removeChild(child.el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function patch(oldVnode, vnode) &#123;</span><br><span class="line">  &#x2F;&#x2F; 判断oldVnode的类型，如果是初次渲染，oldVnode就是el节点，非初次渲染，oldVnode就是上一次的虚拟DOM</span><br><span class="line">  const isRealElement &#x3D; oldVnode.nodeType;</span><br><span class="line">  if (isRealElement) &#123; &#x2F;&#x2F; 初次渲染</span><br><span class="line">    </span><br><span class="line">  &#125; else &#123; &#x2F;&#x2F; 非初次渲染</span><br><span class="line">    if (oldVnode.tag !&#x3D;&#x3D; vnode.tag) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果新旧标签不一致 用新的替换旧的 oldVnode.el代表的是真实dom节点--同级比较</span><br><span class="line">      oldVnode.el.parentNode.replaceChild(createElm(vnode), oldVnode.el);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果旧节点是一个文本节点</span><br><span class="line">    if (!oldVnode.tag) &#123;</span><br><span class="line">      if (oldVnode.text !&#x3D;&#x3D; vnode.text) &#123;</span><br><span class="line">        oldVnode.el.textContent &#x3D; vnode.text;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 不符合上面两种 代表标签一致 并且不是文本节点</span><br><span class="line">    &#x2F;&#x2F; 为了节点复用 所以直接把旧的虚拟dom对应的真实dom赋值给新的虚拟dom的el属性</span><br><span class="line">    const el &#x3D; (vnode.el &#x3D; oldVnode.el);</span><br><span class="line">    updateProperties(vnode, oldVnode.data); &#x2F;&#x2F; 更新属性</span><br><span class="line">    const oldCh &#x3D; oldVnode.children || []; &#x2F;&#x2F; 老的儿子</span><br><span class="line">    const newCh &#x3D; vnode.children || []; &#x2F;&#x2F; 新的儿子</span><br><span class="line">    if (oldCh.length &gt; 0 &amp;&amp; newCh.length &gt; 0) &#123;</span><br><span class="line">      &#x2F;&#x2F; 新老都存在子节点</span><br><span class="line">      updateChildren(el, oldCh, newCh);</span><br><span class="line">    &#125; else if (oldCh.length) &#123;</span><br><span class="line">      &#x2F;&#x2F; 老的有儿子新的没有</span><br><span class="line">      el.innerHTML &#x3D; &quot;&quot;;</span><br><span class="line">    &#125; else if (newCh.length) &#123;</span><br><span class="line">      &#x2F;&#x2F; 新的有儿子</span><br><span class="line">      for (let i &#x3D; 0; i &lt; newCh.length; i++) &#123;</span><br><span class="line">        const child &#x3D; newCh[i];</span><br><span class="line">        el.appendChild(createElm(child));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 解析虚拟DOM的属性 - 方法重写</span><br><span class="line">function updateProperties(vnode，oldProps &#x3D; &#123;&#125;) &#123;</span><br><span class="line">  const newProps &#x3D; vnode.data || &#123;&#125; &#x2F;&#x2F;新的vnode的属性</span><br><span class="line">  const el &#x3D; vnode.el &#x2F;&#x2F; 真实节点</span><br><span class="line">  &#x2F;&#x2F; 如果新的节点没有 需要把老的节点属性移除</span><br><span class="line">  for (const k in oldProps) &#123;</span><br><span class="line">    if (!newProps[k]) &#123;</span><br><span class="line">      el.removeAttribute(k);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 对style样式做特殊处理 如果新的没有 需要把老的style值置为空</span><br><span class="line">  const newStyle &#x3D; newProps.style || &#123;&#125;;</span><br><span class="line">  const oldStyle &#x3D; oldProps.style || &#123;&#125;;</span><br><span class="line">  for (const key in oldStyle) &#123;</span><br><span class="line">    if (!newStyle[key]) &#123;</span><br><span class="line">      el.style[key] &#x3D; &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 遍历新的属性 进行增加操作</span><br><span class="line">  for (const key in newProps) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D;&#x3D; &quot;style&quot;) &#123;</span><br><span class="line">      for (const styleName in newProps.style) &#123;</span><br><span class="line">        el.style[styleName] &#x3D; newProps.style[styleName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (key &#x3D;&#x3D;&#x3D; &quot;class&quot;) &#123;</span><br><span class="line">      el.className &#x3D; newProps.class;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 给这个元素添加属性 值就是对应的值</span><br><span class="line">      el.setAttribute(key, newProps[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="为什么不建议用index作为循环项的key"><a href="#为什么不建议用index作为循环项的key" class="headerlink" title="为什么不建议用index作为循环项的key"></a>为什么不建议用index作为循环项的key</h1><p>假设有三个li标签，内容分别为a b c，在最前面新增一个li标签，内容是add。</p>
<p>由上面的diff算法可以知道，新旧虚拟DOM会进行头头、尾尾、头尾、尾头对比，判断是否是同一个节点。如果是用index作为循环项的key，新旧节点的头都是key为0的li，就会判定为是同一个节点，key为1和2的节点同理也会被判定会是同一个节点，导致相同key的节点会去进行更新文本的操作，而原本就有的c节点，却因为旧的虚拟DOM没有key为3的节点，而被当做了新节点，执行了插入的操作。这样所有的li标签都更新了。</p>
<p>但是如果是用独一无二的值，比如id作为循环项的key，a b c三个节点的key不会改变，就会节点复用，而新增的add节点由于旧的虚拟DOM中没有key对应的节点，会执行新增操作，这样只需要新增一个节点其他三个节点不动就可以完成视图的更新，节省了性能。</p>
<h1 id="Vue-实例生命周期"><a href="#Vue-实例生命周期" class="headerlink" title="Vue 实例生命周期"></a>Vue 实例生命周期</h1><p>一个 Vue 应用由一个通过 new Vue 创建的根 Vue 实例，以及可选的嵌套的、可复用的组件树组成。所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外)。<br><img src="https://s2.loli.net/2022/04/08/cgPZud6QyU3pb1h.png" alt=""><br>Vue 实例的生命周期如上图所示，大致可以分为四个阶段：</p>
<ul>
<li><strong>初始化阶段</strong>：为 Vue 实例初始化一些属性，事件以及响应式数据；</li>
<li><strong>模板编译阶段</strong>：将模板编译成渲染函数；</li>
<li><strong>挂载阶段</strong>：将实例挂载到指定的 DOM 上，即将模板渲染到真实 DOM 中；</li>
<li><strong>销毁阶段</strong>：将实例自身从父组件中删除，并取消依赖追踪及事件监听器。</li>
</ul>
<h1 id="生命周期-–-初始化阶段"><a href="#生命周期-–-初始化阶段" class="headerlink" title="生命周期 – 初始化阶段"></a>生命周期 – 初始化阶段</h1><h2 id="new-Vue"><a href="#new-Vue" class="headerlink" title="new Vue()"></a>new Vue()</h2><p>初始化阶段做的第一件事就是<code>new Vue()</code>创建一个 Vue 实例，从 new 操作符就可以看出 Vue 其实就是一个构造函数，传入的参数是一个对象，定义为 options，以下是Vue 的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;index.js</span><br><span class="line">function Vue(options) &#123;</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br><span class="line">initMixin(Vue)</span><br><span class="line">&#x2F;&#x2F;将_render函数和渲染对应的创建节点类型的方法_c _v _e _s等绑定到Vue上</span><br><span class="line">renderMixin(Vue)</span><br><span class="line">&#x2F;&#x2F; 将_updata方法(虚拟DOM转为真实DOM方法)绑定到Vue上</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure>
<p>这个构造函数的核心代码只有一行<code>this._init(options)</code>，这个<code>_init</code>方法是在执行<code>initMixin</code>方法的时候得到的，具体<code>initMixin</code>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;init.js</span><br><span class="line">export function initMixin(Vue) &#123;</span><br><span class="line">  Vue.prototype._init &#x3D; function (options) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将Vue实例赋值给变量vm</span><br><span class="line">    const vm &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F; options合并</span><br><span class="line">    vm.$options &#x3D; mergeOptions(</span><br><span class="line">      resolveConstructorOptions(vm.constructor),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">    vm._self &#x3D; vm</span><br><span class="line">    initLifecycle(vm) &#x2F;&#x2F; 初始化生命周期</span><br><span class="line">    initEvents(vm) &#x2F;&#x2F; 初始化事件</span><br><span class="line">    initRender(vm) &#x2F;&#x2F; 初始化渲染</span><br><span class="line">    callHook(vm, &#39;beforeCreate&#39;) &#x2F;&#x2F; 调用生命周期钩子函数</span><br><span class="line">    initInjections(vm) &#x2F;&#x2F;初始化injections</span><br><span class="line">    initState(vm) &#x2F;&#x2F; 初始化状态 props-&gt;methods-&gt;data-&gt;computed-&gt;watch</span><br><span class="line">    initProvide(vm) &#x2F;&#x2F; 初始化 provide</span><br><span class="line">    callHook(vm, &#39;created&#39;)&#x2F;&#x2F; 调用生命周期钩子函数</span><br><span class="line">    &#x2F;&#x2F; 如果传入了 el 就调用$mount函数进入模板编译与挂载阶段</span><br><span class="line">    if (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initMixin</code>方法里面就干了一件事，将<code>_init</code>方法绑定到 Vue 的原型上，同时<code>_init</code>方法也在构造函数内部调用激活，执行了<code>_init</code>方法里面的一系列初始化操作。<br>Vue 实例赋值给 vm – options合并 – 初始化属性、事件和响应数据 – 调用生命周期钩子函数 – 进入模板编译与挂载阶段</p>
<h2 id="options合并"><a href="#options合并" class="headerlink" title="options合并"></a>options合并</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.$options &#x3D; mergeOptions(</span><br><span class="line">  resolveConstructorOptions(vm.constructor),</span><br><span class="line">  options || &#123;&#125;,</span><br><span class="line">  vm</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>options合并就是将用户传递的options选项与当前构造函数的options属性及其父级构造函数的options属性进行合并，得到一个新的options选项，并将新的options选项绑定到Vue实例的$options属性上。</p>
<ul>
<li><code>resolveConstructorOptions(vm.constructor)</code>：返回的是Vue构造函数自定义的options选项，<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 先通过Object.create(null)创建一个options空对象</span><br><span class="line">Vue.options &#x3D; Object.create(null)</span><br><span class="line">&#x2F;&#x2F; ASSET_TYPES &#x3D; [&#39;component&#39;,&#39;directive&#39;,&#39;filter&#39;]</span><br><span class="line">&#x2F;&#x2F; 然后给options绑定component,directive,filter空对象</span><br><span class="line">ASSET_TYPES.forEach(type &#x3D;&gt; &#123;</span><br><span class="line">  Vue.options[type + &#39;s&#39;] &#x3D; Object.create(null)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; Vue.options.components &#x3D; &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; Vue.options.directives &#x3D; &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; Vue.options.filters &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最后通过extend把一些内置组件扩展到Vue.options.components上</span><br><span class="line">&#x2F;&#x2F; 内置组件：&lt;keep-alive&gt;、&lt;transition&gt;、&lt;transition-group&gt;</span><br><span class="line">extend(Vue.options.components, builtInComponents)</span><br></pre></td></tr></table></figure></li>
<li>mergeOptions：主要功能是把Vue实例的options和用户传入的options根据一些合并策略，合并成一个新对象并返回。这里的合并并不是简单的属性复制，而是根据被合并的不同的选项使用不同的合并策略。但是需要注意的是<strong>生命周期的钩子函数的合并</strong>，如果Vue实例的options和用户传入的options都定义了相同的钩子函数，那么它们会把 <strong>2 个钩子函数合并成一个数组</strong>。这是因为Vue允许用户使用Vue.mixin方法向实例混入自定义行为。</li>
</ul>
<h2 id="initLifecycle-初始化生命周期"><a href="#initLifecycle-初始化生命周期" class="headerlink" title="initLifecycle - 初始化生命周期"></a>initLifecycle - 初始化生命周期</h2><p>initLifecycle函数的逻辑很简单，就是给实例初始化了一些属性，包括以$开头的供用户使用的外部属性（$refs、$root、$parent、$children），也包括以_开头的供内部使用的内部属性。</p>
<h2 id="initEvents-初始化事件"><a href="#initEvents-初始化事件" class="headerlink" title="initEvents - 初始化事件"></a>initEvents - 初始化事件</h2><p>当我们在父组件中使用子组件时，可以给子组件上注册一些事件，这些事件包括使用v-on或@注册的自定义事件，也包括注册的浏览器原生事件（需要加 .native 修饰符）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;child @select&#x3D;&quot;selectHandler&quot; 	@click.native&#x3D;&quot;clickHandler&quot;&gt;&lt;&#x2F;child&gt;</span><br></pre></td></tr></table></figure>
<p>对于自定义事件和原生事件，Vue有不同的处理时机，<strong>原生事件是由父组件处理，而自定义事件是在子组件初始化的时候由父组件传给子组件，再由子组件注册到实例的事件系统中。</strong>所以实现原理如下：</p>
<ol>
<li>定义_events空对象用来存储事件；</li>
<li>获取父组件注册的事件listeners；</li>
<li>通过对比listeners和oldListeners的不同，调用add和remove进行事件注册和事件卸载：<ul>
<li>先遍历listeners，获取每一个事件名，如果事件名对应的值不存在，抛出异常，如果存在就判断oldListeners是否有该事件名；</li>
<li>如果oldListeners不存在该事件名，就调用add函数进行事件注册；</li>
<li>最后遍历oldListeners，获取每一个事件名，判断事件名在listeners中是否存在，如果不存在就调用remove函数进行事件卸载。</li>
</ul>
</li>
</ol>
<h2 id="callHook-调用生命周期钩子函数"><a href="#callHook-调用生命周期钩子函数" class="headerlink" title="callHook - 调用生命周期钩子函数"></a>callHook - 调用生命周期钩子函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function callHook (vm: Component, hook: string) &#123;</span><br><span class="line">  const handlers &#x3D; vm.$options[hook]</span><br><span class="line">  if (handlers) &#123;</span><br><span class="line">    for (let i &#x3D; 0, j &#x3D; handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        handlers[i].call(vm)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, vm, &#96;$&#123;hook&#125; hook&#96;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>从实例的$options中获取到需要触发的钩子名称所对应的钩子函数数组handlers；</li>
<li>遍历该数组，将数组中的每个钩子函数都执行一遍。</li>
</ul>
<h2 id="initInjections-初始化inject"><a href="#initInjections-初始化inject" class="headerlink" title="initInjections - 初始化inject"></a>initInjections - 初始化inject</h2><p>在Vue的组件通信中，常用的方法有inject和provide，provide和inject都是成对出现的。父组件可以使用provide选项给自己的下游子孙组件内注入一些数据，在下游子孙组件中可以使用inject选项来接收这些数据以便为自己所用。</p>
<p><strong>既然rovide和inject都是成对出现的，为什么没有一起初始化？</strong><br>_init函数中调用initInjections函数和initProvide函数之间穿插一个initState函数，这是因为inject接收到父组件注入的数据之后，可能会在props、methods、data、computed、watch中使用，所以初始化完inject之后，就需要初始化数据，然后再初始化provide。</p>
<p>初始化inject试下原理如下：</p>
<ol>
<li>初始化inject之前，调用了normalizeInject函数，将inject的选项数据规范化：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">var Child &#x3D; &#123;</span><br><span class="line">  inject: [&#39;foo&#39;]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">const Child &#x3D; &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    foo: &#123; default: &#39;xxx&#39; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 写法三</span><br><span class="line">const Child &#x3D; &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 统统转换成以下规范化格式</span><br><span class="line">const Child &#x3D; &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      from: &#39;foo&#39;,</span><br><span class="line">      default: &#39;xxx&#39;  &#x2F;&#x2F;如果有默认的值就有default属性</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>调用resolveInject函数将inject选项中的数据转化成键值对赋值给result：<br>inject选项中的每一项数据key都是由上游父组件提供的，所以我们应该遍历每一个数据key，从数据key拿到对应的from属性，从当前组件起，不断的向上游父级组件的_provided属性中查找该数据key对应的值，直到找到为止。如果在上游所有父级组件中没找到，那么就看在inject 选项是否为该数据key设置了默认值，如果设置了就使用默认值，如果没有设置，则抛出异常。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">provide:&#123;</span><br><span class="line">  foo: &#39;bar&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">inject:[&#39;foo&#39;]</span><br><span class="line">&#x2F;&#x2F; result</span><br><span class="line">result &#x3D; &#123;</span><br><span class="line">    &#39;foo&#39;:&#39;bar&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>遍历result中的每一对键值，调用defineReactive函数将其添加当前实例上；<br>defineReactive函数，判断数据是数组还是对象，是数组的话就重写数组的变异方法实现数组的双向数据绑定，如果不是数组的话就是用<code>Object.defineProperty()</code>方法对数据进行get set劫持实现数据的双向绑定。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm:&#123;</span><br><span class="line">  foo:bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在遍历之前调用toggleObserving(false)函数让<code>shouldObserve = false</code>，作用就是告诉defineReactive函数仅仅是把键值添加到当前实例上但是不需要将其转换成响应式，所以<strong>provide 和 inject 绑定并不是可响应的</strong>。</li>
</ol>
<h2 id="initState-初始化状态"><a href="#initState-初始化状态" class="headerlink" title="initState - 初始化状态"></a>initState - 初始化状态</h2><ol>
<li>给实例新增一个_watchers属性，用来存储当前实例中所有的watcher实例；<br>Vue对每个组件进行数据劫持，所以在每个组件上新增了vm._watchers属性，用来存放这个组件内用到的所有状态的依赖，当其中一个状态发生变化时，就会通知到组件，然后由组件内部使用虚拟DOM进行数据比对，从而降低内存开销，提高性能。</li>
<li>依次开始初始化<strong>props -&gt; methods -&gt; data -&gt; computed -&gt; watch</strong>：<br>这些顺序不是任意的，而是精心安排的，这样的顺序可以在data里面使用props，在watch里面监听data和props。<ul>
<li>initProps：<ul>
<li>props写法既可以是数组，也可以是对象，所以需要调用normalizeProps函数将props接收的数据进行规范化转化，判断props是数组还是对象，遍历props统一转化成一下格式：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  name:&#123;</span><br><span class="line">      type: xxx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>遍历props将键名key保存在keys里面，调用validateProp函数校验键key的数据类型是否匹配和获取键对应的值；</li>
<li>将键key和值通过defineReactive函数添加到props中；</li>
<li>然后判断键key在vue实例当中是否存在，如果不存在就调用proxy函数在vue实例vm上面绑定以key为属性的代码，<code>this[key] = this._props[key]</code>。<br><code>proxy(vm,&#39;_props&#39;,key)</code>，proxy函数是采用<code>Object.defineProperty()</code></li>
</ul>
</li>
<li>initMethods:<ul>
<li>遍历传入的methods，判断方法是否存在和有效：<br>判断某个方法key是否有value，判断方法名是否和props里的属性名重复，判断方法名是否已经存在，判断方法名是否以_或者$开头不符合规范。</li>
<li>如果方法存在且有效，就将方法绑定到vm实例上。</li>
</ul>
</li>
<li>initData：<ul>
<li>将data指向vm._data，然后遍历data，判断data里面的数据是否合法，比如有无重复定义等；</li>
<li>如果合法的话就将data里面的属性通过proxy进行代理，使用<code>Object.defineProperty()</code>方法将data里的属性绑定到vue的实例上，比如data里面有一个参数a，这样就可以通过this.a直接访问this._data.a；</li>
<li>设置监听器Observer，给每个传进来的数据都绑定一个__ ob __对象，表示该数据已经做了响应式处理；</li>
<li>如果数据对象的属性是<strong>数组</strong>，就重写数组原型的七种变异方法(push pop shift unshift reverse sort splice)，将数组的原型保留并且继承，在不破坏原来执行结果的基础上进行功能的动态扩展，循环数组里面的元素，判断是对象还是数组进行递归操作；</li>
<li>如果数据对象的属性是<strong>对象</strong>，就遍历每一个属性，执行defineReactive函数，用<code>Object.defineProperty()</code>对数据进行set和get劫持；</li>
</ul>
</li>
<li>initComputed：<ul>
<li>computed写法，既可以是函数，也可以是对象(里面包含get set函数)；</li>
<li>遍历computed，判断里面的对应的键key值是函数还是对象，函数的话就默认是getter，对象的话取get函数作为getter，无getter则抛出异常；</li>
<li>如果不是在服务端渲染环境下，使用键值创建一个Watcher实例<code>new Watcher(vm, getter, () =&gt; {}, { lazy: true })</code>；</li>
<li>判断当前key在vm实例上是否存在，存在抛出异常，不存在就调用defineComputed函数，使用Watcher实例的depend()方法，将计算属性的watcher添加到依赖表中实现相应处理，最后将computed的键值绑定到vm实例上。</li>
</ul>
</li>
<li>initWatch：<ul>
<li>watch写法，既可以是函数，也可以是函数名，也可以是对象，也可以是侦听表达式，为了可以灵活运用，多种写法就需要多种判断；</li>
<li>遍历watch，判断key对应的value是否是数组，是数组就循环调用createWatcher函数创建watcher<code>new Watcher(vm, key, handler, {user: true})</code>，不是就直接创建；</li>
<li>createWatcher函数：</li>
</ul>
<ol>
<li>先判断value是否是对象，如果是的就表示计算属性是这样的写法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  c: &#123;</span><br><span class="line">    handler: function (val, oldVal) &#123; &#x2F;* ... *&#x2F; &#125;,</span><br><span class="line">    deep: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
取value的handler作为value。</li>
<li>然后判断value是否是字符串，如果是字符串就表示计算属性直接调用了methods里面的方法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  &#x2F;&#x2F; methods选项中的方法名</span><br><span class="line">  b: &#39;someMethod&#39;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
既然是methods里面的方法，就说明该方法已经绑定到了vm实例上面，就让<code>value=vm[value]</code>；</li>
<li>既不是对象也不是字符串，就默认是函数，不做任何处理。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h1 id="生命周期-–-模板编译阶段"><a href="#生命周期-–-模板编译阶段" class="headerlink" title="生命周期 – 模板编译阶段"></a>生命周期 – 模板编译阶段</h1><p>初始化阶段各项工作做完之后调用vm.$mount方法，该方法的调用标志着初始化阶段的结束和进入下一个阶段——模板编译阶段。该阶段所做的主要工作是获取到用户传入的模板内容并将其编译成渲染函数。</p>
<h2 id="Vue版本"><a href="#Vue版本" class="headerlink" title="Vue版本"></a>Vue版本</h2><ul>
<li><strong>完整版本</strong>：<br>完整版本是runtime + compiler，同时包含编译器和运行，在完整版本中，可以使用template选项进行模板编写，编译器会自动将template选项中的模板字符串编译成渲染函数render。</li>
<li><strong>只包含运行时版本</strong>：<br>只包含运行时的版本是指该版本拥有创建Vue实例、渲染并处理Virtual DOM等功能，基本上就是除去编译器外的完整代码。这个版本使用场景有以下两种：<ul>
<li>在选项中手写render函数去定义渲染过程；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不需要编译器</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    return h(&#39;div&#39;, this.hi)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>借助vue-loader这样的编译工具进行编译：比如利用webpack进行vue的工程化开发，会利用vue-loader对*.vue文件进行编译，尽管我们也是利用template模板标签去书写代码，但是此时的Vue已经不需要利用编译器去负责模板的编译工作了，这个过程交给了插件去实现。</li>
</ul>
</li>
</ul>
<p>编译过程对性能会造成一定的损耗，并且由于加入了编译的流程代码，Vue代码的总体积也更加庞大(运行时版本相比完整版体积要小大约 30%)。因此在实际开发中，我们需要借助像webpack的vue-loader这类工具进行编译，将Vue对模板的编译阶段合并到webpack的构建流程中，这样不仅减少了生产环境代码的体积，也大大提高了运行时的性能，一举两得。</p>
<h2 id="模板编译过程解析"><a href="#模板编译过程解析" class="headerlink" title="模板编译过程解析"></a>模板编译过程解析</h2><p>模板编译是通过vm.$mount方法实现，有两个版本的Vue，就有两个版本的vm.$mount方法。</p>
<p><strong>只包含运行时版本的$mount方法</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$mount &#x3D; function (el,hydrating) &#123;</span><br><span class="line">  el &#x3D; el &amp;&amp; inBrowser ? query(el) : undefined;</span><br><span class="line">  return mountComponent(this, el, hydrating)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该版本没有模板编译过程，直接获取el对应的元素，调用mountComponent方法进行挂载操作。</p>
<p><strong>完整版本的$mount方法</strong>：</p>
<ul>
<li>获取template模板：options里面如果没有render就是用template，没有template就是用el.outerHTML作为template；</li>
<li>compileToFunctions(template) - 模板转化成渲染函数render的核心方法：<ul>
<li><strong>模板解析</strong>：调用parse(html)函数，利用正则匹配HTML代码的开始标签、结束标签和文本，生成对应的AST语法树，不断截取HTML代码字符串，直到HTML代码解析完毕。</li>
<li><strong>优化</strong>：调用optimize函数，遍历AST语法树，找出其中的静态节点和静态根节点，并打上标记；</li>
<li><strong>代码生成</strong>：拿到生成好的AST之后，调用generate函数，把AST转化成类似<code>with(this){_c(&#39;div&#39;,{id:&quot;app&quot;},_c(&#39;div&#39;,undefined,_v(&quot;hello&quot;+_s(name)),_c(&#39;span&#39;,undefined,_v(&quot;world&quot;))))}</code>这样的code字符串，然后使用new Function将字符串转化成渲染函数。</li>
</ul>
</li>
</ul>
<h1 id="生命周期-–-挂载阶段"><a href="#生命周期-–-挂载阶段" class="headerlink" title="生命周期 – 挂载阶段"></a>生命周期 – 挂载阶段</h1><p>模板编译完成之后，会调用mountComponent方法，进入挂载阶段，挂载阶段就是将编译阶段产生的渲染函数执行生成虚拟DOM，将虚拟DOM转化成真实DOM的过程，并对这一过程进行监听，当数据发生变更的时候通过diff算法进行视图更新。</p>
<p>在mountComponent方法中，会在获取虚拟DOM之前执行生命周期函数<code>callHook(vm, &#39;beforeMount&#39;)</code>，之后执行<code>callHook(vm, &#39;mounted&#39;)</code>，在数据更新之前执行<code>callHook(vm, &#39;beforeUpdate&#39;)</code>，之后执行<code>callHook(vm, &#39;updated&#39;)</code></p>
<p>所以挂载阶段实际上分成两个阶段：</p>
<ol>
<li>beforeMount-mounted：初次渲染，生成虚拟DOM并转化成真正的DOM；</li>
<li>beforeUpdate-updated: 数据变更，产生新的虚拟DOM，新旧diff对比，更新视图。</li>
</ol>
<p>具体过程解析查看上面的模板编译原理。</p>
<h1 id="生命周期-–-销毁阶段"><a href="#生命周期-–-销毁阶段" class="headerlink" title="生命周期 – 销毁阶段"></a>生命周期 – 销毁阶段</h1><p>当调用了实例的$destroy方法之后，当前实例就进入了销毁阶段，该阶段所做的主要工作是将当前的Vue实例从其父级实例中删除，取消当前实例上的所有依赖追踪并且移除实例上的所有事件监听器。</p>
<ul>
<li>判断 _isBeingDestroyed 属性是否为true，这个属性是用来标记当前实例是否处于正在被销毁的状态，如果是true的话直接return，防止反复执行销毁逻辑；</li>
<li>触发生命周期钩子函数beforeDestroy<code>callHook(vm, &#39;beforeDestroy&#39;)</code>，该钩子函数的调用标志着当前实例正式开始销毁；</li>
<li>将Vue实例从其父级实例中删除；</li>
<li>执行<code>vm._watcher.teardown()</code>将实例自身从其他数据的依赖列表中删除，teardown方法的作用是从所有依赖项的Dep列表中将自己删除；</li>
<li>遍历_watchers，将其中的每一个watcher都调用teardown方法，从而实现移除实例内数据对其他数据的依赖；</li>
<li>移除实例内响应式数据的引用、给当前实例上添加_isDestroyed属性来表示当前实例已经被销毁，同时将实例的VNode树设置为null；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (vm._data.__ob__) &#123;</span><br><span class="line">  vm._data.__ob__.vmCount--</span><br><span class="line">&#125;</span><br><span class="line">vm._isDestroyed &#x3D; true</span><br><span class="line">vm.__patch__(vm._vnode, null)</span><br></pre></td></tr></table></figure></li>
<li>触发生命周期钩子函数destroyed<code>callHook(vm, &#39;destroyed&#39;)</code>:</li>
<li>调用实例的vm.$off方法，移除实例上的所有事件监听器。</li>
</ul>
<h1 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>keep-alive是Vue内置组件，用于将包裹的组件缓存，而不是销毁。可以将不常变动的组件使用keep-alive包裹起来，这样就可以将组件缓存起来，这样做可以保留组件的状态或避免多次重新渲染，以提高页面性能。</p>
<p>keep-alive组件接收三个属性：</p>
<ol>
<li>include：字符串、正则或者数组，只有名称匹配的组件才会被缓存；</li>
<li>exculde：字符串、正则或者数组，任何名称匹配的组件都不会被缓存；</li>
<li>max：数字，最多可以缓存多少个组件实例，一旦这个数字达到了，在新的组件被创建之前，<strong>已缓存的所有组件中最久没有被访问的组件实例会悲哀销毁</strong>。</li>
</ol>
<h2 id="实现原理-LRU-最近最少使用算法"><a href="#实现原理-LRU-最近最少使用算法" class="headerlink" title="实现原理 - LRU(最近最少使用算法)"></a>实现原理 - LRU(最近最少使用算法)</h2><p>keep-alive组件内没有常规的template标签，取而代之的是它内部多了一个叫做render的函数，所以它不是一个常规的模板组件，而是一个<strong>函数式组件</strong>。keep-alive组件被渲染的时候，render函数就会被执行，并且设置了abstract属性，不会被渲染成真正的DOM展示到页面上。</p>
<ol>
<li><strong>abstract</strong>: 判断此组件是否需要在渲染成真实DOM，true的话会跳过该实例，不进行渲染；</li>
<li><strong>props</strong>：接收include exclude max三个属性；</li>
<li><strong>created</strong>：初始化catch 和 keys 两个属性：<ul>
<li>catch是一个对象，用来存储需要缓存的组件，键名是组件的key，值是组件的VNode；</li>
<li>keys是一个数组，用来存储每个需要缓存的组件的key。</li>
</ul>
</li>
<li><strong>render函数</strong>：<ul>
<li>获取默认插槽里面第一个组件节点的VNode，获取组件的name去和include和exclude匹配，如果那么和include不匹配 / 和exclude匹配，说明这个组件不需要缓存，直接return VNode；</li>
<li>如果需要缓存的话，根据组件ID、tag生成缓存key，根据key取catch[key]：<br>catch[key]无值，未命中缓存，说明这个组件是第一次被缓存，将组件的VNode保存到catch对象里，组件的key保存到keys中，<strong>如果keys的长度超过设定的max，将缓存中的第一个删除(删除catch/keys第一个，将对应的组件销毁(调用$destroy()钩子函数))</strong>；<br>catch[key]有值，命中缓存，说明这个组件已经被缓存了，<strong>将keys里面的key删除，将key放到keys的最后一个</strong>。</li>
<li>将此组件实例的keepAlive属性设置为true。</li>
</ul>
</li>
<li><strong>mounted</strong>：监听 include 和 exclude 属性是否发生变化，如果发生改变就说明缓存规则发生变化，会遍历catch对象，取出每一项的name，用于和新的缓存规则进行匹配，include如果匹配不上     / exclude如果匹配上了，说明这个组件不需要被缓存，将这个组件实例销毁，再从catch对象里面删除；</li>
<li><strong>destroyed</strong>：当keep-alive组件被销毁的时候，会遍历catch对象，将还没有销毁的组件进行销毁并从catch对象里面删除。</li>
</ol>
<p><strong>注意</strong>：catch[key]未命中缓存，将缓存的第一个删除；catch[key]命中缓存，将原来的key删除放到keys最后，这里用到了缓存淘汰策略<strong>LUR</strong>(Least recently used，最近最少使用)。<br><img src="https://s2.loli.net/2022/04/15/AnjPafBX9c1qLHU.png" alt=""><br>LRU的核心思想是如果数据最近被访问过，那么将来被访问的几率会更高，所以我们将命中缓存的组件key重新插入到this.keys的尾部，这样一来，this.keys中越往头部的数据即将来被访问几率越低，所以当缓存数量达到最大值时，我们就删除将来被访问几率最低的数据，即this.keys中第一个缓存的组件。</p>
<h2 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h2><p>组件被keep-alive缓存之后，再次渲染的时候就不会在执行created mounted钩子函数，但是在实际的业务场景中，经常需要在组件再次渲染的时候做一些事情，Vue提供了两个钩子函数：</p>
<ul>
<li>activated：keep-alive包裹的组件激活的时候触发；</li>
<li>deactivated：keep-alive包裹的组件移除的时候触发。</li>
</ul>
<p>假设keep-alive报过了动态组件A和B，默认展示A，有一个按钮可以切换动态组件：<br>初次渲染：<br>A created -&gt; A mounted -&gt; A activated<br>切换至B组件：<br>A deactivated -&gt; B created -&gt; B mounted -&gt; B activated<br>切换回A组件：<br>B deactivated -&gt; A activated<br>切换回B组件：<br>A deactivated -&gt; B activated</p>
<h1 id="vm-nextTick"><a href="#vm-nextTick" class="headerlink" title="vm.$nextTick"></a>vm.$nextTick</h1><p><code>vm.$nextTick([callback])</code>的作用是将回调延迟到下次DOM更新循环之后执行，也就是等DOM更新之后再去执行回调函数。</p>
<p>由<a href="https://crystalsummer.gitee.io/2021/03/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%B8%80)/">前端基础进阶(一)——事件循环机制(Event Loop)</a>这篇文章知道，事件循环机制有函数调用栈（同步）和任务队列（异步），任务队列需要等函数调用栈执行结束之后执行，而任务又分为宏任务和微任务，微任务的优先级高，先执行微任务，再执行宏任务。<br>微任务：Promise，MutationObserver(html5新特性)，process.nextTick；<br>宏任务：script(整体代码), setTimeout, setInterval, setImmediate。</p>
<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>Vue的DOM更新是异步的，也就是说当数据发生变更的时候，不会立即更新DOM，而是会开启一个异步队列，并缓冲在同一个事件循环中发生的所有数据改变，如果一个数据被多次修改的话，只会被推入到队列里面一次。</p>
<p>但有时候确实会会需要进行DOM的操作，尤其是和第三方插件进行配合的时候。nextTick就提供了一个桥梁，确保我们操作的是更新后的DOM。</p>
<p><strong>为什么DOM更新是异步的？</strong><br>假设更新是同步的，如果在一段时间内多次修改数据，每修改一次就去更新一次DOM，就会经历set-&gt;dep-&gt;watcher-&gt;update-&gt;patch这样的过程，会非常损耗性能。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>nextTick的核心原理就是利用异步队列来实现顺序的控制。</p>
<p>Vue进行DOM更新，内部也是调用nextTick来做异步队列控制，当我们调用nextTick的时候，它就在更新DOM的队列后追加了我们定义的回调函数，从而确保我们的回调函数在DOM更新后执行。</p>
<p>队列控制的最佳选择是微任务，因为宏任务耗费的时间是大于微任务的。但是因为兼容性问题，Vue做了<strong>降级处理</strong>，在浏览器支持的情况下，优先使用微任务Promise/MutationObserver，如果浏览器不支持微任务，就使用宏任务setImmediate/setTimeout(fn, 0)。</p>
<p>当执行回调队列的时候，需要将队列备份，这是因为有这样的一种情况，nextTick里面又调用了nextTick，如果不备份直接循环执行回调函数，会导致里面nextTick 中的回调函数会进入回调队列。</p>
<h1 id="vm-set"><a href="#vm-set" class="headerlink" title="vm.$set"></a>vm.$set</h1><p><code>vm.$set(target, key=propertyName/index, value)</code>向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。</p>
<p>核心：<br>如果target是数组，判断key是否是有效索引，是的话就是用splice方法将传入的索引key对应的value值添加进数组<code>target.splice(key, 1, val)</code>。使用splice是因为响应式对数组做了处理，重写了数组的七个变异方法。</p>
<p>如果target是对象，判断key是否已经存在，存在的话表明不是新增操作，而是修改操作，直接对已经存在的属性进行修改<code>target[key] = value</code>，不存在的话表明是新增操作，判断该对象是否有__ ob __属性，没有的话说明该对象不是响应式数据，直接添加属性即可<code>target[key] = value</code>，有的话说明该对象是响应式数据，调用<code>defineReactive()</code>函数实现数据的绑定和响应，然后通知监听器更新视图<code>ob.dep.notify()</code>。</p>
<p><img src="https://s2.loli.net/2022/04/18/ixXR1Qvulja6Ynb.png" alt=""></p>
<h1 id="vm-delete"><a href="#vm-delete" class="headerlink" title="vm.$delete"></a>vm.$delete</h1><p><code>vm.$delete( target, key=propertyName/index )</code>删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。</p>
<p>核心：<br>如果target是数组，判断key是否是有效索引，是的话就是用splice方法将传入的索引key对应的value值删除 <code>target.splice(key, 1)</code>。</p>
<p>如果target是对象，判断key是否已经存在，不存在的话什么都不用做，直接退出程序，存在的话删除该属性<code>delete target[key]</code>，然后通知监听器更新视图<code>ob.dep.notify()</code>。</p>
<h1 id="computed-和-watch"><a href="#computed-和-watch" class="headerlink" title="computed 和 watch"></a>computed 和 watch</h1><ul>
<li><p>computed：计算属性，依赖已有的变量来计算一个目标变量，大多数情况都是多个变量凑在一起计算出一个变量，<strong>多对一</strong>，具有<strong>缓存机制</strong>，依赖值不变的情况下会直接读取缓存进行复用，computed<strong>不能进行异步操作</strong>；</p>
</li>
<li><p>watch：监听属性，监听某一个变量的变化，并执行相应的回调函数，通常是一个变量的变化决定多个变量的变化，<strong>一对多</strong>，watch可以进行<strong>异步操作</strong>。</p>
</li>
</ul>
<p>由数据响应式原理可知，Vue有监听器Watcher，大致分为三类：</p>
<ol>
<li>渲染Watcher：变量修改时，负责通知HTML里的重新渲染；</li>
<li>computed Watcher：变量修改时，负责通知computed里依赖此变量的computed属性变量的修改；</li>
<li>user Watcher：变量修改时，负责通知watch属性里所对应的变量函数的执行。</li>
</ol>
<p>由上文<strong>生命周期-初始化阶段</strong>中的initState里的initComputed和initWatch可知，会对computed和watch创建监听器，computed是<code>new Watcher(vm, getter, () =&gt; {}, { lazy: true })</code>这样创建的，其中lazy是computed特有的，将computed设置成可缓存，即lazy为true的时候，不执行get()方法；watch是<code>new Watcher(vm, key, handler, {user: true})</code>这样创建的，其中user是watch特有的。</p>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在双括号里面使用</span><br><span class="line">&lt;div&gt;&#123;&#123; text | textFilter &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F; 在v-bind里面使用</span><br><span class="line">&lt;div v-bind:id&#x3D;&quot;id | idFilter&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F; 过滤器串联</span><br><span class="line">&lt;div&gt;&#123;&#123; text | aFilter | bFilter &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F; 过滤器传参 默认第一个参数是前一个的值，第二个参数是&#39;name&#39;</span><br><span class="line">&lt;div&gt;&#123;&#123; text | aFilter(&#39;name&#39;) &#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>Vue 对模板进行编译的时候，如果是标签，就使用HTML解析器parseHTML；如果是文本，就是用文本解析器parseText；如果是过滤器的话，有过滤器解析器parseFilters。</p>
<p>如果过滤器是在双花括号中，过滤器就存在文本中，就在文本解析器parseText中调用过滤器解析器parseFilters函数对写在该处的过滤器进行解析。</p>
<p>如果过滤器是在v-bind中，过滤器就相当于属性，就在HTML解析器parseHTML的processAttrs函数中调用过滤器解析器parseFilters函数对写在该处的过滤器进行解析。</p>
<p>最后将过滤器解析成<code>_f(&quot;filter1&quot;)(message)</code>，如果是串联过滤器，就解析成<code>_f(&quot;filter2&quot;)(_f(&quot;filter1&quot;)(message),arg)</code>。</p>
<p>_f 对应 resolveFilter 函数，该函数取得_f对应的过滤器函数并执行，最后返回需要的值。<br>从options中获取所有的过滤器函数，根据过滤器ID去除对应的函数，先从本地注册找，找不到将ID转换成驼峰形式找，找不到将ID转换成首字母大写找，再找不到就去原型链上找。</p>
<h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><h2 id="普通插槽"><a href="#普通插槽" class="headerlink" title="普通插槽"></a>普通插槽</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;child&gt;</span><br><span class="line">    这是插入到默认插槽的内容</span><br><span class="line">    &lt;template v-slot:one&gt;这是插入到one插槽的内容&lt;&#x2F;template&gt;</span><br><span class="line">  &lt;&#x2F;child&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;slot name&#x3D;&quot;one&quot;&gt;&lt;&#x2F;slot&gt;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>父组件先解析，把child当成子元素处理，把插槽当做child的子元素处理，生成的节点如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  tag: &quot;div&quot;,    </span><br><span class="line">  children: [&#123;        </span><br><span class="line">    tag: &quot;child&quot;,        </span><br><span class="line">    children: [&#39;这是插入到默认插槽的内容&#39;,&#39;这是插入到one插槽的内容&#39;]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>子组件解析，slot 作为一个占位符，会被解析成一个函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    tag: &quot;div&quot;,    </span><br><span class="line">    children: [</span><br><span class="line">        _t(&#39;default&#39;), &#x2F;&#x2F; 匿名插槽，默认名称为default</span><br><span class="line">        _t(&#39;one&#39;) &#x2F;&#x2F; 具名插槽，名称为one</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>_t函数的作用是把第一步解析得到的插槽节点拿到，然后返回解析后的节点，这样子组件解析后的节点如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  tag: &quot;div&quot;,    </span><br><span class="line">  children: [&#39;这是插入到默认插槽的内容&#39;,&#39;这是插入到one插槽的内容&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>作用域插槽是指父组件在子组件的slot中使用子组件的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;child&gt; </span><br><span class="line">  &lt;template v-slot:default&#x3D;&#39;slotde&#39;&gt; </span><br><span class="line">     插入默认 slot 中&#123;&#123; slotde.value1 &#125;&#125;&#123;&#123; slotde.value2 &#125;&#125; </span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line">  &lt;template v-slot:one&#x3D;&#39;slotone&#39;&gt;  </span><br><span class="line">    插入one slot 中&#123;&#123; slotone.value1 &#125;&#125;&#123;&#123; slotone.value2 &#125;&#125;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line">  </span><br><span class="line">&lt;&#x2F;child&gt;</span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;slot :value1&#x3D;&#39;child1&#39; :value2&#x3D;&#39;child2&#39;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;slot name&#x3D;&quot;one&quot; :value1&#x3D;&#39;child1&#39; :value2&#x3D;&#39;child2&#39;&gt;&lt;&#x2F;slot&gt;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">data:&#123;</span><br><span class="line">  child1:&#39;数据1&#39;,</span><br><span class="line">  child2:&#39;数据2&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>父组件解析，遇到作用域插槽，将此插槽封装成一个函数保存到子元素 child 下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line"> tag: &quot;div&quot;,    </span><br><span class="line">  children: [&#123;        </span><br><span class="line">    tag: &quot;child&quot;</span><br><span class="line">    scopeSlots:&#123;            </span><br><span class="line">        default (data) &#123; &#x2F;&#x2F; 记住这个data参数               </span><br><span class="line">            return [&#39;插入默认 slot 中&#39; + data.value1 + data.value2]</span><br><span class="line">        &#125;,</span><br><span class="line">        one (data) &#123; &#x2F;&#x2F; 记住这个data参数             </span><br><span class="line">            return [&#39;插入one slot 中&#39; + data.value1 + data.value2]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>子组件解析，将对应的插槽数据包装成一个对象，传进_t函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  tag: &quot;div&quot;,    </span><br><span class="line">  children: [</span><br><span class="line">    _t(&#39;default&#39;,&#123;value1: &#39;数据1&#39;, value2: &#39;数据2&#39;&#125;),</span><br><span class="line">    _t(&#39;one&#39;,&#123;value1: &#39;数据1&#39;, value2: &#39;数据2&#39;&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>_t内部执行，包装后的对象被当做data参数传入了scopeSlots中的对应的各个函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  tag: &quot;div&quot;,    </span><br><span class="line">  children: [</span><br><span class="line">    &#39;插入默认 slot 中 数据1 数据2&#39;,</span><br><span class="line">    &#39;插入one slot 中 数据1 数据2&#39;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://baijiahao.baidu.com/s?id=1713594930243225961&wfr=spider&for=pc" target="_blank" rel="noopener">MVC、MVP、MVVM的区别及联系</a><br><a href="https://juejin.cn/column/6969563635194527758" target="_blank" rel="noopener">Sunshine_Lin的掘金专栏：Vue源码解析</a><br><a href="https://vue-js.com/learn-vue/" target="_blank" rel="noopener">Vue源码系列-Vue中文社区</a><br><a href="https://www.cnblogs.com/canfoo/p/6891868.html" target="_blank" rel="noopener">vue的双向绑定原理及实现</a><br><a href="https://www.jianshu.com/p/af0b398602bc" target="_blank" rel="noopener">vue核心之虚拟DOM(vdom)</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>原理</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2019/09/01/Git/</url>
    <content><![CDATA[<p><img src="https://w.wallhaven.cc/full/2e/wallhaven-2em38y.jpg" alt=""></p>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　由于公司进行统一化管理，代码的提交不再使用Git命令，而是使用SourceTree工具，防止时间久了之后忘记，这里记录一下Git的学习。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>　　Git是Linus用C语言写的一个分布式版本控制系统，并且开源，可用于敏捷高效地处理任何或小或大的项目。<br>集中式（SVN、CVS）：将项目集中存放在中央服务器中，在工作的时候，大家只在自己电脑上操作，从同一个地方下载最新版本，然后开始工作，做完的工作再提交给中央服务器保存，这种方式需要联网。</p>
<ul>
<li>版本库是集中存放在一个中央服务器</li>
<li>必须联网才能工作</li>
<li>分支的创建和切换很慢</li>
</ul>
<p>分布式（Git）：只要提供一台电脑作为版本集中存的服务器放就够了，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它也一样干活，只是交换修改不方便而已。而每一台电脑有各自独立的开发环境，不需要联网，本地直接运行，相对集中式安全系数高很多。</p>
<ul>
<li>无中央服务器，每个人的电脑都有一个完整的版本库</li>
<li>开源、不必联网工作</li>
<li>管理的是修改，而非文件</li>
<li>分支的创建和切换很快，不管分支里面是有多少文件</li>
</ul>
<div style='color:#F56C6C;border:1px solid #F56C6C;border-radius:4px;background:rgba(245,108,108,0.1);padding:5px 10px;margin-bottom:20px;'>
    <i class="fa fa-exclamation-triangle" style='margin-right:10px;'></i>注意：此篇所有内容都是基于Windows系统。
</div>

<p>　　Git具体安装教程，请点击<a href="https://www.runoob.com/git/git-install-setup.html" target="_blank" rel="noopener"><strong>这里</strong></a>，在此不再赘述。</p>
<h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><p>　　版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<div style='color:#F56C6C;border:1px solid #F56C6C;border-radius:4px;background:rgba(245,108,108,0.1);padding:5px 10px;margin-bottom:20px;'>
    <i class="fa fa-exclamation-triangle" style='margin-right:10px;'></i>注意：Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 在需要新建仓库的地方，点击右键选择Git Bash here</span><br><span class="line">&#x2F;&#x2F; 2. 新建一个空目录，用于存放所有git管理的文件</span><br><span class="line">mkdir testGit</span><br><span class="line">&#x2F;&#x2F; 3. 切换目录至新建的文件</span><br><span class="line">cd testGit</span><br><span class="line">&#x2F;&#x2F; 4. 查看当前目录</span><br><span class="line">pwd</span><br><span class="line">&#x2F;&#x2F; 5. 将当前目录变成Git仓库</span><br><span class="line">git init</span><br><span class="line">&#x2F;&#x2F; 6. 仓库建好后，会提示是一个空的仓库（empty Git repository），然后testGit下面就会出现一个.git文件夹，</span><br><span class="line">&#x2F;&#x2F;如果没有看到这个文件夹，是因为被隐藏了，可以执行以下命令查看</span><br><span class="line">ls -ah</span><br></pre></td></tr></table></figure>

<h1 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h1><p>　　Git只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，但是图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了什么，版本控制系统不知道，也没法知道。<br>　　不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的。</p>
<div style='color:#F56C6C;border:1px solid #F56C6C;border-radius:4px;background:rgba(245,108,108,0.1);padding:5px 10px;margin-bottom:20px;'>
    <i class="fa fa-exclamation-triangle" style='margin-right:10px;'></i>注意：Windows系统，不要使用Windows自带的记事本编辑任何文本文件，原因是Microsoft开发记事本的团队保存UTF-8编码的文件的时候，在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误等等，都是由记事本的这个行为带来的。
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 在testGit目录下新建一个readme.txt文件(使用vi命令，i切换成输入模式，按Esc退出输入模式，:wq保存并退出)</span><br><span class="line">&#x2F;&#x2F; readme.txt 里面的内容暂时是123456 qwerty</span><br><span class="line">vi readme.txt</span><br><span class="line">&#x2F;&#x2F; 2. 将readme.txt文件添加到暂存区</span><br><span class="line">git add readme.txt</span><br><span class="line">&#x2F;&#x2F; 3. 提交readme.txt文件</span><br><span class="line">git commit -m &#39;feat:wrote a readme.txt&#39;</span><br><span class="line">&#x2F;&#x2F; 我们可以多次add不同的文件，然后一次commit多个文件</span><br><span class="line">git add file1.txt</span><br><span class="line">git add file2.txt file3.txt</span><br><span class="line">&#x2F;&#x2F; 或者一次性将本地所有文件add</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#39;add 3 files.&#39;</span><br></pre></td></tr></table></figure>

<h1 id="内容管理"><a href="#内容管理" class="headerlink" title="内容管理"></a>内容管理</h1><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>接下来对readme.txt文件内容进行修改，每修改一次就提交一次，修改内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第一次 feat:wrote a readme.txt</span><br><span class="line">123456</span><br><span class="line">qwerty</span><br><span class="line">&#x2F;&#x2F;第二次 feat:add content asdfgh</span><br><span class="line">123456</span><br><span class="line">qwerty</span><br><span class="line">asdfgh</span><br><span class="line">&#x2F;&#x2F;第三次 feat:append content 789</span><br><span class="line">123456789</span><br><span class="line">qwerty</span><br><span class="line">asdfgh</span><br><span class="line">git status &#x2F;&#x2F;查看当前工作区的状态，是否有文件被修改等等</span><br><span class="line">git diff &#x2F;&#x2F;查看修改内容</span><br><span class="line">&#x2F;&#x2F;执行以下命令可以查看从最近到最远的提交日志</span><br><span class="line">git log</span><br><span class="line">&#x2F;&#x2F;加上--pretty&#x3D;oneline参数就可以查看简略版的日志</span><br><span class="line">git log --pretty&#x3D;oneline</span><br></pre></td></tr></table></figure>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>
    日志中出现的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。
</div>
<div style='color:#67C23A;border:1px solid #67C23A;border-radius:4px;background:rgba(103,194,58,0.1);padding:5px 10px;margin-bottom:20px;'>
    在Git中，用HEAD表示当前版本，也就是最新的提交，上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本可以写成HEAD~100。
</div>

<p>接下来使用Git命令进行版本回退</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">cat readme.txt</span><br><span class="line">&#x2F;&#x2F;此时readme.txt文件里面的内容是上一个版本feat:add content asdfgh的内容，feat:append content 789的内容被回退掉了</span><br><span class="line">123456</span><br><span class="line">qwerty</span><br><span class="line">asdfgh</span><br></pre></td></tr></table></figure>

<p>回退到上一版本后，如果后悔了，有两种解决方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 如果命令行窗口还没有关闭，可以顺着往上找到feat:append content 789的commit id，就执行以下命令</span><br><span class="line">&#x2F;&#x2F; commit id不需要全部写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</span><br><span class="line">git reset --hard d7e3708711f6cc</span><br><span class="line">&#x2F;&#x2F; 2. 如果找不到版本号，这个时候就执行以下命令查找版本号，然后回退就可以了</span><br><span class="line">git reflog     &#x2F;&#x2F;该命令用来记录每一次命令日志，而git log仅用来记录提交的日志</span><br><span class="line"></span><br><span class="line">cat readme.txt</span><br><span class="line">&#x2F;&#x2F;此时readme.txt文件里面的内容是feat:append content 789</span><br><span class="line">123456789</span><br><span class="line">qwerty</span><br><span class="line">asdfgh</span><br></pre></td></tr></table></figure>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>工作区：就是你在电脑里能看到的目录，比如testGit文件夹就是一个工作区。</li>
<li>版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</li>
<li>暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。<br>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：<br>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；<br>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</li>
</ul>
<h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>场景介绍：第一次修改readme.txt -&gt; <code>git add</code> -&gt; 第二次修改readme.txt -&gt; <code>git commit</code></p>
<p>这个时候如果使用<code>git status</code>查看仓库当前的状态，会发现第二次的修改并没有被提交。</p>
<p>原因：Git管理的是修改，当使用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>解决方法：第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; git commit</p>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>场景1：修改readme.txt文件 -&gt; 并没有执行<code>git add</code>放到暂存区 -&gt; 想要回到修改前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- readme.txt &#x2F;&#x2F;把readme.txt文件在工作区的修改全部撤销</span><br><span class="line">git status</span><br><span class="line">&#x2F;&#x2F; 撤销在工作区的所有更改，不会撤销未跟踪或者新增的文件</span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure>
<p>场景2：修改readme.txt文件 -&gt; <code>git add</code> -&gt; 想要回到修改前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD readme.txt</span><br><span class="line">git status</span><br><span class="line">git checkout -- readme.txt</span><br><span class="line">git status</span><br><span class="line">&#x2F;&#x2F; 将暂存区所有文件恢复到工作区</span><br><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure>
<p>场景3：修改readme.txt文件 -&gt; <code>git add</code> -&gt; <code>git commit</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 回退上一个版本就好了，但是此次改动的代码全没了</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">&#x2F;&#x2F; 回退上一个版本，回退的内容回到工作区</span><br><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure>

<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 新建一个文件</span><br><span class="line">vi test.txt</span><br><span class="line">&#x2F;&#x2F; 2. 放到暂存区</span><br><span class="line">git add test.txt</span><br><span class="line">&#x2F;&#x2F; 3. 提交</span><br><span class="line">git commit -m &#39;feat:add test.txt&#39;</span><br><span class="line">&#x2F;&#x2F; 4. 查看当前工作区的文件</span><br><span class="line">ls</span><br><span class="line">&#x2F;&#x2F; 5. 手动删除该文件或者命令删除的文件</span><br><span class="line">rm test.txt</span><br><span class="line">&#x2F;&#x2F; 6. 查看工作区状态-此时工作区和版本库不一致，会提示那些文件被删除了</span><br><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>删除工作区的test.txt文件后，可能会遇到两种情况：<br>情况一：删除工作区的文件之后后悔了，不想删除了，想恢复回来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure>
<p>情况二：确定删除该文件，删除版本库里面的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm test.txt  或者使用 git add test.txt</span><br><span class="line">git status</span><br><span class="line">git commit -m &#39;feat:remove test.txt&#39;</span><br></pre></td></tr></table></figure>
<p>情况三：已经把版本库里面的文件删除后，后悔了，这个时候版本回退就可以了。</p>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>　　找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。我们可以使用<a href="https://github.com/" target="_blank" rel="noopener"><strong>GitHub</strong></a>网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
<ol>
<li>注册GitHub账号</li>
<li>创建SSH Key：<br>在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Git Bash，创建SSH Key：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>
一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</li>
<li>添加公钥：<br>登录GitHub，打开“Account settings”，“SSH Keys”页面，添加公钥。因为GitHub需要识别出推送的提交确实是本人推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了公钥，就可以确认只有本人才能推送。GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</li>
</ol>
<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>
   友情提醒：在GitHub上免费托管的Git仓库，任何人都可以看到，所以不要把敏感信息放进去。
</div>

<h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><p>　　场景：先有本地库，后有远程库的时候，如何关联远程库？（现在需要在GitHub上创建一个远程仓库，具体创建过程这里不再描述。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 本地库关联远程库：远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库</span><br><span class="line">git remote add origin 仓库名</span><br><span class="line">&#x2F;&#x2F; 2. 将本地库所有内容推送到远程库</span><br><span class="line">&#x2F;&#x2F;由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，</span><br><span class="line">&#x2F;&#x2F;还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</span><br><span class="line">git push -u origin master</span><br><span class="line">&#x2F;&#x2F; 3. 之后本地做了提交，可以执行以下命令</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<h2 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h2><p>　　场景：先有远程库，无本地库，将远程库克隆到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone 仓库名</span><br></pre></td></tr></table></figure>

<h2 id="修改远程仓库地址"><a href="#修改远程仓库地址" class="headerlink" title="修改远程仓库地址"></a>修改远程仓库地址</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote set-url origin &#39;仓库地址&#39;</span><br></pre></td></tr></table></figure>

<h2 id="删除再添加远程仓库"><a href="#删除再添加远程仓库" class="headerlink" title="删除再添加远程仓库"></a>删除再添加远程仓库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">git remote rm origin</span><br><span class="line">git remote add origin &#39;仓库地址&#39;</span><br></pre></td></tr></table></figure>

<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p>　　在Git里，有一个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。<br>　　当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。<br>　　Git创建一个分支很快，是因为除了增加一个dev指针，改变HEAD的指向，工作区的文件都没有任何变化！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch dev &#x2F;&#x2F;创建dev分支</span><br></pre></td></tr></table></figure>

<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>　　切换分支使用<code>git checkout &lt;branch&gt;</code>，和撤销修改<code>git checkout -- &lt;file&gt;</code>是同一个命令，有两种作用，会有点令人迷惑，所以推荐使用<code>git switch</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;切换至dev分支</span><br><span class="line">git switch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure>

<h2 id="查看当前分支"><a href="#查看当前分支" class="headerlink" title="查看当前分支"></a>查看当前分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 创建并切换dev分支：-b 参数表示创建并切换</span><br><span class="line">git switch -c dev 或者 git checkout -b dev</span><br><span class="line">&#x2F;&#x2F; 相当于以下两个命令的缩写</span><br><span class="line">git branch dev &#x2F;&#x2F;创建dev分支</span><br><span class="line">git checkout dev &#x2F;&#x2F;切换到dev分支</span><br><span class="line">&#x2F;&#x2F; 2. 查看当前分支</span><br><span class="line">git branch</span><br></pre></td></tr></table></figure>

<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>　　假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。<br>　　Git合并分支也很快，是因为就改变了指针，工作区内容也没有改变！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将dev分支的内容合并到当前分支，如果是要合并到master分支，必须保证当前分支是master</span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure>

<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d dev</span><br><span class="line">&#x2F;&#x2F;如果要删除一个没有被合并过的分支，执行上面的命令会发出警告，可以执行下面强制删除的指令</span><br><span class="line">git branch -D dev</span><br></pre></td></tr></table></figure>

<h2 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h2><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将dev分支推送到远程库</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure>

<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>　　当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>　　解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。<br>　　用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h2 id="分支合并模式"><a href="#分支合并模式" class="headerlink" title="分支合并模式"></a>分支合并模式</h2><ol>
<li>Fast Forward<br>　　当前分支合并另一个分支的时候，如果合并的过程中没有Conflict冲突，则会通过直接移动两个分支的指针，来达到合并的过程，这个过程就叫做Fast Forward。<br>　　在Fast Forward模式下，当我们merge合并后，将会删除无用的分支，在这种情况下，Fast Forward就有一个弊端暴露了，即：删除分支之后，会丢掉分支的所有信息。<br>　　场景：新建一个分支dev，在分支dev上做了三次操作：①新增用户功能  ②新增角色功能  ③新增权限功能，然后切换至master主分支，使用Fast Forward模式进行合并分支。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190624141311297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6YjM0ODExMDE3NQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<ol start="2">
<li>–no-ff<br>　　如果要强制禁用Fast Forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。此处就会使用到 <code>--no-ff</code> 参数方式merge提交了。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190624142358314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6YjM0ODExMDE3NQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<h2 id="贮藏"><a href="#贮藏" class="headerlink" title="贮藏"></a>贮藏</h2><p>　　场景1：dev分支有进行到一半的工作，但是现在有需要切换到release分支去改一个bug。<br>　　解决方法：将当前分支的工作内容贮藏来，切换到release分支改完bug后切回dev分支，将贮藏的工作内容释放出来就可以继续工作了。<br>　　场景2：多人协作的项目，个人在提交代码之前需要拉一下别人提交的代码，这个时候可能会发生冲突。<br>　　解决方法：先把自己的代码贮藏起来，然后把别人的代码拉下来，再释放自己的代码，有冲突就解决冲突，没有就直接提交代码即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 贮藏</span><br><span class="line">git stash</span><br><span class="line">&#x2F;&#x2F; 查看贮藏列表</span><br><span class="line">git stash list</span><br><span class="line">&#x2F;&#x2F; 恢复贮藏区的内容，但不删除贮藏区内容</span><br><span class="line">git stash apply</span><br><span class="line">&#x2F;&#x2F; 恢复贮藏区并删除贮藏区内容</span><br><span class="line">git stash pop</span><br><span class="line">&#x2F;&#x2F; 如果多次stash，可以指定恢复某一次的stash</span><br><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复制部分提交到当前分支"><a href="#复制部分提交到当前分支" class="headerlink" title="复制部分提交到当前分支"></a>复制部分提交到当前分支</h2><p>　　场景：dev1分支和dev2分支上有相同的一个bug，我们在dev1分支上解决bug之后，需要去dev2分支上解决相同的bug。<br>　　注意：当前分支必须在dev2分支，如果复制的时候发生代码冲突，cherry-pick 会停下来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将dev1指定的提交应用于dev2分支 commit_id（版本号）</span><br><span class="line">git cherry-pick &lt;commit_id&gt;</span><br><span class="line">&#x2F;&#x2F; 将dev1最新一次提交应用于dev2分支</span><br><span class="line">git cherry-pick dev1</span><br><span class="line">&#x2F;&#x2F; 将dev1多个指定的提交应用于dev2分支</span><br><span class="line">git cherry-pick &lt;commit_id1&gt; &lt;commit_id2&gt; &lt;commit_id3&gt;</span><br><span class="line">&#x2F;&#x2F; 将dev1 commit_id1 到 commit_id3 的提交全部应用于dev2，但是commit_id1的提交不会被应用</span><br><span class="line">git cherry-pick &lt;commit_id1&gt;...&lt;commit_id3&gt;</span><br><span class="line">&#x2F;&#x2F; 将dev1 commit_id1 到 commit_id3 的提交全部应用于dev2，commit_id1的提交也会被应用</span><br><span class="line">git cherry-pick &lt;commit_id1&gt;^...&lt;commit_id3&gt;</span><br></pre></td></tr></table></figure>

<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><ol>
<li><p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p>
</li>
<li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p>
</li>
<li><p>如果合并有冲突，则解决冲突，并在本地提交；</p>
</li>
<li><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功；</p>
</li>
<li><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
</li>
</ol>
<h1 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h1><h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>　　场景：有时候我们必须将某些文件放在工作区，但是又不能提交它们，比如vue项目打包文件夹dist、安装依赖的文件夹node-modules。<br>　　解决方法：在工作区的根目录下新建一个<code>.gitignore</code>文件，然后把需要忽略的文件名称填写进去就可以了。</p>
<h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><p>　　Git有一些命令很长或者很复杂，为了简化，我们可以配置别名，具体示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global alias.st status</span><br><span class="line">git st 就相当于 git status</span><br></pre></td></tr></table></figure>
<p>　　Git的配置文件放在了<code>.git/config</code>文件中，别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中,配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<h1 id="GitHub和Gitee"><a href="#GitHub和Gitee" class="headerlink" title="GitHub和Gitee"></a>GitHub和Gitee</h1><p>　　我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。但是使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况。<br>　　如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——<a href="https://gitee.com/?utm_source=blog_lxf" target="_blank" rel="noopener"><strong>Gitee（gitee.com）</strong></a>。<br>　　将本地库既关联GitHub，又关联Gitee，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add github GitHub仓库名</span><br><span class="line">git remote add gitee Gitee仓库名</span><br><span class="line">git push github master</span><br><span class="line">git push gitee master</span><br></pre></td></tr></table></figure>

<h1 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h1><p>　　Git有很多图形界面工具，这里我们推荐<a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener"><strong>SourceTree</strong></a>，它是由Atlassian开发的免费Git图形界面工具，可以操作任何Git库。<br>　　使用SourceTree可以以图形界面操作Git，省去了敲命令的过程，对于常用的提交、分支、推送等操作来说非常方便。<br>　　SourceTree使用Git命令执行操作，出错时，仍然需要阅读Git命令返回的错误信息。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><code>git init</code> 初始化一个Git仓库</li>
<li>添加文件到Git仓库的两个步骤<ul>
<li><code>git add &lt;file&gt;</code>   暂存-将修改的文件放置暂存区</li>
<li><code>git commit -m &lt;message&gt;</code>  提交-将暂存区的文件提交到当前分支，此时工作区清空</li>
</ul>
</li>
<li><code>git status</code> 查看仓库当前的状态</li>
<li>如果<code>git status</code>提示有文件被修改过，用<code>git diff</code>可以查看修改内容</li>
<li><code>git diff HEAD -- readme.txt</code>可以查看工作区和版本库里面最新版本的区别</li>
<li>HEAD指向的版本就是当前版本</li>
<li><code>git log</code> 查看提交历史</li>
<li><code>git reflog</code> 查看命令历史</li>
<li><code>git checkout -- &lt;file&gt;</code> 可以把<strong>工作区</strong>的修改撤销掉（unstage）</li>
<li><code>git reset HEAD &lt;file&gt;</code> 可以把<strong>暂存区</strong>的修改撤销掉（unstage），重新放回工作区</li>
<li><code>git reset --hard commit_id/HEAD</code> 版本回退</li>
<li><code>rm &lt;file&gt;</code> 删除<strong>工作区</strong>的文件</li>
<li><code>git rm &lt;file&gt;</code> 删除<strong>版本库</strong>里面的文件</li>
<li><code>git remote add origin 仓库名</code>本地库关联远程库</li>
<li><code>git push -u origin master</code>第一次推送master分支的所有内容</li>
<li><code>git push origin master</code>每次本地提交后，推送最新修改</li>
<li><code>git clone 仓库名</code>克隆远程库</li>
<li>Git支持多种协议，包括https，但ssh协议速度最快。</li>
<li><code>git branch</code>查看分支</li>
<li><code>git branch &lt;name&gt;</code>创建分支</li>
<li><code>git switch &lt;name&gt;</code>或者<code>git checkout &lt;name&gt;</code>切换分支</li>
<li><code>git switch -c &lt;name&gt;</code>或者<code>git checkout -b &lt;name&gt;</code>创建+切换分支</li>
<li><code>git merge &lt;name&gt;</code>合并某分支到当前分支</li>
<li><code>git branch -d &lt;name&gt;</code>删除分支</li>
<li><code>git log --graph</code>查看分支合并图</li>
<li><code>git remote rm origin</code>删除远程仓库</li>
<li><code>git remote</code>查看远程库信息 <code>git remote -v</code>查看远程库详细信息</li>
<li><code>git cherry-pick</code> 复制某次或者多次提交</li>
<li><code>git checkout -b branch-name origin/branch-name</code>在本地创建和远程分支对应的分支</li>
<li><code>git pull</code>拉取代码</li>
<li><code>git push origin branch-name</code> 推送修改</li>
<li><code>git branch --set-upstream branch-name origin/branch-name</code>建立本地分支和远程分支的关联</li>
</ul>
<p>参考文章：</p>
<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰官网-Git教程</a></li>
<li><a href="https://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Git</a></li>
</ul>
]]></content>
      <categories>
        <category>Web</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>web开发踩坑</title>
    <url>/2019/07/26/web%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/08/01/00/37/architecture-2562316_960_720.jpg" alt=""></p>
<a id="more"></a>

<style>
  .border{
    padding: 10px;
    border: 1px solid #ebebeb;
    border-radius: 4px;
    margin-bottom: 20px;
  }
  .border .title{
    font-size: 16px;
    font-weight: 500;
  }
  .border .content-slove{
    text-indent: 20px;
  }
</style>

<h3 id="页面抖动"><a href="#页面抖动" class="headerlink" title="页面抖动"></a>页面抖动</h3><div class="border">
    <div class="title">页面抖动问题</div>
    <div class="content-slove">页面疯狂抖动，那是因为页面在要滚不滚的边缘疯狂试探，看是高度还是宽度问题，设置值 100% 改成 99.9% 即可。</div>
</div>

<h3 id="验证码报错"><a href="#验证码报错" class="headerlink" title="验证码报错"></a>验证码报错</h3><div class="border">
    <div class="title">登录页填写验证码报错问题</div>
    <div class="content-slove">在登录之前需要填写验证码，但是在填写正确的情况下登录，后台老是提示验证码错误，由于获取验证码图片是使用 el-image 展示的，默认会调用两次接口，这个和 Element UI 的组件性有关，为了解决这个问题，使用了原生的 img 标签。</div>
</div>

<h3 id="子组件获取prop"><a href="#子组件获取prop" class="headerlink" title="子组件获取prop"></a>子组件获取prop</h3><div class="border">
    <div class="title">Vue 父组件给子组件传值，子组件获取不到问题</div>
    <div class="content-slove">是和父子组件的生命周期有关，为了解决这个问题，可以使用 <code>this.$nextTick()</code>。</div>
</div>

<h3 id="页面刷新"><a href="#页面刷新" class="headerlink" title="页面刷新"></a>页面刷新</h3><div class="border">
    <div class="title">Vue 改变URL上面参数，第一遍不会刷新页面调用接口，必须刷新第二遍问题</div>
    <div class="content-slove">Vue默认采用 hash 模式，而 hash 的变化不会导致浏览器发送请求到服务器。将获取数据的函数执行放在了created 或者 mounted 中，组件初次加载执行了created 或者 mounted 中的函数，但是改变参数，由于组件已经挂载结束而且不会重新加载，created 或者mounted 中的函数不会再执行。真正开发的时候页面跳转不会有问题，但是为了测试会直接改变 URL 上面的参数进行测试，出现了这一个问题。</div>
</div>

<h3 id="Echarts-雷达图名称过长"><a href="#Echarts-雷达图名称过长" class="headerlink" title="Echarts 雷达图名称过长"></a>Echarts 雷达图名称过长</h3><div class="border">
    <div class="title">Echarts 雷达图名称过长问题</div>
    <div class="content-slove">解决方法：1、换行；2、换行后 toolTip 提示会有空格，需要用 formatter 函数重置一下。</div>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">radar: &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        &#x2F;&#x2F; 解决文字太长问题-换行，但是换行之后 toolTip 提示里面就会出现空格</span><br><span class="line">        formatter: function (value, indicator) &#123;</span><br><span class="line">            if(value.length&gt;5)&#123;</span><br><span class="line">                    return value.substr(0,5)+&#96;\n&#96;+value.substr(5)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                    return value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">tooltip: &#123;</span><br><span class="line">    &#x2F;&#x2F; 解决 name 文字太长问题换行之后 toolTip 提示出现空格问题</span><br><span class="line">    &#x2F;&#x2F; names 是文字数组</span><br><span class="line">    formatter:function (params)&#123;</span><br><span class="line">        var data &#x3D; &#39;&#39;;</span><br><span class="line">        for(var i&#x3D;0; i&lt;params.data.value.length; i++)&#123;</span><br><span class="line">            data +&#x3D; names[i]+&#39;：&#39;+params.data.value[i]+ &#39;&lt;br&#x2F;&gt;&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        return params.data.name+&#39;&lt;br&#x2F;&gt;&#39;+data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="数据变更页面渲染问题"><a href="#数据变更页面渲染问题" class="headerlink" title="数据变更页面渲染问题"></a>数据变更页面渲染问题</h3><div class="border">
    <div class="title">页面连续调用两个接口并且两个接口的数据用同一个对象接收，第二个接口返回的数据是在页面渲染完成之后获取到的，导致页面没有渲染出第二个接口返回的数据问题</div>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 解决方法一：</span><br><span class="line">this.$set(this.entInfo,&#39;introduction&#39;,10)</span><br><span class="line">&#x2F;&#x2F; 解决方法二：</span><br><span class="line">this.entInfo &#x3D; Object.assign( &#123;&#125;, this.entInfo, &#123;</span><br><span class="line">    introduction: res.entBasic?(res.entBasic.entProfile || &#39;&#39;):&#39;&#39;,</span><br><span class="line">    labels: res.transitLabel || [],</span><br><span class="line">    entRule:res.entBasic?res.entBasic.entRule:&#39;&#39;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="el-upload-传文件没有反应"><a href="#el-upload-传文件没有反应" class="headerlink" title="el-upload 传文件没有反应"></a>el-upload 传文件没有反应</h3><div class="border">
    <div class="title">Element UI 上传文件或者图片的组件 el-upload，上传文件第二次或者第 N 次没有反应问题。</div>
    <div class="content-slove">是因为给 el-upload 组件设置了 limit 属性（最大允许上传个数）为1，把这个属性去掉就可以了。</div>
</div>

<h3 id="echarts-图表刷新超出容器范围"><a href="#echarts-图表刷新超出容器范围" class="headerlink" title="echarts 图表刷新超出容器范围"></a>echarts 图表刷新超出容器范围</h3><div class="border">
    <div class="title">echarts 图表，路由跳转时各个页面图表显示正常，刷新页面图表会超出容器范围问题。</div>
    <div class="content-slove">原因：在 Vue 中 echarts 的 init 我们一般会放在钩子函数 Mounted 中，以确保我们可以获取到图表容器的宽度，这样图表就会基于其父元素的宽度进行绘制，但项目初次
启动进入页面或者在项目中刷新页面，受页面侧边栏的影响，mounted 中获取的 echarts 对象的 clientWidth 其实是有差别的：刷新页面的时候计算 clientWidth 是会忽略侧边栏的，所以计算结果会偏大，最终造成图表变宽，超出其容器宽度。当然如果页面没有侧边栏，或菜单是在头部的，则不会出现这种情况。</div>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 解决方法一：过一点时间后再初始化echarts</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化图表</span><br><span class="line">    this.initEchart()</span><br><span class="line">&#125;, 20)</span><br><span class="line">&#x2F;&#x2F; 解决方法二：初始化echarts后，过一点时间之后再resize一下</span><br><span class="line">let chart &#x3D; echarts.init(document.getElementById(&#39;echartsDiv&#39;))</span><br><span class="line">chart.setOption(newIndexOptions)</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    window.addEventListener(&#39;resize&#39;, function() &#123;</span><br><span class="line">        chart.resize()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, 20)</span><br></pre></td></tr></table></figure>

<h3 id="浮点精准度"><a href="#浮点精准度" class="headerlink" title="浮点精准度"></a>浮点精准度</h3><div class="border">
    <div class="title">后台返回小数，前端乘以100后小数位变多问题。</div>
    <div class="content-slove">比如后台返回数据0.1284，前端获取到数据后对数据进行操作，就会出现这样的结果 0.1284*100=12.839999999999998。这和浮点精准度有关，float 精确到小数点后7位，
double 精确到小数点后15位。使用 toFixed(n) 解决该问题</div>
</div>

<h3 id="el-image-引入本地图片"><a href="#el-image-引入本地图片" class="headerlink" title="el-image 引入本地图片"></a>el-image 引入本地图片</h3><div class="border">
    <div class="title">Element UI 的 el-image 组件引入本地图片 undefined 问题。</div>
    <div class="content-slove">el-image 的 src 属性值不要使用绝对路径或者相对路径，使用 require 即可，比如：src="require('@/assets/XXX.png')"</div>
</div>

<h3 id="路由重定向报错"><a href="#路由重定向报错" class="headerlink" title="路由重定向报错"></a>路由重定向报错</h3><div class="border">
    <div class="title">Vue 路由重定向报错：Uncaught (in promise) Error: Redirected when going from "/login" to "/dashboard" via a navigation guard.。</div>
    <div class="content-slove">简单的解决方法就是直接触发跳转的逻辑上,把error抛出来。</div>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$router.push(&#123;path: &#39;&#x2F;dashboard&#39;&#125;).catch(()&#x3D;&gt;&#123;&#125;);&#x2F;&#x2F;把error 抛出来</span><br></pre></td></tr></table></figure>

<h3 id="切换路由组件刷新"><a href="#切换路由组件刷新" class="headerlink" title="切换路由组件刷新"></a>切换路由组件刷新</h3><div class="border">
    <div class="title">切换子组件的路由，父组件会重新渲染的原因。</div>
    <div class="content-slove">父组件的 router-view 上面定义了 key 值，该值改变后会导致父组件重新渲染。</div>
</div>

<h3 id="Vue-hover"><a href="#Vue-hover" class="headerlink" title="Vue hover"></a>Vue hover</h3><div class="border">
    <div class="title">Vue hover事件。</div>
    <div class="content-slove">Vue 没有 hover 事件，可以使用 mouseover 或者 mouseenter 事件代替。</div>
</div>

<h3 id="三个数据比较"><a href="#三个数据比较" class="headerlink" title="三个数据比较"></a>三个数据比较</h3><div class="border">
    <div class="title">三个数据比较的问题。</div>
    <div class="content-slove">有三个数字a,b,c，需要判断b是否在a和c之间，如果直接用 if(a<=b<=c) 来判断的话，结果可能不会达到预期的结果，因为这样判断的步骤是：如果a <= b为真，结果为1,否则为0，再与c比较，真正想要达到目的的写法是 if(a<=b && b<=c)。</div>
</div>

<h3 id="el-autocomplete-显示上一次的数据"><a href="#el-autocomplete-显示上一次的数据" class="headerlink" title="el-autocomplete 显示上一次的数据"></a>el-autocomplete 显示上一次的数据</h3><div class="border">
    <div class="title">element UI 的 el-autocomplete 带输入建议的输入框，显示上一次后台返回的数据问题。</div>
    <div class="content-slove">在承出租土地中，当输入企业名称的时候需要根据后台返回的输入建议选择企业并反显统代，但是在下次未输入企业名称，直接聚焦输入框的时候会反显上一次后台返回的数据，这是由于上一次的数据没有清空，解决方法就是给 el-autocomplete 绑定 ref="elaotocomplate"，调用 this.$refs.elaotocomplate.handleChange('') 清空上一次的数据。</div>
</div>

<h3 id="el-table-根据条件显示不同的列"><a href="#el-table-根据条件显示不同的列" class="headerlink" title="el-table 根据条件显示不同的列"></a>el-table 根据条件显示不同的列</h3><div class="border">
    <div class="title">element UI 的 el-table 根据筛选条件显示不同的列出现的问题。</div>
    <div class="content-slove">
        1. 使用 v-show 出现的问题：使用 v-show 没有效果，所有的列都会显示，是因为 v-show 的本质就是对 dom 元素设置 display:none，但是 td 设置的 display:table-cell 并且权限层级高于 display:none，所以v-show 不会有效果；
    </div>
    <div class="content-slove">
        2. 使用 v-if 出现的问题：使用 v-if 虽然实现了根据筛选条件显示不同列的需求，但是列的顺序出现错乱，这是因为 el-table 做了一些优化，可以复用列，不加 key，就成了 bug，所以给列加上不同的 key 就可以了；
    </div>
    <div class="content-slove">
        3. 列加上 key 之后出现的问题：使用 v-if 和 key 之后，已经基本满足需求，但是这个时候出现了一个页面交互的 bug，由于页面底色是深色的，刷新页面或者列表的时候，表格头部会出现一闪而过的白色，极其明显，解决方法就是使用 template 将相同条件的列包裹判断，并在页面更新前重新渲染表格；
    </div>
    <div class="content-slove">
       总结：template + v-if + key + doLayout
    </div>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-table class&#x3D;&#39;analysis-table&#39;  :data&#x3D;&#39;tableData&#39; stripe ref&#x3D;&quot;table&quot;&gt;</span><br><span class="line">    &lt;el-table-column label&#x3D;&quot;排名&quot; width&#x3D;&#39;80&#39; align&#x3D;&#39;center&#39; type&#x3D;&quot;index&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;el-table-column prop&#x3D;&quot;town&quot; label&#x3D;&quot;乡镇名称&quot; width&#x3D;&#39;100&#39; align&#x3D;&#39;center&#39;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;!-- 规上 --&gt;</span><br><span class="line">    &lt;template v-if&#x3D;&quot;entRule&#x3D;&#x3D;0&quot;&gt;</span><br><span class="line">        &lt;el-table-column prop&#x3D;&quot;entUpNumberA&quot; label&#x3D;&quot;A类&quot;  width&#x3D;&#39;60&#39; align&#x3D;&#39;center&#39; :key&#x3D;&quot;1&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">        &lt;el-table-column prop&#x3D;&quot;entUpNumberB&quot; label&#x3D;&quot;B类&quot;  width&#x3D;&#39;60&#39; align&#x3D;&#39;center&#39; :key&#x3D;&quot;2&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;!-- 规下 --&gt;</span><br><span class="line">    &lt;template v-else&gt;</span><br><span class="line">        &lt;el-table-column  label&#x3D;&quot;单位用电税收（万元&#x2F;万千瓦时）&quot; align&#x3D;&#39;center&#39; :key&#x3D;&quot;11&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;el-table&gt;</span><br><span class="line"></span><br><span class="line">beforeUpdate()&#123;</span><br><span class="line">    this.$nextTick(() &#x3D;&gt; &#123; </span><br><span class="line">      &#x2F;&#x2F; 数据加载完，重新渲染表格</span><br><span class="line">      this.$refs[&#39;table&#39;].doLayout();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="echarts-legend-滚动分页"><a href="#echarts-legend-滚动分页" class="headerlink" title="echarts legend 滚动分页"></a>echarts legend 滚动分页</h3><div class="border">
    <div class="title">echarts 的 legend 滚动分页点击无反应，并且和真实数据不符合问题。</div>
    <div class="content-slove">echarts低版本的bug，更新版本为4.2.1以上即可</div>
</div>

<h3 id="系统文字错乱"><a href="#系统文字错乱" class="headerlink" title="系统文字错乱"></a>系统文字错乱</h3><div class="border">
    <div class="title">系统页面中文字错乱，变成其他文字。</div>
    <div class="content-slove">原因：谷歌浏览器自动翻译功能开启。</div>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">&lt;html lang&#x3D;&quot;zh-CN&quot;&gt; 或者 &lt;html&gt; 或者 &lt;html translate&#x3D;&quot;no&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="系统登录弹出浏览器默认窗口填写用户名和密码"><a href="#系统登录弹出浏览器默认窗口填写用户名和密码" class="headerlink" title="系统登录弹出浏览器默认窗口填写用户名和密码"></a>系统登录弹出浏览器默认窗口填写用户名和密码</h3><div class="border">
    <div class="title">系统登录时，会弹出浏览器默认窗口让我们填写用户名和密码。</div>
    <div class="content-slove">原因：登录接口开启了basic认证，认证方式由前后端统一，如果认证失败，就会弹出这种窗口。</div>
</div>

<h3 id="模态框表单数据没有清空"><a href="#模态框表单数据没有清空" class="headerlink" title="模态框表单数据没有清空"></a>模态框表单数据没有清空</h3><div class="border">
    <div class="title">element ui 编辑和新增使用同一个模态框，在关闭模态框的时候清空表单数据，但是如果先打开编辑，再打开新增，表单数据没有清空。</div>
    <div class="content-slove">解决方法：在编辑打开时使用this.$nextTick(()=>{赋值操作})。</div>
</div>

<h3 id="日期选择器设置默认值后修改功能失效"><a href="#日期选择器设置默认值后修改功能失效" class="headerlink" title="日期选择器设置默认值后修改功能失效"></a>日期选择器设置默认值后修改功能失效</h3><div class="border">
    <div class="title">element ui 日期选择器，设置默认值后修改功能失效，vue调试后，发现model值已经改变，但是页面上显示的数据没变。</div>
    <div class="content-slove">解决方法：不要用=直接设置默认值，用this.$set(this.form,'time',2021-02)。</div>
</div>

<h3 id="filter-获取不到-this"><a href="#filter-获取不到-this" class="headerlink" title="filter 获取不到 this"></a>filter 获取不到 this</h3><div class="border">
    <div class="title">vue filter过滤器里面获取不到vue对象this。</div>
    <div class="content-slove">原因：因为过滤器是在vue示例初始化之前执行的，所以拿不到this。</div>
    <div class="content-slove">解决方法：定义that=this，把that作为参数传进过滤器。</div>
</div>

<h3 id="项目打包部署缓存"><a href="#项目打包部署缓存" class="headerlink" title="项目打包部署缓存"></a>项目打包部署缓存</h3><div class="border">
    <div class="title">vue 项目打包部署缓存导致浏览器必须强刷问题。</div>
    <div class="content-slove">解决方法：项目打包时，都会将打出的静态资源文件名加个哈希后缀，且index.html中引入时也加了对应的哈希后缀，所以每个版本的静态资源都是全新的，不用担心因升级导致的缓存问题。那么只需让index.html不缓存，且让其他静态资源缓存就可以解决问题，在 nginx 加段配置add_header Cache-Control "no-cache, no-store";即可。详情请参考：<a href="https://blog.csdn.net/Mr_linjw/article/details/102812503?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link" target="_blank" rel="noopener">vue前端缓存问题解决方案</a>。</div>
</div>

<h3 id="el-row-使用-gutter-出现横向滚动条"><a href="#el-row-使用-gutter-出现横向滚动条" class="headerlink" title="el-row 使用 gutter 出现横向滚动条"></a>el-row 使用 gutter 出现横向滚动条</h3><div class="border">
    <div class="title">elementui 的 el-row 使用栅栏属性 gutter之后出现横向滚动条问题。</div>
    <div class="content-slove">原因：使用 gutter 后，会给 el-row 左右加上 margin，导致超出容器范围。</div>
    <div class="content-slove">解决方法：给 el-row 一个容器，如 div，让容器留出足够的空间 padding（值为gutter的一半），并设置 box-sizing:border-box;。</div>
</div>

<h3 id="谷歌低版本不兼容-flex-1"><a href="#谷歌低版本不兼容-flex-1" class="headerlink" title="谷歌低版本不兼容 flex:1"></a>谷歌低版本不兼容 flex:1</h3><div class="border">
    <div class="title">谷歌低版本 flex:1;height:100% 不兼容问题。</div>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 解决方法1：</span><br><span class="line">父元素：position:relative;</span><br><span class="line">子元素：position:absolute;top:0;bottom:0;left:0;right:0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解决方法2：</span><br><span class="line">父元素：display:flex;flex-direction:column;</span><br><span class="line">子元素：flex-grow:1;</span><br></pre></td></tr></table></figure>

<h3 id="ranstion-grop-循环-key-不可以使用-index"><a href="#ranstion-grop-循环-key-不可以使用-index" class="headerlink" title="ranstion-grop 循环 key 不可以使用 index"></a>ranstion-grop 循环 key 不可以使用 index</h3><div class="border">
    <div class="title">transtion-grop 下的 div for循环，key 值用index无效。</div>
    <div class="content-slove">原因：vue 源码中对 transtion-grop 下的 div for循环禁止使用 index 作为 key 值。</div>
    <div class="content-slove">解决方法：自己设定唯一的 key 值然后绑定。</div>
</div>

<h3 id="表单-item-v-if-判断后表单校验失效"><a href="#表单-item-v-if-判断后表单校验失效" class="headerlink" title="表单 item v-if 判断后表单校验失效"></a>表单 item v-if 判断后表单校验失效</h3><div class="border">
    <div class="title">element UI 表单 item，通过 v-if 判断是否显示后，表单校验失效。</div>
    <div class="content-slove">解决方法：1.v-if + key;2.v-show;3.v-if + div。</div>
</div>

<h3 id="表格自定义表头更新后表头不更新"><a href="#表格自定义表头更新后表头不更新" class="headerlink" title="表格自定义表头更新后表头不更新"></a>表格自定义表头更新后表头不更新</h3><div class="border">
    <div class="title">element UI 表格自定义表头，数据定义在data中，数据更新之后表头不更新问题。</div>
    <div class="content-slove">原因：自定义表头的插槽没有加上 slot-scope='scope'，这和插槽的作用域有关，加上后作用指向data，data里面的数据更新，自定义表头也会更新。</div>
</div>

<h3 id="flex-wrap-换行后有空隙"><a href="#flex-wrap-换行后有空隙" class="headerlink" title="flex wrap 换行后有空隙"></a>flex wrap 换行后有空隙</h3><div class="border">
    <div class="title">flex布局，flex-wrap:wrap换行之后中间有一段大空空隙问题。</div>
    <div class="content-slove">解决：设置align-content:flex-start让div与交叉轴的起点对齐。</div>
</div>

<h3 id="vue3-deep-类名"><a href="#vue3-deep-类名" class="headerlink" title="vue3 :deep(类名)"></a>vue3 :deep(类名)</h3><div class="border">
    <div class="title">vue3中scss使用::v-deep写法报警告。</div>
    <div class="content-slove">解决：改为:deep(类名)的写法。</div>
</div>

<h3 id="自定义表单设置默认值后无法编辑"><a href="#自定义表单设置默认值后无法编辑" class="headerlink" title="自定义表单设置默认值后无法编辑"></a>自定义表单设置默认值后无法编辑</h3><div class="border">
    <div class="title">vue2 element UI 表单，表单项是配置化，通过后台接口拿到表单项的label、prop、默认值、是否必填等，然后通过循环展示在页面，但是设置默认值的表单无法编辑。</div>
    <div class="content-slove">这是因为在拿到数据后设置默认值直接用了 = 来设置，这个时候数据不是响应式的。可以使用 $set 赋值，这样就可以解决问题。</div>
</div>

<h3 id="Quill-富文本自动聚焦问题"><a href="#Quill-富文本自动聚焦问题" class="headerlink" title="Quill 富文本自动聚焦问题"></a>Quill 富文本自动聚焦问题</h3><div class="border">
    <div class="title">弹框显示表单，表单内容很长，弹框出现滚动条，Quill在最下面，每次打开弹框Quill自动聚焦，导致弹框滚动条自动滚动到底部。</div>
    <div class="content-slove">这是因为Quill回显内容，内容发生变更，Quill自动聚焦，解决方法就是设置enable来禁用和启用Quill。</div>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Editor.vue 富文本</span><br><span class="line">watch: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      handler(val) &#123;</span><br><span class="line">        if (val !&#x3D;&#x3D; this.currentValue) &#123;</span><br><span class="line">          this.currentValue &#x3D; val &#x3D;&#x3D;&#x3D; null ? &#39;&#39; : val</span><br><span class="line">          if (this.Quill) &#123;</span><br><span class="line">            &#x2F;&#x2F; 取消自动聚焦 - 解决新增时聚焦问题</span><br><span class="line">            this.Quill.enable(false)</span><br><span class="line">            this.$nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">              this.Quill.enable(true)</span><br><span class="line">            &#125;)</span><br><span class="line">            this.Quill.pasteHTML(this.currentValue)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      immediate: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    this.init()</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">    this.Quill &#x3D; null</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">        .......</span><br><span class="line">        const editor &#x3D; this.$refs.editor</span><br><span class="line">        this.Quill &#x3D; new Quill(editor, this.options)</span><br><span class="line">        &#x2F;&#x2F; 取消自动聚焦 - 解决编辑时聚焦问题</span><br><span class="line">        &#x2F;&#x2F; 多个quill 默认取最后一个聚焦</span><br><span class="line">        this.Quill.enable(false)</span><br><span class="line">        this.$nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">            this.Quill.enable(true)</span><br><span class="line">        &#125;)</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web</category>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>踩坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Echarts</title>
    <url>/2019/05/20/Echarts/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/05/20/WH1GhPTjnkzslbZ.jpg" alt=""></p>
<a id="more"></a>

<p>公司许多项目都涉及到数据的可视化展示，都用到了 ECharts ，这里记录工作中遇到的不常见的需求。</p>
<h1 id="数据缩放"><a href="#数据缩放" class="headerlink" title="数据缩放"></a>数据缩放</h1><!-- ![data-zoom.gif](https://i.loli.net/2020/05/20/jrkPLqMvt3xoBQg.gif) -->
<img src='https://i.loli.net/2020/05/20/jrkPLqMvt3xoBQg.gif' style='width:100%;height:500px;'/>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">    title: &#123;text: &#39;数据缩放示例&#39;,&#125;,</span><br><span class="line">    tooltip: &#123;confine: true&#125;,</span><br><span class="line">    xAxis: &#123;</span><br><span class="line">        data: [],      &#x2F;&#x2F;x轴数据</span><br><span class="line">        axisLine: &#123;</span><br><span class="line">            show: true,</span><br><span class="line">            lineStyle: &#123;color: &#39;rgba(50,197,255,0.5)&#39;,&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        axisLabel: &#123;color: &#39;#000&#39;,fontSize: 14,&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;</span><br><span class="line">        type: &#39;value&#39;,</span><br><span class="line">        axisLine: &#123;show: false,&#125;,</span><br><span class="line">        axisLabel: &#123;color: &#39;#000&#39;,fontSize: 18&#125;,</span><br><span class="line">        splitLine: &#123;</span><br><span class="line">            show: true,</span><br><span class="line">            lineStyle: &#123;color: &#39;rgba(50,197,255,0.5)&#39;,&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    dataZoom: &#123;</span><br><span class="line">        type: &#39;slider&#39;,</span><br><span class="line">        handleIcon: &#39;M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4v1.3h1.3v-1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z&#39;,</span><br><span class="line">        handleStyle: &#123;</span><br><span class="line">            color: &#39;#fff&#39;,</span><br><span class="line">            shadowBlur: 3,</span><br><span class="line">            shadowColor: &#39;rgba(0, 0, 0, 0.6)&#39;,</span><br><span class="line">            shadowOffsetX: 2,</span><br><span class="line">            shadowOffsetY: 2</span><br><span class="line">        &#125;,</span><br><span class="line">        dataBackground: &#123;</span><br><span class="line">            lineStyle: &#123;color: &#39;#32C5FF&#39;,opacity: 1,&#125;,</span><br><span class="line">            areaStyle: &#123;opacity: 1,color: &#39;#002839&#39;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        backgroundColor: &#39;rgba(0,37,51,1)&#39;,</span><br><span class="line">        fillerColor: &#39;rgba(0,16,22,0.38)&#39;,</span><br><span class="line">        borderColor: &#39;rgba(50,197,255,0.6)&#39;,</span><br><span class="line">        textStyle: &#123;color: &#39;#fff&#39;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    series: [&#123;</span><br><span class="line">        name: &#39;&#39;,</span><br><span class="line">        type: &#39;bar&#39;,</span><br><span class="line">        data: [],   &#x2F;&#x2F;y轴数据</span><br><span class="line">        itemStyle: &#123;</span><br><span class="line">            normal: &#123;</span><br><span class="line">                color: &#123;</span><br><span class="line">                    type: &#39;linear&#39;,x: 0,y: 0,x2: 0,y2: 1,</span><br><span class="line">                    colorStops: [&#123;offset: 0, color: &#39;#FFDD2D&#39;&#125;, &#123;offset: 1, color: &#39;#FA5B00&#39;&#125;],</span><br><span class="line">                    global: false</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多个图表联动"><a href="#多个图表联动" class="headerlink" title="多个图表联动"></a>多个图表联动</h1><!-- ![multiple-chart-linkage.gif](https://i.loli.net/2020/05/20/8gMYwyT2cUbHnao.gif) -->
<img src='https://i.loli.net/2020/05/20/8gMYwyT2cUbHnao.gif' style='width:100%;height:400px;'/>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var option &#x3D; &#123;</span><br><span class="line">    color:[&#39;#FCDB00&#39;,&#39;#FF7A46&#39;,&#39;#32C5FF&#39;],</span><br><span class="line">    legend: &#123;&#125;,</span><br><span class="line">    title:[</span><br><span class="line">        &#123;</span><br><span class="line">            text:&#39;单位用地税收&#39;,</span><br><span class="line">            top: &#39;33%&#39;,</span><br><span class="line">            left: &#39;15%&#39;,</span><br><span class="line">            textStyle: &#123;</span><br><span class="line">                color: &#39;#ccc&#39;,</span><br><span class="line">                fontSize: 14,</span><br><span class="line">                align: &#39;center&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            text:&#39;单位用地主营业务收入&#39;,</span><br><span class="line">            top: &#39;33%&#39;,</span><br><span class="line">            left: &#39;44%&#39;,</span><br><span class="line">            textStyle: &#123;</span><br><span class="line">                color: &#39;#ccc&#39;,</span><br><span class="line">                fontSize: 14,</span><br><span class="line">                align: &#39;center&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            text:&#39;单位能耗主营业务收入&#39;,</span><br><span class="line">            top: &#39;33%&#39;,</span><br><span class="line">            left: &#39;74%&#39;,</span><br><span class="line">            textStyle: &#123;</span><br><span class="line">                color: &#39;#ccc&#39;,</span><br><span class="line">                fontSize: 14,</span><br><span class="line">                align: &#39;center&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            text:&#39;单位用地税收&#39;,</span><br><span class="line">            top: &#39;75%&#39;,</span><br><span class="line">            left: &#39;12%&#39;,</span><br><span class="line">            textStyle: &#123;</span><br><span class="line">                color: &#39;#ccc&#39;,</span><br><span class="line">                fontSize: 14,</span><br><span class="line">                align: &#39;center&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            text:&#39;单位用地主营业务收入&#39;,</span><br><span class="line">            top: &#39;75%&#39;,</span><br><span class="line">            left: &#39;41%&#39;,</span><br><span class="line">            textStyle: &#123;</span><br><span class="line">                color: &#39;#ccc&#39;,</span><br><span class="line">                fontSize: 14,</span><br><span class="line">                align: &#39;center&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            text:&#39;单位能耗主营业务收入&#39;,</span><br><span class="line">            top: &#39;75%&#39;,</span><br><span class="line">            left: &#39;76%&#39;,</span><br><span class="line">            textStyle: &#123;</span><br><span class="line">                color: &#39;#ccc&#39;,</span><br><span class="line">                fontSize: 14,</span><br><span class="line">                align: &#39;center&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    tooltip: &#123;&#125;,</span><br><span class="line">    grid: [</span><br><span class="line">        &#123;</span><br><span class="line">            show: false,</span><br><span class="line">            left: &#39;10%&#39;,</span><br><span class="line">            top: &#39;42%&#39;,</span><br><span class="line">            containLabel: true,</span><br><span class="line">            width: &#39;25%&#39;,</span><br><span class="line">            height:&#39;30%&#39;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            show: false,</span><br><span class="line">            left: &#39;43%&#39;,</span><br><span class="line">            top: &#39;42%&#39;,</span><br><span class="line">            containLabel: true,</span><br><span class="line">            width: &#39;25%&#39;,</span><br><span class="line">            height:&#39;30%&#39;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            show: false,</span><br><span class="line">            left: &#39;73%&#39;,</span><br><span class="line">            top: &#39;42%&#39;,</span><br><span class="line">            containLabel: true,</span><br><span class="line">            width: &#39;25%&#39;,</span><br><span class="line">            height:&#39;30%&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    xAxis: [</span><br><span class="line">        &#123;gridIndex:0,type:&#39;category&#39;,&#125;,</span><br><span class="line">        &#123;gridIndex:1,type:&#39;category&#39;,&#125;,</span><br><span class="line">        &#123;gridIndex:2,type:&#39;category&#39;,&#125;</span><br><span class="line">    ],</span><br><span class="line">    yAxis: [</span><br><span class="line">        &#123;gridIndex:0,&#125;,</span><br><span class="line">        &#123;gridIndex:1,&#125;,</span><br><span class="line">        &#123;gridIndex:2,&#125;</span><br><span class="line">    ],</span><br><span class="line">    series : [</span><br><span class="line">        &#123;</span><br><span class="line">            type:&#39;pie&#39;,</span><br><span class="line">            name:&#39;单位用地税收&#39;,</span><br><span class="line">            radius: [&#39;15%&#39;,&#39;20%&#39;],</span><br><span class="line">            center: [&#39;20%&#39;, &#39;20%&#39;],</span><br><span class="line">            avoidLabelOverlap: false,</span><br><span class="line">            label: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            labelLine: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            data:[</span><br><span class="line">                &#123;value:335, name:&#39;领跑者企业&#39;&#125;,</span><br><span class="line">                &#123;value:310, name:&#39;规上企业&#39;&#125;,</span><br><span class="line">                &#123;value:234, name:&#39;新上规企业&#39;&#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            type:&#39;pie&#39;,</span><br><span class="line">            name:&#39;单位用地主营业务收入&#39;,</span><br><span class="line">            radius: [&#39;15%&#39;,&#39;20%&#39;],</span><br><span class="line">            avoidLabelOverlap: false,</span><br><span class="line">            center: [&#39;50%&#39;, &#39;20%&#39;],</span><br><span class="line">            label: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            labelLine: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            data:[</span><br><span class="line">                &#123;value:335, name:&#39;领跑者企业&#39;&#125;,</span><br><span class="line">                &#123;value:310, name:&#39;规上企业&#39;&#125;,</span><br><span class="line">                &#123;value:234, name:&#39;新上规企业&#39;&#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            type:&#39;pie&#39;,</span><br><span class="line">            name:&#39;单位能耗主营业务收入&#39;,</span><br><span class="line">            radius: [&#39;15%&#39;,&#39;20%&#39;],</span><br><span class="line">            avoidLabelOverlap: false,</span><br><span class="line">            center: [&#39;80%&#39;, &#39;20%&#39;],</span><br><span class="line">            label: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            labelLine: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            data:[</span><br><span class="line">                &#123;value:335, name:&#39;领跑者企业&#39;&#125;,</span><br><span class="line">                &#123;value:310, name:&#39;规上企业&#39;&#125;,</span><br><span class="line">                &#123;value:234, name:&#39;新上规企业&#39;&#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            type:&#39;bar&#39;,</span><br><span class="line">            avoidLabelOverlap: false,</span><br><span class="line">            center: [&#39;20%&#39;, &#39;55%&#39;],</span><br><span class="line">            name:&#39;领跑者企业&#39;,</span><br><span class="line">            label: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            labelLine: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            xAxisIndex:0,</span><br><span class="line">            yAxisIndex:0,</span><br><span class="line">            data:[335]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            type:&#39;bar&#39;,</span><br><span class="line">            avoidLabelOverlap: false,</span><br><span class="line">            center: [&#39;20%&#39;, &#39;55%&#39;],</span><br><span class="line">            name:&#39;规上企业&#39;,</span><br><span class="line">            label: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            labelLine: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            xAxisIndex:0,</span><br><span class="line">            yAxisIndex:0,</span><br><span class="line">            data:[310]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            type:&#39;bar&#39;,</span><br><span class="line">            avoidLabelOverlap: false,</span><br><span class="line">            center: [&#39;20%&#39;, &#39;55%&#39;],</span><br><span class="line">            name:&#39;新上规企业&#39;,</span><br><span class="line">            label: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            labelLine: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            xAxisIndex:0,</span><br><span class="line">            yAxisIndex:0,</span><br><span class="line">            data:[234]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            type:&#39;bar&#39;,</span><br><span class="line">            avoidLabelOverlap: false,</span><br><span class="line">            xAxisIndex:1,</span><br><span class="line">            yAxisIndex:1,</span><br><span class="line">            center: [&#39;50%&#39;, &#39;55%&#39;],</span><br><span class="line">            name:&#39;领跑者企业&#39;,</span><br><span class="line">            label: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            labelLine: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            data:[335]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            type:&#39;bar&#39;,</span><br><span class="line">            avoidLabelOverlap: false,</span><br><span class="line">            xAxisIndex:1,</span><br><span class="line">            yAxisIndex:1,</span><br><span class="line">            center: [&#39;50%&#39;, &#39;55%&#39;],</span><br><span class="line">            name:&#39;规上企业&#39;,</span><br><span class="line">            label: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            labelLine: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            data:[310]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            type:&#39;bar&#39;,</span><br><span class="line">            avoidLabelOverlap: false,</span><br><span class="line">            xAxisIndex:1,</span><br><span class="line">            yAxisIndex:1,</span><br><span class="line">            center: [&#39;50%&#39;, &#39;55%&#39;],</span><br><span class="line">            name:&#39;新上规企业&#39;,</span><br><span class="line">            label: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            labelLine: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            data:[234]  </span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            type:&#39;bar&#39;,</span><br><span class="line">            xAxisIndex:2,</span><br><span class="line">            yAxisIndex:2,</span><br><span class="line">            name:&#39;领跑者企业&#39;,</span><br><span class="line">            avoidLabelOverlap: false,</span><br><span class="line">            center: [&#39;80%&#39;, &#39;55%&#39;],</span><br><span class="line">            label: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            labelLine: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            data:[335]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            type:&#39;bar&#39;,</span><br><span class="line">            xAxisIndex:2,</span><br><span class="line">            yAxisIndex:2,</span><br><span class="line">            name:&#39;规上企业&#39;,</span><br><span class="line">            avoidLabelOverlap: false,</span><br><span class="line">            center: [&#39;80%&#39;, &#39;55%&#39;],</span><br><span class="line">            label: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            labelLine: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            data:[310]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            type:&#39;bar&#39;,</span><br><span class="line">            xAxisIndex:2,</span><br><span class="line">            yAxisIndex:2,</span><br><span class="line">            name:&#39;新上规企业&#39;,</span><br><span class="line">            avoidLabelOverlap: false,</span><br><span class="line">            center: [&#39;80%&#39;, &#39;55%&#39;],</span><br><span class="line">            label: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            labelLine: &#123;normal:&#123;show: false&#125;&#125;,</span><br><span class="line">            data:[444]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="不同渐变色的柱状图"><a href="#不同渐变色的柱状图" class="headerlink" title="不同渐变色的柱状图"></a>不同渐变色的柱状图</h1><p><img src="https://i.loli.net/2020/05/20/Tum4LeUPp7RI9vr.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;先定义变量把柱状体的渐变色放进去</span><br><span class="line">var series1Colors &#x3D; [new echarts.graphic.LinearGradient(</span><br><span class="line">    0, 0, 0, 1,</span><br><span class="line">    [</span><br><span class="line">        &#123;offset: 0, color: &#39;#00C3FF&#39;&#125;,</span><br><span class="line">        &#123;offset: 1, color: &#39;rgba(0, 195, 255, 0.5)&#39;&#125;</span><br><span class="line">    ]</span><br><span class="line">), new echarts.graphic.LinearGradient(</span><br><span class="line">    0, 0, 0, 1,</span><br><span class="line">    [</span><br><span class="line">        &#123;offset: 0, color: &#39;#0066FF&#39;&#125;,</span><br><span class="line">        &#123;offset: 1, color: &#39;rgba(0, 102, 255, 0.6)&#39;&#125;</span><br><span class="line">    ]</span><br><span class="line">), new echarts.graphic.LinearGradient(</span><br><span class="line">    0, 0, 0, 1,</span><br><span class="line">    [</span><br><span class="line">        &#123;offset: 0, color: &#39;#FF911C&#39;&#125;,</span><br><span class="line">        &#123;offset: 1, color: &#39;rgba(255, 145, 28, 0.5)&#39;&#125;</span><br><span class="line">    ]</span><br><span class="line">), new echarts.graphic.LinearGradient(</span><br><span class="line">    0, 0, 0, 1,</span><br><span class="line">    [</span><br><span class="line">        &#123;offset: 0, color: &#39;#F15887&#39;&#125;,</span><br><span class="line">        &#123;offset: 1, color: &#39;rgba(241, 88, 135, 0.5)&#39;&#125;</span><br><span class="line">    ]</span><br><span class="line">), new echarts.graphic.LinearGradient(</span><br><span class="line">    0, 0, 0, 1,</span><br><span class="line">    [</span><br><span class="line">        &#123;offset: 0, color: &#39;#5EEB8D&#39;&#125;,</span><br><span class="line">        &#123;offset: 1, color: &#39;rgba(0, 255, 218, 0.5)&#39;&#125;</span><br><span class="line">    ]</span><br><span class="line">), new echarts.graphic.LinearGradient(</span><br><span class="line">    0, 0, 0, 1,</span><br><span class="line">    [</span><br><span class="line">        &#123;offset: 0, color: &#39;#FFDD00&#39;&#125;,</span><br><span class="line">        &#123;offset: 1, color: &#39;rgba(255, 221, 0, 0.5)&#39;&#125;</span><br><span class="line">    ]</span><br><span class="line">)];</span><br><span class="line">var temp &#x3D; [1,2,3,4,5,6];</span><br><span class="line">&#x2F;&#x2F;柱状图配置</span><br><span class="line">option &#x3D; &#123;</span><br><span class="line">     xAxis: [</span><br><span class="line">        &#123;</span><br><span class="line">            type: &#39;category&#39;,</span><br><span class="line">            data: [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;], &#x2F;&#x2F;x轴中的六个区域</span><br><span class="line">            axisTick: &#123;</span><br><span class="line">                alignWithLabel: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    yAxis: [</span><br><span class="line">        &#123;</span><br><span class="line">            type: &#39;value&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    series:[&#123;</span><br><span class="line">        type:&#39;bar&#39;,</span><br><span class="line">        data : temp.map(function (v,i) &#123;  &#x2F;&#x2F;temp是每个x轴对应的数据</span><br><span class="line">            return &#123;</span><br><span class="line">                value: v || 0,</span><br><span class="line">                itemStyle: &#123;</span><br><span class="line">                    normal:&#123;</span><br><span class="line">                        barBorderRadius: false,</span><br><span class="line">                        color:series1Colors[i%6]  &#x2F;&#x2F;对区域个数取余 获取对应渐变色</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                label:&#123;</span><br><span class="line">                    show:true,</span><br><span class="line">                    position:&#39;top&#39;,</span><br><span class="line">                    formatter: &#39;&#123;c&#125; 家&#39;,</span><br><span class="line">                    textStyle:&#123;</span><br><span class="line">                        color:&#39;#53F5FF&#39;,</span><br><span class="line">                        fontSize:16</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="象形柱图"><a href="#象形柱图" class="headerlink" title="象形柱图"></a>象形柱图</h1><p><img src="https://i.loli.net/2020/05/20/tNk5mpauwcIl4bA.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">    backgroundColor: &#39;#0f375f&#39;,</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">        trigger: &quot;axis&quot;,</span><br><span class="line">        axisPointer: &#123;</span><br><span class="line">            type: &quot;shadow&quot;,</span><br><span class="line">            label: &#123;show: true&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    axisLabel: &#123;</span><br><span class="line">        color: &#39;#fff&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis: &#123;</span><br><span class="line">        type: &#39;category&#39;,</span><br><span class="line">        data:[&#39;2014&#39;,&#39;2015&#39;,&#39;2016&#39;,&#39;2017&#39;,&#39;2018&#39;,&#39;2019&#39;,],</span><br><span class="line">        splitLine: &#123;</span><br><span class="line">            show: true,</span><br><span class="line">            lineStyle: &#123;color: &#39;#3C52AB&#39;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        axisTick: &#123;show: false&#125;,</span><br><span class="line">        axisLine: &#123;</span><br><span class="line">            lineStyle: &#123;color: &#39;#3C52AB&#39;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: [</span><br><span class="line">        &#123;</span><br><span class="line">            type: &quot;value&quot;,</span><br><span class="line">            name: &quot;亿元&quot;,</span><br><span class="line">            nameTextStyle: &#123;color: &quot;#fff&quot;&#125;,</span><br><span class="line">            splitLine: &#123;</span><br><span class="line">                show: true,</span><br><span class="line">                lineStyle: &#123;color: &#39;#3C52AB&#39;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            axisTick: &#123;show: false&#125;,</span><br><span class="line">            axisLabel: &#123;</span><br><span class="line">                show: false,</span><br><span class="line">                textStyle: &#123;color: &quot;#ebf8ac&quot;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            axisLine: &#123;</span><br><span class="line">                lineStyle: &#123;color: &#39;#3C52AB&#39;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            type: &quot;value&quot;,</span><br><span class="line">            name: &quot;%&quot;,</span><br><span class="line">            nameTextStyle: &#123;color: &quot;#fff&quot;&#125;,</span><br><span class="line">            position: &quot;right&quot;,</span><br><span class="line">            splitLine: &#123;show: false&#125;,</span><br><span class="line">            axisTick: &#123;show: false&#125;,</span><br><span class="line">            axisLine: &#123;</span><br><span class="line">                show: true,</span><br><span class="line">                lineStyle: &#123;color: &#39;#3C52AB&#39;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            axisLabel: &#123;</span><br><span class="line">                show: false,</span><br><span class="line">                formatter: &quot;&#123;value&#125; %&quot;, &#x2F;&#x2F;右侧Y轴文字显示</span><br><span class="line">                textStyle: &#123;color: &quot;#ebf8ac&quot;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    series: [</span><br><span class="line">        &#123;</span><br><span class="line">            data: [23,34,56,43,65,32],</span><br><span class="line">            type: &#39;pictorialBar&#39;,</span><br><span class="line">            name: &#39;数量&#39;,</span><br><span class="line">            symbolPosition: &#39;center&#39;,</span><br><span class="line">            barWidth: &#39;20%&#39;,</span><br><span class="line">            label: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    show: true,</span><br><span class="line">                    position: &quot;top&quot;,</span><br><span class="line">                    formatter: &quot;&#123;c&#125;&quot;,</span><br><span class="line">                    color: &quot;#fff&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            symbol:&#39;image:&#x2F;&#x2F;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAACcCAYAAABsvctMAAAABGdBTUEAALGPC&#x2F;xhBQAACz9JREFUeAHtmjuOJVkRhquaYQesYSx8FoCQwMDBGAOwcXCwESbCxsHBZjAwcDBAQiwAH4s1sAOYLuL&#x2F;I744JyMzq4cZJCjpnlZnxInHH4&#x2F;zyHtv9&#x2F;OTxp&#x2F;&#x2F;+WKqx0uwz89JLQz+SWpRDfhywVb0Qm03XL711eeP2shAmhGsAERe4lHTxZTglKDshVNDvhKYPj1lQAk6w+IFpFGkaUrX81Th8K94JFwBIx7ABgi8SmAWMPxjBV4C69m0syBZwQSuoKEO+E7hN6O9GoFJZ2pE+Mww5cg65IHBVx4O+CzArih5Za4xOxYSy6GuMIyWffJ3eFlhBcsACYiDqyOqQ0nvJuXMOiVWiYTKfObbvGSfhUdXSMZGmY9ynmLNWRv2gFOJR7vAFF1reIVm2bGFaYZMy&#x2F;vy9C6yp6XwolejKgwVemUinsyGl3C0vI0HU1S6DFqOYBV+VThQX5sqmPSvJCQdediOoOHWAWtTZnGAFu5mr1CvDxKBynrnX&#x2F;d+aN9AB7zhvvbHf&#x2F;Wynq+qcQxkue8ibcfDOTkZhEPK&#x2F;vGdj&#x2F;J9qLuU4QxibmrsONTxpy&#x2F;gUEhXr7cVbMPIACCCnTQPfgHLBHBRD4IX4Eok1UrEXekU5eeU0qD59OxzWNpQpwKa2d4DSJ+2JKh4wdd0xOPgr7uQwFDd8qyrZPCiGlNf+WaRtsfG5utt4VeKZAJiI3hevpWx7WySnZB9yspglKQdoAU3DbxqaThjLwfzCXheU8kTRPkYKqYsgVwX&#x2F;OLR56ZxezKA4jlgTcX7IhZSDIq3LEV2KTaWLx1654chMtnULg0hASQ98DUpA+EdXj+dXWbk6tTmI4hQPSpgGPTBQpVUMAqZcBFMvIKmukqWUSUWOtbZJjgW7TWkKMn3AMihAtn5zqQA7Rs8NhOvAgYKDvZQloLOasSrKg34W32adUACQ0v9IG+4A17Lr&#x2F;&#x2F;hM67GKGXuqw9VJwh8ZAufu0xHhPv3b9&#x2F;9yvX7MK8zAk1A5EnPV1&#x2F;It7dF3qU6JplAHvzgfViFoVuCvW&#x2F;MNMzMLTg8sG3&#x2F;WaFDrZvndA7zoAXm3UHzCVMSebLcLoFyUJXOxvOdA5oVNoiM5REDKp0BMkAqaLPCJs&#x2F;diWa31vdP4Kql1UbFqZaSMd2lYCqDnu0jVGFk4sclypYutF7LXhOcXaUhDo&#x2F;TGkYpKUszePC6QlD8eokG0CK1Ytt0lrMz8aFazdGJaugtZFm9jbJCr4P1abTNCQw1yKZ&#x2F;eu+SnkwVQN0KGRVN+64QA3WOdXN0Z8pWSEDWzXqWo2j6a9emN1iYnSpkd0EjRHpClZD4AixlEwNX0hbCl30F9MayXvDOsiBOaxLBkMlEOPYp+06kAli889g96JvtgLfgN3+vw5QrO4&#x2F;F3NbnStkyhgq1cJDJGv756S&#x2F;fe3f9PpQP7joC+64UxD44k9y9qcvkj3zK8uCHZt0kxwwFlB9+d5AV0m8C25Di0X+vUF59DoHIilYCVCeaY7Uo59y76CXd+bTi2TcNLSHPprWI6+rLe7LtQy8ePcBNx6bIlqolvpMit+IB7GQrab7I3Np&#x2F;YJd1hQBzT7Kmp5ZGYFdPAtpUSjKl1c2w6K7CZ8+6wm7ByNCfRcKWzyT9KqmOyI&#x2F;kjDFaOO0zoFwygYy7T+CLJp6qStMsRc4p0Fqe1hSMsKqWhvHN98MToFoX0agqA0SVndDxB9tcACWTFa0KSfhEKT1pukYVZUermzqh1eZpXxWGdyMUT5yxJq5EFdKm8DOL&#x2F;0gYGOhQP6ZvsANeyx&#x2F;8LnaBNkcMPSW82QMyOQxs2RTTP49NbrJPP3m+eR8GJAAr&#x2F;JIcIkZqeSYrxSD7rvUBkqxKyHNoowTklujLu2stwGO0ROfoKNG6C5MqUIQKGRfF6RzmOZNjVQRYtVwQq&#x2F;FilUjIWh&#x2F;TTlJ8eiTXv7VpWhVQSFFnGGBkeHp7jASUp2KvfHP96Niq0I4yPhqwHgAQGHqyr2rRqw73qgrINaxgqpNWQpVutrk8ZLQNdHf2U1+bZoEpM9omXGm0D7CY+oztGszavvwkwNd7KebV0uUgbq3Y4iVjdLsk0IJJZyoueWwmXldIS7Qm+bklayJM01hM1i0TaI2n6EQ1LluqzyO4Ud1ekT15BE5WgeBIM0AFkkr22nEZn5Z2R06&#x2F;+LKeohoKhkxzePT5ySFs908QFUz2j&#x2F;H2O+DN+ePf1B6OesR5U9VCw4t+2fGrH9b7UEHYSML1bz2FjhxqQxmVQGSbltci6EQ1fPD5MUkCeFGPSSVEFqwqx8eq0NEVzZWN+1cRHdD+G8hqcGLLFjV8+Xc3OkHZYqyAwXtasgyIUAZjCPh9&#x2F;O0AxUvGKCxPqY41p3oS6oAYKDuchOALQwlVxJnAtLfPlgHVQrulCKZD97JAwIJOe3CgU98VSvGFhkpWdHoOv2e0AXeFm+w&#x2F;Y1lgFnX2fKD9jyqkDcoGnpZ8npZhSzX7fOB1S1lk44dRL0m0yru2WgZ&#x2F;2NXKs4LM&#x2F;JzDngBJPeib7YD3xvd&#x2F;zZLn4u9Xm3cPO+2izLlJMGWf7Prf&#x2F;qjeh1ys4K3wuVsBQb&#x2F;TeTlLR7CdR7YOvmsta9LStCyhAjmMsH3htpGC7IgAVuH3ObxM64B8MwEYSlDMkRftCpGPhM49lSFGgO4UXVU0K+6AXC1zTewfQfA3NtlpcpXAptdSgCHzy5bu6+UEwpCNZeeYv5qAkEdQiTQcEDAJJiB+UNns&#x2F;HRwRQFC0hOvKyRjwKAzAPKmF5f7+5LtvtivNZQ2hhRkZcF4oCNBGbuaElzugcIU1ApYDmQClZgk5DABJdt7LHvbWHG2d0DpWEc7xLzinwLo2ju0LLKRLWtGolBhoxP&#x2F;GG+&#x2F;A94b3&#x2F;7lWlZx+&#x2F;sQXvTLjj&#x2F;95It8P5xRtR29TVMxpq0iXx8LzpZcXGtoqdkVI0&#x2F;Mw9Md2G4WKQ9HoqyR9TkkgPVoh3FND4RDzjk+KGNC8YcKFWzEaL+5hq5464CA9hf+jED3SOiypQRRVCeyJeQAMSfjCSg5y2D&#x2F;qoQOdkvJYALijEP5d0emvROISHd4XaGy0ZiAu8wGLiE40Rr4aOrEQtcJlj3foB1wd5h40iEzPsZFZwAZ75&#x2F;iLn+gJRtnaNRV6S6ziuiiMbzeRTUX1mkPSC5ljKxQswKw9LUHW1I0xvzRwTLQPYkHSQa7WrobybAGuaC2b0zIzxWFLV0CG71hcAb0Qd90B7y23&#x2F;gFS37e1mxxUY3LTRTywyax5fnx159evA9ltsKn09xk+3zepecwR0lfbXcVcGuYHn09k9&#x2F;hY2NIVS1JwdOBPodUJQVnW4huYTwAkGwf+EGl223hoeumKRQUUKVrMFKUQnwblGOR05qHHTKZdIXtdgU4wff5sLcqHm0CX4JThZ3956zIiTZ6zOChMth4B+SlaedhoHa6g+VEe0Qvh+z2lsOXvQPKsZOAgUp3wSOTCkzhmA9h4S&#x2F;gwjhVOAEEso+rCgvLZvNckgwJ5BruiMHvAEPVZ05nT+MygQ2AI1bmuUsVAcHMSL7IHCAe+5rDi96NV1R3Lg&#x2F;5&#x2F;3EHvFs&#x2F;&#x2F;hn&#x2F;CP7fz5QNJ&#x2F;r3n9&#x2F;8XnoIu3scFDWZ23jYsEOheQ5xGsaejoOEKQA+h2Fze9UNzHXwQRgGng7dPu0rroQiNEW+8KIaHRDHaTA9ZMftIgD4vcJTQgEKvgNyWwhgdPD0v0Vkg7PtlYD8KspM2AluPg4oxwYhG3nGcDLBA5jS9ZQZSUoKL6phfSWleVaIVhKNQ09qikwI4kVroNLUiYeOAuaXnV7D9scbapRCLkDHLD1mUOn2Jerky2C1dGG+yjlYWHSCQ+A1CxkVDnW9njYAJYKRIsOLakz9rMD2YXRn7woBFSD8ncOH9NW5zoMkRTX+DVOyETAMyO4&#x2F;AAAAAElFTkSuQmCC&#39;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">            data: [17,24,28,48,35,32],</span><br><span class="line">            type: &#39;line&#39;,</span><br><span class="line">            name: &#39;折线图&#39;,</span><br><span class="line">            symbolSize: 10, &#x2F;&#x2F; 控制线条上 点 的大小</span><br><span class="line">            lineStyle: &#123;color: &#39;rgba(206, 196, 88, 1)&#39;,&#125;,</span><br><span class="line">            itemStyle: &#123;</span><br><span class="line">                color: &#39;rgba(206, 196, 88, 1)&#39;,</span><br><span class="line">                borderType: &#39;solid&#39;,</span><br><span class="line">                symbol: &#39;circle&#39;,</span><br><span class="line">                borderWidth:0,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="图表放大操作"><a href="#图表放大操作" class="headerlink" title="图表放大操作"></a>图表放大操作</h1><p><img src="https://i.loli.net/2020/10/24/bYqExs4m3rfu5tC.gif" alt="chart-enlarge.gif"><br>操作1：点击图表只进行放大操作；<br>操作2：点击图表放大的同时显示柱状图，柱状图数据和折线图数据相同（这个时候悬浮框会有多个重复提示，需要去掉重复）；<br>操作3：点击图表放大的同时显示柱状图，柱状图数据和折线图数据不同（这个时候需要新增legend）。</p>
<ul>
<li>新建一个公共组件 ChartEnlargeDialog.vue，用于显示放大后的图表；</li>
<li>新建一个 vuex 文件，用来存放图表的数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 公共组件  ChartEnlargeDialog.vue，用于显示放大后的图表</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-dialog</span><br><span class="line">    class&#x3D;&quot;chart-enlarge&quot;</span><br><span class="line">    title</span><br><span class="line">    :fullscreen&#x3D;&quot;true&quot;</span><br><span class="line">    :visible.sync&#x3D;&quot;chartEnlarge.isShow&quot;</span><br><span class="line">    @close&#x3D;&quot;closeDialog&quot;</span><br><span class="line">    @opened&#x3D;&quot;openDialog&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;dialog-content&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;dialog-body&quot;&gt;</span><br><span class="line">        &lt;div id&#x3D;&quot;enlargeChart&quot; v-show&#x3D;&quot;!chartEnlarge.chartType&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div id&#x3D;&quot;dbdb&quot; v-if&#x3D;&quot;chartEnlarge.chartType &#x3D;&#x3D;&#x3D; &#39;dbdb&#39;&quot;&gt;</span><br><span class="line">          &lt;table class&#x3D;&quot;right-top-table&quot; border&#x3D;&quot;1&quot;&gt;</span><br><span class="line">            &lt;thead&gt;</span><br><span class="line">              &lt;tr&gt;</span><br><span class="line">                &lt;th v-for&#x3D;&quot;(item,index) in tableEnlarge.headerData&quot; :key&#x3D;&quot;index&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;&#x2F;th&gt;</span><br><span class="line">              &lt;&#x2F;tr&gt;</span><br><span class="line">            &lt;&#x2F;thead&gt;</span><br><span class="line">            &lt;tbody&gt;</span><br><span class="line">              &lt;tr v-for&#x3D;&quot;(item,index) in tableEnlarge.tableData&quot; :key&#x3D;&quot;&#39;a&#39;+index&quot;&gt;</span><br><span class="line">                &lt;td</span><br><span class="line">                  v-for&#x3D;&quot;(column,index2) in tableEnlarge.headerData&quot;</span><br><span class="line">                  :key&#x3D;&quot;index2&quot;</span><br><span class="line">                &gt;&#123;&#123;item[column.key] || &#39;-&#39;&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">              &lt;&#x2F;tr&gt;</span><br><span class="line">            &lt;&#x2F;tbody&gt;</span><br><span class="line">          &lt;&#x2F;table&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;el-dialog&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;ChartEnlargeDialog&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    chartEnlarge: &#123;</span><br><span class="line">      get: function() &#123;</span><br><span class="line">        return this.$store.state.yxjc.chartEnlargeDialog</span><br><span class="line">      &#125;,</span><br><span class="line">      set: function() &#123;</span><br><span class="line">        this.$store.commit(&#39;yxjc&#x2F;setChartEnlargeDialog&#39;, &#123;</span><br><span class="line">          isShow: false</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    tableEnlarge: &#123;</span><br><span class="line">      get: function() &#123;</span><br><span class="line">        return this.$store.state.yxjc.dbdbDialog.data</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    closeDialog() &#123;</span><br><span class="line">      if (this.chartEnlarge.myChart) &#123;</span><br><span class="line">        this.enlargeChart.clear()</span><br><span class="line">      &#125;</span><br><span class="line">      this.$store.commit(&#39;yxjc&#x2F;setChartEnlargeDialog&#39;, &#123;</span><br><span class="line">        isShow: false</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    openDialog() &#123;</span><br><span class="line">      &#x2F;&#x2F; 未传入图表对象（即放大的是表格），不做任何操作</span><br><span class="line">      if (!this.chartEnlarge.myChart) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 获取要放大的echarts的配置项和dom节点</span><br><span class="line">      let options &#x3D; this.chartEnlarge.myChart.getOption()</span><br><span class="line">      const dom &#x3D; this.chartEnlarge.myChart.getDom()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 操作1：点击图表只进行放大操作；</span><br><span class="line">      this.enlargeChart &#x3D; echarts.init(document.getElementById(&#39;enlargeChart&#39;))</span><br><span class="line">      this.enlargeChart.setOption(options)</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 操作2：点击图表放大的同时显示柱状图，柱状图数据和折线图数据相同（这个时候悬浮框会有多个重复提示，需要去掉重复）；</span><br><span class="line">      &#x2F;&#x2F; 操作3：点击图表放大的同时显示柱状图，柱状图数据和折线图数据不同（这个时候需要新增legend）。</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 放大后需要展示对应柱状图的特殊图表的dom id</span><br><span class="line">      let domId &#x3D; [&#39;productCharts&#39;, &#39;industryTotalOutPut&#39;, &#39;exportTotalVal&#39;, &#39;bascEcharts&#39;, &#39;industrysEcharts0&#39;, &#39;industrysEcharts1&#39;, &#39;industrysEcharts2&#39;]</span><br><span class="line">      if (domId.indexOf(dom.id) !&#x3D; -1) &#123;</span><br><span class="line">        let barSeries &#x3D; []</span><br><span class="line">        let tempName &#x3D; dom.id &#x3D;&#x3D; &#39;industryTotalOutPut&#39; ? &#39;工业总产值&#39; : (dom.id &#x3D;&#x3D; &#39;exportTotalVal&#39; ? &#39;外贸出口总额&#39; : &#39;工业用电&#39;)</span><br><span class="line">        if (dom.id &#x3D;&#x3D; &#39;industryTotalOutPut&#39; || dom.id &#x3D;&#x3D; &#39;exportTotalVal&#39; || dom.id &#x3D;&#x3D; &#39;bascEcharts&#39;) &#123; &#x2F;&#x2F; 折线图是增速 柱状图是具体数值</span><br><span class="line">          if (this.chartEnlarge.data &amp;&amp; this.chartEnlarge.data.length &gt; 0) &#123;</span><br><span class="line">            barSeries.push(&#123;</span><br><span class="line">              type: &#39;bar&#39;,</span><br><span class="line">              name: tempName,</span><br><span class="line">              barWidth: &#39;20%&#39;,</span><br><span class="line">              itemStyle: &#123;</span><br><span class="line">                borderWidth: 3,</span><br><span class="line">                color: &#39;#6388FF&#39;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#x2F;&#x2F; this.chartEnlarge.type 1-月度 2-累计</span><br><span class="line">              data: this.chartEnlarge.data.map(cu &#x3D;&gt; &#123; return this.chartEnlarge.type &#x3D;&#x3D; 1 ? cu.absoluteValue : cu.accumulateValue &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 放大后展示的柱状图和折线图数据保持一致</span><br><span class="line">          options.series.map((cu, index) &#x3D;&gt; &#123;</span><br><span class="line">            if (cu.data &amp;&amp; cu.data.length &gt; 0) &#123;</span><br><span class="line">              barSeries.push(&#123;</span><br><span class="line">                type: &#39;bar&#39;,</span><br><span class="line">                name: cu.name || &#39;&#39;,</span><br><span class="line">                barWidth: &#39;20%&#39;,</span><br><span class="line">                itemStyle: &#123;</span><br><span class="line">                  borderWidth: 3,</span><br><span class="line">                  color: typeof (options.color) &#x3D;&#x3D; &#39;object&#39; ? options.color[index] : options.color</span><br><span class="line">                &#125;,</span><br><span class="line">                data: cu.data</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 悬浮框提示修改：解决放大后展示的柱状图和折线图数据保持一致时，提示内容重复</span><br><span class="line">        let tooltipTemp &#x3D; &#123;</span><br><span class="line">          formatter: (params) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 移除重复的数据</span><br><span class="line">            for (var i &#x3D; 0; i &lt; params.length; i++) &#123;</span><br><span class="line">              for (var j &#x3D; params.length - 1; j &gt; i; j--) &#123;</span><br><span class="line">                if (params[j].seriesName &#x3D;&#x3D; params[i].seriesName) &#123;</span><br><span class="line">                  params.splice(j, 1)</span><br><span class="line">                  break</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            var tip &#x3D; &#39;&#39;</span><br><span class="line">            if (params &amp;&amp; params.length &gt; 0) &#123;</span><br><span class="line">              tip &#x3D; params[0].axisValueLabel + &#39;&lt;br &#x2F;&gt;&#39;</span><br><span class="line">            &#125;</span><br><span class="line">            for (var m &#x3D; 0; m &lt; params.length; m++) &#123; &#x2F;&#x2F; 这里是自己定义样式， params[i].marker 表示是否显示左边的那个小圆圈</span><br><span class="line">              tip +&#x3D; params[m].marker + params[m].seriesName + &#39;:&#39; + params[m].value + &#39;&lt;br&#x2F;&gt;&#39;</span><br><span class="line">            &#125;</span><br><span class="line">            return tip</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.enlargeChart.setOption(&#123;</span><br><span class="line">          tooltip: dom.id &#x3D;&#x3D; &#39;industryTotalOutPut&#39; || dom.id &#x3D;&#x3D; &#39;exportTotalVal&#39; || dom.id &#x3D;&#x3D; &#39;bascEcharts&#39; ? &#123;&#125; : tooltipTemp,</span><br><span class="line">          legend: &#123;</span><br><span class="line">            data: dom.id &#x3D;&#x3D; &#39;industryTotalOutPut&#39; || dom.id &#x3D;&#x3D; &#39;exportTotalVal&#39; || dom.id &#x3D;&#x3D; &#39;bascEcharts&#39; ? [options.legend[0].data[0], tempName] : options.legend[0].data</span><br><span class="line">          &#125;,</span><br><span class="line">          yAxis: &#123;</span><br><span class="line">            name: dom.id &#x3D;&#x3D; &#39;industryTotalOutPut&#39; || dom.id &#x3D;&#x3D; &#39;exportTotalVal&#39; || dom.id &#x3D;&#x3D; &#39;bascEcharts&#39; ? &#39;区本级企业&#39; : &#39;&#39;,</span><br><span class="line">            nameTextStyle: &#123;</span><br><span class="line">              color: &#39;#fff&#39;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          series: [...options.series, ...barSeries]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const that &#x3D; this</span><br><span class="line">      window.addEventListener(&#39;resize&#39;, function(e) &#123;</span><br><span class="line">        that.enlargeChart.resize()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vuex 保存图表数据</span><br><span class="line">const state &#x3D; &#123;</span><br><span class="line">  chartEnlargeDialog: &#123;  &#x2F;&#x2F; echarts全局弹出框</span><br><span class="line">    myChart: &#123;&#125;,</span><br><span class="line">    isShow: false,</span><br><span class="line">    data: null, &#x2F;&#x2F; 放大后需要另外展示的数据</span><br><span class="line">    type: null</span><br><span class="line">  &#125;,</span><br><span class="line">  dbdbDialog: &#123; &#x2F;&#x2F; 表格数据弹出层</span><br><span class="line">    data: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mutations &#x3D; &#123;</span><br><span class="line">  setChartEnlargeDialog(state, dialog) &#123;</span><br><span class="line">    state.chartEnlargeDialog &#x3D; dialog</span><br><span class="line">  &#125;,</span><br><span class="line">  setDbdbDialog(state, dialog2) &#123;</span><br><span class="line">    state.dbdbDialog &#x3D; dialog2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const actions &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  namespaced: true,</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getChartEnlargeDialog: state &#x3D;&gt; state.yxjc.chartEnlargeDialog,</span><br><span class="line">getdbdbDialog: state &#x3D;&gt; state.yxjc.dbdbDialog</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 具体使用</span><br><span class="line">&#x2F;&#x2F; echarts</span><br><span class="line">chartEnlarge() &#123;</span><br><span class="line">    this.$store.commit(&#39;yxjc&#x2F;setChartEnlargeDialog&#39;, &#123;</span><br><span class="line">        myChart: this.charts,</span><br><span class="line">        isShow: true,</span><br><span class="line">        data: this.resData,</span><br><span class="line">        type: this.topMatchType</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 表格</span><br><span class="line">chartEnlarge() &#123;</span><br><span class="line">    this.$store.commit(&#39;yxjc&#x2F;setChartEnlargeDialog&#39;, &#123;</span><br><span class="line">        chartType: &#39;dbdb&#39;,</span><br><span class="line">        isShow: true</span><br><span class="line">    &#125;)</span><br><span class="line">    this.$store.commit(&#39;yxjc&#x2F;setDbdbDialog&#39;, &#123;</span><br><span class="line">        data: &#123;</span><br><span class="line">            tableData: this.tableData,</span><br><span class="line">            headerData: [</span><br><span class="line">                &#123; name: &#39;行业&#39;, key: &#39;industryName&#39; &#125;,</span><br><span class="line">                &#123; name: &#39;企业数&#39;, key: &#39;entCount&#39; &#125;,</span><br><span class="line">                &#123; name: &#39;累计产值&#39;, key: &#39;accumulateOutput&#39; &#125;,</span><br><span class="line">                &#123; name: &#39;同比增幅&#39;, key: &#39;yoyGrowth&#39; &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h1 id="饼状图加转动的圆圈"><a href="#饼状图加转动的圆圈" class="headerlink" title="饼状图加转动的圆圈"></a>饼状图加转动的圆圈</h1><p><img src="https://i.loli.net/2020/12/31/rDFInO1ejXwu8mf.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;indusPieEchart&quot; @mouseover&#x3D;&quot;stopTimer&quot; @mouseout&#x3D;&quot;startTimer&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取数据</span><br><span class="line">getData()&#123;</span><br><span class="line">  this.indusData&#x3D;[</span><br><span class="line">    &#123;industryName:&#39;针织或钩针编织物及其制品制造&#39;,exceptionEntCount:266&#125;,</span><br><span class="line">    &#123;industryName:&#39;化纤织造及印染精加工&#39;,exceptionEntCount:167&#125;,</span><br><span class="line">    &#123;industryName:&#39;塑料制品业&#39;,exceptionEntCount:81&#125;,</span><br><span class="line">    &#123;industryName:&#39;棉纺织及印染精加工&#39;,exceptionEntCount:266&#125;,</span><br><span class="line">    &#123;industryName:&#39;皮革制品制造&#39;,exceptionEntCount:70&#125;,</span><br><span class="line">    &#123;industryName:&#39;其他&#39;,exceptionEntCount:812&#125;</span><br><span class="line">  ]</span><br><span class="line">  this.totalEntCount &#x3D; 1544</span><br><span class="line">  let pieColors &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">      type: &#39;linear&#39;,</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0,</span><br><span class="line">      x2: 1,</span><br><span class="line">      y2: 0,</span><br><span class="line">      colorStops: [&#123;</span><br><span class="line">        offset: 0,</span><br><span class="line">        color: &#39;#05E1E0&#39; &#x2F;&#x2F; 0% 处的颜色</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        offset: 1,</span><br><span class="line">        color: &#39;#00BFFE&#39; &#x2F;&#x2F; 100% 处的颜色</span><br><span class="line">      &#125;],</span><br><span class="line">      global: false &#x2F;&#x2F; 缺省为 false</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      type: &#39;linear&#39;,</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0,</span><br><span class="line">      x2: 1,</span><br><span class="line">      y2: 0,</span><br><span class="line">      colorStops: [&#123;</span><br><span class="line">        offset: 0,</span><br><span class="line">        color: &#39;#6850FC&#39; &#x2F;&#x2F; 0% 处的颜色</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        offset: 1,</span><br><span class="line">        color: &#39;#6750FD&#39; &#x2F;&#x2F; 100% 处的颜色</span><br><span class="line">      &#125;],</span><br><span class="line">      global: false &#x2F;&#x2F; 缺省为 false</span><br><span class="line">    &#125;,</span><br><span class="line">    &#39;#FA954B&#39;,</span><br><span class="line">    &#123;</span><br><span class="line">      type: &#39;linear&#39;,</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0,</span><br><span class="line">      x2: 1,</span><br><span class="line">      y2: 0,</span><br><span class="line">      colorStops: [&#123;</span><br><span class="line">        offset: 0,</span><br><span class="line">        color: &#39;#FFDE57&#39; &#x2F;&#x2F; 0% 处的颜色</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        offset: 1,</span><br><span class="line">        color: &#39;#FBC412&#39; &#x2F;&#x2F; 100% 处的颜色</span><br><span class="line">      &#125;],</span><br><span class="line">      global: false &#x2F;&#x2F; 缺省为 false</span><br><span class="line">    &#125;,</span><br><span class="line">    &#39;#6EC5FF&#39;,</span><br><span class="line">    &#123;</span><br><span class="line">      type: &#39;linear&#39;,</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0,</span><br><span class="line">      x2: 1,</span><br><span class="line">      y2: 0,</span><br><span class="line">      colorStops: [&#123;</span><br><span class="line">        offset: 0,</span><br><span class="line">        color: &#39;#FD5D5D&#39; &#x2F;&#x2F; 0% 处的颜色</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        offset: 1,</span><br><span class="line">        color: &#39;#FF4C9F&#39; &#x2F;&#x2F; 100% 处的颜色</span><br><span class="line">      &#125;],</span><br><span class="line">      global: false &#x2F;&#x2F; 缺省为 false</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      type: &#39;linear&#39;,</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0,</span><br><span class="line">      x2: 1,</span><br><span class="line">      y2: 0,</span><br><span class="line">      colorStops: [&#123;</span><br><span class="line">        offset: 0,</span><br><span class="line">        color: &#39;#32C5FF&#39; &#x2F;&#x2F; 0% 处的颜色</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        offset: 1,</span><br><span class="line">        color: &#39;#003DFF&#39; &#x2F;&#x2F; 100% 处的颜色</span><br><span class="line">      &#125;],</span><br><span class="line">      global: false &#x2F;&#x2F; 缺省为 false</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  this.chart &#x3D; echarts.init(document.getElementById(&#39;indusPieEchart&#39;))</span><br><span class="line">  let that &#x3D; this</span><br><span class="line">  window.addEventListener(&#39;resize&#39;, function() &#123;</span><br><span class="line">    that.chart.resize()</span><br><span class="line">  &#125;)</span><br><span class="line">  this.chart.setOption(&#123;</span><br><span class="line">    color: pieColors,</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">      trigger: &#39;item&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">    grid: &#123;</span><br><span class="line">      left: 0,</span><br><span class="line">      right: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    legend: &#123;</span><br><span class="line">      bottom: 0,</span><br><span class="line">      left: 5,</span><br><span class="line">      textStyle: &#123;</span><br><span class="line">        color: &#39;#fff&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      icon: &#39;circle&#39;,</span><br><span class="line">      itemHeight: 8,</span><br><span class="line">      itemGap: 20,</span><br><span class="line">      type: &#39;scroll&#39;,</span><br><span class="line">      pageIconColor: &#39;#fff&#39;,</span><br><span class="line">      pageTextStyle: &#123;</span><br><span class="line">        color: &#39;#fff&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      data: this.indusData.length &gt; 0 ? this.indusData.map(cu &#x3D;&gt; &#123; return cu.industryName &#125;) : []</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; title相对饼图居中</span><br><span class="line">    title: [&#123;</span><br><span class="line">      text: &#39;&#123;name|总&#125;\n&#39; + &#39;&#123;val|&#39; + this.totalEntCount + &#39;&#125;&#39;,</span><br><span class="line">      top: &#39;center&#39;,</span><br><span class="line">      left: &#39;50%&#39;,</span><br><span class="line">      textAlign: &#39;center&#39;,</span><br><span class="line">      textStyle: &#123;</span><br><span class="line">        rich: &#123;</span><br><span class="line">          name: &#123;</span><br><span class="line">            fontSize: 14,</span><br><span class="line">            fontWeight: &#39;normal&#39;,</span><br><span class="line">            color: &#39;#fff&#39;,</span><br><span class="line">            padding: [5, 0]</span><br><span class="line">          &#125;,</span><br><span class="line">          val: &#123;</span><br><span class="line">            fontSize: 20,</span><br><span class="line">            fontWeight: &#39;bold&#39;,</span><br><span class="line">            color: &#39;#fff&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    series: [</span><br><span class="line">      &#123;</span><br><span class="line">        type: &#39;pie&#39;,</span><br><span class="line">        zlevel: 2,</span><br><span class="line">        silent: true,</span><br><span class="line">        radius: [&#39;80%&#39;, &#39;81%&#39;],</span><br><span class="line">        startAngle: 90,</span><br><span class="line">        hoverAnimation: false,</span><br><span class="line">        color: &#39;rgba(216, 216, 216, .4)&#39;,</span><br><span class="line">        label: &#123;</span><br><span class="line">          normal: &#123;</span><br><span class="line">            show: false</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        labelLine: &#123;</span><br><span class="line">          normal: &#123;</span><br><span class="line">            show: false</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        data: this.pieCircle()</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        name: &#39;规上异常企业按行业分布&#39;,</span><br><span class="line">        type: &#39;pie&#39;,</span><br><span class="line">        radius: [&#39;50%&#39;, &#39;70%&#39;],</span><br><span class="line">        &#x2F;&#x2F;   roseType: &#39;radius&#39;,</span><br><span class="line">        label: &#123;</span><br><span class="line">          show: false</span><br><span class="line">        &#125;,</span><br><span class="line">        emphasis: &#123;</span><br><span class="line">          label: &#123;</span><br><span class="line">            show: false</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        data: this.indusData.length &gt; 0 ? this.indusData.map(cu &#x3D;&gt; &#123; return &#123; value: cu.exceptionEntCount * 1, name: cu.industryName &#125; &#125;) : []</span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; 开始转圈</span><br><span class="line">  this.startTimer()</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 圈圈数据</span><br><span class="line">pieCircle() &#123;</span><br><span class="line">  const dataArr &#x3D; []</span><br><span class="line">  for (var i &#x3D; 0; i &lt; 16; i++) &#123;</span><br><span class="line">    if (i % 4 &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      dataArr.push(&#123;</span><br><span class="line">        name: (i + 1).toString(),</span><br><span class="line">        value: 50,</span><br><span class="line">        itemStyle: &#123;</span><br><span class="line">          normal: &#123;</span><br><span class="line">            borderWidth: 0,</span><br><span class="line">            borderColor: &#39;rgba(0,0,0,0)&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else if (i % 4 &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">      dataArr.push(&#123;</span><br><span class="line">        name: (i + 1).toString(),</span><br><span class="line">        value: 2,</span><br><span class="line">        itemStyle: &#123;</span><br><span class="line">          normal: &#123;</span><br><span class="line">            color: &#39;rgba(88,142,197,0)&#39;,</span><br><span class="line">            borderWidth: 0,</span><br><span class="line">            borderColor: &#39;rgba(0,0,0,0)&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else if (i % 4 &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">      dataArr.push(&#123;</span><br><span class="line">        name: (i + 1).toString(),</span><br><span class="line">        value: 20,</span><br><span class="line">        itemStyle: &#123;</span><br><span class="line">          normal: &#123;</span><br><span class="line">            borderWidth: 0,</span><br><span class="line">            borderColor: &#39;rgba(0,0,0,0)&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      dataArr.push(&#123;</span><br><span class="line">        name: (i + 1).toString(),</span><br><span class="line">        value: 2,</span><br><span class="line">        itemStyle: &#123;</span><br><span class="line">          normal: &#123;</span><br><span class="line">            color: &#39;rgba(88,142,197,0)&#39;,</span><br><span class="line">            borderWidth: 0,</span><br><span class="line">            borderColor: &#39;rgba(0,0,0,0)&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return dataArr</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 开始转圈</span><br><span class="line">startTimer() &#123;</span><br><span class="line">  if (this.chart) &#123;</span><br><span class="line">    const pieAnaimationOption &#x3D; this.chart.getOption()</span><br><span class="line">    this.timer &amp;&amp; clearInterval(this.timer)</span><br><span class="line">    this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">      pieAnaimationOption.series[0].startAngle &#x3D; pieAnaimationOption.series[0].startAngle - 1</span><br><span class="line">      this.chart.setOption(pieAnaimationOption, true)</span><br><span class="line">    &#125;, 100)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 停止转圈</span><br><span class="line">stopTimer() &#123;</span><br><span class="line">  this.timer &amp;&amp; clearInterval(this.timer)</span><br><span class="line">  this.timer &#x3D; null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="悬浮框提示动画"><a href="#悬浮框提示动画" class="headerlink" title="悬浮框提示动画"></a>悬浮框提示动画</h1><p><img src="https://i.loli.net/2020/12/31/7taiulOD1wIjsKe.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;abnormalLineEchart&quot; class&#x3D;&quot;common-chart-pages&quot; @mouseenter&#x3D;&quot;mouseEnter&quot; @mouseleave&#x3D;&quot;animateToolTip&quot;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取数据</span><br><span class="line">getAbnormalLine()&#123;</span><br><span class="line">  this.lineData &#x3D; &#123;</span><br><span class="line">    electricityDataList:[</span><br><span class="line">      &#123;dataYear: 2019, dataMonth: 12, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 1, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 2, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 3, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 4, entCount: 770&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 5, entCount: 441&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 6, entCount: 521&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 7, entCount: 1352&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 8, entCount: 552&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 9, entCount: 634&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 10, entCount: 664&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 11, entCount: 0&#125;</span><br><span class="line">    ],</span><br><span class="line">    saleDataList:[</span><br><span class="line">      &#123;dataYear: 2019, dataMonth: 12, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 1, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 2, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 3, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 4, entCount: 1089&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 5, entCount: 1001&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 6, entCount: 855&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 7, entCount: 836&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 8, entCount: 859&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 9, entCount: 880&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 10, entCount: 900&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 11, entCount: 0&#125;</span><br><span class="line">    ],</span><br><span class="line">    taxElectricityRatioDataList:[</span><br><span class="line">      &#123;dataYear: 2019, dataMonth: 12, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 1, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 2, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 3, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 4, entCount: 443&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 5, entCount: 666&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 6, entCount: 509&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 7, entCount: 418&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 8, entCount: 428&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 9, entCount: 434&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 10, entCount: 707&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 11, entCount: 0&#125;</span><br><span class="line">    ],</span><br><span class="line">    taxRevenueDataList:[</span><br><span class="line">      &#123;dataYear: 2019, dataMonth: 12, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 1, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 2, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 3, entCount: 0&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 4, entCount: 1410&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 5, entCount: 1352&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 6, entCount: 1355&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 7, entCount: 1323&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 8, entCount: 1241&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 9, entCount: 1248&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 10, entCount: 1230&#125;,</span><br><span class="line">      &#123;dataYear: 2020, dataMonth: 11, entCount: 0&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; X轴坐标</span><br><span class="line">  let xData &#x3D; []</span><br><span class="line">  for (const item in this.lineData) &#123;</span><br><span class="line">    if (this.lineData[item] &amp;&amp; this.lineData[item].length &gt; 0) &#123;</span><br><span class="line">      xData &#x3D; this.lineData[item].map(cu &#x3D;&gt; &#123;</span><br><span class="line">        return cu.dataYear + &#39;.&#39; + (cu.dataMonth &lt; 10 ? &#39;0&#39; + cu.dataMonth : cu.dataMonth)</span><br><span class="line">      &#125;)</span><br><span class="line">      break</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.charts &#x3D; echarts.init(document.getElementById(&#39;indusPieEchart&#39;))</span><br><span class="line">  let that &#x3D; this</span><br><span class="line">  window.addEventListener(&#39;resize&#39;, function() &#123;</span><br><span class="line">    that.charts.resize()</span><br><span class="line">  &#125;)</span><br><span class="line">  this.charts.setOption(&#123;</span><br><span class="line">    color: [&#39;#FF6A32&#39;, &#39;#FFC911&#39;, &#39;#1D62FF&#39;, &#39;#11E6FF&#39;],</span><br><span class="line">    legend: &#123;</span><br><span class="line">      right: 0,</span><br><span class="line">      top: 20,</span><br><span class="line">      textStyle: &#123;</span><br><span class="line">        color: &#39;#fff&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      icon: &#39;circle&#39;,</span><br><span class="line">      itemHeight: 8,</span><br><span class="line">      itemGap: 20,</span><br><span class="line">      type: &#39;scroll&#39;,</span><br><span class="line">      pageIconColor: &#39;#fff&#39;,</span><br><span class="line">      pageTextStyle: &#123;</span><br><span class="line">        color: &#39;#fff&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    grid: &#123;</span><br><span class="line">      show: false,</span><br><span class="line">      top: 70</span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">      trigger: &#39;axis&#39;,</span><br><span class="line">      confine: true,</span><br><span class="line">      axisPointer: &#123;</span><br><span class="line">        type: &#39;line&#39;,</span><br><span class="line">        snap: true,</span><br><span class="line">        label: &#123;</span><br><span class="line">          padding: [5, 10],</span><br><span class="line">          backgroundColor: &#39;transparent&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        lineStyle: &#123;</span><br><span class="line">          color: &#39;#fff&#39;,</span><br><span class="line">          type: &#39;dashed&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis: &#123;</span><br><span class="line">      type: &#39;category&#39;,</span><br><span class="line">      splitLine: &#123;</span><br><span class="line">        show: true,</span><br><span class="line">        interval: 0,</span><br><span class="line">        lineStyle: &#123;</span><br><span class="line">          color: &#39;#878787&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      axisLine: &#123;</span><br><span class="line">        lineStyle: &#123;</span><br><span class="line">          color: &#39;#878787&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      axisTick: &#123;</span><br><span class="line">        show: false</span><br><span class="line">      &#125;,</span><br><span class="line">      boundaryGap: true,</span><br><span class="line">      axisLabel: &#123;</span><br><span class="line">        color: &#39;#fff&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      data: xData</span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;</span><br><span class="line">      type: &#39;value&#39;,</span><br><span class="line">      splitLine: &#123;</span><br><span class="line">        interval: 0,</span><br><span class="line">        lineStyle: &#123;</span><br><span class="line">          color: &#39;#878787&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      axisLabel: &#123;</span><br><span class="line">        show: false,</span><br><span class="line">        color: &#39;#fff&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      axisLine: &#123;</span><br><span class="line">        lineStyle: &#123;</span><br><span class="line">          color: &#39;#878787&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      axisTick: &#123;</span><br><span class="line">        show: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    series: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: &#39;用电异常&#39;,</span><br><span class="line">        type: &#39;line&#39;,</span><br><span class="line">        data: this.lineData.electricityDataList &amp;&amp; this.lineData.electricityDataList.length &gt; 0</span><br><span class="line">          ? this.lineData.electricityDataList.map(cu &#x3D;&gt; &#123; return cu.entCount &#125;) : [],</span><br><span class="line">        symbolSize: 6,</span><br><span class="line">        symbol: &#39;circle&#39;,</span><br><span class="line">        lineStyle: &#123;</span><br><span class="line">          width: 3</span><br><span class="line">        &#125;,</span><br><span class="line">        label: &#123;</span><br><span class="line">          show: false,</span><br><span class="line">          position: &#39;top&#39;,</span><br><span class="line">          color: &#39;#FFF&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        areaStyle: &#123;</span><br><span class="line">          color: &#39;#FF6A32&#39;,</span><br><span class="line">          opacity: 0.1</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: &#39;税收异常&#39;,</span><br><span class="line">        type: &#39;line&#39;,</span><br><span class="line">        data: this.lineData.taxRevenueDataList &amp;&amp; this.lineData.taxRevenueDataList.length &gt; 0</span><br><span class="line">          ? this.lineData.taxRevenueDataList.map(cu &#x3D;&gt; &#123; return cu.entCount &#125;) : [],</span><br><span class="line">        symbolSize: 6,</span><br><span class="line">        symbol: &#39;circle&#39;,</span><br><span class="line">        lineStyle: &#123;</span><br><span class="line">          width: 3</span><br><span class="line">        &#125;,</span><br><span class="line">        label: &#123;</span><br><span class="line">          show: false,</span><br><span class="line">          position: &#39;top&#39;,</span><br><span class="line">          color: &#39;#FFF&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        areaStyle: &#123;</span><br><span class="line">          color: &#39;#FFC911&#39;,</span><br><span class="line">          opacity: 0.1</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: &#39;销售异常&#39;,</span><br><span class="line">        type: &#39;line&#39;,</span><br><span class="line">        data: this.lineData.saleDataList &amp;&amp; this.lineData.saleDataList.length &gt; 0</span><br><span class="line">          ? this.lineData.saleDataList.map(cu &#x3D;&gt; &#123; return cu.entCount &#125;) : [],</span><br><span class="line">        symbolSize: 6,</span><br><span class="line">        symbol: &#39;circle&#39;,</span><br><span class="line">        lineStyle: &#123;</span><br><span class="line">          width: 3</span><br><span class="line">        &#125;,</span><br><span class="line">        label: &#123;</span><br><span class="line">          show: false,</span><br><span class="line">          position: &#39;top&#39;,</span><br><span class="line">          color: &#39;#FFF&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        areaStyle: &#123;</span><br><span class="line">          color: &#39;#11E6FF&#39;,</span><br><span class="line">          opacity: 0.1</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: &#39;税电比异常&#39;,</span><br><span class="line">        type: &#39;line&#39;,</span><br><span class="line">        data: this.lineData.taxElectricityRatioDataList &amp;&amp; this.lineData.taxElectricityRatioDataList.length &gt; 0</span><br><span class="line">          ? this.lineData.taxElectricityRatioDataList.map(cu &#x3D;&gt; &#123; return cu.entCount &#125;) : [],</span><br><span class="line">        symbolSize: 6,</span><br><span class="line">        symbol: &#39;circle&#39;,</span><br><span class="line">        lineStyle: &#123;</span><br><span class="line">          width: 3</span><br><span class="line">        &#125;,</span><br><span class="line">        label: &#123;</span><br><span class="line">          show: false,</span><br><span class="line">          position: &#39;top&#39;,</span><br><span class="line">          color: &#39;#FFF&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        areaStyle: &#123;</span><br><span class="line">          color: &#39;#1D62FF&#39;,</span><br><span class="line">          opacity: 0.1</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; 添加悬浮框</span><br><span class="line">  if (this.charts) &#123;</span><br><span class="line">    this.animateToolTip()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 添加悬浮框</span><br><span class="line">animateToolTip () &#123;</span><br><span class="line">  let startNum &#x3D; 0</span><br><span class="line">  this.timer &amp;&amp; clearInterval(this.timer)</span><br><span class="line">  this.timer &#x3D; null</span><br><span class="line">  this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里的12是指数据的长度</span><br><span class="line">    if (startNum &gt;&#x3D; 12) &#123;</span><br><span class="line">      startNum &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 显示提示框</span><br><span class="line">    this.charts.dispatchAction(&#123;</span><br><span class="line">      type: &#39;showTip&#39;,</span><br><span class="line">      seriesIndex: 1, &#x2F;&#x2F; series有4个，可取值0 1 2 3</span><br><span class="line">      dataIndex: startNum</span><br><span class="line">    &#125;)</span><br><span class="line">    startNum++</span><br><span class="line">  &#125;, 2000)</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 鼠标移入清空动画</span><br><span class="line">mouseEnter () &#123;</span><br><span class="line">  this.timer &amp;&amp; clearInterval(this.timer)</span><br><span class="line">  this.timer &#x3D; null</span><br><span class="line">  this.charts.dispatchAction(&#123;</span><br><span class="line">    type: &#39;hideTip&#39;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="饼状图高亮动画"><a href="#饼状图高亮动画" class="headerlink" title="饼状图高亮动画"></a>饼状图高亮动画</h1><p><img src="https://i.loli.net/2020/12/31/BsUPovaxCAXQfuw.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;abnormalPieEchart&quot; class&#x3D;&quot;common-chart-pages&quot; @mouseenter&#x3D;&quot;mouseEnter&quot; @mouseleave&#x3D;&quot;animateHighLight&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取饼状图数据</span><br><span class="line">getData()&#123;</span><br><span class="line">  this.abnormalData&#x3D;&#123;</span><br><span class="line">    electricityCount: 664,</span><br><span class="line">    saleCount: 900,</span><br><span class="line">    taxElectricityRatioCount: 707,</span><br><span class="line">    taxRevenueCount: 1230,</span><br><span class="line">    totalCount: 3501</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.chart &#x3D; echarts.init(document.getElementById(&#39;indusPieEchart&#39;))</span><br><span class="line">  let that &#x3D; this</span><br><span class="line">  window.addEventListener(&#39;resize&#39;, function() &#123;</span><br><span class="line">    that.chart.resize()</span><br><span class="line">  &#125;)</span><br><span class="line">  this.chart.setOption(&#123;</span><br><span class="line">    color: [&#39;#FF6A32&#39;, &#39;#FFC911&#39;, &#39;#1D62FF&#39;, &#39;#11E6FF&#39;],</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">      trigger: &#39;item&#39;,</span><br><span class="line">      confine: true,</span><br><span class="line">      formatter: (param) &#x3D;&gt; &#123;</span><br><span class="line">        return param.seriesName + &#39;&lt;br&#x2F;&gt;&#39; + param.marker + &#39; &#39; + param.name +</span><br><span class="line">        &#39;&lt;div style&#x3D;&quot;margin:0 0 0 20px;padding:0;&quot;&gt;&#39; + param.value + &#39;家 占比&#39; + param.percent + &#39;%&#39; + &#39;&lt;&#x2F;div&gt;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    legend: &#123;</span><br><span class="line">      orient: &#39;vertical&#39;,</span><br><span class="line">      right: 0,</span><br><span class="line">      textStyle: &#123;</span><br><span class="line">        color: &#39;#fff&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      formatter: (name) &#x3D;&gt; &#123;</span><br><span class="line">        let num &#x3D; 0</span><br><span class="line">        const that &#x3D; this</span><br><span class="line">        if (name &#x3D;&#x3D;&#x3D; &#39;用电异常&#39;) &#123;</span><br><span class="line">          num &#x3D; that.abnormalData.electricityCount</span><br><span class="line">        &#125;</span><br><span class="line">        if (name &#x3D;&#x3D;&#x3D; &#39;税收异常&#39;) &#123;</span><br><span class="line">          num &#x3D; that.abnormalData.taxRevenueCount</span><br><span class="line">        &#125;</span><br><span class="line">        if (name &#x3D;&#x3D;&#x3D; &#39;销售异常&#39;) &#123;</span><br><span class="line">          num &#x3D; that.abnormalData.saleCount</span><br><span class="line">        &#125;</span><br><span class="line">        if (name &#x3D;&#x3D;&#x3D; &#39;税电比异常&#39;) &#123;</span><br><span class="line">          num &#x3D; that.abnormalData.taxElectricityRatioCount</span><br><span class="line">        &#125;</span><br><span class="line">        return name + &#39; &#39; + num + &#39;家&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    grid: &#123;</span><br><span class="line">      bottom: 10,</span><br><span class="line">      left: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    title: [&#123;</span><br><span class="line">      text: &#39;&#123;name|总&#125;\n&#39; + &#39;&#123;val|&#39; + this.abnormalData.totalCount + &#39;&#125;&#39;,</span><br><span class="line">      top: &#39;center&#39;,</span><br><span class="line">      left: &#39;30%&#39;,</span><br><span class="line">      textAlign: &#39;center&#39;,</span><br><span class="line">      textStyle: &#123;</span><br><span class="line">        rich: &#123;</span><br><span class="line">          name: &#123;</span><br><span class="line">            fontSize: 14,</span><br><span class="line">            fontWeight: &#39;normal&#39;,</span><br><span class="line">            color: &#39;#fff&#39;,</span><br><span class="line">            padding: [5, 0]</span><br><span class="line">          &#125;,</span><br><span class="line">          val: &#123;</span><br><span class="line">            fontSize: 20,</span><br><span class="line">            fontWeight: &#39;bold&#39;,</span><br><span class="line">            color: &#39;#fff&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    series: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: &#39;规上异常企业分布&#39;,</span><br><span class="line">        type: &#39;pie&#39;,</span><br><span class="line">        radius: [&#39;40%&#39;, &#39;60%&#39;],</span><br><span class="line">        center: [&#39;30%&#39;, &#39;50%&#39;],</span><br><span class="line">        avoidLabelOverlap: true,</span><br><span class="line">        label: &#123;</span><br><span class="line">          show: false,</span><br><span class="line">          formatter: (params) &#x3D;&gt; &#123;</span><br><span class="line">            return params.data.name + &#39;：&#39; + &#39;\n&#39; + params.percent + &#39;%&#39;</span><br><span class="line">          &#125;,</span><br><span class="line">          color: &#39;#fff&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        emphasis: &#123;</span><br><span class="line">          label: &#123;</span><br><span class="line">            show: false,</span><br><span class="line">            fontWeight: &#39;bold&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        labelLine: &#123;</span><br><span class="line">          show: false,</span><br><span class="line">          lineStyle: &#123;</span><br><span class="line">            color: &#39;#fff&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        data: [</span><br><span class="line">          &#123;</span><br><span class="line">            value: this.abnormalData.electricityCount,</span><br><span class="line">            name: &#39;用电异常&#39;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            value: this.abnormalData.taxRevenueCount,</span><br><span class="line">            name: &#39;税收异常&#39;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            value: this.abnormalData.saleCount,</span><br><span class="line">            name: &#39;销售异常&#39;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            value: this.abnormalData.taxElectricityRatioCount,</span><br><span class="line">            name: &#39;税电比异常&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; 高亮并显示悬浮框</span><br><span class="line">  if (this.chart) &#123;</span><br><span class="line">    this.animateHighLight()</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 高亮并显示悬浮框</span><br><span class="line">    animateHighLight () &#123;</span><br><span class="line">      let startNum &#x3D; -1</span><br><span class="line">      this.timer &amp;&amp; clearInterval(this.timer)</span><br><span class="line">      this.timer &#x3D; null</span><br><span class="line">      this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">        this.chart.dispatchAction(&#123;</span><br><span class="line">          type: &#39;downplay&#39;,</span><br><span class="line">          seriesIndex: 0, &#x2F;&#x2F; 里层的圆形</span><br><span class="line">          dataIndex: startNum</span><br><span class="line">        &#125;)</span><br><span class="line">        if (startNum &gt;&#x3D; 3) &#123;</span><br><span class="line">          startNum &#x3D; -1</span><br><span class="line">        &#125;</span><br><span class="line">        startNum++</span><br><span class="line">        this.chart.dispatchAction(&#123;</span><br><span class="line">          type: &#39;highlight&#39;,</span><br><span class="line">          seriesIndex: 0,</span><br><span class="line">          dataIndex: startNum</span><br><span class="line">        &#125;)</span><br><span class="line">        this.chart.dispatchAction(&#123;</span><br><span class="line">          type: &#39;showTip&#39;,</span><br><span class="line">          seriesIndex: 0,</span><br><span class="line">          dataIndex: startNum</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;, 2000)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 鼠标移入清除动画</span><br><span class="line">    mouseEnter () &#123;</span><br><span class="line">      this.timer &amp;&amp; clearInterval(this.timer)</span><br><span class="line">      this.timer &#x3D; null</span><br><span class="line">      for (let i &#x3D; 0; i &lt;&#x3D; 3; i++) &#123;</span><br><span class="line">        this.chart.dispatchAction(&#123;</span><br><span class="line">          type: &#39;downplay&#39;,</span><br><span class="line">          seriesIndex: 0,</span><br><span class="line">          dataIndex: i</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      this.chart.dispatchAction(&#123;</span><br><span class="line">        type: &#39;hideTip&#39;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="legend名字过长处理"><a href="#legend名字过长处理" class="headerlink" title="legend名字过长处理"></a>legend名字过长处理</h1><p><img src="https://i.loli.net/2020/12/31/JOXLogvsunGNzqk.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">legend: &#123;</span><br><span class="line">  top: 5,</span><br><span class="line">  bottom: &#39;2%&#39;,</span><br><span class="line">  right: &#39;6%&#39;,</span><br><span class="line">  orient: &#39;vertical&#39;,</span><br><span class="line">  textStyle: &#123;</span><br><span class="line">    color: &#39;#fff&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  itemWidth: 15,</span><br><span class="line">  itemGap: 0,</span><br><span class="line">  type: &#39;scroll&#39;,</span><br><span class="line">  pageIconColor: &#39;#fff&#39;,</span><br><span class="line">  pageTextStyle: &#123;</span><br><span class="line">    color: &#39;#fff&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 开启tooltip</span><br><span class="line">  tooltip: &#123;</span><br><span class="line">    show: true</span><br><span class="line">  &#125;,</span><br><span class="line">  data: this.pieData.length &gt; 0 ? this.pieData.map(cu &#x3D;&gt; &#123; return cu.industryName &#125;) : [],</span><br><span class="line">  &#x2F;&#x2F; 名字截取</span><br><span class="line">  formatter: (name) &#x3D;&gt; &#123;</span><br><span class="line">    if (this.pieData &amp;&amp; this.pieData.length &gt; 0) &#123;</span><br><span class="line">      let temp &#x3D; this.pieData.filter(cu &#x3D;&gt; &#123; return cu.industryName &#x3D;&#x3D; name &#125;)</span><br><span class="line">      if (temp &amp;&amp; temp.length &gt; 0) &#123;</span><br><span class="line">        return &#39;\n\n&#39; + (name.length &gt; 10 ? name.slice(0, 10) + &#39;......&#39; : name) + &#39;\n&#39; + &#39;\n&#39; + temp[0].proportion + &#39;%&#39;  + &#39; &#39; + temp[0].num + &#39;家&#39;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="饼图外根据比例新增点状圈"><a href="#饼图外根据比例新增点状圈" class="headerlink" title="饼图外根据比例新增点状圈"></a>饼图外根据比例新增点状圈</h1><p><img src="https://s2.loli.net/2022/04/13/Jx8KOvpMTrcGY7L.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pieData &#x3D;[</span><br><span class="line">  &#123;name:&#39;男&#39;,value:100&#125;,</span><br><span class="line">  &#123;name:&#39;女&#39;,value:200&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">total &#x3D; pieData[0].value+pieData[1].value</span><br><span class="line"></span><br><span class="line">radio &#x3D; pieData[0].value&#x2F;total</span><br><span class="line"></span><br><span class="line">function Pie2() &#123;</span><br><span class="line">  let dataArr &#x3D; [];</span><br><span class="line">  for (var i &#x3D; 0; i &lt; total; i++) &#123;</span><br><span class="line">    if(i&#x2F;total&lt;radio)&#123;</span><br><span class="line">        if (i % 2 &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">            dataArr.push(&#123;</span><br><span class="line">                value: 1,</span><br><span class="line">                itemStyle: &#123;</span><br><span class="line">                    normal: &#123;</span><br><span class="line">                        color: &#39;#00AFFF&#39;,</span><br><span class="line">                        borderWidth: 0,</span><br><span class="line">                        borderColor: &#39;rgba(0,0,0,0)&#39;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dataArr.push(&#123;</span><br><span class="line">                value: 1,</span><br><span class="line">                itemStyle: &#123;</span><br><span class="line">                    normal: &#123;</span><br><span class="line">                        color: &#39;rgba(0,0,0,0)&#39;,</span><br><span class="line">                        borderWidth: 0,</span><br><span class="line">                        borderColor: &#39;rgba(0,0,0,0)&#39;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        dataArr.push(&#123;</span><br><span class="line">            value: 1,</span><br><span class="line">            itemStyle: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    color: &#39;rgba(0,0,0,0)&#39;,</span><br><span class="line">                    borderWidth: 0,</span><br><span class="line">                    borderColor: &#39;rgba(0,0,0,0)&#39;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return dataArr;</span><br><span class="line">&#125;</span><br><span class="line">option &#x3D; &#123;</span><br><span class="line">  tooltip: &#123;</span><br><span class="line">    trigger: &#39;item&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  legend: &#123;</span><br><span class="line">    top: &#39;5%&#39;,</span><br><span class="line">    left: &#39;center&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  series: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &#39;Access From&#39;,</span><br><span class="line">      type: &#39;pie&#39;,</span><br><span class="line">      radius: [&#39;78%&#39;, &#39;80%&#39;],</span><br><span class="line">      avoidLabelOverlap: false,</span><br><span class="line">      label: &#123;</span><br><span class="line">        show: false,</span><br><span class="line">        position: &#39;center&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      emphasis: &#123;</span><br><span class="line">        label: &#123;</span><br><span class="line">          show: true,</span><br><span class="line">          fontSize: &#39;40&#39;,</span><br><span class="line">          fontWeight: &#39;bold&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      labelLine: &#123;</span><br><span class="line">        show: false</span><br><span class="line">      &#125;,</span><br><span class="line">      data:Pie2()</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &#39;Access From&#39;,</span><br><span class="line">      type: &#39;pie&#39;,</span><br><span class="line">      radius: [&#39;40%&#39;, &#39;70%&#39;],</span><br><span class="line">      avoidLabelOverlap: false,</span><br><span class="line">      label: &#123;</span><br><span class="line">        show: false,</span><br><span class="line">        position: &#39;center&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      emphasis: &#123;</span><br><span class="line">        label: &#123;</span><br><span class="line">          show: true,</span><br><span class="line">          fontSize: &#39;40&#39;,</span><br><span class="line">          fontWeight: &#39;bold&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      labelLine: &#123;</span><br><span class="line">        show: false</span><br><span class="line">      &#125;,</span><br><span class="line">      data:pieData</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web</category>
        <category>Echarts</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title>Element</title>
    <url>/2019/03/21/Element/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/05/18/mqbKhCTkEvD5e4s.png" alt=""></p>
<a id="more"></a>
<p><a href="https://element.eleme.cn/#/zh-CN" target="_blank" rel="noopener"><strong>Element</strong></a>，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。这里记录了工作中遇到的常用操作。</p>
<h1 id="走马灯：多个幻灯片循环展示多个数据"><a href="#走马灯：多个幻灯片循环展示多个数据" class="headerlink" title="走马灯：多个幻灯片循环展示多个数据"></a>走马灯：多个幻灯片循环展示多个数据</h1><p><img src="https://i.loli.net/2020/05/21/DVHFEjAiTg8oYZl.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据：</span><br><span class="line">muIndexOption &#x3D; [</span><br><span class="line">    &#123;&quot;name&quot;:&quot;亩均税收&quot;,&quot;unit&quot;:&quot;万元&#x2F;亩&quot;,&quot;key&quot;:&quot;muPerTax&quot;,&quot;id&quot;:1,&quot;value&quot;:67.19,&quot;lastValue&quot;:12.46,&quot;ratio&quot;:&quot;439.25%&quot;,&quot;level&quot;:&quot;up&quot;&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;亩均销售&quot;,&quot;unit&quot;:&quot;万元&#x2F;亩&quot;,&quot;key&quot;:&quot;muPerSaleTax&quot;,&quot;id&quot;:11,&quot;value&quot;:2056.41,&quot;lastValue&quot;:325.79,&quot;ratio&quot;:&quot;531.21%&quot;,&quot;level&quot;:&quot;up&quot;&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;亩均增加值&quot;,&quot;unit&quot;:&quot;万元&#x2F;亩&quot;,&quot;key&quot;:&quot;muIndustryAddValue&quot;,&quot;id&quot;:2,&quot;value&quot;:588.45,&quot;lastValue&quot;:51.13,&quot;ratio&quot;:&quot;1050.89%&quot;,&quot;level&quot;:&quot;up&quot;&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;单位能耗增加值&quot;,&quot;unit&quot;:&quot;万元&#x2F;吨标煤&quot;,&quot;key&quot;:&quot;consumeAdd&quot;,&quot;id&quot;:3,&quot;value&quot;:37.84,&quot;lastValue&quot;:1.49,&quot;ratio&quot;:&quot;2439.60%&quot;,&quot;level&quot;:&quot;up&quot;&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;单位排放增加值&quot;,&quot;unit&quot;:&quot;万元&#x2F;吨&quot;,&quot;key&quot;:&quot;blowdownAdd&quot;,&quot;id&quot;:4,&quot;value&quot;:36623.81,&quot;lastValue&quot;:1038.88,&quot;ratio&quot;:&quot;3425.32%&quot;,&quot;level&quot;:&quot;up&quot;&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;全员劳动生产率&quot;,&quot;unit&quot;:&quot;万元&#x2F;人·年&quot;,&quot;key&quot;:&quot;allWorkRate&quot;,&quot;id&quot;:6,&quot;value&quot;:19.67,&quot;lastValue&quot;:19.83,&quot;ratio&quot;:&quot;0.81%&quot;,&quot;level&quot;:&quot;down&quot;&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;R&amp;D经费支出占比&quot;,&quot;unit&quot;:&quot;%&quot;,&quot;key&quot;:&quot;researchRate&quot;,&quot;id&quot;:5,&quot;value&quot;:2.96,&quot;lastValue&quot;:1.89,&quot;ratio&quot;:&quot;56.61%&quot;,&quot;level&quot;:&quot;up&quot;&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;优秀人才当量密度&quot;,&quot;unit&quot;:&quot;%&quot;,&quot;key&quot;:&quot;people&quot;,&quot;id&quot;:10,&quot;value&quot;:24.48,&quot;lastValue&quot;:29.81,&quot;ratio&quot;:&quot;17.88%&quot;,&quot;level&quot;:&quot;down&quot;&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;单位电耗税收&quot;,&quot;unit&quot;:&quot;万元&#x2F;万千瓦时&quot;,&quot;key&quot;:&quot;eleTax&quot;,&quot;id&quot;:12,&quot;value&quot;:0,&quot;lastValue&quot;:7.9,&quot;ratio&quot;:&quot;100.00%&quot;,&quot;level&quot;:&quot;down&quot;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>写法分析：</p>
<ol>
<li>图中只有2个幻灯片，所以 el-carousel-item 的循环是1,2即可，即 v-for=&#39; item in 2 &#39;；</li>
<li>每个幻灯片中有6个div块，样式一致，只是具体的数值不同，找到规律取对 muIndexOption 数组里面的数据即可；<br>数幻灯片第一笔数据：muIndexOption[6 * item-6]    数幻灯片第二笔数据：muIndexOption[6 * item-5]<br>数幻灯片第三笔数据：muIndexOption[6 * item-4]    数幻灯片第四笔数据：muIndexOption[6 * item-3]<br>数幻灯片第五笔数据：muIndexOption[6 * item-2]    数幻灯片第六笔数据：muIndexOption[6 * item-1]</li>
<li>最后一个幻灯片不确定可以展示几笔数据，如果只有一笔的话，那么就会因为取不到数据控制台报错，所以需要在每个展示数据的div块上写上 v-if=&#39; 6 * item- ? &lt; muIndexOption.length &#39;。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-carousel class&#x3D;&#39;visual-main-div&#39;&gt;</span><br><span class="line">    &lt;el-carousel-item v-for&#x3D;&quot;item in 2&quot; :key&#x3D;&quot;item&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&#39;muIndex-container&#39;&gt;</span><br><span class="line">            &lt;div class&#x3D;&#39;muIndex-carousel&#39;&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-name&#39;&gt;&lt;div&gt;&lt;&#x2F;div&gt;&#123;&#123;muIndexOption[6*item-6].name+&#39;(&#39;+muIndexOption[6*item-6].unit+&#39;)&#39;&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-value&#39;&gt;</span><br><span class="line">                    &lt;div&gt;&#123;&#123;muIndexOption[6*item-6].value&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div&gt;&#123;&#123;muIndexOption[6*item-6].ratio&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div&gt;</span><br><span class="line">                        &lt;i class&#x3D;&#39;iconfont&#39; :class&#x3D;&quot;muIndexOption[6*item-6].level&#x3D;&#x3D;&#39;equal&#39;?&#39;iconhengxian equal&#39;:(muIndexOption[6*item-6].level&#x3D;&#x3D;&#39;down&#39;?&#39;iconxiajiangjiantoux down&#39;:(muIndexOption[6*item-6].level&#x3D;&#x3D;&#39;up&#39;?&#39;iconshangshengjiantoux up&#39;:&#39;&#39;))&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-lastValue&#39;&gt;去年同期&#123;&#123;muIndexOption[6*item-6].lastValue+muIndexOption[6*item-6].unit&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&#39;muIndex-carousel&#39;&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-name&#39;&gt;&lt;div&gt;&lt;&#x2F;div&gt;&#123;&#123;muIndexOption[6*item-5].name+&#39;(&#39;+muIndexOption[6*item-5].unit+&#39;)&#39;&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-value&#39;&gt;</span><br><span class="line">                    &lt;div&gt;&#123;&#123;muIndexOption[6*item-5].value&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div&gt;&#123;&#123;muIndexOption[6*item-5].ratio&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div&gt;</span><br><span class="line">                        &lt;i class&#x3D;&#39;iconfont&#39; :class&#x3D;&quot;muIndexOption[6*item-5].level&#x3D;&#x3D;&#39;equal&#39;?&#39;iconhengxian equal&#39;:(muIndexOption[6*item-5].level&#x3D;&#x3D;&#39;down&#39;?&#39;iconxiajiangjiantoux down&#39;:(muIndexOption[6*item-5].level&#x3D;&#x3D;&#39;up&#39;?&#39;iconshangshengjiantoux up&#39;:&#39;&#39;))&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-lastValue&#39;&gt;去年同期&#123;&#123;muIndexOption[6*item-5].lastValue+muIndexOption[6*item-5].unit&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&#39;muIndex-carousel&#39; v-if&#x3D;&#39;6*item-4&lt;muIndexOption.length&#39;&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-name&#39;&gt;&lt;div&gt;&lt;&#x2F;div&gt;&#123;&#123;muIndexOption[6*item-4].name+&#39;(&#39;+muIndexOption[6*item-4].unit+&#39;)&#39;&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-value&#39;&gt;</span><br><span class="line">                    &lt;div&gt;&#123;&#123;muIndexOption[6*item-4].value&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div&gt;&#123;&#123;muIndexOption[6*item-4].ratio&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div&gt;</span><br><span class="line">                        &lt;i class&#x3D;&#39;iconfont&#39; :class&#x3D;&quot;muIndexOption[6*item-4].level&#x3D;&#x3D;&#39;equal&#39;?&#39;iconhengxian equal&#39;:(muIndexOption[6*item-4].level&#x3D;&#x3D;&#39;down&#39;?&#39;iconxiajiangjiantoux down&#39;:(muIndexOption[6*item-4].level&#x3D;&#x3D;&#39;up&#39;?&#39;iconshangshengjiantoux up&#39;:&#39;&#39;))&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-lastValue&#39;&gt;去年同期&#123;&#123;muIndexOption[6*item-4].lastValue+muIndexOption[6*item-4].unit&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&#39;muIndex-carousel&#39; v-if&#x3D;&#39;6*item-3&lt;muIndexOption.length&#39;&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-name&#39;&gt;&lt;div&gt;&lt;&#x2F;div&gt;&#123;&#123;muIndexOption[6*item-3].name+&#39;(&#39;+muIndexOption[6*item-3].unit+&#39;)&#39;&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-value&#39;&gt;</span><br><span class="line">                    &lt;div&gt;&#123;&#123;muIndexOption[6*item-3].value&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div&gt;&#123;&#123;muIndexOption[6*item-3].ratio&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div&gt;</span><br><span class="line">                        &lt;i class&#x3D;&#39;iconfont&#39; :class&#x3D;&quot;muIndexOption[6*item-3].level&#x3D;&#x3D;&#39;equal&#39;?&#39;iconhengxian equal&#39;:(muIndexOption[6*item-3].level&#x3D;&#x3D;&#39;down&#39;?&#39;iconxiajiangjiantoux down&#39;:(muIndexOption[6*item-3].level&#x3D;&#x3D;&#39;up&#39;?&#39;iconshangshengjiantoux up&#39;:&#39;&#39;))&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-lastValue&#39;&gt;去年同期&#123;&#123;muIndexOption[6*item-3].lastValue+muIndexOption[6*item-3].unit&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&#39;muIndex-carousel&#39; v-if&#x3D;&#39;6*item-2&lt;muIndexOption.length&#39;&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-name&#39;&gt;&lt;div&gt;&lt;&#x2F;div&gt;&#123;&#123;muIndexOption[6*item-2].name+&#39;(&#39;+muIndexOption[6*item-2].unit+&#39;)&#39;&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-value&#39;&gt;</span><br><span class="line">                    &lt;div&gt;&#123;&#123;muIndexOption[6*item-2].value&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div&gt;&#123;&#123;muIndexOption[6*item-2].ratio&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div&gt;</span><br><span class="line">                        &lt;i class&#x3D;&#39;iconfont&#39; :class&#x3D;&quot;muIndexOption[6*item-2].level&#x3D;&#x3D;&#39;equal&#39;?&#39;iconhengxian equal&#39;:(muIndexOption[6*item-2].level&#x3D;&#x3D;&#39;down&#39;?&#39;iconxiajiangjiantoux down&#39;:(muIndexOption[6*item-2].level&#x3D;&#x3D;&#39;up&#39;?&#39;iconshangshengjiantoux up&#39;:&#39;&#39;))&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-lastValue&#39;&gt;去年同期&#123;&#123;muIndexOption[6*item-2].lastValue+muIndexOption[6*item-2].unit&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&#39;muIndex-carousel&#39; v-if&#x3D;&#39;6*item-1&lt;muIndexOption.length&#39;&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-name&#39;&gt;&lt;div&gt;&lt;&#x2F;div&gt;&#123;&#123;muIndexOption[6*item-1].name+&#39;(&#39;+muIndexOption[6*item-1].unit+&#39;)&#39;&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-value&#39;&gt;</span><br><span class="line">                    &lt;div&gt;&#123;&#123;muIndexOption[6*item-1].value&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div&gt;&#123;&#123;muIndexOption[6*item-1].ratio&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div&gt;</span><br><span class="line">                        &lt;i class&#x3D;&#39;iconfont&#39; :class&#x3D;&quot;muIndexOption[6*item-1].level&#x3D;&#x3D;&#39;equal&#39;?&#39;iconhengxian equal&#39;:(muIndexOption[6*item-1].level&#x3D;&#x3D;&#39;down&#39;?&#39;iconxiajiangjiantoux down&#39;:(muIndexOption[6*item-1].level&#x3D;&#x3D;&#39;up&#39;?&#39;iconshangshengjiantoux up&#39;:&#39;&#39;))&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;munindex-lastValue&#39;&gt;去年同期&#123;&#123;muIndexOption[6*item-1].lastValue+muIndexOption[6*item-1].unit&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;el-carousel-item&gt;</span><br><span class="line">&lt;&#x2F;el-carousel&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="自动搜索"><a href="#自动搜索" class="headerlink" title="自动搜索"></a>自动搜索</h1><p><img src="https://i.loli.net/2020/05/21/W9qsDxy3PC2oj75.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;el-autocomplete class&#x3D;&quot;inline-input&quot; v-model&#x3D;&quot;ruleForm.lessor&quot; placeholder&#x3D;&quot;请输入出租方&quot; value-key&#x3D;&quot;entName&quot;</span><br><span class="line">    :fetch-suggestions&#x3D;&quot;querySearch&quot; :trigger-on-focus&#x3D;&quot;false&quot; @select&#x3D;&quot;handleSelect&quot; &gt;&lt;&#x2F;el-autocomplete&gt;</span><br><span class="line">&#x2F;&#x2F;模糊查询</span><br><span class="line">querySearch(query,cb)&#123;</span><br><span class="line">    if (query !&#x3D; &quot;&quot;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用接口获取数据</span><br><span class="line">        selectEntName(&#123; entName: query &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">            if (res.code &#x3D;&#x3D; &quot;0000&quot;) &#123;</span><br><span class="line">                cb(res.data);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.$message.error(res.msg || &quot;获取企业数据失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">handleSelect(item)&#123;</span><br><span class="line">    this.ruleForm.lessorCreditCode &#x3D; item.creditCode;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="级联选择器"><a href="#级联选择器" class="headerlink" title="级联选择器"></a>级联选择器</h1><h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2><p><img src="https://i.loli.net/2020/05/21/qsevyQuzrgp9SGH.gif" alt="lazyout.gif"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    let that &#x3D; this;</span><br><span class="line">    return &#123;</span><br><span class="line">        &#x2F;&#x2F;1.设置在props设置lazy和lazyLoad属性</span><br><span class="line">        addProps: &#123;</span><br><span class="line">            lazy: true,</span><br><span class="line">            value: &quot;code&quot;,</span><br><span class="line">            children: &quot;childList&quot;,</span><br><span class="line">            label: &quot;name&quot;,</span><br><span class="line">            lazyLoad(node, resolve) &#123;</span><br><span class="line">                const &#123; level &#125; &#x3D; node;</span><br><span class="line">                if (level &#x3D;&#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;一级</span><br><span class="line">                    that.queryRegions(0, resolve) </span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    that.queryRegions(node, resolve);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br><span class="line">methods:()&#123;</span><br><span class="line">    &#x2F;&#x2F; 调用后台接口，根据父级的code获取子集，若是第一级parentCode传0 </span><br><span class="line">    queryRegions(node, resolve) &#123;</span><br><span class="line">        let parentCode &#x3D; node ? node.data.code : 0;</span><br><span class="line">        queryRegions(&#123; parentCode &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">            let &#123; code, data &#125; &#x3D; res.data;</span><br><span class="line">            if (code &#x3D;&#x3D; &quot;000000&quot; &amp;&amp; data) &#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve([]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单选模式加动态加载"><a href="#单选模式加动态加载" class="headerlink" title="单选模式加动态加载"></a>单选模式加动态加载</h2><p><img src="https://i.loli.net/2020/10/23/MWehUDKJuIi3Yf7.gif" alt="singnal-lazyout.gif"><br>　　级联选择器在动态加载的情况下，只能选择最后一级的数据，但是现在需求是任一级数据都可以选择，所以需要加上单选模式，但是在单选模式加动态加载模式下，选择单选按钮可以选中数据但不会动态加载下一级数据，点击当前数据和&gt;箭头可以动态加载下一级数据但是不能选中当前数据，为了解决这个问题，做出以下修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-cascader </span><br><span class="line">    v-model&#x3D;&quot;groupItem.areaCode&quot; </span><br><span class="line">    :show-all-levels&#x3D;&quot;false&quot; </span><br><span class="line">    :props&#x3D;&quot;addProps&quot; </span><br><span class="line">    clearable </span><br><span class="line">    @visible-change&#x3D;&quot;elCascaderOnlick&quot; </span><br><span class="line">    @expand-change&#x3D;&quot;elCascaderOnlick&quot;&gt;</span><br><span class="line">        &lt;template slot-scope&#x3D;&quot;&#123; node, data &#125;&quot;&gt;</span><br><span class="line">            &lt;span&gt;&#123;&#123; data.name &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;el-cascader&gt;</span><br><span class="line"></span><br><span class="line">addProps: &#123;</span><br><span class="line">    lazy: true,</span><br><span class="line">    value: &#39;code&#39;,</span><br><span class="line">    children: &#39;childList&#39;,</span><br><span class="line">    emitPath: false,</span><br><span class="line">    label: &#39;code&#39;,</span><br><span class="line">    checkStrictly: true,</span><br><span class="line">    lazyLoad(node, resolve) &#123;</span><br><span class="line">        const &#123; level &#125; &#x3D; node</span><br><span class="line">        if (level &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 一级</span><br><span class="line">            that.queryRegions(0, resolve)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            that.queryRegions(node, resolve)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态加载行政代码</span><br><span class="line">queryRegions(node, resolve) &#123;</span><br><span class="line">    let parentCode &#x3D; node ? node.data.code : 0</span><br><span class="line">    queryRegions(&#123; parentCode &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">        let &#123; code, data &#125; &#x3D; res.data</span><br><span class="line">        if (code &#x3D;&#x3D; &#39;000000&#39; &amp;&amp; data) &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            resolve([])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 解决 单选 + 动态加载 存在的问题</span><br><span class="line">elCascaderOnlick(leafOnly) &#123;</span><br><span class="line">    let that &#x3D; this</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        &#x2F;&#x2F; 点击当前数据，触发前一个元素（单选按钮）的点击事件</span><br><span class="line">        document.querySelectorAll(&#39;.el-cascader-node__label&#39;).forEach(el &#x3D;&gt; &#123;</span><br><span class="line">            el.onclick &#x3D; function() &#123;</span><br><span class="line">                this.previousElementSibling.click()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; 点击单选按钮，触发下一个元素（当前数据label）的点击事件</span><br><span class="line">        document.querySelectorAll(&#39;.el-radio&#39;).forEach(el &#x3D;&gt; &#123;</span><br><span class="line">            el.onclick &#x3D; function() &#123;</span><br><span class="line">                this.nextElementSibling.click()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, 100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h1><h2 id="限制上传图片的宽高"><a href="#限制上传图片的宽高" class="headerlink" title="限制上传图片的宽高"></a>限制上传图片的宽高</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 限制图片上传尺寸</span><br><span class="line"> * 图片宽大于550像素，高大于350像素，高在宽的1&#x2F;2到3&#x2F;4范围内</span><br><span class="line"> * 入参 that 是将 vue 对象绑定的element-ui传入</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function ruleImgSize(that,file)&#123;</span><br><span class="line">  let supportFormat &#x3D; [&#39;jpg&#39;, &#39;jpeg&#39;, &#39;png&#39;, &#39;gif&#39;]</span><br><span class="line">  if (supportFormat.indexOf(file.type.split(&#39;&#x2F;&#39;)[1]) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">    that.$message.warning(&#39;上传文件的格式不合符，请重新上传！&#39;)</span><br><span class="line">    return false &#x2F;&#x2F;必须加上return false; 才能阻止上传</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 图片文件大小限制，限制宽高</span><br><span class="line">    let imgWidth &#x3D; &#39;&#39;</span><br><span class="line">    let imgHight &#x3D; &#39;&#39;</span><br><span class="line">    const isSize &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">      let _URL &#x3D; window.URL || window.webkitURL</span><br><span class="line">      let img &#x3D; new Image()</span><br><span class="line">      img.onload &#x3D; function() &#123;</span><br><span class="line">        imgWidth &#x3D; img.width</span><br><span class="line">        imgHight &#x3D; img.height</span><br><span class="line">        let valid</span><br><span class="line">        if (imgWidth &lt; 550 || imgHight &lt; 350 || imgHight &gt; (3 * imgWidth) &#x2F; 4 || imgHight &lt; imgWidth &#x2F; 3) &#123;</span><br><span class="line">          valid &#x3D; false</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          valid &#x3D; true</span><br><span class="line">        &#125;</span><br><span class="line">        valid ? resolve() : reject()</span><br><span class="line">      &#125;</span><br><span class="line">      img.src &#x3D; _URL.createObjectURL(file)</span><br><span class="line">    &#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">      return file</span><br><span class="line">    &#125;, () &#x3D;&gt; &#123;</span><br><span class="line">      that.$message.warning(&#123; message: &#39;上传文件的图片大小不合符标准,图片宽大于550像素，高大于350像素，高在宽的1&#x2F;2到3&#x2F;4范围内。当前上传图片的宽高分别为：&#39; + imgWidth + &#39;像素和&#39; + imgHight + &#39;像素&#39;, btn: false &#125;)</span><br><span class="line">      return Promise.reject()</span><br><span class="line">    &#125;)</span><br><span class="line">    return isSize</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用：在el-upload上绑定before-upload事件</span><br><span class="line">imgBeforeUpload(file) &#123;</span><br><span class="line">    return ruleImgSize(this, file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h2 id="动态增减表单项"><a href="#动态增减表单项" class="headerlink" title="动态增减表单项"></a>动态增减表单项</h2><p><img src="https://i.loli.net/2020/11/24/5D3iJonGMRmckYw.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-form ref&#x3D;&quot;infoForm&quot; :model&#x3D;&quot;infoForm&quot; label-width&#x3D;&quot;180px&quot;  :rules&#x3D;&quot;infoRules&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;info-common&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;info-common-title&quot;&gt;企业用地数据&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;info-common-subtitle&quot;&gt;实际用地面积&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;info-common-body flx&quot;&gt;</span><br><span class="line">                &lt;el-form-item label&#x3D;&quot;实际用地面积（亩）&quot;&gt;</span><br><span class="line">                    &lt;el-input v-model&#x3D;&quot;actualLandArea&quot; placeholder&#x3D;&quot;请输入实际用地面积&quot; disabled&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                &lt;&#x2F;el-form-item&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;info-common-subtitle&quot;&gt;</span><br><span class="line">                土地证载面积</span><br><span class="line">                &lt;span class&#x3D;&quot;add&quot; @click&#x3D;&quot;addLand&quot;&gt;&lt;i class&#x3D;&quot;el-icon-plus&quot; &gt;&lt;&#x2F;i&gt;添加&lt;&#x2F;span&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;info-common-body&quot; v-if&#x3D;&quot;infoForm.landDataList &amp;&amp; infoForm.landDataList.length&gt;0&quot;&gt;</span><br><span class="line">                &lt;div v-for&#x3D;&quot;(item,index) in infoForm.landDataList&quot; :key&#x3D;&#39;index&#39; class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;item-title&quot;&gt;土地证载面积&#123;&#123;index+1&#125;&#125;&lt;i class&#x3D;&quot;el-icon-delete&quot; @click&#x3D;&quot;delLand(item)&quot;&gt;&lt;&#x2F;i&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;flx&quot;&gt;</span><br><span class="line">                        &lt;el-form-item</span><br><span class="line">                            label&#x3D;&quot;土地字号&quot;</span><br><span class="line">                            :prop&#x3D;&quot;&#39;landDataList.&#39; + index + &#39;.landNumber&#39;&quot;</span><br><span class="line">                            :key&#x3D;&quot;item.key+&#39;1&#39;&quot;</span><br><span class="line">                            :rules&#x3D;&quot;&#123;</span><br><span class="line">                                required: true, message: &#39;请输入土地字号&#39;, trigger: &#39;blur&#39;</span><br><span class="line">                            &#125;&quot;&gt;</span><br><span class="line">                            &lt;el-input placeholder&#x3D;&quot;请输入土地字号&quot; v-model&#x3D;&quot;item.landNumber&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                        &lt;el-form-item</span><br><span class="line">                            label&#x3D;&quot;土地使用权面积(平方米)&quot;</span><br><span class="line">                            :prop&#x3D;&quot;&#39;landDataList.&#39; + index + &#39;.landUseArea&#39;&quot;</span><br><span class="line">                            :key&#x3D;&quot;item.key+&#39;2&#39;&quot;</span><br><span class="line">                            :rules&#x3D;&quot;[&#123;</span><br><span class="line">                                required: true, message: &#39;请输入土地使用权面积&#39;, trigger: &#39;blur&#39;</span><br><span class="line">                            &#125;,&#123; pattern: &#x2F;^\d&#123;1,6&#125;$|^\d&#123;1,6&#125;[.]\d&#123;1,6&#125;$&#x2F;, message: &#96;必须为数字,整数最多6位，小数最多6位&#96;, trigger: &#39;blur&#39; &#125;]&quot;&gt;</span><br><span class="line">                            &lt;el-input placeholder&#x3D;&quot;请输入土地使用权面积&quot; v-model&#x3D;&quot;item.landUseArea&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                        &lt;el-form-item</span><br><span class="line">                            label&#x3D;&quot;土地使用权面积(亩)&quot;</span><br><span class="line">                            :prop&#x3D;&quot;&#39;landDataList.&#39; + index + &#39;.landUseAreaMu&#39;&quot;</span><br><span class="line">                            :key&#x3D;&quot;item.key+&#39;3&#39;&quot;&gt;</span><br><span class="line">                            &lt;el-input placeholder&#x3D;&quot;请输入土地使用权面积&quot; v-model&#x3D;&quot;item.landUseAreaMu&quot; disabled&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                        &lt;el-form-item</span><br><span class="line">                            label&#x3D;&quot;不动产权证号&quot;</span><br><span class="line">                            :prop&#x3D;&quot;&#39;landDataList.&#39; + index + &#39;.realPropertyNumber&#39;&quot;</span><br><span class="line">                            :key&#x3D;&quot;item.key+&#39;4&#39;&quot;</span><br><span class="line">                            :rules&#x3D;&quot;&#123;</span><br><span class="line">                                required: true, message: &#39;请输入不动产权证号&#39;, trigger: &#39;blur&#39;</span><br><span class="line">                            &#125;&quot;&gt;</span><br><span class="line">                            &lt;el-input placeholder&#x3D;&quot;请输入不动产权证号&quot; v-model&#x3D;&quot;item.realPropertyNumber&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                        &lt;el-form-item</span><br><span class="line">                            label&#x3D;&quot;供地日期&quot;</span><br><span class="line">                            :prop&#x3D;&quot;&#39;landDataList.&#39; + index + &#39;.landSupply&#39;&quot;</span><br><span class="line">                            :key&#x3D;&quot;item.key+&#39;5&#39;&quot;</span><br><span class="line">                            :rules&#x3D;&quot;&#123;</span><br><span class="line">                                required: true, message: &#39;请选择供地日期&#39;, trigger: &#39;blur&#39;</span><br><span class="line">                            &#125;&quot;&gt;</span><br><span class="line">                            &lt;el-date-picker v-model&#x3D;&quot;item.landSupply&quot; type&#x3D;&quot;date&quot; placeholder&#x3D;&quot;请选择供地日期&quot; value-format&#x3D;&#39;yyyy-MM-dd&#39;&gt;&lt;&#x2F;el-date-picker&gt;</span><br><span class="line">                        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;noData&quot; v-else&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;noData-img&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;el-form&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新增土地证载面积</span><br><span class="line">addLand() &#123;</span><br><span class="line">    this.infoForm.landDataList.push(&#123;</span><br><span class="line">        landNumber: null,</span><br><span class="line">        landUseArea: null,</span><br><span class="line">        landUseAreaMu: this.landUseArea ? (this.landUseArea * 0.0015).toFixed(6) : null,</span><br><span class="line">        realPropertyNumber: null,</span><br><span class="line">        landSupply: null,</span><br><span class="line">        key: Date.now()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 删除土地证载面积</span><br><span class="line">delLand(item) &#123;</span><br><span class="line">    var index &#x3D; this.infoForm.landDataList.indexOf(item)</span><br><span class="line">    if (index !&#x3D;&#x3D; -1) &#123;</span><br><span class="line">        this.infoForm.landDataList.splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="表单校验报错但不影响提交"><a href="#表单校验报错但不影响提交" class="headerlink" title="表单校验报错但不影响提交"></a>表单校验报错但不影响提交</h2><p>　　最近有个项目，在填写表单的厂房面积字段时，需要和出租方填写的登记用地面积总量进行比对，<strong>如果承租厂房面积大于出租方填写的登记用地面积总量，要给出错误提示，但是依然可以提交。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; areaOfInPlant-承租厂房面积 currentTotalLand-出租方填写的登记用地面积总量</span><br><span class="line">&lt;el-form&gt;</span><br><span class="line">    &lt;el-form-item label&#x3D;&quot;承租厂房面积(亩)&quot; prop&#x3D;&quot;areaOfInPlant&quot;&gt;</span><br><span class="line">        &lt;el-input v-model&#x3D;&quot;ruleForm.areaOfInPlant&quot; placeholder&#x3D;&quot;请输入承租厂房面积&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &#x2F;&#x2F; 在这里进行判断，给div加上el-form-item__error的class即可</span><br><span class="line">        &lt;div v-if&#x3D;&quot;ruleForm.areaOfInPlant&gt;currentTotalLand&quot; class&#x3D;&quot;el-form-item__error&quot;&gt;承租厂房面积大于出租方填写的登记用地面积总量&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;el-form-item&gt;</span><br><span class="line">&lt;&#x2F;el-form&gt;</span><br></pre></td></tr></table></figure>

<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h2 id="表格多选"><a href="#表格多选" class="headerlink" title="表格多选"></a>表格多选</h2><h3 id="默认选中某些多选框"><a href="#默认选中某些多选框" class="headerlink" title="默认选中某些多选框"></a>默认选中某些多选框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; tableData-表格所有数据 res-获取到的勾选的数据的id数组</span><br><span class="line">&#x2F;&#x2F; 先清空所有的勾选状态</span><br><span class="line">this.$refs.multipleTable.clearSelection()</span><br><span class="line">if (res &amp;&amp; res.length &gt; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; 过滤出勾选的表格数据</span><br><span class="line">    let temp &#x3D; tableData.filter(cu &#x3D;&gt; &#123; return res.indexOf(cu.id) !&#x3D; -1 &#125;)</span><br><span class="line">    if (temp &amp;&amp; temp.length &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认选中这些数据的多选框</span><br><span class="line">        temp.forEach(row &#x3D;&gt; &#123;</span><br><span class="line">            this.$refs.multipleTable.toggleRowSelection(row)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多选框disabled"><a href="#多选框disabled" class="headerlink" title="多选框disabled"></a>多选框disabled</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 多选框的列</span><br><span class="line">&lt;el-table-column type&#x3D;&quot;selection&quot;  width&#x3D;&quot;55&quot; :selectable&#x3D;&quot;selectable&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 多选框disabled是根据selectable函数的返回值确定的</span><br><span class="line">selectable(row, index) &#123;</span><br><span class="line">    &#x2F;&#x2F; editFlag true-非disabled状态，可勾选 false-disabled状态</span><br><span class="line">    return editFlag</span><br><span class="line">    &#x2F;&#x2F; 这里可以根据row和index限制某些行多选框disabled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>表格行多选框disabled只针对行多选框，表头的多选框不受限制；</li>
<li>表格行多选框disabled之后，表头的全选多选框就会忽略掉disabled的行，如果将表格的所有行多选框disabled之后，不管行多选框有没有选中，表头的全选多选框都会是勾选的状态；</li>
<li>为了解决 2 的问题，我们一般在行多选框disabled时，将表头多选框隐藏掉，行多选框非disabled时，将表头多选框显示出来，<strong>显示出来的时候一定要再次走一遍默认选中多选框的操作，否则的话还是会出现2的情况。</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 给表头加class</span><br><span class="line">&lt;el-table :data&#x3D;&quot;tableData&quot; ref&#x3D;&quot;multipleTable&quot; :header-cell-class-name&#x3D;&quot;cellClass&quot;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 表头多选框是否disabled</span><br><span class="line">cellClass(row) &#123;</span><br><span class="line">    if (row.columnIndex &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; editFlag true-非disabled状态，可勾选,这个时候要显示表头多选框，所以不给class false-disabled状态，不展示表头多选框</span><br><span class="line">        return editFlag ? &#39;&#39; : &#39;DisableSelection&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;deep&#x2F;.DisableSelection&#123;</span><br><span class="line">  .cell&#123;</span><br><span class="line">    display: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表格编辑"><a href="#表格编辑" class="headerlink" title="表格编辑"></a>表格编辑</h2><p><img src="https://i.loli.net/2021/11/23/foiAUlexzcsJYkZ.gif" alt=""><br>&emsp;&emsp;获取到表格数据后，for 循环给表格新增 edit 属性，通过该属性来判断单元格是展示输入框还是展示文字。<br><strong>注意：</strong>vue只会监听表格数据的row有没有发生变化，row里面具体某个数据发生改变 vue 监听不到，所以在修改 edit 的状态，需要使用 <code>this.$set(this.tableData, index, row)</code> 来重新渲染表格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML</span><br><span class="line">&lt;el-table-column label&#x3D;&quot;排序&quot; align&#x3D;&quot;center&quot; min-width&#x3D;&quot;130&quot;&gt;</span><br><span class="line">    &lt;template slot-scope&#x3D;&quot;&#123;row,$index&#125;&quot;&gt;</span><br><span class="line">        &lt;div v-if&#x3D;&quot;row.edit&quot;&gt;</span><br><span class="line">            &lt;el-input-number v-model&#x3D;&quot;row.sort&quot; size&#x3D;&quot;mini&quot; :min&#x3D;&quot;1&quot; :precision&#x3D;&quot;0&quot; &#x2F;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-button type&#x3D;&quot;text&quot; @click&#x3D;&quot;editShow(row,$index,false)&quot;&gt;取消&lt;&#x2F;el-button&gt;</span><br><span class="line">                &lt;el-button type&#x3D;&quot;text&quot; @click&#x3D;&quot;sortChange(row,$index)&quot;&gt;确定&lt;&#x2F;el-button&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div v-else&gt;</span><br><span class="line">            &#123;&#123; row.sort &#125;&#125;&lt;i class&#x3D;&quot;el-icon-edit&quot; @click&#x3D;&quot;editShow(row,$index,true)&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;el-table-column&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; JS</span><br><span class="line">this.tableData.map(cu &#x3D;&gt; &#123; cu.edit &#x3D; false &#125;)</span><br><span class="line">&#x2F;&#x2F; 排序输入框显示切换 status:false-取消编辑 true-提交编辑</span><br><span class="line">editShow(row, index, status) &#123;</span><br><span class="line">    &#x2F;&#x2F; 先查看当前表格是否有在编辑中的状态，有的话不允许编辑其他项</span><br><span class="line">    const findindex &#x3D; this.tableData.findIndex(cu &#x3D;&gt; &#123; return cu.edit &#x3D;&#x3D;&#x3D; true &#125;)</span><br><span class="line">    if (findindex !&#x3D;&#x3D; -1 &amp;&amp; status) &#123;</span><br><span class="line">        this.$message.warning(&#39;请先保存之前的编辑项&#39;)</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    row.edit &#x3D; status</span><br><span class="line">    if (status) &#123; &#x2F;&#x2F; 保存当前编辑项的排序</span><br><span class="line">        this.tempSort &#x3D; row.sort</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 取消编辑还原排序</span><br><span class="line">        row.sort &#x3D; this.tempSort</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 修改表格数据</span><br><span class="line">    this.$set(this.tableData, index, row)</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 修改排序</span><br><span class="line">sortChange(row, index) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调接口修改排序，修改成功后要将 edit 设置成 false</span><br><span class="line">    sortEdit(&#123; detailId: row.detailId, sort: row.sort &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">        this.$message.success(&#39;排序修改成功&#39;)</span><br><span class="line">        this.getTableData()</span><br><span class="line">        row.edit &#x3D; false</span><br><span class="line">        this.$set(this.tableData, index, row)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表格列宽拖拽"><a href="#表格列宽拖拽" class="headerlink" title="表格列宽拖拽"></a>表格列宽拖拽</h2><p>查看 element 源码发现表格拖拽不能拖拽到宽度0，保留了最小宽度 30px，现在需求是指定表格每列拖拽的范围，拖拽到设定的最小宽度就不能再减少列宽，拖拽到指定的最大宽度就不能再增加列宽。<br><img src="https://s2.loli.net/2023/03/28/k3d6LtBuPN1RolW.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-table ref&#x3D;&quot;table&quot; v-loading&#x3D;&quot;loading&quot; :data&#x3D;&quot;tableData&quot; height&#x3D;&quot;100%&quot; border @header-dragend&#x3D;&quot;tableDrag&quot;&gt;</span><br><span class="line">&lt;&#x2F;el-table&gt;</span><br><span class="line"></span><br><span class="line">tableDrag(newWidth, oldWidth, column, event) &#123;</span><br><span class="line">    console.log(newWidth, oldWidth, column, event)</span><br><span class="line">    if (newWidth &lt;&#x3D; (column.minWidth || 200)) &#123;</span><br><span class="line">        column.width &#x3D; column.minWidth || 200</span><br><span class="line">    &#125;</span><br><span class="line">    if (newWidth &gt;&#x3D; 300) &#123;</span><br><span class="line">        column.width &#x3D; 300</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="表格展开-收缩"><a href="#表格展开-收缩" class="headerlink" title="表格展开/收缩"></a>表格展开/收缩</h2><p><img src="https://s2.loli.net/2023/03/28/Cjp9XLGUqeYusKw.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-button plain type&#x3D;&quot;primary&quot; size&#x3D;&quot;mini&quot; @click&#x3D;&quot;expandAll&quot;&gt;展开所有&lt;&#x2F;el-button&gt;</span><br><span class="line">&lt;el-button plain type&#x3D;&quot;primary&quot; size&#x3D;&quot;mini&quot; @click&#x3D;&quot;collapseAll&quot;&gt;收起所有&lt;&#x2F;el-button&gt;</span><br><span class="line">&lt;el-table ref&#x3D;&quot;table&quot; v-loading&#x3D;&quot;loading&quot; :data&#x3D;&quot;menuList&quot; height&#x3D;&quot;100%&quot; </span><br><span class="line">    row-key&#x3D;&quot;rsId&quot; default-expand-all :tree-props&#x3D;&quot;&#123;children: &#39;childrenList&#39;,hasChildren: &#39;hasChildren&#39;&#125;&quot;&gt;</span><br><span class="line">&lt;&#x2F;el-table&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 切换表格的展开收起</span><br><span class="line">expandTable(arr, isExpand) &#123;</span><br><span class="line">    arr.forEach(i &#x3D;&gt; &#123;</span><br><span class="line">        this.$refs.table.toggleRowExpansion(i, isExpand)</span><br><span class="line">        if (i.childrenList) &#123;</span><br><span class="line">            this.expandTable(i.childrenList, isExpand)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 全部展开</span><br><span class="line">expandAll() &#123;</span><br><span class="line">    &#x2F;&#x2F; 默认展开全部的话，首次加载需要在$nextTick下进行</span><br><span class="line">    this.expandTable(this.menuList, true)</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 全部收起</span><br><span class="line">collapseAll() &#123;</span><br><span class="line">    this.expandTable(this.menuList, false)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="时间选择器-期限设置"><a href="#时间选择器-期限设置" class="headerlink" title="时间选择器-期限设置"></a>时间选择器-期限设置</h1><ol>
<li>开始时间需要从当前天+1开始设置，截止时间必须为开始时间+1；</li>
<li>若已经设置过开始、截止时间，且在设置的时间范围内进行修改时，只可修改截止时间，不可修改开始时间。    </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-dialog title&#x3D;&quot;填报期限修改&quot; :visible.sync&#x3D;&quot;editTimeVisible&quot; width&#x3D;&quot;660px&quot; :before-close&#x3D;&quot;editTimeClose&quot;&gt;</span><br><span class="line">    &lt;el-form ref&#x3D;&quot;editTimeForm&quot; :model&#x3D;&quot;editTimeForm&quot; label-width&#x3D;&quot;110px&quot; :rules&#x3D;&quot;editTimeRules&quot;&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;企业填报时间&quot; required&gt;</span><br><span class="line">            &lt;el-col :span&#x3D;&quot;11&quot;&gt;</span><br><span class="line">                &lt;el-form-item prop&#x3D;&quot;submitStartTime&quot;&gt;</span><br><span class="line">                &lt;el-date-picker</span><br><span class="line">                    v-model&#x3D;&quot;editTimeForm.submitStartTime&quot;</span><br><span class="line">                    type&#x3D;&quot;date&quot;</span><br><span class="line">                    placeholder&#x3D;&quot;开始期限&quot;</span><br><span class="line">                    value-format&#x3D;&quot;yyyy-MM-dd HH:mm:ss&quot;</span><br><span class="line">                    :picker-options&#x3D;&quot;pickerOptions1&quot;</span><br><span class="line">                    :disabled&#x3D;&quot;startTimeFlag&quot;</span><br><span class="line">                    style&#x3D;&quot;width:100%&quot;&gt;</span><br><span class="line">                &lt;&#x2F;el-date-picker&gt;</span><br><span class="line">                &lt;&#x2F;el-form-item&gt;</span><br><span class="line">            &lt;&#x2F;el-col&gt;</span><br><span class="line">            &lt;el-col style&#x3D;&quot;text-align:center&quot; :span&#x3D;&quot;2&quot;&gt;至&lt;&#x2F;el-col&gt;</span><br><span class="line">            &lt;el-col :span&#x3D;&quot;11&quot;&gt;</span><br><span class="line">                &lt;el-form-item prop&#x3D;&quot;submitEndTime&quot;&gt;</span><br><span class="line">                &lt;el-date-picker</span><br><span class="line">                    v-model&#x3D;&quot;editTimeForm.submitEndTime&quot;</span><br><span class="line">                    type&#x3D;&quot;date&quot;</span><br><span class="line">                    placeholder&#x3D;&quot;结束期限&quot;</span><br><span class="line">                    value-format&#x3D;&quot;yyyy-MM-dd&quot;</span><br><span class="line">                    :picker-options&#x3D;&quot;pickerOptions2&quot;</span><br><span class="line">                    @change&#x3D;&quot;endTimeChange&quot;</span><br><span class="line">                    style&#x3D;&quot;width:100%&quot;&gt;</span><br><span class="line">                &lt;&#x2F;el-date-picker&gt;</span><br><span class="line">                &lt;&#x2F;el-form-item&gt;</span><br><span class="line">            &lt;&#x2F;el-col&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;&#x2F;el-form&gt;</span><br><span class="line">    &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;editTimeClose&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;editTimeSure&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 时间参数</span><br><span class="line">pickerOptions1: &#123;   &#x2F;&#x2F; 开始时间为当前天+1</span><br><span class="line">    disabledDate(v) &#123;</span><br><span class="line">        &#x2F;&#x2F; return v.getTime() &lt; new Date().getTime() - 8.64e7  当前天也可选择</span><br><span class="line">        return v.getTime() &lt; new Date().getTime()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">pickerOptions2: this.endTimeOptions(), &#x2F;&#x2F; 结束时间</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置结束期限的禁用日期</span><br><span class="line">endTimeOptions() &#123;</span><br><span class="line">    let that &#x3D; this</span><br><span class="line">    return &#123;</span><br><span class="line">        disabledDate(v) &#123;</span><br><span class="line">            if (that.editTimeForm.submitStartTime) &#123;</span><br><span class="line">                &#x2F;&#x2F; 开始时间有值，截止时间为开始时间+1</span><br><span class="line">                return v.getTime() &lt; new Date(that.editTimeForm.submitStartTime).getTime()</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 无开始时间，截止时间为当前天+1</span><br><span class="line">                return v.getTime() &lt; new Date().getTime()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 结束期限改变的时候需要判断开始期限的值</span><br><span class="line">endTimeChange(val) &#123;</span><br><span class="line">    if (!this.editTimeForm.submitStartTime) &#123;</span><br><span class="line">        this.$message.warning(&#39;请先选择开始期限&#39;)</span><br><span class="line">        this.editTimeForm.submitEndTime &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 填报期限设置模态框打开</span><br><span class="line">editTimeOpen(row) &#123;</span><br><span class="line">    &#x2F;&#x2F; 若已经设置过填报开始、截止时间，且在设置的时间范围内进行修改时，只可修改截止时间，不可修改开始时间。</span><br><span class="line">    if (row.submitStartTime &amp;&amp; row.submitEndTime) &#123;</span><br><span class="line">        let currTime &#x3D; (new Date()).getTime()</span><br><span class="line">        let beforeTime &#x3D; (new Date(row.submitStartTime)).getTime()</span><br><span class="line">        let afterTime &#x3D; (new Date(row.submitEndTime)).getTime()</span><br><span class="line">        if (beforeTime &lt;&#x3D; currTime &amp;&amp; currTime &lt;&#x3D; afterTime) &#123;</span><br><span class="line">            this.startTimeFlag &#x3D; true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.startTimeFlag &#x3D; false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.startTimeFlag &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">    this.editTimeForm.submitStartTime &#x3D; row.submitStartTime</span><br><span class="line">    this.editTimeForm.submitEndTime &#x3D; row.submitEndTime</span><br><span class="line">    this.editTimeForm.dataYear &#x3D; row.dataYear</span><br><span class="line">    this.editTimeVisible &#x3D; true</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="滑块组件改装成滑动校验"><a href="#滑块组件改装成滑动校验" class="headerlink" title="滑块组件改装成滑动校验"></a>滑块组件改装成滑动校验</h1><p><img src="https://i.loli.net/2021/02/24/ajrsuq5gGdo6O1M.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-form :model&#x3D;&quot;ruleForm&quot; :rules&#x3D;&quot;rules&quot; ref&#x3D;&quot;ruleForm&quot; label-width&#x3D;&quot;100px&quot;&gt;</span><br><span class="line">    &lt;el-form-item label&#x3D;&quot;滑动验证&quot; prop&#x3D;&quot;checkBtn&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;slider-div&quot;&gt;</span><br><span class="line">            &lt;el-slider</span><br><span class="line">                v-model&#x3D;&quot;ruleForm.checkBtn&quot;</span><br><span class="line">                :show-tooltip&#x3D;&quot;false&quot;</span><br><span class="line">            &gt;&lt;&#x2F;el-slider&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;el-form-item&gt;</span><br><span class="line">&lt;&#x2F;el-form&gt;</span><br><span class="line"></span><br><span class="line">const checkBtnValid &#x3D; (rule, value, callback) &#x3D;&gt; &#123;</span><br><span class="line">    if (value &lt; 100) &#123;</span><br><span class="line">        callback(new Error(&#39;滑动验证失败，请重新滑动&#39;))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        callback()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ruleForm: &#123;</span><br><span class="line">    checkBtn: 0,</span><br><span class="line">&#125;,</span><br><span class="line">rules: &#123;</span><br><span class="line">    checkBtn: [</span><br><span class="line">        &#123;</span><br><span class="line">            required: true,</span><br><span class="line">            validator: checkBtnValid,</span><br><span class="line">            trigger: &#39;change&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过更改样式将element UI的滑块改成滑动校验</span><br><span class="line">.slider-div &#123;&#x2F;&#x2F; 滑块的父div</span><br><span class="line">    border: 1px solid rgba(4, 22, 22, 0.25);</span><br><span class="line">    background-color: rgba(0, 165, 161, 0.05);</span><br><span class="line">    border-radius: 4px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 滑块样式</span><br><span class="line">&#x2F;deep&#x2F;.el-slider &#123;</span><br><span class="line">    &#x2F;&#x2F; 由于按钮滑到最右边是超出滑块横条的，所以留出0.4rem（按钮的宽度）的空间存放按钮，凿除滑倒头并且还在框内的假象</span><br><span class="line">    width: calc(100% - 0.4rem); </span><br><span class="line">    &amp;__runway &#123;</span><br><span class="line">        height: 0.4rem;</span><br><span class="line">        margin: 0;</span><br><span class="line">        background-color: transparent;</span><br><span class="line">        .el-slider__bar &#123;</span><br><span class="line">            height: 0.4rem;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 在滑条上面增加文字</span><br><span class="line">        &amp;::after &#123;</span><br><span class="line">            content: &quot;按住滑块拖到右边&quot;;</span><br><span class="line">            color: rgba(4, 22, 22, 0.25);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 设置按钮的样式</span><br><span class="line">    &amp;__button-wrapper &#123;</span><br><span class="line">        width: 0.4rem;</span><br><span class="line">        height: 0.4rem;</span><br><span class="line">        top: -1px;</span><br><span class="line">        transform: translateX(0%);</span><br><span class="line">        .el-slider__button &#123;</span><br><span class="line">            width: 0.4rem;</span><br><span class="line">            height: 0.4rem;</span><br><span class="line">            border: 1px solid rgba(4, 22, 22, 0.25);</span><br><span class="line">            border-radius: 4px;</span><br><span class="line">            &amp;::after &#123;</span><br><span class="line">                content: &quot;&gt;&gt;&quot;;</span><br><span class="line">                line-height: 0.4rem;</span><br><span class="line">                color: rgba(4, 22, 22, 0.25);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h2 id="图片预览组件新增下载功能"><a href="#图片预览组件新增下载功能" class="headerlink" title="图片预览组件新增下载功能"></a>图片预览组件新增下载功能</h2><p>element内部有一个图片预览组件 - image-viewer，但是这个组件只有图片的放大缩小旋转等功能，但是没有下载的功能。以下是引用该组件并且新增下载功能的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;previewImage&quot;&gt;显示图片&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;!-- 图片预览组件 --&gt;</span><br><span class="line">        &lt;el-image-viewer </span><br><span class="line">            v-if&#x3D;&quot;imgViewerShow&quot; </span><br><span class="line">            ref&#x3D;&quot;elImageViewer&quot; </span><br><span class="line">            :on-close&#x3D;&quot;()&#x3D;&gt;&#123;imgViewerShow&#x3D;false&#125;&quot; </span><br><span class="line">            :url-list&#x3D;&quot;preImgList&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 引入图片预览组件</span><br><span class="line">import ElImageViewer from &#39;element-ui&#x2F;packages&#x2F;image&#x2F;src&#x2F;image-viewer&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    &#x2F;&#x2F; 注册图片预览组件</span><br><span class="line">    components: &#123; ElImageViewer &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            qrcodeUrl:&#39;图片的具体url&#39;,</span><br><span class="line">            &#x2F;&#x2F; 图片预览组件需要展示的图片数据</span><br><span class="line">            preImgList:[],</span><br><span class="line">            &#x2F;&#x2F; 图片预览组件是否显示标志</span><br><span class="line">            imgViewerShow:false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        &#x2F;&#x2F; 预览图片-新增下载功能</span><br><span class="line">        previewImage() &#123;</span><br><span class="line">            if (this.qrcodeUrl) &#123;</span><br><span class="line">                this.preImgList &#x3D; [this.qrcodeUrl]</span><br><span class="line">                this.imgViewerShow &#x3D; true</span><br><span class="line">                this.$nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">                    &#x2F;&#x2F; 获取图片预览工具按钮容器元素</span><br><span class="line">                    const iParent &#x3D; document.getElementsByClassName(&#39;el-image-viewer__actions__inner&#39;)</span><br><span class="line">                    if (iParent &amp;&amp; iParent.length &gt; 0) &#123;</span><br><span class="line">                        const lastNodeClass &#x3D; iParent[0].lastChild.getAttribute(&#39;class&#39;)</span><br><span class="line">                        &#x2F;&#x2F; 新增下载按钮</span><br><span class="line">                        if (lastNodeClass !&#x3D;&#x3D; &#39;el-icon-download&#39;) &#123;</span><br><span class="line">                            const i &#x3D; document.createElement(&#39;i&#39;)</span><br><span class="line">                            i.setAttribute(&#39;class&#39;, &#39;el-icon-download&#39;)</span><br><span class="line">                            &#x2F;&#x2F; 给下载按钮绑定点击事件</span><br><span class="line">                            i.onclick &#x3D; () &#x3D;&gt; &#123; this.downloadOpera() &#125;</span><br><span class="line">                            iParent[0].appendChild(i)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.preImgList &#x3D; []</span><br><span class="line">                this.$message.warning(&#39;当前无图片！&#39;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 下载图片操作</span><br><span class="line">        downloadOpera() &#123;</span><br><span class="line">            this.downloadImg(this.$refs.elImageViewer.currentImg, &#39;图片.png&#39;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 图片下载公共方法</span><br><span class="line">        downloadImg(url,name)&#123;</span><br><span class="line">            const image &#x3D; new Image()</span><br><span class="line">            &#x2F;&#x2F; 解决跨域 Canvas 污染问题</span><br><span class="line">            image.setAttribute(&#39;crossOrigin&#39;, &#39;anonymous&#39;)</span><br><span class="line">            image.src &#x3D; url</span><br><span class="line">            image.onload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">                const canvas &#x3D; document.createElement(&#39;canvas&#39;)</span><br><span class="line">                canvas.width &#x3D; image.width</span><br><span class="line">                canvas.height &#x3D; image.height</span><br><span class="line">                const ctx &#x3D; canvas.getContext(&#39;2d&#39;)</span><br><span class="line">                ctx.drawImage(image, 0, 0, image.width, image.height)</span><br><span class="line">                canvas.toBlob((blob) &#x3D;&gt; &#123;</span><br><span class="line">                    const url &#x3D; URL.createObjectURL(blob)</span><br><span class="line">                    const eleLink &#x3D; document.createElement(&#39;a&#39;)</span><br><span class="line">                    eleLink.download &#x3D; name</span><br><span class="line">                    eleLink.href &#x3D; url</span><br><span class="line">                    eleLink.click()</span><br><span class="line">                    eleLink.remove()</span><br><span class="line">                    &#x2F;&#x2F; 用完释放URL对象</span><br><span class="line">                    URL.revokeObjectURL(url)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="图片上传后自动切割"><a href="#图片上传后自动切割" class="headerlink" title="图片上传后自动切割"></a>图片上传后自动切割</h2><p><img src="https://s2.loli.net/2023/03/29/NyJuDaiYPV1noA4.gif" alt=""><br>现项目中需要配置楼层广告，一层展示一张或多张广告图，由于UI提供的广告图都是完整的，运维那边自己切图，图片比列相差很大，导致楼层广告最终的展示效果差强人意，为了解决这个问题，由系统自行切图，根据上传的广告图，按照模版要求数量将广告图切割成多个等比的图片。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-upload :http-request&#x3D;&quot;requestUpload&quot;&gt;&lt;&#x2F;el-upload&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fileUpload -- 图片上传接口，返回图片地址</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 覆盖默认的上传行为，自定义上传</span><br><span class="line">requestUpload(file)&#123;</span><br><span class="line">    const formData &#x3D; new FormData()</span><br><span class="line">    formData.append(&#39;file&#39;, file.file)</span><br><span class="line">    &#x2F;&#x2F; 压缩图片后上传</span><br><span class="line">    fileUpload(formData).then(res &#x3D;&gt; &#123;</span><br><span class="line">        const name &#x3D; res.result.path.split(&#39;&#x2F;&#39;)</span><br><span class="line">        this.fileList.push(&#123;</span><br><span class="line">            name: name[name.length - 1],</span><br><span class="line">            url: res.result.url</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; 切割图片</span><br><span class="line">        this.divisionImg(file.file)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图片上传 检验宽高 必须和第一张图片保持一致</p>
<h1 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h1><h2 id="展开至某个层级"><a href="#展开至某个层级" class="headerlink" title="展开至某个层级"></a>展开至某个层级</h2><p><img src="https://s2.loli.net/2023/03/28/Jx1cZDoyMsXFvI7.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 视图</span><br><span class="line">&lt;el-row class&#x3D;&quot;mt20&quot;&gt;</span><br><span class="line">    &lt;el-col :span&#x3D;&quot;6&quot;&gt;</span><br><span class="line">        展开至：</span><br><span class="line">        &lt;el-select v-model&#x3D;&quot;value&quot; placeholder&#x3D;&quot;请选择&quot; @change&#x3D;&quot;levelChange&quot;&gt;</span><br><span class="line">            &lt;el-option v-for&#x3D;&quot;item in options&quot; :key&#x3D;&quot;item.value&quot; :label&#x3D;&quot;item.label&quot; :value&#x3D;&quot;item.value&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;el-select&gt;</span><br><span class="line">    &lt;&#x2F;el-col&gt;</span><br><span class="line">    &lt;el-col :span&#x3D;&quot;18&quot;&gt;</span><br><span class="line">        &lt;el-button class&#x3D;&quot;ml20&quot; type&#x3D;&quot;primary&quot; plain @click&#x3D;&quot;openAll&quot;&gt;展开所有&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; plain @click&#x3D;&quot;closeAll&quot;&gt;收缩所有&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;&#x2F;el-col&gt;</span><br><span class="line">&lt;&#x2F;el-row&gt;</span><br><span class="line">&lt;el-tree ref&#x3D;&quot;tree&quot; :data&#x3D;&quot;treeData&quot; node-key&#x3D;&quot;id&quot; :default-expanded-keys&#x3D;&quot;expand&quot; </span><br><span class="line">  :props&#x3D;&quot;defaultProps&quot; class&#x3D;&quot;mt20&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数据</span><br><span class="line">&#x2F;&#x2F; 树形结构展示数据</span><br><span class="line">treeData: [</span><br><span class="line">    &#123;</span><br><span class="line">        id: 1,label: &#39;一级 1&#39;,</span><br><span class="line">        children: [&#123;</span><br><span class="line">            id: 4,label: &#39;二级 1-1&#39;,</span><br><span class="line">            children: [</span><br><span class="line">                &#123;id: 9,label: &#39;三级 1-1-1&#39;&#125;, </span><br><span class="line">                &#123;id: 10,label: &#39;三级 1-1-2&#39;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        id: 2,label: &#39;一级 2&#39;,</span><br><span class="line">        children: [</span><br><span class="line">            &#123; id: 5,label: &#39;二级 2-1&#39;&#125;, </span><br><span class="line">            &#123; id: 6,label: &#39;二级 2-2&#39;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        id: 3,label: &#39;一级 3&#39;,</span><br><span class="line">        children: [</span><br><span class="line">            &#123;id: 7,label: &#39;二级 3-1&#39;&#125;, </span><br><span class="line">            &#123;id: 8,label: &#39;二级 3-2&#39;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">&#x2F;&#x2F; 树形接口默认配置</span><br><span class="line">defaultProps: &#123;</span><br><span class="line">    children: &#39;children&#39;,</span><br><span class="line">    label: &#39;label&#39;</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 树形结构展开项</span><br><span class="line">expand: [],</span><br><span class="line">&#x2F;&#x2F; 树形结构添加层级后的展示数据</span><br><span class="line">levelData: [],</span><br><span class="line">&#x2F;&#x2F; 展开收缩标志</span><br><span class="line">expandAll: false,</span><br><span class="line">&#x2F;&#x2F; 下拉选选项</span><br><span class="line">options: [</span><br><span class="line">    &#123;value: &#39;1&#39;,label: &#39;1级&#39;&#125;, </span><br><span class="line">    &#123;value: &#39;2&#39;,label: &#39;2级&#39;&#125;,</span><br><span class="line">    &#123;value: &#39;3&#39;,label: &#39;3级&#39;&#125;</span><br><span class="line">],</span><br><span class="line">&#x2F;&#x2F; 下拉选值</span><br><span class="line">value: &#39;&#39;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方法</span><br><span class="line">created() &#123;</span><br><span class="line">    &#x2F;&#x2F; 给tree数据添加指定层级数据</span><br><span class="line">    this.levelData &#x3D; this.setLevel(this.treeData, 0)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; 给tree数据添加指定层级数据</span><br><span class="line">    setLevel(arry, level) &#123;</span><br><span class="line">        level++</span><br><span class="line">        return arry.map(cu &#x3D;&gt; &#123;</span><br><span class="line">            cu.level &#x3D; level</span><br><span class="line">            if (cu.children &amp;&amp; cu.children.length &gt; 0) &#123;</span><br><span class="line">                this.setLevel(cu.children, level)</span><br><span class="line">            &#125;</span><br><span class="line">            return cu</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 展开所有</span><br><span class="line">    openAll() &#123;</span><br><span class="line">        this.expandAll &#x3D; false</span><br><span class="line">        &#x2F;&#x2F; 否则将所有节点的expanded设置成true，展开所有</span><br><span class="line">        this.changeTreeNodeStatus(this.$refs.tree.store.nodesMap)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 收缩所有</span><br><span class="line">    closeAll() &#123;</span><br><span class="line">        this.expandAll &#x3D; true</span><br><span class="line">        &#x2F;&#x2F; 否则将所有节点的expanded设置成false，收缩所有</span><br><span class="line">        this.changeTreeNodeStatus(this.$refs.tree.store.nodesMap)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 修改节点展开&#x2F;收缩的状态</span><br><span class="line">    changeTreeNodeStatus(node) &#123;</span><br><span class="line">        this.expandAll &#x3D; !this.expandAll</span><br><span class="line">        for (const i in node) &#123;</span><br><span class="line">            node[i].expanded &#x3D; this.expandAll</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 指定展开某个层级</span><br><span class="line">    levelChange(val) &#123;</span><br><span class="line">        &#x2F;&#x2F; 收缩所有的节点</span><br><span class="line">        this.closeAll()</span><br><span class="line">        this.expand &#x3D; []</span><br><span class="line">        const list &#x3D; []</span><br><span class="line">        &#x2F;&#x2F; 获取指定层级的数据</span><br><span class="line">        const curLevel &#x3D; this.getLevelData(this.levelData, val, list)</span><br><span class="line">        &#x2F;&#x2F; 获取指定层级所有的id，设置成展开项</span><br><span class="line">        if (curLevel &amp;&amp; curLevel.length &gt; 0) &#123;</span><br><span class="line">            this.expand &#x3D; curLevel.map(cu &#x3D;&gt; &#123;</span><br><span class="line">                return cu.id</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 获取指定层级的数据</span><br><span class="line">    getLevelData(array, level, list) &#123;</span><br><span class="line">      array.map(cu &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 将所有小于等于指定层级-1的所有数据保留</span><br><span class="line">        if (cu.level &lt;&#x3D; level * 1 - 1) &#123;</span><br><span class="line">          list.push(cu)</span><br><span class="line">        &#125;</span><br><span class="line">        if (cu.children &amp;&amp; cu.children.length &gt; 0) &#123;</span><br><span class="line">          this.getLevelData(cu.children, level, list)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      return list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据太多渲染慢，无法显示loading<br>vue-easy-tree</p>
<p>数据太多清空多选慢<br>获取选中的数据然后循环一个一个清空，加loading</p>
]]></content>
      <categories>
        <category>UI</category>
        <category>Element</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>Element</tag>
      </tags>
  </entry>
</search>
