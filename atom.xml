<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Crystal&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://crystalsummer.gitee.io/"/>
  <updated>2023-06-14T08:04:35.897Z</updated>
  <id>http://crystalsummer.gitee.io/</id>
  
  <author>
    <name>Crystal</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Element Plus</title>
    <link href="http://crystalsummer.gitee.io/2022/05/21/Element%20Plus/"/>
    <id>http://crystalsummer.gitee.io/2022/05/21/Element%20Plus/</id>
    <published>2022-05-21T06:16:18.000Z</published>
    <updated>2023-06-14T08:04:35.897Z</updated>
    
    <content type="html"><![CDATA[<style>  .border{    padding: 10px;    border: 1px solid #ebebeb;    border-radius: 4px;    margin-bottom: 20px;  }  .border .title{    font-size: 16px;    font-weight: 500;  }  .border .content-solve{    text-indent: 20px;  }</style><p><img src="https://cdn.pixabay.com/photo/2023/02/09/16/36/bridge-7779222_1280.jpg" alt=""></p><a id="more"></a><p><a href="https://element-plus.gitee.io/zh-CN/" target="_blank" rel="noopener"><strong>Element Plus</strong></a>，基于 Vue 3，面向设计师和开发者的组件库。这里记录了工作中遇到的常用操作和踩坑。</p><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><h3 id="form表单无法输入"><a href="#form表单无法输入" class="headerlink" title="form表单无法输入"></a>form表单无法输入</h3><div class="border">    <div class="title">form表单输入框能聚焦但是无法输入。</div>    <div class="content-solve">解决：ref 和 mode 定义为不同的变量。</div></div><h3 id="dialog嵌套form回显数据问题"><a href="#dialog嵌套form回显数据问题" class="headerlink" title="dialog嵌套form回显数据问题"></a>dialog嵌套form回显数据问题</h3><div class="border">    <div class="title">el-dialog里嵌套form表单，打开dialog后表单数组循环回显上一次编辑时的数据。</div>    <div class="content-solve">原因：第一次打开dialog给表单的model赋值，这个时候model的初始值就是赋的值，第二次打开dialog使用resetFields的时候，会将model重置到初始值，也就是赋的值。详情请参考：<a href="https://github.com/ElemeFE/element/issues/1871" target="_blank" rel="noopener">form resetFields并没有清空表单 #1871</a></div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打开dialog</span><br><span class="line">const open&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F; 重置数据</span><br><span class="line">    reset()</span><br><span class="line">    show.value &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 解决方法1：先resetFields，后重置数据</span><br><span class="line">const reset &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    proxy.$refs[&#39;formRef&#39;].resetFields();</span><br><span class="line">    for (let item in form.value) &#123;</span><br><span class="line">        form.value[item] &#x3D; undefined;</span><br><span class="line">    &#125;</span><br><span class="line">    form.value.spuList &#x3D; [&#123;</span><br><span class="line">        spuId: undefined,</span><br><span class="line">        spuName: undefined,</span><br><span class="line">        settlePrice: undefined,</span><br><span class="line">        retailPrice: undefined,</span><br><span class="line">        saleNum: undefined,</span><br><span class="line">        totalAmount: undefined,</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解决方法2： 等dialog初始化mounted之后再给model赋值，也就是使用nextTick</span><br><span class="line">const reset &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    proxy.$nextTick(()&#x3D;&gt;&#123;</span><br><span class="line">        for (let item in form.value) &#123;</span><br><span class="line">            form.value[item] &#x3D; undefined;</span><br><span class="line">        &#125;</span><br><span class="line">        form.value.spuList &#x3D; [&#123;</span><br><span class="line">            spuId: undefined,</span><br><span class="line">            spuName: undefined,</span><br><span class="line">            settlePrice: undefined,</span><br><span class="line">            retailPrice: undefined,</span><br><span class="line">            saleNum: undefined,</span><br><span class="line">            totalAmount: undefined,</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">    proxy.$refs[&#39;formRef&#39;].resetFields();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;style&gt;
  .border{
    padding: 10px;
    border: 1px solid #ebebeb;
    border-radius: 4px;
    margin-bottom: 20px;
  }
  .border .title{
    font-size: 16px;
    font-weight: 500;
  }
  .border .content-solve{
    text-indent: 20px;
  }
&lt;/style&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2023/02/09/16/36/bridge-7779222_1280.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="UI" scheme="http://crystalsummer.gitee.io/categories/UI/"/>
    
      <category term="Element" scheme="http://crystalsummer.gitee.io/categories/UI/Element/"/>
    
    
      <category term="UI" scheme="http://crystalsummer.gitee.io/tags/UI/"/>
    
      <category term="Element" scheme="http://crystalsummer.gitee.io/tags/Element/"/>
    
  </entry>
  
  <entry>
    <title>Vue3后台管理框架搭建</title>
    <link href="http://crystalsummer.gitee.io/2022/03/28/Vue3%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    <id>http://crystalsummer.gitee.io/2022/03/28/Vue3%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</id>
    <published>2022-03-28T10:45:50.000Z</published>
    <updated>2023-06-21T07:36:54.796Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2018/04/28/22/03/dawn-3358468_960_720.jpg" alt=""></p><a id="more"></a><p>Vue3已经成功落地，并成为默认版本，这里使用以下技术栈搭建一套后台管理的前端框架：</p><ul><li><a href="https://v3.cn.vuejs.org/" target="_blank" rel="noopener">Vue3</a></li><li><a href="https://cn.vitejs.dev/" target="_blank" rel="noopener">Vite2.9</a></li><li><a href="https://router.vuejs.org/" target="_blank" rel="noopener">vue-router4</a></li><li><a href="https://pinia.vuejs.org/" target="_blank" rel="noopener">pinia</a></li><li><a href="https://pnpm.io/zh/" target="_blank" rel="noopener">pnpm</a></li><li><a href="https://element-plus.gitee.io/zh-CN/" target="_blank" rel="noopener">Element Plus</a></li><li><a href="https://github.com/axios/axios/blob/master/README.md" target="_blank" rel="noopener">axios</a></li><li><a href="https://www.sass.hk/" target="_blank" rel="noopener">Sass</a></li></ul><!-- 该框架的接口和数据均来自[若依](http://www.ruoyi.vip/)，在此特别声明。 --><p>框架gitee地址：<a href="https://gitee.com/crystalSummer/vue3-admin" target="_blank" rel="noopener"><strong>vue3-admin-gitee</strong></a><br>框架github地址：<a href="https://github.com/crystal-summer/vue3-admin" target="_blank" rel="noopener"><strong>vue3-admin-github</strong></a></p><h1 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h1><p><a href="https://pnpm.io/zh/" target="_blank" rel="noopener">pnpm</a>是包管理器，类似 npm，yarn，但是 npm 和 yarn 存在以下问题：</p><ul><li>扁平化算法要遍历所有的依赖关系，消耗时间，下载安装慢；</li><li>依赖包非法访问；</li><li>一个项目一个 node_modules，占磁盘空间。</li></ul><p>而 pnpm 速度快、不占磁盘空间，解决了扁平化算法复杂、避免依赖包非法访问的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局安装 pnpm</span><br><span class="line">npm install -g pnpm</span><br></pre></td></tr></table></figure><h1 id="ni"><a href="#ni" class="headerlink" title="ni"></a>ni</h1><p><a href="https://github.com/antfu/ni" target="_blank" rel="noopener">ni</a>根据当前项目的锁文件，采用对应的包管理工具对项目进行依赖安装、脚本运行等操作的一个小工具，安装这个小工具，可以不用考虑当前项目的包管理工具是什么，也方便使用不同包管理工具的项目的管理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局安装 ni</span><br><span class="line">npm i -g @antfu&#x2F;ni</span><br><span class="line">&#x2F;&#x2F; 安装依赖</span><br><span class="line">ni  &#x3D;&#x3D;&#x3D; npm install &#x3D;&#x3D;&#x3D; pnpm install &#x3D;&#x3D;&#x3D; yarn install</span><br><span class="line">&#x2F;&#x2F; 运行脚本</span><br><span class="line">nr dev &#x3D;&#x3D;&#x3D; npm run dev &#x3D;&#x3D;&#x3D; pnpm run dev &#x3D;&#x3D;&#x3D; yarn run dev </span><br><span class="line">&#x2F;&#x2F; 安装某个包</span><br><span class="line">ni antd-mobile &#x3D;&#x3D;&#x3D; npm i antd-mobile</span><br></pre></td></tr></table></figure><h1 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h1><h2 id="Vite初始化项目"><a href="#Vite初始化项目" class="headerlink" title="Vite初始化项目"></a>Vite初始化项目</h2><p><a href="https://cn.vitejs.dev/" target="_blank" rel="noopener">Vite</a>是新一代前端开发与构建工具，类似 webpack。</p><p>webpack、Rollup 和 Parcel 等工具的诞生，极大地改善了前端开发者的开发体验。但是，当构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。我们开始遇到性能瓶颈 —— <strong>使用 JavaScript 开发的工具通常需要很长时间（甚至是几分钟！）才能启动开发服务器</strong>。</p><p>而Vite旨在解决这个问题，将应用中的模块区分为 依赖 和 源码 两类，让浏览器接管了打包程序的部分工作，改进了开发服务器启动时间；将动态模块热重载（HMR）在原生 ESM 上执行，保持 HMR 快速更新；利用 HTTP 头来加速整个页面的重新加载，源码模块请求根据 304 进行协商缓存，依赖模块请求进行强缓存。<br>总而言之，Vite神速！！！</p><p>注意：如果使用Vite，那么vscode需要安装volar插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行以下命令搭建一个 JS 版的 Vue 项目</span><br><span class="line">pnpm create vite vue3-admin -- --template vue</span><br><span class="line">&#x2F;&#x2F; 创建完成后执行以下命令运行项目</span><br><span class="line">cd vue3-admin</span><br><span class="line">pnpm install</span><br><span class="line">pnpm run dev</span><br></pre></td></tr></table></figure><p>生成的项目初始目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public</span><br><span class="line">  - favicon.ico</span><br><span class="line">src</span><br><span class="line">  - assets</span><br><span class="line">    - logo.png</span><br><span class="line">  - components</span><br><span class="line">    - HelloWord.vue</span><br><span class="line">  - APP.vue</span><br><span class="line">  - main.js</span><br><span class="line">.gitignore</span><br><span class="line">index.html</span><br><span class="line">package.json</span><br><span class="line">README.md</span><br><span class="line">vite.config.js</span><br></pre></td></tr></table></figure><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>使用 Vite 初始化项目之后，使用 EditorConfig + Prettier + ESLint 设置代码规范。</p><h3 id="EditorConfig"><a href="#EditorConfig" class="headerlink" title="EditorConfig"></a>EditorConfig</h3><p><a href="https://editorconfig.org/" target="_blank" rel="noopener">EditorConfig</a><br>vscode先安装插件：EditorConfig for VS Code，webstorm或者IDEA不需要安装插件，直接配置，在项目根目录下面新建.editorconfig文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Editor configuration, see http:&#x2F;&#x2F;editorconfig.org </span><br><span class="line"></span><br><span class="line">root &#x3D; true # 表示是最顶层的 EditorConfig 配置文件 </span><br><span class="line"></span><br><span class="line">[*] # 表示所有文件适用 </span><br><span class="line">charset &#x3D; utf-8 # 设置文件字符集为 utf-8 </span><br><span class="line">indent_style &#x3D; space # 缩进风格（tab | space） </span><br><span class="line">indent_size &#x3D; 2 # 缩进大小 </span><br><span class="line">end_of_line &#x3D; lf # 控制换行类型(lf | cr | crlf) </span><br><span class="line">trim_trailing_whitespace &#x3D; true # 去除行首的任意空白字符 </span><br><span class="line">insert_final_newline &#x3D; true # 始终在文件末尾插入一个新行 </span><br><span class="line"></span><br><span class="line">[*.md] # 表示仅 md 文件适用以下规则 </span><br><span class="line">max_line_length &#x3D; off </span><br><span class="line">trim_trailing_whitespace &#x3D; false</span><br></pre></td></tr></table></figure><h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><p><a href="https://prettier.io/" target="_blank" rel="noopener">Prettier</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install prettier -D</span><br></pre></td></tr></table></figure><p>vscode先安装插件：Prettier - Code formatter，webstorm或者IDEA不需要安装插件，直接配置，在项目根目录下面新建.prettierrc.js 和 .prettierignore文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .prettierignore</span><br><span class="line">node_modules</span><br><span class="line">dist</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; .prettierrc.js</span><br><span class="line">module.exports &#x3D;&#123;</span><br><span class="line">  tabWidth: 2,</span><br><span class="line">  printWidth: 100,</span><br><span class="line">  singleQuote: true,</span><br><span class="line">  semi: false,</span><br><span class="line">  overrides: [</span><br><span class="line">    &#123;</span><br><span class="line">      files: &#39;*.json&#39;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        printWidth: 200,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  arrowParens: &#39;always&#39;,</span><br><span class="line">  endOfLine: &#39;auto&#39;,</span><br><span class="line">  vueIndentScriptAndStyle: true,</span><br><span class="line">  trailingComma: &#39;all&#39;,</span><br><span class="line">  proseWrap: &#39;never&#39;,</span><br><span class="line">  htmlWhitespaceSensitivity: &#39;strict&#39;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vscode打开文件-》首选项-》设置-》当前工作区，<br>搜索formatter，将 Editor:Default Formatter 选择为 prettier<br>搜索save，将 Editor:Formatter On Save勾选<br>这样保存文件的时候就会自动格式化代码。</p><h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><p><a href="https://github.com/eslint/eslint" target="_blank" rel="noopener">ESLint</a><br>vscode先安装插件：ESLint，webstorm或者IDEA不需要安装插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装</span><br><span class="line">pnpm install eslint -D</span><br><span class="line">&#x2F;&#x2F; 执行以下命令完成设置，并创建.eslintrc.js配置文件</span><br><span class="line">pnpm init @eslint&#x2F;config</span><br><span class="line"> How would you like to use ESLint? （你想如何使用 ESLint?）</span><br><span class="line">     To check syntax, find problems, and enforce code style（检查语法、发现问题并强制执行代码风格）</span><br><span class="line"> What type of modules does your project use?（你的项目使用哪种类型的模块?）</span><br><span class="line">     JavaScript modules (import&#x2F;export)</span><br><span class="line"> Which framework does your project use? （你的项目使用哪种框架?）</span><br><span class="line">     Vue.js</span><br><span class="line">Does your project use TypeScript?（你的项目是否使用 TypeScript？）</span><br><span class="line">    Yes</span><br><span class="line">Where does your code run?（你的代码在哪里运行?）</span><br><span class="line">    Browser 和 Node（按空格键进行选择，a全选，选完按回车键确定）      </span><br><span class="line">How would you like to define a style for your project?（你想怎样为你的项目定义风格？）</span><br><span class="line">    Use a popular style guide（使用一种流行的风格指南）</span><br><span class="line">Which style guide do you want to follow?（你想遵循哪一种风格指南?）</span><br><span class="line">    Airbnb、Standard、Google中我选择了Airbnb(https:&#x2F;&#x2F;github.com&#x2F;airbnb&#x2F;javascript)</span><br><span class="line">What format do you want your config file to be in?（你希望你的配置文件是什么格式?）</span><br><span class="line">    JavaScript</span><br><span class="line">Would you like to install them now with npm?（你想现在就用 NPM 安装它们吗?）  </span><br><span class="line">    Yes    &#x2F;&#x2F; 如果安装失败，手动安装</span><br></pre></td></tr></table></figure><p>配置完成后在项目根目录下面自动生成.eslintrc.js文件，在根目录下面新建.eslintignore文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .eslintignore</span><br><span class="line"># eslint 忽略检查</span><br><span class="line">node_modules</span><br><span class="line">dist</span><br><span class="line">!.prettierrc.js</span><br></pre></td></tr></table></figure><p>vscode在settings.json设置文件中增加以下代码，我是在工作区的设置文件中添加的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 每次保存时将代码按eslint格式进行保存</span><br><span class="line">  &quot;editor.codeActionsOnSave&quot;: &#123;</span><br><span class="line">    &quot;source.fixAll.eslint&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;eslint.run&quot;: &quot;onSave&quot;,</span><br><span class="line">  &#x2F;&#x2F; 添加vue支持</span><br><span class="line">  &quot;eslint.validate&quot;: [&quot;javascript&quot;, &quot;vue&quot;, &quot;html&quot;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决-ESLint-和-Prettier-的冲突"><a href="#解决-ESLint-和-Prettier-的冲突" class="headerlink" title="解决 ESLint 和 Prettier 的冲突"></a>解决 ESLint 和 Prettier 的冲突</h3><p>比如Airbnb代码结束需要增加封号，而Prettier不需要。<br>解决两者冲突问题，需要用到 eslint-plugin-prettier 和 eslint-config-prettier。</p><ul><li>eslint-plugin-prettier 将 Prettier 的规则设置到 ESLint 的规则中;</li><li>eslint-config-prettier 关闭 ESLint 中与 Prettier 中会发生冲突的规则;</li></ul><p>最后形成优先级：Prettier 配置规则 &gt; ESLint 配置规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装</span><br><span class="line">pnpm install eslint-plugin-prettier eslint-config-prettier -D</span><br><span class="line">&#x2F;&#x2F; 修改.eslintrc.js文件</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">     ... extends: [ </span><br><span class="line">         &#39;plugin:vue&#x2F;essential&#39;, </span><br><span class="line">         &#39;airbnb-base&#39;, </span><br><span class="line">         &#39;plugin:prettier&#x2F;recommended&#39; &#x2F;&#x2F; 添加 prettier 插件 </span><br><span class="line">     ], ... </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="配置vite-config-js"><a href="#配置vite-config-js" class="headerlink" title="配置vite.config.js"></a>配置vite.config.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &#39;vite&#39;</span><br><span class="line">import &#123; resolve &#125; from &#39;path&#39;</span><br><span class="line">import createVitePlugins from &#39;.&#x2F;vite&#x2F;plugins&#39;</span><br><span class="line"></span><br><span class="line">function resolvePath(paths) &#123;</span><br><span class="line">  return resolve(__dirname, paths)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;vitejs.dev&#x2F;config&#x2F;</span><br><span class="line">export default defineConfig((&#123; mode, command &#125;) &#x3D;&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    &#x2F;&#x2F; 项目中用到的插件集合</span><br><span class="line">    plugins: createVitePlugins(command &#x3D;&#x3D;&#x3D; &#39;build&#39;),</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      &#x2F;&#x2F; alias - 路径别名 https:&#x2F;&#x2F;cn.vitejs.dev&#x2F;config&#x2F;#resolve-alias</span><br><span class="line">      alias: &#123;</span><br><span class="line">        &#39;@&#39;: resolvePath(&#39;src&#39;),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 导入时想要省略的扩展名列表 https:&#x2F;&#x2F;cn.vitejs.dev&#x2F;config&#x2F;#resolve-extensions</span><br><span class="line">      extensions: [&#39;.mjs&#39;, &#39;.js&#39;, &#39;.ts&#39;, &#39;.jsx&#39;, &#39;.tsx&#39;, &#39;.json&#39;, &#39;.vue&#39;],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; server - 本地开发相关配置</span><br><span class="line">    server: &#123;</span><br><span class="line">      host: &#39;0.0.0.0&#39;, &#x2F;&#x2F; IP配置，支持从IP启动</span><br><span class="line">      port: 3000, &#x2F;&#x2F; 端口号</span><br><span class="line">      open: true, &#x2F;&#x2F; 自动打开浏览器</span><br><span class="line">      &#x2F;&#x2F; 接口代理</span><br><span class="line">      proxy: &#123;</span><br><span class="line">        &#39;&#x2F;vue3-admin&#39;: &#123;</span><br><span class="line">          target: &#96;http:&#x2F;&#x2F;vue.ruoyi.vip&#x2F;prod-api&#96;,</span><br><span class="line">          changeOrigin: true,</span><br><span class="line">          rewrite: (path) &#x3D;&gt; path.replace(&#x2F;^\&#x2F;vue3-admin&#x2F;, &#39;&#39;),</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="element-plus"><a href="#element-plus" class="headerlink" title="element-plus"></a>element-plus</h2><ol><li>安装并引入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装</span><br><span class="line">pnpm install element-plus</span><br><span class="line">&#x2F;&#x2F; main.js 完整引入</span><br><span class="line">import &#123; createApp &#125; from &#39;vue&#39;</span><br><span class="line">import ElementPlus from &#39;element-plus&#39;</span><br><span class="line">import &#39;element-plus&#x2F;dist&#x2F;index.css&#39;</span><br><span class="line">&#x2F;&#x2F; element-plus 国际化</span><br><span class="line">import zhCn from &#39;element-plus&#x2F;es&#x2F;locale&#x2F;lang&#x2F;zh-cn&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line"></span><br><span class="line">const app &#x3D; createApp(App)</span><br><span class="line">app.use(ElementPlus, &#123; size: &#39;small&#39;, locale: zhCn &#125;)</span><br><span class="line">app.mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure></li><li>自定义主题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; assets&#x2F;styles&#x2F;element-index.scss</span><br><span class="line">&#x2F;*</span><br><span class="line">  只需要重写你需要改变的颜色即可</span><br><span class="line">  可以在  element-plus&#x2F;theme-chalk&#x2F;src&#x2F;common&#x2F;var.scss 文件中查找SCSS变量。</span><br><span class="line">*&#x2F;</span><br><span class="line">$--color-primary: #409eff;</span><br><span class="line">$--color-success: #67c23a;</span><br><span class="line">$--color-warning: #e6a23c;</span><br><span class="line">$--color-danger: #f56c6c;</span><br><span class="line">$--color-info: #909399;</span><br><span class="line">@forward &#39;element-plus&#x2F;theme-chalk&#x2F;src&#x2F;common&#x2F;var.scss&#39; with (</span><br><span class="line">  $colors: (</span><br><span class="line">    &#39;primary&#39;: (</span><br><span class="line">      &#39;base&#39;: $--color-primary,</span><br><span class="line">    ),</span><br><span class="line">    &#39;success&#39;: (</span><br><span class="line">      &#39;base&#39;: $--color-success,</span><br><span class="line">    ),</span><br><span class="line">    &#39;warning&#39;: (</span><br><span class="line">      &#39;base&#39;: $--color-warning,</span><br><span class="line">    ),</span><br><span class="line">    &#39;danger&#39;: (</span><br><span class="line">      &#39;base&#39;: $--color-danger,</span><br><span class="line">    ),</span><br><span class="line">    &#39;error&#39;: (</span><br><span class="line">      &#39;base&#39;: $--color-danger,</span><br><span class="line">    ),</span><br><span class="line">    &#39;info&#39;: (</span><br><span class="line">      &#39;base&#39;: $--color-info,</span><br><span class="line">    ),</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 如果你想导入所有样式:</span><br><span class="line">@use &#39;element-plus&#x2F;theme-chalk&#x2F;src&#x2F;index.scss&#39; as *;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; main.js修改</span><br><span class="line">&#x2F;&#x2F; 引入element-index.scss文件，必须在引入element-plus之前，防止样式错乱</span><br><span class="line">import &#39;@&#x2F;assets&#x2F;styles&#x2F;element-index.scss&#39;</span><br><span class="line">import ElementPlus from &#39;element-plus&#39;</span><br></pre></td></tr></table></figure></li><li>全局使用icon<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、安装</span><br><span class="line">pnpm install @element-plus&#x2F;icons-vue</span><br><span class="line">&#x2F;&#x2F; 2、components&#x2F;SvgIcon&#x2F;svgicon.js</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @name install</span><br><span class="line"> * @description 全局注册使用element-plus的icon</span><br><span class="line"> *&#x2F;</span><br><span class="line">import * as components from &#39;@element-plus&#x2F;icons-vue&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  install: (app) &#x3D;&gt; &#123;</span><br><span class="line">    for (const key in components) &#123;</span><br><span class="line">      const componentConfig &#x3D; components[key]</span><br><span class="line">      app.component(componentConfig.name, componentConfig)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 3、全局注册main.js</span><br><span class="line">import elementIcons from &#39;@&#x2F;components&#x2F;SvgIcon&#x2F;svgicon&#39;</span><br><span class="line">app.use(elementIcons)</span><br></pre></td></tr></table></figure></li></ol><h2 id="vue-router4"><a href="#vue-router4" class="headerlink" title="vue-router4"></a>vue-router4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装</span><br><span class="line">pnpm install vue-router@4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; src下新建router&#x2F;index.js，里面有constantRoutes（公共路由）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import &#123; createApp &#125; from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">const app &#x3D; createApp(App)</span><br><span class="line">app.use(router)</span><br></pre></td></tr></table></figure><h2 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h2><p><a href="https://pinia.vuejs.org/" target="_blank" rel="noopener">pinia</a>状态管理，类似Vuex。<br><strong>Vuex 和 Pinia 的区别？</strong></p><ul><li>Pinia更轻量，比Vuex快；</li><li>没有mutations，更加简洁；</li><li>Pinia完整的支持TypeScript，添加TS比Vuex更容易；</li><li>Pinia支持多个store，Vuex一般只定义一个；</li><li>Pinia的action和普通函数一样，直接调用，而Vuex的action需要使用dispatch或者mapaction辅助函数；</li><li>Pinia不支持时间旅行和编辑等调试功能，而Vuex支持；</li><li>Pinia适合中小型项目，Vuex适合大型、高复杂度的项目。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 安装</span><br><span class="line">pnpm install pinia</span><br><span class="line">&#x2F;&#x2F; 2. 使用 src&#x2F;store</span><br><span class="line">&#x2F;&#x2F; src&#x2F;store&#x2F;index.js  全局pinia</span><br><span class="line">import &#123; createPinia &#125; from &#39;pinia&#39;</span><br><span class="line">const pinia &#x3D; createPinia()</span><br><span class="line">export default pinia</span><br><span class="line">&#x2F;&#x2F; src&#x2F;store&#x2F;modules  pinia模块</span><br><span class="line">app.js - 侧边栏配置、当前设备、element-plus的size</span><br><span class="line">permission.js - 动态路由</span><br><span class="line">settings.js - 项目布局模块</span><br><span class="line">tagsView.js - 框架顶部tags模块</span><br><span class="line">user.js - 用户操作模块：登录、用户信息、退出登录</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. main.js</span><br><span class="line">import &#123; createApp &#125; from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;</span><br><span class="line">const app &#x3D; createApp(App)</span><br><span class="line">app.use(store)</span><br></pre></td></tr></table></figure><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、安装</span><br><span class="line">pnpm install axios</span><br><span class="line">&#x2F;&#x2F; 2、src&#x2F;utils&#x2F;request.js 定义通讯</span><br><span class="line">&#x2F;&#x2F; 具体请查看https:&#x2F;&#x2F;gitee.com&#x2F;crystalSummer&#x2F;vue3-admin&#x2F;blob&#x2F;master&#x2F;src&#x2F;utils&#x2F;request.js</span><br></pre></td></tr></table></figure><h2 id="css处理器-–-Sass"><a href="#css处理器-–-Sass" class="headerlink" title="css处理器 – Sass"></a>css处理器 – Sass</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pnpm install sass</span><br><span class="line">&#x2F;&#x2F; src&#x2F;assets&#x2F;styles下写样式</span><br><span class="line">&#x2F;&#x2F; 具体请查看https:&#x2F;&#x2F;gitee.com&#x2F;crystalSummer&#x2F;vue3-admin&#x2F;tree&#x2F;master&#x2F;src&#x2F;assets&#x2F;styles</span><br></pre></td></tr></table></figure><h1 id="Vite插件"><a href="#Vite插件" class="headerlink" title="Vite插件"></a>Vite插件</h1><p>在项目根目录新建vite/plugins文件夹，下面是所有用到的Vite插件的配置。</p><h2 id="unplugin-auto-import-vite"><a href="#unplugin-auto-import-vite" class="headerlink" title="unplugin-auto-import/vite"></a>unplugin-auto-import/vite</h2><p><a href="https://www.npmjs.com/package/unplugin-auto-import" target="_blank" rel="noopener">unplugin-auto-import/vite</a>的作用是按需引入项目中常用的api，比如ref、computed就不需要手动引入，项目运行时会自动生成auto-imports.d.js文件，里面是全局声明的api。</p><h2 id="unplugin-vue-components-vite"><a href="#unplugin-vue-components-vite" class="headerlink" title="unplugin-vue-components/vite"></a>unplugin-vue-components/vite</h2><p><a href="https://www.npmjs.com/package/unplugin-vue-components" target="_blank" rel="noopener">unplugin-vue-components/vite</a>的作用是自动引入页面需要的组件，项目运行的时候会自动新建components.d.js文件，里面是全局安装的自动引入的组件。</p><p><strong>本框架未使用该插件</strong>。</p><h2 id="vite-plugin-svg-icons"><a href="#vite-plugin-svg-icons" class="headerlink" title="vite-plugin-svg-icons"></a>vite-plugin-svg-icons</h2><p><a href="https://github.com/vbenjs/vite-plugin-svg-icons/blob/main/README.zh_CN.md" target="_blank" rel="noopener">vite-plugin-svg-icons</a>用于生成svg雪碧图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、安装</span><br><span class="line">pnpm install vite-plugin-svg-icons -D</span><br><span class="line">&#x2F;&#x2F; 2、在 src&#x2F;main.js 内引入注册脚本</span><br><span class="line">import &#39;virtual:svg-icons-register&#39;</span><br><span class="line">import SvgIcon from &#39;@&#x2F;components&#x2F;SvgIcon&#39;</span><br><span class="line">app.component(&#39;svg-icon&#39;, SvgIcon)</span><br><span class="line">&#x2F;&#x2F; 3、使用-新增svgIcon组件</span><br><span class="line">&#x2F;&#x2F; 详情请查看https:&#x2F;&#x2F;gitee.com&#x2F;crystalSummer&#x2F;vue3-admin&#x2F;blob&#x2F;master&#x2F;src&#x2F;components&#x2F;SvgIcon&#x2F;index.vue</span><br></pre></td></tr></table></figure><h2 id="vite-plugin-compression"><a href="#vite-plugin-compression" class="headerlink" title="vite-plugin-compression"></a>vite-plugin-compression</h2><p><a href="https://github.com/vbenjs/vite-plugin-compression/blob/main/README.zh_CN.md" target="_blank" rel="noopener">vite-plugin-compression</a>的作用是使用 gzip 或者 brotli 来压缩资源。</p><h2 id="vite-plugin-vue-setup-extend"><a href="#vite-plugin-vue-setup-extend" class="headerlink" title="vite-plugin-vue-setup-extend"></a>vite-plugin-vue-setup-extend</h2><p><a href="https://github.com/vbenjs/vite-plugin-vue-setup-extend" target="_blank" rel="noopener">vite-plugin-vue-setup-extend</a>的作用是解决vue3下 script setup语法糖 下 ，手动设置组件name不方便的问题。</p><h1 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h1><h2 id="nprogress"><a href="#nprogress" class="headerlink" title="nprogress"></a>nprogress</h2><p><a href="https://ricostacruz.com/nprogress/" target="_blank" rel="noopener">nprogress</a>是一个进度条插件，通过和路由配合，显示页面切换进程的进度条。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 安装</span><br><span class="line">pnpm  install --save nprogress</span><br><span class="line">&#x2F;&#x2F; 2. 使用</span><br><span class="line">import NProgress from &#39;nprogress&#39;</span><br><span class="line">import &#39;nprogress&#x2F;nprogress.css&#39;</span><br><span class="line">NProgress.configure(&#123; showSpinner: false &#125;)</span><br><span class="line">NProgress.start()</span><br><span class="line">NProgress.done()</span><br></pre></td></tr></table></figure><h1 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h1><h2 id="js-cookie"><a href="#js-cookie" class="headerlink" title="js-cookie"></a>js-cookie</h2><p><a href="https://www.npmjs.com/package/js-cookie" target="_blank" rel="noopener">js-cookie</a>一个简单、轻量级的处理cookie的js API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 安装</span><br><span class="line">pnpm install js-cookie</span><br><span class="line">&#x2F;&#x2F; 2. 使用 src&#x2F;utils&#x2F;auth.js 用于操作token</span><br><span class="line">import Cookies from &#39;js-cookie&#39;</span><br><span class="line">const TokenKey &#x3D; &#39;Admin-Token&#39;</span><br><span class="line">export function getToken() &#123;</span><br><span class="line">  return Cookies.get(TokenKey)</span><br><span class="line">&#125;</span><br><span class="line">export function setToken(token) &#123;</span><br><span class="line">  return Cookies.set(TokenKey, token)</span><br><span class="line">&#125;</span><br><span class="line">export function removeToken() &#123;</span><br><span class="line">  return Cookies.remove(TokenKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="file-saver"><a href="#file-saver" class="headerlink" title="file-saver"></a>file-saver</h2><p><a href="https://www.npmjs.com/package/file-saver" target="_blank" rel="noopener">file-saver</a>浏览器下载文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 安装</span><br><span class="line">pnpm install file-saver --save</span><br><span class="line">&#x2F;&#x2F; 2. 使用 src&#x2F;utils&#x2F;request.js 下载</span><br><span class="line">import &#123; saveAs &#125; from &#39;file-saver&#39;;</span><br><span class="line">saveAs(Blob&#x2F;File&#x2F;Url, optional DOMString filename, optional Object &#123; autoBom &#125;)</span><br></pre></td></tr></table></figure><h2 id="jsencrypt"><a href="#jsencrypt" class="headerlink" title="jsencrypt"></a>jsencrypt</h2><p>jsencrypt是基于RSA对数据进行加解密的JS工具，RSA是非对称加密，采用不同的密钥（加密用公钥，解密用私钥）对数据进行加密和解密操作，具体的算法原理可以查看以下文章：</p><ul><li><a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener"><strong>阮一峰网络日志-RSA算法原理（一）</strong></a></li><li><a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener"><strong>阮一峰网络日志-RSA算法原理（二）</strong></a></li></ul><p>密钥对生成：</p><ul><li>MAC系统内置OpenSSL(开源加密库),所以可以直接在终端上使用命令；</li><li>Windows系统可以使用Git命令行工具；</li><li>在线生成密钥对：<a href="http://web.chacuo.net/netrsakeypair" target="_blank" rel="noopener"><strong>http://web.chacuo.net/netrsakeypair</strong></a>。</li></ul><p>目前最常用的场景就是前端记住密码的操作，将密码加密保存在cookie中，回显的时候获取加密的数据进行解密，比如若依前端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 安装</span><br><span class="line">pnpm install jsencrypt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 引入</span><br><span class="line">import JSEncrypt from &#39;jsencrypt&#x2F;bin&#x2F;jsencrypt.min&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 具体使用</span><br><span class="line">const publicKey &#x3D; &#39;...........&#39;</span><br><span class="line">const privateKey &#x3D; &#39;...........&#39;</span><br><span class="line">&#x2F;&#x2F; 加密</span><br><span class="line">export function encrypt(txt: string) &#123;</span><br><span class="line">  const encryptor &#x3D; new JSEncrypt()</span><br><span class="line">  encryptor.setPublicKey(publicKey) &#x2F;&#x2F; 设置公钥</span><br><span class="line">  return encryptor.encrypt(txt) &#x2F;&#x2F; 对数据进行加密</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解密</span><br><span class="line">export function decrypt(txt: string) &#123;</span><br><span class="line">  const encryptor &#x3D; new JSEncrypt()</span><br><span class="line">  encryptor.setPrivateKey(privateKey) &#x2F;&#x2F; 设置私钥</span><br><span class="line">  return encryptor.decrypt(txt) &#x2F;&#x2F; 对数据进行解密</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vueuse-core"><a href="#vueuse-core" class="headerlink" title="@vueuse/core"></a>@vueuse/core</h2><p>@vueuse/core是为Vue 2和3服务的一套Vue Composition API的常用工具集，通俗的来说，就是一个工具函数包，它可以帮助快速实现一些常见的功能，不用自己手写，解决重复手写工具函数实现的问题。</p><p>常见常用的API如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装</span><br><span class="line">pnpm install @vueuse&#x2F;core</span><br><span class="line">&#x2F;&#x2F; 监听视窗尺寸</span><br><span class="line">import &#123; useWindowSize &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">const windowSize &#x3D; reactive(useWindowSize())</span><br><span class="line">console.log(windowSize.width,windowSize.height)</span><br><span class="line">&#x2F;&#x2F; 监听鼠标坐标位置</span><br><span class="line">import &#123; useMouse &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">const mousePosition &#x3D; reactive(useMouse())</span><br><span class="line">console.log(mousePosition.x,mousePosition.y)</span><br><span class="line">&#x2F;&#x2F; 判断用户是否喜欢深色</span><br><span class="line">import &#123; usePreferredDark &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">const isDark &#x3D; usePreferredDark()</span><br><span class="line">&#x2F;&#x2F; 设置浏览器title</span><br><span class="line">import &#123; useTitle &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">const title &#x3D; useTitle()</span><br><span class="line">console.log(title.value) &#x2F;&#x2F; print current title</span><br><span class="line">title.value &#x3D; &#39;Hello&#39; &#x2F;&#x2F; change current title</span><br><span class="line">&#x2F;&#x2F; copy</span><br><span class="line">import &#123; useClipboard &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">const source &#x3D; ref(&#39;Hello&#39;)</span><br><span class="line">const &#123; text, copy, copied, isSupported &#125; &#x3D; useClipboard(&#123; source &#125;)</span><br><span class="line">&#x2F;&#x2F; 防抖</span><br><span class="line">import &#123; debounceFilter &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">&#x2F;&#x2F; 100ms后更新鼠标的位置</span><br><span class="line">const &#123; x, y &#125; &#x3D; useMouse(&#123; eventFilter: debounceFilter(100) &#125;)</span><br><span class="line">&#x2F;&#x2F; 节流</span><br><span class="line">import &#123; throttleFilter，useLocalStorage &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">&#x2F;&#x2F; 以节流的方式去改变 localStorage 的值</span><br><span class="line">const storage &#x3D; useLocalStorage(&#39;my-key&#39;, &#123; foo: &#39;bar&#39; &#125;, &#123; eventFilter: throttleFilter(1000) &#125;)</span><br><span class="line">&#x2F;&#x2F; 全屏</span><br><span class="line">import &#123; useFullscreen &#125; from &#39;@vueuse&#x2F;core&#39;</span><br><span class="line">const &#123; isFullscreen, enter, exit, toggle &#125; &#x3D; useFullscreen();</span><br></pre></td></tr></table></figure><p>VueUse封装了很多其他的API，具体内容可以查看<a href="https://vueuse.org/" target="_blank" rel="noopener"><strong>VueUse官网</strong></a>。</p><h2 id="fuse-js"><a href="#fuse-js" class="headerlink" title="fuse.js"></a>fuse.js</h2><p><a href="https://fusejs.io/" target="_blank" rel="noopener">Fuse.js</a>是一个功能强大、轻量级的模糊搜索库，没有依赖关系。一般来说，模糊搜索（更正式地称为近似字符串匹配）是一种寻找近似等于给定模式（而不是精确地）的字符串的技术。</p><h1 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h1><h2 id="新增-view"><a href="#新增-view" class="headerlink" title="新增 view"></a>新增 view</h2><p>在<code>@/views</code>文件下创建对应的文件夹，一般一个路由对应一个文件，该模块下的功能就建议在本文件夹下创建一个新文件夹，各个功能模块维护自己的<code>utils</code>或<code>components</code>组件。</p><h2 id="新增-api"><a href="#新增-api" class="headerlink" title="新增 api"></a>新增 api</h2><p>在<code>@/api</code>文件夹下创建本模块对应的 api 服务。</p><h2 id="新增组件"><a href="#新增组件" class="headerlink" title="新增组件"></a>新增组件</h2><p>在全局的<code>@/components</code>写一些全局的组件，如富文本，各种搜索组件，封装的分页组件等等能被公用的组件。<br>每个页面或者模块特定的业务组件则会写在当前<code>@/views</code>下面。如：<code>@/views/system/user/components/xxx.vue</code>。这样拆分大大减轻了维护成本。</p><h2 id="新增样式"><a href="#新增样式" class="headerlink" title="新增样式"></a>新增样式</h2><p>页面的样式和组件是一个道理，全局的<code>@/style</code>放置一下全局公用的样式，每一个页面的样式就写在当前<code>views</code>下面，请记住加上<code>scoped</code>就只会作用在当前组件内了，避免造成全局的样式污染。</p><h1 id="权限-角色使用"><a href="#权限-角色使用" class="headerlink" title="权限/角色使用"></a>权限/角色使用</h1><p>框架封装了全局指令<code>v-hasPermi</code>权限字符串和<code>v-hasRole</code>角色字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 单个权限</span><br><span class="line">&lt;el-button v-hasPermi&#x3D;&quot;[&#39;system:user:add&#39;]&quot;&gt;存在权限字符串才能看到&lt;&#x2F;el-button&gt;</span><br><span class="line">&#x2F;&#x2F; 多个权限</span><br><span class="line">&lt;el-button v-hasPermi&#x3D;&quot;[&#39;system:user:add&#39;, &#39;system:user:edit&#39;]&quot;&gt;包含权限字符串才能看到&lt;&#x2F;el-button&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 单个角色</span><br><span class="line">&lt;el-button v-hasRole&#x3D;&quot;[&#39;admin&#39;]&quot;&gt;管理员才能看到&lt;&#x2F;el-button&gt;</span><br><span class="line">&#x2F;&#x2F; 多个角色</span><br><span class="line">&lt;el-button v-hasRole&#x3D;&quot;[&#39;role1&#39;, &#39;role2&#39;]&quot;&gt;包含角色才能看到&lt;&#x2F;el-button&gt;</span><br></pre></td></tr></table></figure><p>在某些情况下，不适合使用指令，只能通过<code>v-if</code>手动设置，以使用全局权限/角色判断函数<code>checkPermi</code>和<code>checkRole</code>，用法和指令 <code>v-hasPermi</code>和<code>v-hasRole</code> 类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-tabs&gt;</span><br><span class="line">    &lt;el-tab-pane v-if&#x3D;&quot;checkPermi([&#39;system:user:add&#39;])&quot; label&#x3D;&quot;用户管理&quot; name&#x3D;&quot;user&quot;&gt;用户管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">    &lt;el-tab-pane v-if&#x3D;&quot;checkPermi([&#39;system:user:add&#39;, &#39;system:user:edit&#39;])&quot; label&#x3D;&quot;参数管理&quot; name&#x3D;&quot;menu&quot;&gt;参数管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">    &lt;el-tab-pane v-if&#x3D;&quot;checkRole([&#39;admin&#39;])&quot; label&#x3D;&quot;角色管理&quot; name&#x3D;&quot;role&quot;&gt;角色管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">    &lt;el-tab-pane v-if&#x3D;&quot;checkRole([&#39;admin&#39;,&#39;common&#39;])&quot; label&#x3D;&quot;定时任务&quot; name&#x3D;&quot;job&quot;&gt;定时任务&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">   &lt;&#x2F;el-tabs&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> &#x2F;&#x2F; 权限判断函数</span><br><span class="line">import &#123; checkPermi, checkRole &#125; from &quot;@&#x2F;utils&#x2F;permission&quot;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h1 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h1><h2 id="auth对象"><a href="#auth对象" class="headerlink" title="$auth对象"></a>$auth对象</h2><p><code>$auth</code>对象用于验证用户是否拥有某（些）权限或角色，它定义在<code>plugins/auth.js</code>文件中，它有如下方法：</p><ul><li>验证用户权限<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 验证用户是否具备某权限</span><br><span class="line">this.$auth.hasPermi(&quot;system:user:add&quot;);</span><br><span class="line">&#x2F;&#x2F; 验证用户是否含有指定权限，只需包含其中一个</span><br><span class="line">this.$auth.hasPermiOr([&quot;system:user:add&quot;, &quot;system:user:update&quot;]);</span><br><span class="line">&#x2F;&#x2F; 验证用户是否含有指定权限，必须全部拥有</span><br><span class="line">this.$auth.hasPermiAnd([&quot;system:user:add&quot;, &quot;system:user:update&quot;]);</span><br></pre></td></tr></table></figure></li><li>验证用户角色<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 验证用户是否具备某角色</span><br><span class="line">this.$auth.hasRole(&quot;admin&quot;);</span><br><span class="line">&#x2F;&#x2F; 验证用户是否含有指定角色，只需包含其中一个</span><br><span class="line">this.$auth.hasRoleOr([&quot;admin&quot;, &quot;common&quot;]);</span><br><span class="line">&#x2F;&#x2F; 验证用户是否含有指定角色，必须全部拥有</span><br><span class="line">this.$auth.hasRoleAnd([&quot;admin&quot;, &quot;common&quot;]);</span><br></pre></td></tr></table></figure></li></ul><h2 id="download对象"><a href="#download对象" class="headerlink" title="$download对象"></a>$download对象</h2><p><code>$download</code>对象用于文件下载，它定义在<code>plugins/download.js</code>文件中，它有如下方法：</p><ul><li>根据名称下载download路径下的文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const name &#x3D; &quot;be756b96-c8b5-46c4-ab67-02e988973090.xlsx&quot;;</span><br><span class="line">const isDelete &#x3D; true;</span><br><span class="line">&#x2F;&#x2F; 默认下载方法</span><br><span class="line">this.$download.name(name);</span><br><span class="line">&#x2F;&#x2F; 下载完成后是否删除文件</span><br><span class="line">this.$download.name(name, isDelete);</span><br></pre></td></tr></table></figure></li><li>根据名称下载upload路径下的文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const resource &#x3D; &quot;&#x2F;profile&#x2F;upload&#x2F;2021&#x2F;09&#x2F;27&#x2F;be756b96-c8b5-46c4-ab67-02e988973090.png&quot;;</span><br><span class="line">&#x2F;&#x2F; 默认方法</span><br><span class="line">this.$download.resource(resource);</span><br></pre></td></tr></table></figure></li><li>根据请求地址下载zip包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const url &#x3D; &quot;&#x2F;tool&#x2F;gen&#x2F;batchGenCode?tables&#x3D;&quot; + tableNames;</span><br><span class="line">const name &#x3D; &quot;vue3-admin&quot;;</span><br><span class="line">&#x2F;&#x2F; 默认方法</span><br><span class="line">this.$download.zip(url, name);</span><br></pre></td></tr></table></figure></li><li>更多文件下载操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义文本保存</span><br><span class="line">var blob &#x3D; new Blob([&quot;Hello, world!&quot;], &#123;type: &quot;text&#x2F;plain;charset&#x3D;utf-8&quot;&#125;);</span><br><span class="line">this.$download.saveAs(blob, &quot;hello world.txt&quot;);</span><br><span class="line">&#x2F;&#x2F; 自定义文件保存</span><br><span class="line">var file &#x3D; new File([&quot;Hello, world!&quot;], &quot;hello world.txt&quot;, &#123;type: &quot;text&#x2F;plain;charset&#x3D;utf-8&quot;&#125;);</span><br><span class="line">this.$download.saveAs(file);</span><br><span class="line">&#x2F;&#x2F; 自定义data数据保存</span><br><span class="line">const blob &#x3D; new Blob([data], &#123; type: &#39;text&#x2F;plain;charset&#x3D;utf-8&#39; &#125;)</span><br><span class="line">this.$download.saveAs(blob, name)</span><br><span class="line">&#x2F;&#x2F; 根据地址保存文件</span><br><span class="line">this.$download.saveAs(&quot;https:&#x2F;&#x2F;ruoyi.vip&#x2F;images&#x2F;logo.png&quot;, &quot;logo.jpg&quot;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="modal对象"><a href="#modal对象" class="headerlink" title="$modal对象"></a>$modal对象</h2><p><code>$modal</code>对象用于做消息提示、通知提示、对话框提醒、二次确认、遮罩等，它定义在<code>plugins/modal.js</code>文件中，它有如下方法：</p><ul><li>提供成功、警告和错误等反馈信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$modal.msg(&quot;默认反馈&quot;);</span><br><span class="line">this.$modal.msgError(&quot;错误反馈&quot;);</span><br><span class="line">this.$modal.msgSuccess(&quot;成功反馈&quot;);</span><br><span class="line">this.$modal.msgWarning(&quot;警告反馈&quot;);</span><br></pre></td></tr></table></figure></li><li>提供成功、警告和错误等提示信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$modal.alert(&quot;默认提示&quot;);</span><br><span class="line">this.$modal.alertError(&quot;错误提示&quot;);</span><br><span class="line">this.$modal.alertSuccess(&quot;成功提示&quot;);</span><br><span class="line">this.$modal.alertWarning(&quot;警告提示&quot;);</span><br></pre></td></tr></table></figure></li><li>提供成功、警告和错误等通知信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$modal.notify(&quot;默认通知&quot;);</span><br><span class="line">this.$modal.notifyError(&quot;错误通知&quot;);</span><br><span class="line">this.$modal.notifySuccess(&quot;成功通知&quot;);</span><br><span class="line">this.$modal.notifyWarning(&quot;警告通知&quot;);</span><br></pre></td></tr></table></figure></li><li>提供确认窗体信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.$modal.confirm(&#39;确认信息&#39;).then(function() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;).catch(() &#x3D;&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure></li><li>提供遮罩层信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打开遮罩层</span><br><span class="line">this.$modal.loading(&quot;正在导出数据，请稍后...&quot;);</span><br><span class="line">&#x2F;&#x2F; 关闭遮罩层</span><br><span class="line">this.$modal.closeLoading();</span><br></pre></td></tr></table></figure></li></ul><h2 id="cache对象"><a href="#cache对象" class="headerlink" title="$cache对象"></a>$cache对象</h2><p><code>$cache</code>对象用于处理缓存。不建议直接使用sessionStorage或localStorage，因为项目的缓存策略可能发生变化，通过$cache对象做一层调用代理则是一个不错的选择。$cache提供session和local两种级别的缓存。</p><h2 id="tab对象"><a href="#tab对象" class="headerlink" title="$tab对象"></a>$tab对象</h2><p><code>$tab</code>对象用于做页签操作、刷新页签、关闭页签、打开页签、修改页签等，它定义在<code>plugins/tab.js</code>文件中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2018/04/28/22/03/dawn-3358468_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="http://crystalsummer.gitee.io/categories/Vue/"/>
    
      <category term="Frame" scheme="http://crystalsummer.gitee.io/categories/Vue/Frame/"/>
    
    
      <category term="Vue" scheme="http://crystalsummer.gitee.io/tags/Vue/"/>
    
      <category term="Frame" scheme="http://crystalsummer.gitee.io/tags/Frame/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 - monorepo</title>
    <link href="http://crystalsummer.gitee.io/2022/03/28/Vue3%20-%20monorepo/"/>
    <id>http://crystalsummer.gitee.io/2022/03/28/Vue3%20-%20monorepo/</id>
    <published>2022-03-28T10:45:50.000Z</published>
    <updated>2023-06-21T07:35:41.574Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2022/09/07/17/26/vintage-pocket-watch-7439233_1280.jpg" alt=""></p><a id="more"></a><h1 id="Vue2-和-Vue3-的区别"><a href="#Vue2-和-Vue3-的区别" class="headerlink" title="Vue2 和 Vue3 的区别"></a>Vue2 和 Vue3 的区别</h1><ul><li>vue2 对 typescript 不友好。</li><li>vue2是选项API - options，逻辑过于分散，Vue3采用组合式API - setup，代码更简洁。</li><li>vue2大量的API挂载到vue对象的原型上，难以实现treeShaking，vue3做了性能上的优化，没有用到的方法，打包的时候将不会对其进行打包。</li><li>vue3对虚拟dom进行了重写，对模版的编译进行了优化。</li></ul><h1 id="monorepo"><a href="#monorepo" class="headerlink" title="monorepo"></a>monorepo</h1><p>monorepo 是将多个项目代码存储到一个仓库里的代码管理模式，一个项目一个包，每个包独立发布且互不干扰（mono：单一，repo：仓库）。<br>代码复用和重构变得简单，跨组合作更方便，但是每个项目缺少了权限的控制，随着整体代码量的变多，构建的时间也会变得更长。</p><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>新建vue3文件夹，使用<code>yarn init -y</code>初始化项目，出来一个对应的package.json文件，在里面加上配置项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 私有化</span><br><span class="line">    &quot;private&quot;: true,</span><br><span class="line">    &#x2F;&#x2F; 利用 workspace 特性复用 package，内部代码可以彼此相互引用；</span><br><span class="line">    &quot;workspaces&quot;:[</span><br><span class="line">        &quot;packages&#x2F;*&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建子包"><a href="#创建子包" class="headerlink" title="创建子包"></a>创建子包</h2><ul><li><p>vue3文件夹下新建packages文件夹，里面存放所有的包，新建reactivity-响应式原理，shared-公共方法两个包，分别在两个包下面执行<code>yarn init -y</code>进行初始化操作，各出现一个package.json文件，在里面修改name配置项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 在原有的名称之前加上@vue&#x2F;，包之间的相互引用就是根据这个name引用的</span><br><span class="line">    &quot;name&quot;:&quot;@vue&#x2F;reactivity&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在每个包下面新建src文件夹，src下新建index.ts文件，之后monorepo打包，会把所有的东西放在这个index.ts文件里面</p></li><li><p>既然使用到了ts,那么就需要安装ts，由于每个包都需要用到ts，所以在根目录下执行命令<code>yarn add typescript -D -W</code>安装ts，注意：这个项目由于使用了workspace，所以安装插件需要加上-W。</p></li><li><p>安装完ts后，需要对ts进行配置，可以使用tsc自动生成一个ts配置文件tsconfig.json。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在vue3文件夹下执行此命令</span><br><span class="line">npx tsc --init</span><br></pre></td></tr></table></figure></li></ul><h2 id="安装rollup打包相关的依赖"><a href="#安装rollup打包相关的依赖" class="headerlink" title="安装rollup打包相关的依赖"></a>安装rollup打包相关的依赖</h2><p>在根目录vue3下面执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; rollup-plugin-typescript2 解析ts</span><br><span class="line">&#x2F;&#x2F; @rollup&#x2F;plugin-node-resolve 处理解析第三方插件</span><br><span class="line">&#x2F;&#x2F; @rollup&#x2F;plugin-json 解析json</span><br><span class="line">&#x2F;&#x2F; execa 开启子进程，用来将packages下面所有的包一起进行打包</span><br><span class="line">yarn add rollup rollup-plugin-typescript2 @rollup&#x2F;plugin-node-resolve @rollup&#x2F;plugin-json execa -D -W</span><br></pre></td></tr></table></figure><h2 id="配置rollup打包配置文件"><a href="#配置rollup打包配置文件" class="headerlink" title="配置rollup打包配置文件"></a>配置rollup打包配置文件</h2><h3 id="配置build-js"><a href="#配置build-js" class="headerlink" title="配置build.js"></a>配置build.js</h3><ul><li><p>创建打包脚本命令<br>在根目录的package.json里面配置打包命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;build&quot;: &quot;node scripts&#x2F;build.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建scripts文件夹，新建build.js文件，里面配置打包的具体操作。<br>在终端执行npm run build，相当于通过node 执行build.js文件。</p></li><li><p>配置包的打包格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; reactivity 下的 package.json 配置自定义打包项</span><br><span class="line">&#123;</span><br><span class="line">    &quot;buildOptions&quot;:&#123;</span><br><span class="line">        &quot;name&quot;:&quot;VueReactivity&quot;,</span><br><span class="line">        &quot;formats&quot;:[</span><br><span class="line">            &quot;esm-bundler&quot;,  &#x2F;&#x2F; 将es6变成es5，处理js</span><br><span class="line">            &quot;cjs&quot;,          &#x2F;&#x2F; 处理common.js，node</span><br><span class="line">            &quot;global&quot;        &#x2F;&#x2F; 处理全局的方法，比如window</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; shared 下的 package.json 配置自定义打包项</span><br><span class="line">&#123;</span><br><span class="line">    &quot;buildOptions&quot;:&#123;</span><br><span class="line">        &quot;name&quot;:&quot;VueShared&quot;,</span><br><span class="line">        &quot;formats&quot;:[</span><br><span class="line">            &quot;esm-bundler&quot;,</span><br><span class="line">            &quot;cjs&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行打包<br>通过monorepo打包，对packages下面的每个文件进行打包，在build.js配置打包的具体操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 读取需要打包的文件目录</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;)</span><br><span class="line"></span><br><span class="line">const dirs &#x3D; fs.readdirSync(&#39;packages&#39;).filter(p&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F; 打包只针对packages下面的文件夹，如果是其他的单文件，将不进行打包</span><br><span class="line">    if(!fs.statSync(&#96;packages&#x2F;$&#123;p&#125;&#96;).isDirectory())&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(dirs) &#x2F;&#x2F; [&#39;reactivity&#39;,&#39;shared&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 并行打包 使用promise对所有的包进行打包</span><br><span class="line">import execa from &#39;execa&#39;</span><br><span class="line">&#x2F;&#x2F; target - 要打包的包名称</span><br><span class="line">async function build(target)&#123;</span><br><span class="line">    console.log(target)</span><br><span class="line">    &#x2F;&#x2F; execa开启子进程，所有的包一起打包，eseca返回promise</span><br><span class="line">    &#x2F;&#x2F; rollup-打包方式 -c-执行rollup配置 --env-环境变量  stdio: &#39;inherit&#39;-子进程的输出在父包中可以输出看到</span><br><span class="line">    await return execa(&#39;rollup&#39;,[&#39;-c&#39;,&#39;--environment&#39;,&#96;TARGET:$&#123;target&#125;&#96;],&#123;stdio: &#39;inherit&#39;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; dirs-需要打包的包的文件名数组 build-单个包打包的方法</span><br><span class="line">function runParallel(dirs,build)&#123;</span><br><span class="line">    let result &#x3D; []</span><br><span class="line">    for(let item of dirs)&#123;</span><br><span class="line">        result.push(build(item))</span><br><span class="line">    &#125;</span><br><span class="line">    return Promise.all(result)</span><br><span class="line">&#125;</span><br><span class="line">runParallel(dirs,build).then(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;打包成功&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印target时能打印出来的，但是最后会报错，因为rollup配置还没有添加</p></li></ul><h3 id="配置rollup-config-js"><a href="#配置rollup-config-js" class="headerlink" title="配置rollup.config.js"></a>配置rollup.config.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 引入相关依赖</span><br><span class="line">import ts from &quot;rollup-plugin-typescript2&quot; &#x2F;&#x2F; 解析ts </span><br><span class="line">import json from &#39;@rollup&#x2F;plugin-json&#39;</span><br><span class="line">import resolvePlugin from &#39;@rollup&#x2F;plugin-node-resolve&#39;</span><br><span class="line">import path from &#39;path&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 获取文件路径</span><br><span class="line">&#x2F;&#x2F; 2.1 packages文件夹路径</span><br><span class="line">const packagesDir &#x3D; path.resolve(__dirname, &#39;packages&#39;)</span><br><span class="line">console.log(packagesDir) &#x2F;&#x2F; 打印出来的是packages文件夹在系统中的文件路径</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.2 packages下各个包的文件路径</span><br><span class="line">const packageDir &#x3D; path.resolve(packagesDir, process.env.TARGET)</span><br><span class="line">console.log(packageDir) &#x2F;&#x2F; 打印出来的是packages下的各个包的文件路径</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.3 获取各个包下面的打包输出配置 buildOptions</span><br><span class="line">const resolve &#x3D; p &#x3D;&gt; path.resolve(packageDir, p)</span><br><span class="line">const pkg &#x3D; require(resolve(&#96;package.json&#96;))</span><br><span class="line">const packageOptions &#x3D; pkg.buildOptions || &#123;&#125;</span><br><span class="line">const name &#x3D; path.basename(packageDir) &#x2F;&#x2F; 包名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 创建一个打包输出配置项输出文件的映射表</span><br><span class="line">const outputConfigs &#x3D; &#123;</span><br><span class="line">  &#39;esm-bundler&#39;: &#123;</span><br><span class="line">    file: resolve(&#96;dist&#x2F;$&#123;name&#125;.esm-bundler.js&#96;), &#x2F;&#x2F; 打包输出的文件路径</span><br><span class="line">    format: &#96;es&#96;</span><br><span class="line">  &#125;,</span><br><span class="line">  cjs: &#123;</span><br><span class="line">    file: resolve(&#96;dist&#x2F;$&#123;name&#125;.cjs.js&#96;),</span><br><span class="line">    format: &#96;cjs&#96;</span><br><span class="line">  &#125;,</span><br><span class="line">  global: &#123;</span><br><span class="line">    file: resolve(&#96;dist&#x2F;$&#123;name&#125;.global.js&#96;),</span><br><span class="line">    format: &#96;iife&#96;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4. 导出一个rollup配置</span><br><span class="line">function createConfig(format,output)&#123;</span><br><span class="line">    output.name &#x3D; packageOptions.name</span><br><span class="line">    output.sourcemap &#x3D; true</span><br><span class="line">    return &#123;</span><br><span class="line">        input:path.resolve(&#39;src&#x2F;index.ts&#39;), &#x2F;&#x2F; 导入</span><br><span class="line">        output,</span><br><span class="line">        plugins:[ &#x2F;&#x2F; 插件，即上面引入的rollup需要用到的插件</span><br><span class="line">            json(),</span><br><span class="line">            ts(&#123; &#x2F;&#x2F; 解析ts</span><br><span class="line">                tsconfig:path.resolve(__dirname,&#39;tsconfig.json&#39;)</span><br><span class="line">            &#125;),</span><br><span class="line">            resolvePlugin() &#x2F;&#x2F; 解析第三方插件</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export packageOptions.formats.map(format&#x3D;&gt;&#123;</span><br><span class="line">    createConfig(format,outputConfigs)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>到这里就可以执行<code>npm run build</code>进行打包了，报错的话一般都是tsconfig.json里面的配置有问题，如module值需要改成esnext，sourcemap需要打开等等，配置成功后进行打包，各个包下面就会生成dist文件夹，下面是各种格式的打包文件。</p><h2 id="开发环境自动打包"><a href="#开发环境自动打包" class="headerlink" title="开发环境自动打包"></a>开发环境自动打包</h2><p>上面打包是所有的包全部并行，但是在开发过程中，如果只修改了一个包的某个文件，那么我们就需要进行自动打包，方便操作。<br>打包方法和build中的方法类似，只是去掉了并行打包，改成单包打包，并将rollup的配置<code>-c</code>换成<code>-cw</code>，这样修改代码后就会自动打包了。如果不换的话就需要手动执行命令打包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 在根目录的package.json里面添加dev命令</span><br><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;dev&quot;: &quot;node scripts&#x2F;dev.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 在script文件夹下面新增dev.js文件，内容如下</span><br><span class="line">import execa from &#39;execa&#39;</span><br><span class="line">&#x2F;&#x2F; target - 要打包的包名称</span><br><span class="line">async function build(target)&#123;</span><br><span class="line">    &#x2F;&#x2F; execa开启子进程，所有的包一起打包，eseca返回promise</span><br><span class="line">    &#x2F;&#x2F; rollup-打包方式 -c-执行rollup配置 --env-环境变量  stdio: &#39;inherit&#39;-子进程的输出在父包中可以输出看到</span><br><span class="line">    await return execa(&#39;rollup&#39;,[&#39;-cw&#39;,&#39;--environment&#39;,&#96;TARGET:$&#123;target&#125;&#96;],&#123;stdio: &#39;inherit&#39;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build(&#39;reactivity&#39;)</span><br></pre></td></tr></table></figure><h2 id="包的相互引用"><a href="#包的相互引用" class="headerlink" title="包的相互引用"></a>包的相互引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在reactivity&#x2F;index.ts里面引入shared包里面的方法或者变量</span><br><span class="line">import &#123;&#125; from &#39;@vue&#x2F;shared&#39;</span><br><span class="line">&#x2F;&#x2F; 这里引入的包名就是子包初始化的时候修改的name，在node_modules里面也会有相对的链接</span><br><span class="line">&#x2F;&#x2F; 但是这里会报错：@vue&#x2F;shared找不到，这个tsconfig.json缺少配置，添加如下配置：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;baseUrl&quot;: &quot;.&quot;,</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,</span><br><span class="line">    &quot;paths&quot;: &#123;</span><br><span class="line">      &quot;@vue&#x2F;*&quot;: [&quot;packages&#x2F;*&#x2F;src&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化-pnpm"><a href="#优化-pnpm" class="headerlink" title="优化-pnpm"></a>优化-pnpm</h2><p>将 yarn 替换成 pnpm，解决依赖平铺等问题，但是 pnpm 的 workspace 不是配置在 package.json 文件中，而是新建 pnpm-workspace.yaml 来定义工作空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">packages:</span><br><span class="line">  - &#39;packages&#x2F;*&#39;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2022/09/07/17/26/vintage-pocket-watch-7439233_1280.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="http://crystalsummer.gitee.io/categories/Vue/"/>
    
      <category term="原理" scheme="http://crystalsummer.gitee.io/categories/Vue/%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Vue" scheme="http://crystalsummer.gitee.io/tags/Vue/"/>
    
      <category term="原理" scheme="http://crystalsummer.gitee.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Vue3</title>
    <link href="http://crystalsummer.gitee.io/2022/01/15/Vue3/"/>
    <id>http://crystalsummer.gitee.io/2022/01/15/Vue3/</id>
    <published>2022-01-15T05:45:50.000Z</published>
    <updated>2023-06-28T07:29:37.200Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2018/07/18/15/43/animal-3546613_960_720.jpg" alt=""></p><a id="more"></a><h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="Vue3-和-Vue2-的区别"><a href="#Vue3-和-Vue2-的区别" class="headerlink" title="Vue3 和 Vue2 的区别"></a>Vue3 和 Vue2 的区别</h2><ul><li><strong>片段</strong>：Vue2 只能有一个根节点，Vue3 支持多个，也就是片段。</li><li><strong>数据响应式原理不同</strong>：Vue2 是采用<code>Object.defineProperty()</code>对属性进行劫持，而 Vue3 是采用 Proxy + Reflect。</li><li><strong>全局API-创建应用实例不同</strong>：Vue2是new Vue()，Vue3是createApp()。</li><li><strong>API不同</strong>：Vue2采用选项API - options，逻辑过于分散，Vue3采用组合式API - setup，代码更简洁。</li><li>v-model语法糖默认值不同：Vue2默认是value prop + input emit，Vue3默认是modelValue prop + update:modelValue emit</li><li>v-if和v-for的优先级不同：Vue2中v-for的v-if的优先级高，Vue3中v-if的优先级比v-for高，导致v-if不能使用v-for的条件</li><li>生命周期不同：<table><thead><tr><th align="center">Vue2</th><th align="center">Vue3</th></tr></thead><tbody><tr><td align="center">beforeCreate()</td><td align="center">setup()</td></tr><tr><td align="center">created()</td><td align="center">setup()</td></tr><tr><td align="center">beforeMount()</td><td align="center">onBeforeMount()</td></tr><tr><td align="center">mounted()</td><td align="center">onMounted()</td></tr><tr><td align="center">beforeUpdate()</td><td align="center">onBeforeUpdate()</td></tr><tr><td align="center">update()</td><td align="center">onUpdated()</td></tr><tr><td align="center">beforeDestroy()</td><td align="center">onBeforeUnmount()</td></tr><tr><td align="center">destroyed()</td><td align="center">onUnmounted()</td></tr><tr><td align="center">activated()</td><td align="center">onActivated()</td></tr><tr><td align="center">deactivated()</td><td align="center">onDeactivated()</td></tr></tbody></table></li><li>v-model</li><li>父子传参不同</li><li>diff算法不同：Vue2</li><li>Teleport</li></ul><h2 id="Vue3-优点"><a href="#Vue3-优点" class="headerlink" title="Vue3 优点"></a>Vue3 优点</h2><ul><li>使用Proxy进行响应式变量定义，性能提高1.2~2倍</li><li>SSR服务端渲染快了2~3倍</li><li>可在Vue2.0中单独使用composition-api插件，或者直接用它开发插件</li><li>对typescript支持更加友好</li></ul><h2 id="Vue3-缺点"><a href="#Vue3-缺点" class="headerlink" title="Vue3 缺点"></a>Vue3 缺点</h2><p>不再支持IE</p><h1 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h1><p><strong>Vue2 只能有一个根节点，Vue3 支持多个，也就是片段。</strong></p><p>如果组件是单个根节点，非 prop 的属性如果被定义，会被根节点继承，如果不想根节点继承的话，可以在选项中设置<code>inheritAttrs:false</code>，然后使用<code>v-bind=&quot;$attrs&quot;</code>将非 prop 的属性应用在其他某个元素上。</p><p>如果组件是多个根节点，非 prop 的属性如果被定义，组件一定要通过<code>v-bind=&quot;$attrs&quot;</code>显式绑定到某个元素上，否则是有警告。</p><h1 id="数据响应式-核心-Proxy"><a href="#数据响应式-核心-Proxy" class="headerlink" title="数据响应式 - 核心 Proxy"></a>数据响应式 - 核心 Proxy</h1><p>数据响应式原理的源码是在<code>packages/reactivity</code>文件夹里，查看源码需要了解ES6知识点：</p><ul><li><a href="https://crystalsummer.gitee.io/2021/07/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%B8%89)/#Proxy">Proxy</a></li><li><a href="https://crystalsummer.gitee.io/2021/07/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%B8%89)/#Reflect">Reflect</a></li><li><a href="https://crystalsummer.gitee.io/2021/07/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%B8%89)/#Reflect">Map</a></li><li><a href="https://crystalsummer.gitee.io/2021/07/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%B8%89)/#Set">Set</a></li></ul><h2 id="使用-Proxy-重构的原因"><a href="#使用-Proxy-重构的原因" class="headerlink" title="使用 Proxy 重构的原因"></a>使用 Proxy 重构的原因</h2><p>在 Vue2 中，如果数据是对象的话，会对对象遍历，然后使用<code>Object.defineProperty()</code>方法对数据进行 set 和 get 劫持，但是对于新增的或者删除的属性无法被监听到；如果数据是数组的话，重写了数组的七种变异方法实现数据响应，但是通过数组下标修改数组中的数据、通过修改数组长度清空数组 的操作方式来修改数组也是无法被监听到。</p><p>对于 Vue2 中存在的问题，使用 Proxy 就可以完美解决。</p><h2 id="Proxy-与-Object-defineProperty-优劣对比"><a href="#Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="Proxy 与 Object.defineProperty 优劣对比"></a>Proxy 与 Object.defineProperty 优劣对比</h2><p>Proxy 的优点如下:</p><ul><li>Proxy 可以直接监听对象而非属性，并且Proxy 返回的是一个新对象,我们只需要操作新的对象就可以达到目的，而<code>Object.defineProperty</code>需要遍历对象属性修改；</li><li>Proxy 可以直接监听数组的变化；</li><li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是<code>Object.defineProperty</code> 不具备的；</li><li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ul><p>Proxy 的缺点如下:</p><ul><li>基本数据类型响应式的实现，导致必须将其包裹成一个带有value的对象，通过<code>.value</code>的方式访问；</li><li>ES6解构不能随意使用，会破坏数据的响应式特性。</li></ul><p>Object.defineProperty 的优点如下:</p><ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平。</li></ul><p>Object.defineProperty 的缺点如下:</p><ul><li>针对对象，对于新增的或者删除的属性无法被监听到；</li><li>针对数组，通过数组下标修改数组中的数据、通过修改数组长度清空数组 的操作方式来修改数组也是无法被监听到。</li></ul><h1 id="数据响应式-reactive-shallowReactive-readonly-shallowReadonly-原理"><a href="#数据响应式-reactive-shallowReactive-readonly-shallowReadonly-原理" class="headerlink" title="数据响应式 - reactive/shallowReactive/readonly/shallowReadonly 原理"></a>数据响应式 - reactive/shallowReactive/readonly/shallowReadonly 原理</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><code>reactive()</code>接收对象参数，返回一个新的对象。<ul><li>当 ref 定义的变量在 reactive 定义的变量里面，reactive 会将 ref 解包，并维持 ref 的响应性；但是如果 ref 定义的变量是数组或 Map 这样的集合类型的数据，放到 reactive 里面 ref 不会被解包。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const count &#x3D; ref(1)</span><br><span class="line">const obj &#x3D; reactive(&#123; count &#125;)</span><br><span class="line">&#x2F;&#x2F; ref 会被解包</span><br><span class="line">console.log(obj.count &#x3D;&#x3D;&#x3D; count.value) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 它会更新 &#96;obj.count&#96;</span><br><span class="line">count.value++</span><br><span class="line">console.log(count.value) &#x2F;&#x2F; 2</span><br><span class="line">console.log(obj.count) &#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 它也会更新 &#96;count&#96; ref</span><br><span class="line">obj.count++</span><br><span class="line">console.log(obj.count) &#x2F;&#x2F; 3</span><br><span class="line">console.log(count.value) &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ref变量是数组，所以ref不会被解包</span><br><span class="line">const books &#x3D; reactive([ref(&#39;Vue 3 Guide&#39;)])</span><br><span class="line">&#x2F;&#x2F; 这里需要 .value</span><br><span class="line">console.log(books[0].value)</span><br></pre></td></tr></table></figure></li><li>ref 赋值给 reactive 的一个属性的时候，ref 会被解包。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const count &#x3D; ref(1)</span><br><span class="line">const obj &#x3D; reactive(&#123;&#125;)</span><br><span class="line">obj.count &#x3D; count</span><br><span class="line">console.log(obj.count &#x3D;&#x3D;&#x3D; count.value) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li></ul></li><li><code>shallowReactive()</code>是<code>reactive()</code>的浅层作用形式，只有根级别的属性是响应式的，嵌套在深层的属性不是响应式的。</li><li><code>readonly</code>接受一个对象 (不论是响应式还是普通的) 或是一个 ref，返回一个原值的只读代理。</li><li><code>shallowReadonly</code>是<code>readonly</code>的浅层作用形式，只有根层级的属性变为了只读，嵌套在深层的属性是可写的。</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="createReactiveObject"><a href="#createReactiveObject" class="headerlink" title="createReactiveObject()"></a>createReactiveObject()</h3><p>这四个方法这接收一个 target 作为入参，函数内部真正的核心代码都在<code>createReactiveObject()</code>函数中，只不过传入的参数不同。<br>这四个方法区别重点在于<strong>是否是深度的，是否是只读的</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">reactive(target)&#123;</span><br><span class="line">    if (isReadonly(target)) &#123;          &#x2F;&#x2F; target 是否只读，是的话直接返回该参数；</span><br><span class="line">        return target</span><br><span class="line">    &#125;</span><br><span class="line">    return createReactiveObject(</span><br><span class="line">        target,                        &#x2F;&#x2F; 传入的要被创建响应式的对象</span><br><span class="line">        false,                         &#x2F;&#x2F; 不可只读</span><br><span class="line">        mutableHandlers,               &#x2F;&#x2F; 普通对象(数组、对象)的 proxy 的处理函数   baseHandlers.ts</span><br><span class="line">        mutableCollectionHandlers,     &#x2F;&#x2F; 集合数据(Map WeakMap Set  WeakSet)的 proxy 的处理函数 collectionHandlers.ts</span><br><span class="line">        reactiveMap                    &#x2F;&#x2F; 存储所有 proxy 的 WeakMap</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shallowReactive(target)&#123;</span><br><span class="line">    return createReactiveObject(</span><br><span class="line">        target,</span><br><span class="line">        false,</span><br><span class="line">        shallowReactiveHandlers,</span><br><span class="line">        shallowCollectionHandlers,</span><br><span class="line">        shallowReactiveMap</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readonly(target)&#123;</span><br><span class="line">    return createReactiveObject(</span><br><span class="line">        target,</span><br><span class="line">        true,</span><br><span class="line">        readonlyHandlers,</span><br><span class="line">        readonlyCollectionHandlers,</span><br><span class="line">        readonlyMap</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shallowReadonly(target)&#123;</span><br><span class="line">    return createReactiveObject(</span><br><span class="line">        target,</span><br><span class="line">        true,</span><br><span class="line">        shallowReadonlyHandlers,</span><br><span class="line">        shallowReadonlyCollectionHandlers,</span><br><span class="line">        shallowReadonlyMap</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createReactiveObject(target,isReadonly,baseHandlers,collectionHandlers,proxyMap)&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>createReactiveObject()</code>入参：<ul><li>target：传入的要被创建响应式的对象；</li><li>isReadonly：是否只读；</li><li>baseHandlers：普通对象(数组、对象)的 proxy 的处理函数；<ul><li>reactive&emsp;&emsp;&emsp;&emsp;&emsp;对应&emsp;mutableHandlers；</li><li>shallowReactive&emsp;对应&emsp;shallowReactiveHandlers</li><li>readonly&emsp;&emsp;&emsp;&emsp; 对应&emsp;readonlyHandlers</li><li>shallowReadonly&emsp;对应&emsp;shallowReadonlyHandlers</li></ul></li><li>collectionHandlers：集合数据(Map WeakMap Set  WeakSet)的 proxy 的处理函数；<ul><li>reactive&emsp;&emsp;&emsp;&emsp;&emsp;对应&emsp;mutableCollectionHandlers；</li><li>shallowReactive&emsp;对应&emsp;shallowCollectionHandlers</li><li>readonly &emsp;&emsp;&emsp;&emsp; 对应&emsp;readonlyCollectionHandlers</li><li>shallowReadonly&emsp;对应&emsp;shallowReadonlyCollectionHandlers</li></ul></li><li>proxyMap：存储所有 proxy 的 WeakMap。<ul><li>reactive&emsp;&emsp;&emsp;&emsp;&emsp;对应&emsp;reactiveMap</li><li>shallowReactive&emsp;对应&emsp;shallowReactiveMap</li><li>readonly&emsp;&emsp;&emsp;&emsp;  对应&emsp;readonlyMap</li><li>shallowReadonly&emsp;对应&emsp;shallowReadonlyMap</li></ul></li></ul></li><li><code>createReactiveObject()</code>细节处理：<ul><li>target 是否是对象，不是的话抛出警告并且返回原来的值；</li><li>target 是否已经被代理，是的话直接把该对象返回，防止重复代理 —— 从 proxyMap 里面获取 key 为 target 的响应式对象，存在的话直接返回；</li><li>判断 target 类型是否是 Object、Array、Map、Set、WeakMap、WeakSet 中的一种，不是的话不创建代理，直接返回；</li><li>使用 Proxy 对 target 进行代理，如果 target 是 Object、Array 执行<code>baseHandlers</code>代理拦截函数，如果 target 是 Map、Set、WeakMap、WeakSet 就执行<code>collectionHandlers</code>代理拦截函数；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const proxy &#x3D; new Proxy(</span><br><span class="line">    target,</span><br><span class="line">    targetType &#x3D;&#x3D;&#x3D; TargetType.COLLECTION ? collectionHandlers : baseHandlers</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li>代理完成后用 proxyMap 存储下来。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxyMap.set(target, proxy)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Proxy-handler-代理拦截函数"><a href="#Proxy-handler-代理拦截函数" class="headerlink" title="Proxy handler 代理拦截函数"></a>Proxy handler 代理拦截函数</h3><p>Proxy handler 代理拦截函数分为：</p><ul><li><code>baseHandlers</code>：对普通对象(Object、Array)的<code>get set deleteProperty has ownKeys</code>的操作进行拦截监听；</li><li><code>collectionHandlers</code>：对集合数据(Map、Set、WeakMap、WeakSet)的 API 进行<strong>函数劫持</strong>，将所有 API 的访问替换成自己写的方法。</li></ul><h4 id="baseHandlers"><a href="#baseHandlers" class="headerlink" title="baseHandlers"></a>baseHandlers</h4><p><code>baseHandlers</code>代理拦截函数对普通对象(Object、Array)的<code>get set deleteProperty has ownKeys</code>的操作进行拦截监听。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export const mutableHandlers &#x3D; &#123;</span><br><span class="line">    get,set,deleteProperty,has,ownKeys</span><br><span class="line">&#125;</span><br><span class="line">export const readonlyHandlers &#x3D; &#123;&#125;</span><br><span class="line">export const shallowReactiveHandlers &#x3D; &#123;&#125;</span><br><span class="line">export const shallowReadonlyHandlers &#x3D; &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>实现 get 拦截监听<br>由于这四个方法的 get 拦截监听相似，只是核心区别<strong>是否只读，是否深度响应</strong>不同，所以调用同一个方法<code>createGetter</code>，传入不同的参数，实现 get 拦截监听。<div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin:20px 0;'> 注意：vue3这里做了性能的优化，如果数据是深层嵌套的，vue2的话，就需要循环递归，但是在vue3中，如果深层嵌套的数据没有被使用，那么就不会被代理，简称 <span style="font-weight:bold">懒代理</span>。比如：state={a:1,list:[]}，如果没有用到 state.list，那么list就没有被代理，只有用到的时候才会触发 get 拦截方法，将list进行代理。</div></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const get &#x3D; createGetter()</span><br><span class="line">const shallowGet &#x3D; createGetter(false, true)</span><br><span class="line">const readonlyGet &#x3D; createGetter(true)</span><br><span class="line">const shallowReadonlyGet &#x3D; createGetter(true, true)</span><br><span class="line"></span><br><span class="line">function createGetter(isReadonly &#x3D; false, shallow &#x3D; false)&#123;</span><br><span class="line">    return function get(target, key, receiver) &#123;</span><br><span class="line">        const res &#x3D; Reflect.get(target, key, receiver)</span><br><span class="line">        &#x2F;&#x2F; 如果不是只读的</span><br><span class="line">        if(!isReadonly)&#123;</span><br><span class="line">            &#x2F;&#x2F; 收集依赖 - TrackOpTypes是枚举类的操作类型，这里指 get</span><br><span class="line">            &#x2F;&#x2F; TrackOpTypes&#x3D;&#123;</span><br><span class="line">            &#x2F;&#x2F;     GET:&#39;get&#39;,</span><br><span class="line">            &#x2F;&#x2F;     HAS:&#39;has&#39;</span><br><span class="line">            &#x2F;&#x2F; &#125;</span><br><span class="line">            track(target,TrackOpTypes.GET,key)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果不是深度响应，是浅的，直接将第一层返回</span><br><span class="line">        if(shallow)&#123;</span><br><span class="line">            return res</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果数据是深层嵌套，被使用了就执行readonly&#x2F;reactive代理，没有被使用就不代理——懒代理</span><br><span class="line">        if(isObject(res))&#123;</span><br><span class="line">            return isReadonly ? readonly(res) : reactive(res)</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现 set 拦截监听<br>set 是在数据发生变更、赋值的时候才会被触发，对于 readonly 和 shallowReadonly 来说，数据只读不可变更，所以不会触发 set。<br>而 reactive 和 shallowReactive 的区别在于是否是深度响应，所以可以共用一个<code>createSetter</code>方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const set &#x3D; createSetter()</span><br><span class="line">const shallowSet &#x3D; createSetter(true)</span><br><span class="line"></span><br><span class="line">function createSetter(shallow &#x3D; false) &#123;</span><br><span class="line">    return function set(target, key, value, receiver)&#123;</span><br><span class="line">        &#x2F;&#x2F; 触发更新 依赖更新派发</span><br><span class="line">        &#x2F;&#x2F; 重点：（1）target是数组还是对象 （2）是添加值还是修改值</span><br><span class="line">        &#x2F;&#x2F; 获取旧值</span><br><span class="line">        const oldValue &#x3D; target[key]</span><br><span class="line">        &#x2F;&#x2F; hadKey true-修改值 false-添加值            </span><br><span class="line">        &#x2F;&#x2F;             判断是否是数组，并且key的是数字下标             </span><br><span class="line">        const hadKey &#x3D; isArray(target) &amp;&amp; isIntegerKey(key) </span><br><span class="line">            ? (Number(key) &lt; target.length)   &#x2F;&#x2F; 下标key&lt;数组的长度 true&#x2F;false </span><br><span class="line">            : hasOwn(target, key)      &#x2F;&#x2F; target对象是否有key属性 true&#x2F;false</span><br><span class="line">        const result &#x3D; Reflect.set(target, key, value, receiver) &#x2F;&#x2F; 获取最新的值</span><br><span class="line">        if(!hadKey)&#123; &#x2F;&#x2F; 新增值</span><br><span class="line">            trigger(target, TriggerOpTypes.ADD, key, value)</span><br><span class="line">        &#125;else&#123; &#x2F;&#x2F; 修改值 新值和旧值一样，不触发更新</span><br><span class="line">            if(value!&#x3D;&#x3D;oldValue)&#123;</span><br><span class="line">                trigger(target, TriggerOpTypes.SET, key, value, oldValue)</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="collectionHandlers"><a href="#collectionHandlers" class="headerlink" title="collectionHandlers"></a>collectionHandlers</h4><p>对集合数据原生的 API 进行<strong>函数劫持</strong>，在实现原有的 API 功能的基础上进行了其他的操作</p><h3 id="收集依赖-track"><a href="#收集依赖-track" class="headerlink" title="收集依赖 - track"></a>收集依赖 - track</h3><h4 id="收集依赖-effect"><a href="#收集依赖-effect" class="headerlink" title="收集依赖 - effect"></a>收集依赖 - effect</h4><p>effect 相当于 vue2 中的 watch，入参是一个函数和一个option，函数默认执行，函数里面可以获取被代理过的数据，获取数据触发 get 拦截收集 effect，修改数据触发 set 拦截执行 effect。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; effect 使用</span><br><span class="line">const state &#x3D; reactive(&#123;name:&#39;张三&#39;,age:20&#125;)</span><br><span class="line">effect(()&#x3D;&gt;&#123;  &#x2F;&#x2F; 函数默认执行，获取代理的数据，执行 get，收集 effect</span><br><span class="line">    console.log(state.name+state.age) &#x2F;&#x2F; 张三20</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(()&#x3D;&gt;&#123; &#x2F;&#x2F; 修改数据触发 set，执行 effect</span><br><span class="line">    state.name &#x3D; &#39;李四&#39;  &#x2F;&#x2F; effect执行，这个时候打印出来的是:李四20</span><br><span class="line">&#125;,1000)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; option 传入 lazy:true ，代表懒加载，入参函数默认不执行</span><br></pre></td></tr></table></figure><p>effect实现过程如下：</p><ol><li>创建一个响应式的effect，执行用户的方法，默认执行；</li><li>定义相关属性，用来区分每个数据的effect；</li><li>定义activeEffect用来保存当前的effect；</li><li>定义栈结构effectStack=[]解决effect嵌套和重复调用问题——嵌套可以使用入栈和出栈的方式解决，重复调用可以使用数组判断的方式解决。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、定义effect，两个入参，fn和options</span><br><span class="line">export const effect(fn,options)&#123;</span><br><span class="line">    &#x2F;&#x2F; 创建一个响应式的effect</span><br><span class="line">    const effect &#x3D; createReactiveEffect(fn,options)</span><br><span class="line">    &#x2F;&#x2F; 默认执行</span><br><span class="line">    if(!options.lazy)&#123;</span><br><span class="line">        effect()</span><br><span class="line">    &#125;</span><br><span class="line">    return effect</span><br><span class="line">&#125;</span><br><span class="line">let uid &#x3D; 0</span><br><span class="line">let activeEffect &#x2F;&#x2F; 3、保存当前的effect</span><br><span class="line">const effectStack &#x3D; [] &#x2F;&#x2F; 4、栈结构</span><br><span class="line">function createReactiveEffect(fn,options)&#123;</span><br><span class="line">    const effect &#x3D; function reactiveEffect()&#123; &#x2F;&#x2F; 创建一个响应式的effect</span><br><span class="line">        if(!effectStack.include(effect))&#123; &#x2F;&#x2F; 保证 effect 没有加入到 effectStack</span><br><span class="line">            try&#123;</span><br><span class="line">                effectStack.push(effect) &#x2F;&#x2F; 入栈</span><br><span class="line">                activeEffect &#x3D; effect</span><br><span class="line">                fn() &#x2F;&#x2F; 执行用户的方法</span><br><span class="line">            &#125;finally&#123; &#x2F;&#x2F; 出栈</span><br><span class="line">                effectStack.pop()</span><br><span class="line">                activeEffect &#x3D; effectStack[effectStack.length-1]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2、定义相关属性，因为effect是用来收集依赖，更新视图的，每个数据都有一个effect，所以需要进行区分</span><br><span class="line">    effect.id &#x3D; uid++ &#x2F;&#x2F; 区别 effect</span><br><span class="line">    effect._isEffect &#x3D; true &#x2F;&#x2F; 区别 effect 是不是响应式的effect</span><br><span class="line">    effect.raw &#x3D; fn &#x2F;&#x2F; 保存用户方法</span><br><span class="line">    effect.options &#x3D; options &#x2F;&#x2F; 保存用户属性</span><br><span class="line">    return effect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="收集-effect-依赖-track"><a href="#收集-effect-依赖-track" class="headerlink" title="收集 effect 依赖 - track"></a>收集 effect 依赖 - track</h4><p>收集 effect 依赖，主要就是理清 key 与 effect 一一对应的关系：</p><ul><li><strong>effect(fn,options)——收集依赖</strong>：获取属性，触发get，使用<code>effect()</code>副作用函数对依赖进行收集，<code>effectStack</code>作为全局变量effect的栈来管理 effect；</li><li><strong>dep = new Set()——收集effect</strong>：使用 Set 来存储 effect；</li><li><strong>depsMap = new Map()——收集dep</strong>：一个对象有多个不同的属性，就会有多个不同的 effect，也就会有多个 dep，使用 Map 收集所有的 dep；</li><li><strong>targetMap = new WeakMap()——收集depsMap</strong>：项目运行会有多个对象，就会有多个 depsMap，使用 WeakMap 收集所有的 depsMap。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let targetMap &#x3D; new WeakMap()</span><br><span class="line">export function track(target,type,key)&#123;</span><br><span class="line">    if(!activeEffect) return &#x2F;&#x2F; 数据没有在effect中使用，所以不收集</span><br><span class="line">    &#x2F;&#x2F; 获取effect</span><br><span class="line">    &#x2F;&#x2F; 1. 从targetMap中获取当前对象的map</span><br><span class="line">    let depsMap &#x3D; targetMap.get(target)</span><br><span class="line">    &#x2F;&#x2F; 如果当前对象没有map，就创建</span><br><span class="line">    if(!depsMap) targetMap.set(target, (depsMap &#x3D; new Map()))</span><br><span class="line">    &#x2F;&#x2F; 2. 从当前对象的map，即depsMap中获取当前属性key的set</span><br><span class="line">    let dep &#x3D; depsMap.get(key)</span><br><span class="line">    &#x2F;&#x2F; 如果当前对象的属性没有set，就创建</span><br><span class="line">    if(!dep) depsMap.set(key,(dep &#x3D; new Set()))</span><br><span class="line">    &#x2F;&#x2F; 3. 判断当前属性的effect是否收集过</span><br><span class="line">    if(!dep.has(activeEffect))&#123;</span><br><span class="line">        dep.add(activeEffect) &#x2F;&#x2F; 收集effect</span><br><span class="line">        activeEffect.deps.push(dep)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="触发更新-trigger"><a href="#触发更新-trigger" class="headerlink" title="触发更新 - trigger"></a>触发更新 - trigger</h3><p>当属性发生变更，触发set调用<code>trigger()</code>，拿到属性对应的依赖并执行effect。</p><p>为了防止属性值多次被修改且修改的值相同，多次执行相同effect的问题发生，需要使用Set去重过滤。</p><p>这里需要注意的是target的类型：</p><ul><li>target 是对象，就直接获取effect去重之后执行；</li><li>target 是数组：<ul><li>通过length修改数组需要特殊处理，如果更改的长度 小于 收集的索引key，那么这个索引需要重新执行effect；</li><li>通过下标修改数组，判断type是新增还是修改，新增的话需要取length的effect去重后执行，修改的话直接取effect去重之后执行。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; type-操作类型 add-新增 set-修改 </span><br><span class="line">export function trigger(target,type,key,newValue,oldValue)&#123;</span><br><span class="line">    const depsMap &#x3D; targetMap.get(target)</span><br><span class="line">    if(!depsMap) return</span><br><span class="line">    &#x2F;&#x2F; 获取当前属性的effect执行，触发更新</span><br><span class="line">    &#x2F;&#x2F; 但是存在问题，如果属性值多次修改且修改的值相同，就会多次执行相同effect</span><br><span class="line">    &#x2F;&#x2F; let dep &#x3D; depsMap.get(key)</span><br><span class="line">    &#x2F;&#x2F; if(dep)&#123;</span><br><span class="line">    &#x2F;&#x2F;     dep.forEach(effect&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;         effect()</span><br><span class="line">    &#x2F;&#x2F;     &#125;)</span><br><span class="line">    &#x2F;&#x2F; &#125;</span><br><span class="line">    &#x2F;&#x2F; 优化：使用set过滤dep的effect</span><br><span class="line">    let effectSet &#x3D; new Set()</span><br><span class="line">    const add &#x3D; (effectAdd)&#x3D;&gt;&#123;</span><br><span class="line">        if(effectAdd)&#123;</span><br><span class="line">            effectAdd.forEach(effect&#x3D;&gt;effectSet.add(effect))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果是数组，并且通过length修改数组</span><br><span class="line">    if(isArray(target) &amp;&amp; key&#x3D;&#x3D;&#x3D;&#39;length&#39;)&#123;</span><br><span class="line">        const newLength &#x3D; Number(newValue)</span><br><span class="line">        depsMap.forEach((dep, key) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果更改的长度 小于 收集的索引key，那么这个索引需要重新执行effect</span><br><span class="line">            &#x2F;&#x2F; a&#x3D;[1,2,3]  a[2]&#x3D;3 &#x3D;&gt; a.length&#x3D;1 &#x3D;&gt; 执行当前索引的effect a[2]&#x3D;undefined</span><br><span class="line">            &#x2F;&#x2F; a&#x3D;[1,2,3]  a.length&#x3D;5 &#x3D;&gt; 执行当前索引的effect a&#x3D;[1,2,3,epmty*2]</span><br><span class="line">            if (key &#x3D;&#x3D;&#x3D; &#39;length&#39; || key &gt;&#x3D; newLength) &#123;</span><br><span class="line">                add(dep)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F; 对象</span><br><span class="line">        if(key !&#x3D;&#x3D; undefined)&#123;</span><br><span class="line">            add(depsMap.get(key))</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 数组</span><br><span class="line">        switch(type)&#123;</span><br><span class="line">            case TriggerOpTypes.ADD:</span><br><span class="line">                if (!isArray(target) &amp;&amp; isIntegerKey(key)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 新增的话，取length</span><br><span class="line">                    add(depsMap.get(&#39;length&#39;))</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case TriggerOpTypes.SET:</span><br><span class="line">                if (isMap(target)) &#123;</span><br><span class="line">                    add(depsMap.get(key))</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 循环执行effect</span><br><span class="line">    effectSet.forEach(effect&#x3D;&gt;effect())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> reactive数据响应式原理是将数据进行 proxy 代理，对于 Object、Array 这样的普通对象，将它们的<code>get set deleteProperty has ownKeys</code>的操作进行拦截监听，当触发 get 操作的时候，使用<code>track()</code>函数对副作用函数<code>effect()</code>进行依赖收集，当触发 set 操作的时候，使用<code>trigger()</code>函数拿到对应的<code>effect()</code>执行进行依赖更新派发；对于集合数据，Proxy 将它们对应的 API 进行函数劫持，将所有 API 的访问替换成自己写的方法。</p><p><strong>vue3对数据响应做了性能的优化</strong>：如果数据是深层嵌套的，vue2的话，就需要循环递归，但是在vue3中，如果深层嵌套的数据没有被使用，那么就不会被代理，简称<strong>懒代理</strong>。比如：state={a:1,list:[]}，如果没有用到 state.list，那么就不会触发get里的<code>reactive()</code>，list就没有被代理，只有用到的时候才会触发 get 拦截方法，将list进行代理。</p><p><strong>track收集依赖</strong>：获取数据，触发get，使用<code>track()</code>函数对副作用函数<code>effect()</code>进行依赖收集，只需要理清 key 与 effect 一一对应的关系，收集过程就一目了然，<code>dep = new Set()</code>存储effect =&gt; <code>depsMap = new Map()</code>存储dep =&gt; <code>targetMap = new WeakMap()</code>存储depsMap</p><p><strong>trigger更新依赖</strong>：数据发生变更，触发set，使用<code>trigger()</code>函数拿到属性对应的依赖并执行effect进行依赖更新派发，Object 直接获取 effect 去重后执行，Array 通过 length 修改数组需要特殊处理。 </p><h1 id="数据响应式-ref-shallowRef"><a href="#数据响应式-ref-shallowRef" class="headerlink" title="数据响应式 - ref/shallowRef"></a>数据响应式 - ref/shallowRef</h1><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ol><li><code>ref()</code>接收参数并将其包裹成一个带有 value 属性的对象返回。<br>一般用于基本数据类型，也就是说 ref 创建了一个响应式的引用，这样就可以保持数据的统一。<br>如果传入的参数是对象，那么底层会走<code>reactive()</code>。<br>setup中返回一个对象，属性是ref，那么template中使用不需要value，已经自动浅解析。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const count &#x3D; ref(0)</span><br><span class="line">console.log(count) &#x2F;&#x2F; &#123;value:0&#125;</span><br><span class="line">console.log(count.value) &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure></li><li><code>shallowRef()</code>是<code>ref()</code>的浅层作用形式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const state &#x3D; shallowRef(&#123; count: 1 &#125;)</span><br><span class="line">&#x2F;&#x2F; 不会触发更改</span><br><span class="line">state.value.count &#x3D; 2</span><br><span class="line">&#x2F;&#x2F; 会触发更改</span><br><span class="line">state.value &#x3D; &#123; count: 2 &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><h3 id="createRef"><a href="#createRef" class="headerlink" title="createRef()"></a>createRef()</h3><p>ref 和 shallowRef 接收一个 value 作为入参，调用<code>createRef()</code>函数，直接返回一个 RefImpl 的实体类。<br>这两个方法的区别在于是否是深度代理，所以<code>createRef()</code>函数入参：</p><ul><li>value：传入的数据</li><li>shallow：是否是浅层代理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export function ref(value)&#123;</span><br><span class="line">    return createRef(value,false)</span><br><span class="line">&#125;</span><br><span class="line">export function shallowRef(value)&#123;</span><br><span class="line">    return createRef(value,true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createRef(value,shallow&#x3D;false)&#123;</span><br><span class="line">    &#x2F;&#x2F; 通过判断value是否拥有__is_ref&#x3D;true的属性，有的话代表已经使用ref代理过了，直接返回</span><br><span class="line">    if(isRef(value))&#123;</span><br><span class="line">        return value</span><br><span class="line">    &#125;</span><br><span class="line">    return new RefImpl(value,shallow)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RefImpl"><a href="#RefImpl" class="headerlink" title="RefImpl"></a>RefImpl</h3><p>创建 RefImpl 类：</p><ol><li>给 ref 添加属性，如_value _rawValue(存放原始值) __is_ref(标识是否是通过ref实现代理) __v_isShallow(是否是深度响应)等；</li><li>在构造函数中进行赋值操作，使用 _rawValue 保存原始值，_value 保存基本数据类型/已经被reactive代理过的数据；</li><li>使用类的属性访问器<code>get value</code> 和 <code>set value</code>，实现数据获取和更改的监听。<br>通过value获取数据触发get，调用 track 函数收集依赖，并返回值；<br>通过value修改数据触发set，调用 trigger 函数更新依赖，并进行赋值操作。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class RefImpl&#123;</span><br><span class="line">    &#x2F;&#x2F; 1. 添加属性</span><br><span class="line">    private _value</span><br><span class="line">    private _rawValue</span><br><span class="line"></span><br><span class="line">    public __is_ref &#x3D; true &#x2F;&#x2F; 标识是否是通过ref实现代理</span><br><span class="line">    constructor(public value,public __v_isShallow)&#123;</span><br><span class="line">        this._rawValue &#x3D; __v_isShallow ? value : toRaw(value)</span><br><span class="line">        this._value &#x3D; __v_isShallow ? value : （ isObject(value) ? reactive(value) : value）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 类的属性访问器</span><br><span class="line">    get value()&#123;</span><br><span class="line">        &#x2F;&#x2F; 收集依赖</span><br><span class="line">        track(this,TrackOpTypes.GET,&#39;value&#39;)</span><br><span class="line">        return this._value</span><br><span class="line">    &#125;</span><br><span class="line">    set value(newVal)&#123;</span><br><span class="line">        if(newVal !&#x3D;&#x3D; this._value)&#123;</span><br><span class="line">            this._value &#x3D; newVal</span><br><span class="line">            this._rawValue &#x3D; newVal</span><br><span class="line">            &#x2F;&#x2F; 更新依赖</span><br><span class="line">            trigger(this,TriggerOpTypes.SET, &#39;value&#39;, newVal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>ref数据响应式原理是引用数据类型走 reactive，基本数据类型通过创建 RefImpl 类，使用类的属性访问器<code>get value</code> 和 <code>set value</code>，实现数据获取和更改的监听，这是ES6的写法，打包成ES5的代码后发现其实就是 <code>Object.defineProperty</code>，这是因为基本数据类型的操作不像引用数据类型那样多，大多是都是获取和修改，使用<code>Object.defineProperty</code>更为合理。ref的依赖的收集和更新同reactive一样的原理，都用通过effect副作用函数实现。</p><h1 id="数据响应式-toRef"><a href="#数据响应式-toRef" class="headerlink" title="数据响应式 - toRef()"></a>数据响应式 - toRef()</h1><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p><code>toRef()</code>接收三个参数，object-对象 key-属性 defaultValue-默认值，将对象中的某一个属性，变成ref，这个属性和ref同源，更改后会保持一致。<br>如果没有这个属性或者这个属性值为undefined，可以默认给一个默认值</p><p><strong>如果这个对象不是响应式的，那么通过 toRef 变成的 ref 就不是响应式的，只是一个带value的实例。</strong><br><strong>如果这个对象是响应式的，那么通过 toRef 变成的 ref 就是响应式的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const state &#x3D; &#123;age:10&#125;</span><br><span class="line">const myAge &#x3D; toRef(state,&#39;age&#39;)</span><br><span class="line">console.log(myAge.value) &#x2F;&#x2F; 10</span><br><span class="line">myAge.value &#x3D; 12</span><br><span class="line">console.log(state.age, myAge.value) &#x2F;&#x2F; 12 12</span><br><span class="line">state.age &#x3D; 13</span><br><span class="line">console.log(state.age, myAge.value) &#x2F;&#x2F; 13 13</span><br><span class="line"></span><br><span class="line">const myName &#x3D; toRef(state, &#39;name&#39;, &#39;张三&#39;)</span><br><span class="line">console.log(myName.value) &#x2F;&#x2F; 张三</span><br><span class="line">console.log(state) &#x2F;&#x2F; &#123;age:13&#125;</span><br></pre></td></tr></table></figure><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><ol><li>从对象中取出属性对应的值，如果已经是ref，直接返回，如果不是，返回一个 ObjectRefImpl 实例；</li><li>创建 ObjectRefImpl 实例：<ul><li>构造函数，不做任何操作；</li><li>使用类的属性访问器<code>get value</code> 和 <code>set value</code>，实现数据的获取和更改。</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export function roRef(object,key,defaultValue)&#123;</span><br><span class="line">    const val &#x3D; object[key]</span><br><span class="line">    return isRef(val) ? val : new ObjectRefImpl(object, key,defaultValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ObjectRefImpl&#123;</span><br><span class="line">    public __v_isRef &#x3D; true</span><br><span class="line">    constructor(private _object,private _key,private _defaultValue)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get value()&#123;</span><br><span class="line">        const val &#x3D; this._object[this._key]</span><br><span class="line">        return val &#x3D;&#x3D;&#x3D; undefined ? this._defaultValue : val</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set value(newVal)&#123;</span><br><span class="line">        this._object[this._key] &#x3D; newVal</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>toRef的主要作用就是将对象中的某个属性变成ref，这个ref是否是响应式的，取决于对象是是否是响应。</p><p>toRef的原理是创建一个ObjectRefImpl实例，ObjectRefImpl类里面使用类的属性访问器<code>get value</code> 和 <code>set value</code>，实现数据的获取和更改。</p><h1 id="数据响应式-toRefs"><a href="#数据响应式-toRefs" class="headerlink" title="数据响应式 - toRefs()"></a>数据响应式 - toRefs()</h1><h2 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h2><p><code>toRef()</code>接收一个参数 object-对象，将对象中的所有属性变成ref，属性和ref同源，更改后会保持一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const state &#x3D; reactive(&#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  bar: 2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const stateAsRefs &#x3D; toRefs(state)</span><br><span class="line">&#x2F;*</span><br><span class="line">stateAsRefs 的类型：&#123;</span><br><span class="line">  foo: Ref&lt;number&gt;,</span><br><span class="line">  bar: Ref&lt;number&gt;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;&#x2F; 这个 ref 和源属性已经“链接上了”</span><br><span class="line">state.foo++</span><br><span class="line">console.log(stateAsRefs.foo.value) &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">stateAsRefs.foo.value++</span><br><span class="line">console.log(state.foo) &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>传入的参数可能是数组，也可能是对象：</p><ul><li>如果是数组，就需要用数组存储每一个属性的ref；</li><li>如果是对象，就需要用对象存储每一个属性的ref。</li></ul><p>循环数组/对象的每一个属性，调用 toRef 方法将属性变成ref。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export function toRefs(object)&#123;</span><br><span class="line">    const ret &#x3D; isArray(object) ? new Array(object.length) : &#123;&#125;</span><br><span class="line">    &#x2F;&#x2F;遍历数据，使用toRef实现将所有属性变成ref</span><br><span class="line">    for(const key in object)&#123;</span><br><span class="line">        ret[key] &#x3D; toRef(object,key)</span><br><span class="line">    &#125;</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>toRefs的主要作用就是将对象中的每个属性变成ref。</p><p>toRefs的原理是循环数组/对象的每一个属性，调用 toRef 方法将属性变成ref。</p><h1 id="数据响应式-computed"><a href="#数据响应式-computed" class="headerlink" title="数据响应式 - computed()"></a>数据响应式 - computed()</h1><h2 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h2><ol><li>接收一个 getter 函数，返回一个只读的响应式 ref 对象；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const count &#x3D; ref(1)</span><br><span class="line">const plusOne &#x3D; computed(() &#x3D;&gt; count.value + 1)</span><br><span class="line"></span><br><span class="line">console.log(plusOne.value) &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">plusOne.value++ &#x2F;&#x2F; 错误</span><br></pre></td></tr></table></figure><ol start="2"><li>接收一个具有 get 和 set 函数的对象，返回一个可写的响应式对象。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const count &#x3D; ref(1)</span><br><span class="line">const plusOne &#x3D; computed(&#123;</span><br><span class="line">  get: () &#x3D;&gt; count.value + 1,</span><br><span class="line">  set: (val) &#x3D;&gt; &#123;</span><br><span class="line">    count.value &#x3D; val - 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">plusOne.value &#x3D; 1</span><br><span class="line">console.log(count.value) &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li><strong>computed 是懒执行</strong>：computed 定义之后，如果computed没有被使用，那么就不会被执行 computed 里面的方法；</li><li><strong>computed 具有缓存机制</strong>：computed 里面计算的数据如果没有发生改变，不管 computed 被使用多少次，computed 里面的方法只会执行一次；</li><li>如果 computed 里面计算的数据发生改变，如果computed没有被使用，里面的方法就不会被执行，除非 computed 被使用。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let age &#x3D; ref(10)</span><br><span class="line"></span><br><span class="line">let myAge &#x3D; computed(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(1111)</span><br><span class="line">    return age.value + 10</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里不会打印 1111，因为特性1 懒执行</span><br><span class="line"></span><br><span class="line">console.log(myAge.value) &#x2F;&#x2F; 这里会打印 1111 20 因为computed被使用</span><br><span class="line"></span><br><span class="line">console.log(myAge.value) &#x2F;&#x2F; 这里只打印 20 不打印1111 因为特性2 缓存机制</span><br><span class="line"></span><br><span class="line">setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">    age.value &#x3D; 20 &#x2F;&#x2F; 这里不会打印，因为特性3 computed没有被使用</span><br><span class="line">    console.log(myAge.value) &#x2F;&#x2F; 打印 1111 30，因为computed被使用</span><br><span class="line">&#125;,1000)</span><br></pre></td></tr></table></figure><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><ol><li>判断传入的参数是函数还是对象，设置 getter 和 setter 对应的方法，返回一个 ComputedRefImpl 实例；</li><li>创建 ComputedRefImpl 实例：<ul><li>在构造函数中使用 effect 收集依赖，收集的时候默认不执行，实现 computed 的特性1；</li><li>使用类的属性访问器<code>get value</code>，实现数据的获取，获取数据的时候根据 _dirty 字段来实现 computed 的特性2；</li><li>使用类的属性访问器<code>set value</code>，实现数据的设置和更改。</li></ul></li></ol><div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin:20px 0;'>    <div>_dirty 字段的作用：</div>    <div style='text-indent:24px;'>* 类的属性访问器`get value`中，_dirty 为 true 时获取 effect 的返回值，然后将 _dirty 修改为 false，如果数据没有发生变更，再次调用 computed 将直接返回上一次的value值，实现 computed 的特性2；</div>    <div style='text-indent:24px;'>* 类的构造函数里面，使用 effect 收集依赖，options 里面定义`sch`方法，当 computed 里面计算的数据发生改变，trigger 触发依赖时就会调用`sch`方法，将 _dirty 设置成 true，再次调用 computed 的时候会重新获取新值返回，实现 computed 的特性3。</div>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改循环执行effect方法</span><br><span class="line">effectSet.forEach(effect&#x3D;&gt;&#123;</span><br><span class="line">    if(effect.options.sch)&#123;</span><br><span class="line">        effect.options.sch()</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        effect()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">export function computed(getterOrOptions)&#123;</span><br><span class="line">    let getter &#x2F;&#x2F; 获取数据</span><br><span class="line">    let setter &#x2F;&#x2F; 设置数据</span><br><span class="line"></span><br><span class="line">    if(isFunction(getterOrOptions))&#123; &#x2F;&#x2F; 如果传入的函数，只能获取数据，不能设置数据</span><br><span class="line">        getter &#x3D; getterOrOptions</span><br><span class="line">        setter &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">            console.warn(&#39;Write operation failed: computed value is readonly&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 如果传入的是对象，复制获取数据 设置数据的方法</span><br><span class="line">        getter &#x3D; getterOrOptions.get</span><br><span class="line">        setter &#x3D; getterOrOptions.set</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回一个实例</span><br><span class="line">    return new ComputedRefImpl(getter, setter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ComputedRefImpl&#123;</span><br><span class="line">    &#x2F;&#x2F; 定义属性</span><br><span class="line">    public _dirty &#x3D; true &#x2F;&#x2F; 默认获取数据getter方法执行</span><br><span class="line">    private _value</span><br><span class="line">    public effect</span><br><span class="line"></span><br><span class="line">    constructor(getter,private setter)&#123;</span><br><span class="line">        &#x2F;&#x2F; 收集依赖</span><br><span class="line">        this.effect &#x3D; effect(getter,&#123;</span><br><span class="line">            lazy:true, &#x2F;&#x2F; 特性1：computed 是懒执行 —— 默认不执行</span><br><span class="line">            sch:()&#x3D;&gt;&#123;  &#x2F;&#x2F; 特性3：数据修改再次调用computed重新获取新值 —— trigger触发依赖更新的时候执行sch,将_dirty设置成true</span><br><span class="line">                if(!this._dirty)&#123;</span><br><span class="line">                    this._dirty &#x3D; true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get value()&#123;</span><br><span class="line">        if(this._dirty)&#123;</span><br><span class="line">            this._value &#x3D; this.effect() &#x2F;&#x2F; 获取getter运行之后返回的值</span><br><span class="line">            &#x2F;&#x2F; 特性2：computed 具有缓存机制</span><br><span class="line">            this._dirty &#x3D; false </span><br><span class="line">            &#x2F;&#x2F; 设置成false后，如果数据没有发生变更，再次获取数据将直接返回上一次的value值</span><br><span class="line">        &#125;</span><br><span class="line">        return this._value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set value(newValue) &#123;</span><br><span class="line">        this.setter(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组件的渲染-vue3-中的使用"><a href="#组件的渲染-vue3-中的使用" class="headerlink" title="组件的渲染 - vue3 中的使用"></a>组件的渲染 - vue3 中的使用</h1><ol><li>新建挂在应用实例的节点；</li><li>创建一个组件：<ul><li>vue3 使用组合式API，但是也兼容 vue2 的写法；</li><li>setup 相当于 vue2 的 beforeCreate created，只执行一次;</li><li>setup 入参：props-组件间传递的数据 context-上下文;</li><li>setup 返回值：可以直接将数据返回在render函数中使用，也可以直接返回 render 函数</li></ul></li><li>创建一个应用实例；</li><li>将应用实例挂在到节点上。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 挂在应用实例的节点 --&gt;</span><br><span class="line">&lt;div id&#x3D;&#39;app&#39;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个组件</span><br><span class="line">const App &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里是 vue2 的写法，vue3兼容</span><br><span class="line">    &#x2F;&#x2F; data()&#123;</span><br><span class="line">    &#x2F;&#x2F;     a:1</span><br><span class="line">    &#x2F;&#x2F; &#125;,</span><br><span class="line">    &#x2F;&#x2F; methods:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F; vue3的新写法，composition API-组合式API</span><br><span class="line">    setup(props,context)&#123; &#x2F;&#x2F; 相当于 vue2 的 beforeCreate created，只执行一次</span><br><span class="line">        &#x2F;&#x2F; 入参：props-组件间传递的数据 context-上下文</span><br><span class="line">        let state &#x3D; reactive(&#123;age:2&#125;)</span><br><span class="line">        &#x2F;&#x2F; 返回值：可以直接将数据返回在render函数中使用</span><br><span class="line">        &#x2F;&#x2F; return&#123;</span><br><span class="line">        &#x2F;&#x2F;    state</span><br><span class="line">        &#x2F;&#x2F; &#125;</span><br><span class="line">        &#x2F;&#x2F; 返回值：也可以直接返回 render 函数</span><br><span class="line">        const fn&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">            state.age++</span><br><span class="line">        &#125;</span><br><span class="line">        return ()&#x3D;&#123;</span><br><span class="line">            return h(&#39;div&#39;,&#123;style:&#123;color:&#39;red&#39;&#125;，onClick:fn&#125;,&#96;hello state.age&#96;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; render(proxy)&#123; &#x2F;&#x2F; proxy 就是组件所有属性的合并</span><br><span class="line">    &#x2F;&#x2F;    &#x2F;&#x2F; 在 vue3 中，render函数的入参和 vue2的 this 一样，但是 vue3 不实用 this</span><br><span class="line">    &#x2F;&#x2F;    console.log(proxy&#x3D;&#x3D;&#x3D;this) &#x2F;&#x2F; true</span><br><span class="line">    &#x2F;&#x2F;    return h(&#39;div&#39;,&#123;style:&#123;color:&#39;red&#39;&#125;&#125;,&#96;hello proxy.state.age&#96;)</span><br><span class="line">    &#x2F;&#x2F; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个应用实例，并将应用实例挂在到节点上</span><br><span class="line">createApp(App).mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure><h2 id="操作节点-nodeOps-ts"><a href="#操作节点-nodeOps-ts" class="headerlink" title="操作节点 - nodeOps.ts"></a>操作节点 - nodeOps.ts</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 节点的增删改查</span><br><span class="line">export const nodeOps &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 新建节点</span><br><span class="line">    createElement: tag &#x3D;&gt; document.createElement(tag),</span><br><span class="line">    &#x2F;&#x2F; 删除节点</span><br><span class="line">    remove: child &#x3D;&gt; &#123;</span><br><span class="line">        const parent &#x3D; child.parentNode</span><br><span class="line">        if (parent) &#123;</span><br><span class="line">            parent.removeChild(child)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 插入节点</span><br><span class="line">    &#x2F;&#x2F; anchor 参照节点 如果有值，就在该节点之前插入child，如果等于null，child会插在parent最后，相当于appendChild</span><br><span class="line">    insert: (child, parent, anchor) &#x3D;&gt; parent.insertBefore(child, anchor || null),</span><br><span class="line">    &#x2F;&#x2F; 选择节点</span><br><span class="line">    querySelector: selector &#x3D;&gt; document.querySelector(selector),</span><br><span class="line">    &#x2F;&#x2F; 创建节点内的文本</span><br><span class="line">    setElementText: (el, text) &#x3D;&gt; el.textContent &#x3D; text,</span><br><span class="line">    &#x2F;&#x2F; 创建文本</span><br><span class="line">    createText: text &#x3D;&gt; document.createTextNode(text),</span><br><span class="line">    &#x2F;&#x2F; 设置节点的文本</span><br><span class="line">    setText: (node, text) &#x3D;&gt; node.nodeValue &#x3D; text,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>runtime-dom<br>nodeOps.ts // 操作节点<br>patchProp.ts // 比对属性</p><h2 id="属性的比对-patchProp-ts"><a href="#属性的比对-patchProp-ts" class="headerlink" title="属性的比对 - patchProp.ts"></a>属性的比对 - patchProp.ts</h2><p>策略模式：123</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 属性的比对</span><br><span class="line"> * el 节点</span><br><span class="line"> * key 需要比对的属性名，如style class onClick等</span><br><span class="line"> * prevValue 之前的属性值</span><br><span class="line"> * nextValue 现在的属性值</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const patchProp &#x3D; (el,key,prevValue,nextValue,) &#x3D;&gt; &#123;</span><br><span class="line">    switch(key)&#123;</span><br><span class="line">        case &#39;class&#39;:</span><br><span class="line">            &#x2F;&#x2F; 比对class</span><br><span class="line">            patchClass(el, nextValue)</span><br><span class="line">            break;</span><br><span class="line">        case &#39;style&#39;:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比对class-patchClass"><a href="#比对class-patchClass" class="headerlink" title="比对class - patchClass"></a>比对class - patchClass</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export const patchClass &#x3D; (el, nextValue) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="新的全局API-创建应用实例createApp"><a href="#新的全局API-创建应用实例createApp" class="headerlink" title="新的全局API - 创建应用实例createApp()"></a>新的全局API - 创建应用实例createApp()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Vue2</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el:&#39;#app&#39;,</span><br><span class="line">    render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; Vue3</span><br><span class="line">import &#123; createApp &#125; from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">const app &#x3D; createApp(App)</span><br><span class="line">app.use(XXX)</span><br><span class="line">   .component(XXX)</span><br><span class="line">   .mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure><h1 id="新的组合API"><a href="#新的组合API" class="headerlink" title="新的组合API"></a>新的组合API</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Vue2中，采用的是选项API的方式，当组件功能比较大，逻辑复杂的时候，会导致组件难以阅读或理解，为了解决这个问题，Vue3采用了组合式API的方式，代码简洁易读。</p><p>setup在组件创建之前执行，也就是说是围绕beforeCreate和created生命周期钩子运行的，一旦props解析完成，它就将被作为组合式 API 的入口。</p><p>在setup中不能使用this，因为setup的调用发生在data、computed或methods被解析之前，所以它们无法在setup中被获取。</p><h2 id="入参"><a href="#入参" class="headerlink" title="入参"></a>入参</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  components: &#123; &#125;,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    console.log(props) &#x2F;&#x2F; &#123; user: &#39;&#39; &#125;</span><br><span class="line">    return &#123;&#125; &#x2F;&#x2F; 这里返回的任何内容都可以用于组件的其余部分</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 组件的“其余部分”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setup入参</p><p>props:是响应式的，但是不能使用ES6解构，解构会让数据失去响应性，如果真想解构，使用toRefs()或者toRef()<br>context:对象，暴露可能在setup中使用的值 context.attrs === $attrs context.slots===$slots</p><p>setup相当于把代码移到一起，如果setup非常大，可以将里面的逻辑提取出来作为独立的组合是函数，然后在组件内被引入调用</p><h1 id="组件的-v-model"><a href="#组件的-v-model" class="headerlink" title="组件的 v-model"></a>组件的 v-model</h1><h2 id="实现单个v-model"><a href="#实现单个v-model" class="headerlink" title="实现单个v-model"></a>实现单个v-model</h2><p>在Vue2中，组件的v-model默认利用名为 value 的 prop 和名为 input 的emit事件实现。</p><p>而在Vue3中，组件的v-model默认利用名为 model-value 的 prop 和名为 update:model-value 的emit事件实现；也可以使用computed方法来实现，get方法返回modelValue，set方法触发update:model-value的emit事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">&lt;child v-model&#x3D;&quot;title&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方法一：prop + emit</span><br><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">const props &#x3D; defineProps(&#123;</span><br><span class="line">    modelValue:&#123;</span><br><span class="line">        type:String,</span><br><span class="line">        default:&#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const emit &#x3D; defineEmits()</span><br><span class="line">watch(() &#x3D;&gt; props.modelValue, val &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 数据发生变更，通知父组件</span><br><span class="line">    emit(&quot;update:modelValue&quot;, val);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方法二：prop + computed + emit</span><br><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input v-model&#x3D;&quot;value&quot;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">const props &#x3D; defineProps(&#123;</span><br><span class="line">    modelValue:&#123;</span><br><span class="line">        type:String,</span><br><span class="line">        default:&#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const emit &#x3D; defineEmits()</span><br><span class="line">const value &#x3D; computed(&#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    return props.modelValue</span><br><span class="line">  &#125;,</span><br><span class="line">  set(val)&#123;</span><br><span class="line">    emit(&#39;update:modelValue&#39;, val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然，如果不想使用modelValue来接收v-model的值，也可以自定义，比如说使用title</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">&lt;child v-model:title&#x3D;&quot;bookTitle&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">const props &#x3D; defineProps(&#123;</span><br><span class="line">    title:&#123;</span><br><span class="line">        type:String,</span><br><span class="line">        default:&#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const emit &#x3D; defineEmits();</span><br><span class="line">watch(() &#x3D;&gt; props.title, val &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 数据发生变更，通知父组件</span><br><span class="line">    emit(&quot;update:title&quot;, val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="实现多个v-model"><a href="#实现多个v-model" class="headerlink" title="实现多个v-model"></a>实现多个v-model</h2><p>实现多个v-model就是实现多个不同prop来接收v-model值的方法，以分页组件的封装为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">&lt;pagination</span><br><span class="line">    v-model:page&#x3D;&quot;queryParams.pageNum&quot;</span><br><span class="line">    v-model:limit&#x3D;&quot;queryParams.pageSize&quot;</span><br><span class="line">&#x2F;&gt;</span><br><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">&lt;el-pagination</span><br><span class="line">    v-model:current-page&#x3D;&quot;currentPage&quot;</span><br><span class="line">    v-model:page-size&#x3D;&quot;pageSize&quot;</span><br><span class="line">&#x2F;&gt;</span><br><span class="line">const props &#x3D; defineProps(&#123;</span><br><span class="line">    page: &#123;</span><br><span class="line">        type: Number,</span><br><span class="line">        default: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    limit: &#123;</span><br><span class="line">        type: Number,</span><br><span class="line">        default: 20</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const emit &#x3D; defineEmits();</span><br><span class="line">const currentPage &#x3D; computed(&#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    return props.page</span><br><span class="line">  &#125;,</span><br><span class="line">  set(val) &#123;</span><br><span class="line">    emit(&#39;update:page&#39;, val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const pageSize &#x3D; computed(&#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    return props.limit</span><br><span class="line">  &#125;,</span><br><span class="line">  set(val)&#123;</span><br><span class="line">    emit(&#39;update:limit&#39;, val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="v-model-自定义修饰符"><a href="#v-model-自定义修饰符" class="headerlink" title="v-model 自定义修饰符"></a>v-model 自定义修饰符</h2><p>v-model有内置修饰符——.trim、.number 和 .lazy，如果想要实现自定义修饰符，可以通过<strong>modelModifiers</strong> props属性将修饰符传给组件，它默认是一个空对象，有值的话，键名是修饰符，值是布尔值，true代表该修饰符已被使用。</p><p>假设这里实现一个<code>capitalize</code>修饰符，作用是将v-model绑定字符串的第一个字母大写，具体实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">&lt;child v-model.capitalize&#x3D;&quot;title&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">const props &#x3D; defineProps(&#123;</span><br><span class="line">    modelValue:&#123;</span><br><span class="line">        type:String,</span><br><span class="line">        default:&#39;&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    modelModifiers:&#123;</span><br><span class="line">        default:() &#x3D;&gt; (&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const emit &#x3D; defineEmits()</span><br><span class="line">watch(() &#x3D;&gt; props.modelValue, val &#x3D;&gt; &#123;</span><br><span class="line">    if(val &amp;&amp; props.modelModifiers.capitalize)&#123;</span><br><span class="line">        val &#x3D; val.charAt(0).toUpperCase() + val.slice(1)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 数据发生变更，通知父组件</span><br><span class="line">    emit(&quot;update:modelValue&quot;, val);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><h2 id="props-emit-父子组件"><a href="#props-emit-父子组件" class="headerlink" title="props / emit - 父子组件"></a>props / emit - 父子组件</h2><p>父组件通过v-bind向子组件传递数据，子组件通过props(defineProps())接收；<br>子组件通过emit(defineEmits())事件传递数据，父组件通过v-on绑定事件接收数据。<br>若果父组件想把对象的所有属性传递过去，比如post={id:1,name:’12’,…}，里面有很多属性，一个一个传递过去很麻烦，可以简写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v-bind&#x3D;&#39;post&#39; </span><br><span class="line">&#x2F;&#x2F; 类似以下内容：</span><br><span class="line">:id&#x3D;&quot;post.id&quot; </span><br><span class="line">:name&#x3D;&quot;post.name&quot;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="v-model-父子组件"><a href="#v-model-父子组件" class="headerlink" title="v-model - 父子组件"></a>v-model - 父子组件</h2><p>v-model实现组件通信原理就是 props 和 emit。</p><h2 id="ref-defineExpose-父子组件"><a href="#ref-defineExpose-父子组件" class="headerlink" title="ref / defineExpose - 父子组件"></a>ref / defineExpose - 父子组件</h2><p>父组件通过ref获取子组件的实例中暴露出来的数据或者方法等；<br>子组件通过defineExpose方法将数据或者方法暴露出去以供父组件使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">&lt;child ref&#x3D;&quot;childRef&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">const childRef &#x3D; ref(null)</span><br><span class="line">&#x2F;&#x2F; childRef.value.name 子组件暴露的数据</span><br><span class="line">&#x2F;&#x2F; childRef.value.doSomeThing() 子组件暴露的方法</span><br><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">defineExpose(&#123;</span><br><span class="line">    name: &quot;这是子组件的属性&quot;,</span><br><span class="line">    doSomeThing()&#123;</span><br><span class="line">        console.log(&quot;这是子组件的方法&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="provide-inject-隔代组件"><a href="#provide-inject-隔代组件" class="headerlink" title="provide/inject - 隔代组件"></a>provide/inject - 隔代组件</h2><p>父组件通过provide提供变量，子孙组件通过inject注入变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">provide(&#39;name&#39;,&#39;这是一个名字&#39;)</span><br><span class="line">&#x2F;&#x2F; 如果想数据是响应式的，可以用ref或者reactive定义</span><br><span class="line">const location &#x3D; ref(&#39;North Pole&#39;)</span><br><span class="line">const geolocation &#x3D; reactive(&#123;</span><br><span class="line">    longitude: 90,</span><br><span class="line">    latitude: 135</span><br><span class="line">&#125;)</span><br><span class="line">provide(&#39;location&#39;,location)</span><br><span class="line">provide(&#39;geolocation&#39;, geolocation)</span><br><span class="line">&#x2F;&#x2F; 注入的数据只能在父组件中更改，如果子孙组件想修改，可以注入修改数据的方法</span><br><span class="line">const updateLocation &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    location.value &#x3D; &#39;South Pole&#39;</span><br><span class="line">&#125;</span><br><span class="line">provide(&#39;updateLocation&#39;,updateLocation)</span><br><span class="line">&#x2F;&#x2F; 如果要确保注入的数据不被子孙组件更改，可以使用readeonly</span><br><span class="line">const title &#x3D; ref(&#39;这是一个标题&#39;)</span><br><span class="line">provide(&#39;title&#39;, readonly(title))</span><br><span class="line">&lt;!-- 子、孙组件 --&gt;</span><br><span class="line">const name &#x3D; inject(&#39;name&#39;,&#39;这是一个默认的名字&#39;)</span><br><span class="line">const location &#x3D; inject(&#39;location&#39;, &#39;The Universe&#39;)</span><br><span class="line">const geolocation &#x3D; inject(&#39;geolocation&#39;)</span><br><span class="line">const updateUserLocation &#x3D; inject(&#39;updateLocation&#39;)</span><br><span class="line">const title &#x3D; inject(&#39;title&#39;)</span><br></pre></td></tr></table></figure><h2 id="attrs-隔代组件"><a href="#attrs-隔代组件" class="headerlink" title="$attrs - 隔代组件"></a>$attrs - 隔代组件</h2><p>父组件中通过v-bind绑定的传给子孙组件的属性，如果没有被子孙组件通过props接收，就会被绑定到$attrs上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">&lt;child :msg1&#x3D;&quot;msg1&quot; :msg2&#x3D;&quot;msg2&quot; title1&#x3D;&quot;123&quot; title2&#x3D;&quot;456&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">const props &#x3D; defineProps(&#123;</span><br><span class="line">    msg1:String</span><br><span class="line">&#125;)</span><br><span class="line">const attrs &#x3D; useAttrs()</span><br><span class="line">console.log(attrs) </span><br><span class="line">&#x2F;&#x2F; msg1被props接收，不会挂载到attrs上</span><br><span class="line">&#x2F;&#x2F; &#123; msg2:&quot;这是第二条信息&quot;, title1: &quot;123&quot;, title2: &quot;456&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="localStorage-sessionStorage-父子、兄弟、隔代组件"><a href="#localStorage-sessionStorage-父子、兄弟、隔代组件" class="headerlink" title="localStorage / sessionStorage - 父子、兄弟、隔代组件"></a>localStorage / sessionStorage - 父子、兄弟、隔代组件</h2><p>将数据保存在浏览器中，随取随用，但是数据格式、大小等受限。</p><h2 id="Vuex-父子、兄弟、隔代组件"><a href="#Vuex-父子、兄弟、隔代组件" class="headerlink" title="Vuex - 父子、兄弟、隔代组件"></a>Vuex - 父子、兄弟、隔代组件</h2><p>状态管理，解决localStorage / sessionStorage的痛脚。</p><h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 局部注册</span><br><span class="line">directives:&#123;</span><br><span class="line">    focus:&#123;</span><br><span class="line">        &#x2F;&#x2F; 只调用一次，指令第一次绑定到元素时调用</span><br><span class="line">        bind(el,binding,vnode,oldVnode)&#123;&#125;,</span><br><span class="line">        &#x2F;&#x2F; 当被绑定的元素插入到 DOM 中时调用</span><br><span class="line">        inserted()&#123;&#125;,</span><br><span class="line">        &#x2F;&#x2F; 所在组件的 VNode 更新时调用</span><br><span class="line">        update()&#123;&#125;,</span><br><span class="line">        &#x2F;&#x2F; 指令所在组件的 VNode 及其子 VNode 全部更新后调用</span><br><span class="line">        componentUpdated()&#123;&#125;,</span><br><span class="line">        &#x2F;&#x2F; 只调用一次，指令与元素解绑时调用。</span><br><span class="line">        unbind()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 全局注册</span><br><span class="line">Vue.directive(&#39;focus&#39;, &#123;</span><br><span class="line">    inserted()&#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="teleport-任意门"><a href="#teleport-任意门" class="headerlink" title="teleport - 任意门"></a>teleport - 任意门</h1><p>teleport的作用是将组件的HTML结构移动到指定的位置，解决组件定位和层级的问题。<br>常见的操作的是自定义弹框组件，将弹框组件的HTML结构移动到body下，这样就可以根据body进行定位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件引入弹框子组件 --&gt;</span><br><span class="line">&lt;modal @click&#x3D;&quot;show&#x3D;true&quot;&gt;&lt;&#x2F;modal&gt;</span><br><span class="line">&lt;!-- 弹框子组件 --&gt;</span><br><span class="line">&lt;button&gt;&lt;&#x2F;button&gt;</span><br><span class="line">&lt;teleport to&#x3D;&quot;body&quot;&gt;</span><br><span class="line">    &lt;div v-if&#x3D;&quot;show&quot;&gt;这是一个弹框展示内容&lt;&#x2F;div&gt;</span><br><span class="line">&lt;teleport&gt;</span><br></pre></td></tr></table></figure><h1 id="computed、watch-和-watchEffect"><a href="#computed、watch-和-watchEffect" class="headerlink" title="computed、watch 和 watchEffect"></a>computed、watch 和 watchEffect</h1><h1 id="过渡动画"><a href="#过渡动画" class="headerlink" title="过渡动画"></a>过渡动画</h1><p>硬件加速<br>动画时长：0.1到0.4，最佳时长0.25s</p><h1 id="getCurrentInstance"><a href="#getCurrentInstance" class="headerlink" title="getCurrentInstance"></a>getCurrentInstance</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; proxy &#125; &#x3D; getCurrentInstance()</span><br></pre></td></tr></table></figure><h1 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Vite有一个对象<code>import.meta.env</code>，这个对象暴露所有的环境变量。</p><p>为了防止意外地将一些环境变量泄漏到客户端，只有以<code>VITE_</code>为前缀的变量才会暴露给经过vite处理的代码。</p><p>如果想要自定义环境变量的前缀，可以在vite.config.js文件里面配置envPrefix。</p><p>Vite在默认情况下只有development (开发) 模式，production (生产) 模式。</p><p>但是一个项目可能会区分多个环境，如开发、测试、生产环境等，不同的环境可以用.env文件进行区分，Vite启动的时候会加载这些环境文件，使用dotenv从环境目录中加载额外的环境变量。</p><p>详情请查看<a href="https://cn.vitejs.dev/guide/env-and-mode.html" target="_blank" rel="noopener"><strong>环境变量与模式</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 环境目录</span><br><span class="line">.env               所有情况下都会加载</span><br><span class="line">.env.local         所有情况下都会加载，但会被 git 忽略</span><br><span class="line">.env.[mode]        只在指定模式下加载，如mode&#x3D;staging测试模式</span><br><span class="line">.env.[mode].local  只在指定模式下加载，但会被 git 忽略</span><br><span class="line">&#x2F;&#x2F; 常见的环境目录</span><br><span class="line">.env.development   开发环境</span><br><span class="line">.env.production    生产环境</span><br><span class="line">.env.staging       测试环境</span><br><span class="line">&#x2F;&#x2F; 环境变量对象</span><br><span class="line">import.meta.env.MODE &#x2F;&#x2F; string 模式 开发模式-development 生产模式-production</span><br><span class="line">import.meta.env.BASE_URL &#x2F;&#x2F; string 部署时的基本URL，是vite.config.js里的base选项</span><br><span class="line">import.meta.env.PROD &#x2F;&#x2F; boolean 是否是生产环境</span><br><span class="line">import.meta.env.DEV &#x2F;&#x2F; boolean 是否是开发环境</span><br></pre></td></tr></table></figure><h2 id="Glob-导入"><a href="#Glob-导入" class="headerlink" title="Glob 导入"></a>Glob 导入</h2><p>Vite有一个函数<code>import.meta.glob</code>，这个函数可以用来导入文件系统中的多个模块。</p><p>可以在做菜单权限的时候，根据后台返回菜单所在路径，通过和模块的路径比对获取真实的组件。</p><p>详情请查看<a href="https://cn.vitejs.dev/guide/features.html#glob-import" target="_blank" rel="noopener"><strong>glob-import</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 匹配views里面所有的.vue文件</span><br><span class="line">const modules &#x3D; import.meta.glob(&#39;.&#x2F;..&#x2F;..&#x2F;views&#x2F;**&#x2F;*.vue&#39;)</span><br><span class="line">&#x2F;&#x2F; vite 生成的代码</span><br><span class="line">const modules &#x3D; &#123;</span><br><span class="line">  &#39;.&#x2F;..&#x2F;..&#x2F;views&#x2F;login.vue&#39;: () &#x3D;&gt; import(&#39;.&#x2F;..&#x2F;..&#x2F;views&#x2F;login.vue&#39;),</span><br><span class="line">  &#39;.&#x2F;..&#x2F;..&#x2F;views&#x2F;dashboard&#x2F;index.vue&#39;: () &#x3D;&gt; import(&#39;.&#x2F;..&#x2F;..&#x2F;views&#x2F;tool&#x2F;index.vue&#39;)</span><br><span class="line">  &#39;.&#x2F;..&#x2F;..&#x2F;views&#x2F;system&#x2F;config&#x2F;index.vue&#39;: () &#x3D;&gt; import(&#39;.&#x2F;..&#x2F;..&#x2F;views&#x2F;system&#x2F;config&#x2F;index.vue&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步组件：defineAsyncComponent – 局部注册组件使用，返回一个promise<br>Suspense  ？？？？？</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2018/07/18/15/43/animal-3546613_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="http://crystalsummer.gitee.io/categories/Vue/"/>
    
      <category term="原理" scheme="http://crystalsummer.gitee.io/categories/Vue/%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Vue" scheme="http://crystalsummer.gitee.io/tags/Vue/"/>
    
      <category term="原理" scheme="http://crystalsummer.gitee.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>项目兼容问题</title>
    <link href="http://crystalsummer.gitee.io/2021/12/19/%E9%A1%B9%E7%9B%AE%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
    <id>http://crystalsummer.gitee.io/2021/12/19/%E9%A1%B9%E7%9B%AE%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-19T06:30:50.000Z</published>
    <updated>2023-07-03T09:22:13.491Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/08/10/05/43/ferris-wheel-2618716_960_720.jpg" alt=""></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2017/08/10/05/43/ferris-wheel-2618716_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/categories/Web/"/>
    
      <category term="兼容" scheme="http://crystalsummer.gitee.io/categories/Web/%E5%85%BC%E5%AE%B9/"/>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/tags/Web/"/>
    
      <category term="兼容" scheme="http://crystalsummer.gitee.io/tags/%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>项目性能优化</title>
    <link href="http://crystalsummer.gitee.io/2021/11/13/%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://crystalsummer.gitee.io/2021/11/13/%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2021-11-13T06:30:50.000Z</published>
    <updated>2023-07-06T02:24:47.529Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/05/25/09/22/flower-2342706_960_720.jpg" alt=""></p><a id="more"></a><h1 id="代码层面优化"><a href="#代码层面优化" class="headerlink" title="代码层面优化"></a>代码层面优化</h1><h2 id="v-if-v-show-区分使用"><a href="#v-if-v-show-区分使用" class="headerlink" title="v-if v-show 区分使用"></a>v-if v-show 区分使用</h2><p>v-if：只有初始条件为真时，才渲染元素，假的时候不渲染；可以用在 template 上。</p><p>v-show：相当于<code>display:none</code>，不管初始条件是什么，都会渲染 DOM 元素，只是做 CSS 的简单切换，适合频繁切换；不可以用在 template 上。</p><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>使用 v-for 遍历的时候，必须设置唯一值 key，方便 Vue 内部机制精准找到该条列表数据，当数据更新时，新旧值对比，较快定位到 diff。</p><p>v-for 和 v-if 不要一起使用，在 Vue2 中，v-for 的优先级比 v-if 高，比如 v-for 循环1-4，并且 v-if 判断数字是否等于3，Vue  会先v-for 出4个节点，然后再判断是否为3，是3的话就显示节点，其他节点隐藏。很明显，v-for 和 v-if 一起使用的时候，会渲染无用节点，增加无用DOM的操作。</p><p>在 Vue2 中，v-for 的优先级比 v-if 高；在 Vue3 中，v-if 的优先级比 v-for 高。</p><h2 id="computed-watch-区分使用"><a href="#computed-watch-区分使用" class="headerlink" title="computed watch 区分使用"></a>computed watch 区分使用</h2><ul><li><p>computed：<br>计算属性，依赖其它属性值</p><p>它是懒执行，如果 computed 没有被使用，那么就不会被执行 computed 里面的方法；</p><p>它具有缓存机制，computed 里面计算的数据如果没有发生改变，不管 computed 被使用多少次，computed 里面的方法只会执行一次；</p><p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算。</p></li><li><p>watch：<br>数据的监听回调，每当监听的数据变化时都会执行回调；</p><p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch。</p></li></ul><h2 id="纯粹展示的数据不进行数据劫持"><a href="#纯粹展示的数据不进行数据劫持" class="headerlink" title="纯粹展示的数据不进行数据劫持"></a>纯粹展示的数据不进行数据劫持</h2><p>如果某些数据不会有任何改变，我们就不需要用 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间。</p><p>可以将数据定义在 data 外面，也可以使用<code>Object.freeze()</code>方法冻结数据。</p><h2 id="代码精简"><a href="#代码精简" class="headerlink" title="代码精简"></a>代码精简</h2><p>公共代码要提取出来，利用 Vue 的组件化，去除console.log。</p><h2 id="避免行内样式"><a href="#避免行内样式" class="headerlink" title="避免行内样式"></a>避免行内样式</h2><p>开发过程中尽量避免使用行内样式，减少 DOM 的重绘。</p><h2 id="事件销毁"><a href="#事件销毁" class="headerlink" title="事件销毁"></a>事件销毁</h2><p>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListener 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  addEventListener(&#39;click&#39;, this.click, false)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">  removeEventListener(&#39;click&#39;, this.click, false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p>如果页面展示很多图片，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。</p><p>可以使用插件 <a href="https://github.com/hilongjw/vue-lazyload" target="_blank" rel="noopener">vue-lazyload</a> 来实现图片的懒加载，也可以使用<code>scroll getBoundingClientRect IntersectionObserver</code>自己封装来实现，详情查看<a href="">图片懒加载</a>。</p><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>懒加载简单来说就是延迟加载或按需加载，即在需要的时候的时候进行加载。</p><p>Vue 是单页面应用，会有很多的路由引入 ，这样 webpack 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。使用路由懒加载就可以提高首屏显示的速度，解决白屏问题，提高用户体验。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 异步写法</span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#39;&#x2F;foo&#39;, component: (resolve)&#x3D;&gt;&#123;require([&#39;.&#x2F;Foo.vue&#39;&#39;],resolve)&#125; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者采用ES6的写法</span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#39;&#x2F;foo&#39;, component: () &#x3D;&gt; import(&#39;.&#x2F;Foo.vue&#39;) &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="第三方插件按需引入"><a href="#第三方插件按需引入" class="headerlink" title="第三方插件按需引入"></a>第三方插件按需引入</h2><p>项目中经常会需要引入第三方插件，如果直接引入整个插件，会导致项目的体积太大，我们可以按需引入，就可以减小项目体积。</p><h2 id="数据太多前端优化"><a href="#数据太多前端优化" class="headerlink" title="数据太多前端优化"></a>数据太多前端优化</h2><p>对于一次性展示大量数据，可以通过分页、触底加载的方式实现分页操作；也可以采用虚拟列表的方式滚动加载，虚拟列表可以使用插件<a href="https://github.com/tangbc/vue-virtual-scroll-list" target="_blank" rel="noopener">vue-virtual-scroll-list</a> 、 <a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener">vue-virtual-scroller</a>、<a href="https://happy-coding-clans.github.io/vue-easytable/#/zh/doc/intro" target="_blank" rel="noopener">vue-easytable</a>、<a href="https://vxetable.cn/#/table/start/install" target="_blank" rel="noopener">vxetable</a> 。</p><h3 id="setTimeout分页渲染"><a href="#setTimeout分页渲染" class="headerlink" title="setTimeout分页渲染"></a>setTimeout分页渲染</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 要渲染的数据</span><br><span class="line">let renderData &#x3D; []</span><br><span class="line">&#x2F;&#x2F; 后台返回的数据 - 假设10万条数据</span><br><span class="line">const list &#x3D; [......]</span><br><span class="line">&#x2F;&#x2F; 数据总数</span><br><span class="line">const total &#x3D; list.length</span><br><span class="line">&#x2F;&#x2F; 当前页</span><br><span class="line">let pageNo &#x3D; 0</span><br><span class="line">&#x2F;&#x2F; 每页展示数量</span><br><span class="line">let pageSize &#x3D; 10</span><br><span class="line">&#x2F;&#x2F; 分页-总共多少页</span><br><span class="line">const totalPage &#x3D; Math.ceil(total &#x2F; pageSize)</span><br><span class="line">&#x2F;&#x2F; 渲染</span><br><span class="line">render(pageNo)</span><br><span class="line">function render(pageNo)&#123;</span><br><span class="line">    if (pageNo &gt;&#x3D; totalPage) return</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        for(let i &#x3D; pageNo * pageSize;i&lt;pageNo * pageSize + pageSize;i++)&#123;</span><br><span class="line">            renderData.push(list[i])</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; renderData &#x3D; [list.slice(0,pageNo * pageSize + pageSize)]</span><br><span class="line">        render(pageNo + 1)</span><br><span class="line">    &#125;,0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="requestAnimationFrame分页渲染"><a href="#requestAnimationFrame分页渲染" class="headerlink" title="requestAnimationFrame分页渲染"></a>requestAnimationFrame分页渲染</h3><p>使用<code>requestAnimationFrame</code>来代替<code>setTimout</code>实现分页渲染，减少页面重排的次数，提高性能。<code>requestAnimationFrame</code>和<code>setTimout</code>用法一样，只是没有规定的时间，区别在于<code>requestAnimationFrame</code>采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅。</p><ul><li><code>requestAnimationFrame</code>会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率,一般来说，这个频率为每秒60帧；</li><li>在隐藏或不可见的元素中，<code>requestAnimationFrame</code>将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量。</li></ul><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>实现原理：在列表的底部添加一个<code>blank</code>空节点，判断这个空节点是否可见，可见的话就代码已经滚动到页面底部，继续加载下一页数据。我们使用<code>IntersectionObserve</code>交叉观察器来判断节点是否可见。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;container&quot; @scroll&#x3D;&quot;handleScroll&quot; ref&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;div v-for&#x3D;&quot;(item) in renderData&quot; :key&#x3D;&quot;...&quot;&gt;</span><br><span class="line">      ... 渲染的内容 ...</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div ref&#x3D;&quot;blank&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import &#123; onMounted, ref, computed &#125; from &#39;vue&#39;</span><br><span class="line">&#x2F;&#x2F; 空白节点</span><br><span class="line">const blank &#x3D; ref&lt;HTMLElement&gt;()</span><br><span class="line">&#x2F;&#x2F; 后台返回的数据 - 假设10万条数据</span><br><span class="line">const list &#x3D; ref([......])</span><br><span class="line">&#x2F;&#x2F; 当前页</span><br><span class="line">const pageNo &#x3D; ref(1)</span><br><span class="line">&#x2F;&#x2F; 每页展示数量</span><br><span class="line">const pageSize &#x3D; 10</span><br><span class="line">&#x2F;&#x2F; 分页-总共多少页</span><br><span class="line">const totalPage &#x3D;  computed(()&#x3D;&gt; Math.ceil(list.value.length &#x2F; pageSize.value))</span><br><span class="line">&#x2F;&#x2F; 要渲染的数据</span><br><span class="line">let renderData &#x3D; computed(()&#x3D;&gt; list.value.slice(0,pageNo.value * pageSize) )</span><br><span class="line"></span><br><span class="line">const handleScroll &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 当前页数与最大页数的比较</span><br><span class="line">  if (pageNo.value &gt; totalPage.value) return</span><br><span class="line">  const lazyRenderObserver &#x3D; new IntersectionObserver((enteries,observer)&#x3D;&gt;&#123;</span><br><span class="line">    enteries.forEatch((entry)&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F; blank出现在视图，则当前页数加1</span><br><span class="line">        if(entery.intersectionRatio&gt;0)&#123;</span><br><span class="line">            pageNo.value++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  lazyRenderObserver.observer(blank.value)</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h3><p>虚拟滚动，就是根据容器可视区域的列表容积数量，监听用户滑动或滚动事件，动态截取长列表数据中的部分数据渲染到页面上，动态使用空白站位填充容器上下滚动区域内容，模拟实现原生滚动效果。</p><ul><li>可视区域的高度 boxHeight</li><li>列表项的高度 itemHeight</li><li>可视区域能展示的列表项个数 = Math.floor(可视区域高度 / 列表项高度) + 2<br><code>itemNum = Math.floor(boxHeight / itemHeight) + 2</code><br>为什么要 +2 ，是因为可能最上面和最下面的元素都只展示一部分</li><li>开始索引 startIndex </li><li>结束索引 = 开始索引 + 可视区域能展示的列表项个数 * 2<br><code>endIndex = startIndex + itemNum * 2</code><br>itemNum乘以2就是为了实现预加载，防止滚动过快，造成暂时白屏。</li><li>预加载（防止滚动过快，造成暂时白屏）</li><li>根据开始索引和结束索引，截取数据展示在可视区域<br>使用<code>slice</code>截取数组，这样可以保证原数组数据不变。</li><li>监听滚动，确定开始索引 startIndex 的值，startIndex = Math.floor(滚动的距离 / 列表项高度 )，滚动节流<br><code>startIndex = Math.floor(scrollTop / itemHeight )</code></li><li>上下空白区使用padding实现</li></ul><p>具体实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;v-scroll&quot; @scroll.passive&#x3D;&quot;doScroll&quot; ref&#x3D;&quot;scrollBox&quot;&gt;</span><br><span class="line">    &lt;div :style&#x3D;&quot;blankStyle&quot; style&#x3D;&quot;height: 100%&quot;&gt;</span><br><span class="line">      &lt;div v-for&#x3D;&quot;item in tempData&quot; :key&#x3D;&quot;item.id&quot; class&#x3D;&quot;scroll-item&quot;&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; item.msg &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;img :src&#x3D;&quot;item.src&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">allData: [], &#x2F;&#x2F; 所有数据</span><br><span class="line">boxHeight: 0, &#x2F;&#x2F; 可视区域的高度</span><br><span class="line">itemHeight: 150, &#x2F;&#x2F; 列表每一项的高度</span><br><span class="line">startIndex: 0, &#x2F;&#x2F; 元素开始索引</span><br><span class="line"></span><br><span class="line">mounted() &#123;</span><br><span class="line">  &#x2F;&#x2F; 在mounted时获取可视区域的高度</span><br><span class="line">  this.getScrollBoxHeight();</span><br><span class="line">  &#x2F;&#x2F; 监听屏幕变化以及旋转，都要重新获取可视区域的高度</span><br><span class="line">  window.onresize &#x3D; this.getScrollBoxHeight;</span><br><span class="line">  window.onorientationchange &#x3D; this.getScrollBoxHeight;</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  &#x2F;&#x2F; 可视区域能展示的列表项个数</span><br><span class="line">  itemNum() &#123;</span><br><span class="line">    &#x2F;&#x2F; 可视区域能展示的列表项个数 &#x3D; ~~(可视化区域高度 &#x2F; 列表项高度) + 2</span><br><span class="line">    &#x2F;&#x2F; ~~是向下取整的运算符，等同于Math.floor()，为什么要 +2 ，是因为可能最上面和最下面的元素都只展示一部分</span><br><span class="line">    return ~~(this.boxHeight &#x2F; this.itemHeight) + 2;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 结束索引</span><br><span class="line">  endIndex() &#123;</span><br><span class="line">    &#x2F;&#x2F; endIndex &#x3D; 开始索引 + 可视区域可展示多少个列表项 * 2</span><br><span class="line">    &#x2F;&#x2F; 比如可视区域可展示8个列表项，startIndex是0的话endIndex就是0 + 8 * 2 &#x3D; 16，</span><br><span class="line">    &#x2F;&#x2F; startIndex是1的话endIndex就是1 + 8 * 2 &#x3D; 17，以此类推</span><br><span class="line">    &#x2F;&#x2F; 为什么要乘2呢，因为这样的话可以预加载出一页的数据，防止滚动过快，出现暂时白屏现象</span><br><span class="line">    let index &#x3D; this.startIndex + this.itemNum * 2;</span><br><span class="line">    &#x2F;&#x2F; 到底情况处理</span><br><span class="line">    if (!this.allData[index]) &#123;</span><br><span class="line">      &#x2F;&#x2F; 比如startIndex是99995，那么endIndex本应该是99995 + 8 * 2 &#x3D; 10011</span><br><span class="line">      &#x2F;&#x2F; 但是列表数据总数只有10000条，此时就需要让endIndex &#x3D; (列表数据长度 - 1)</span><br><span class="line">      index &#x3D; this.allData.length - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return index;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 可视区要展示的数据</span><br><span class="line">  tempData() &#123;</span><br><span class="line">    &#x2F;&#x2F; 可视区域展示的截取数据，使用了数组的slice方法，不改变原数组又能截取</span><br><span class="line">    let startIndex &#x3D; 0;</span><br><span class="line">    if (this.startIndex &lt;&#x3D; this.itemNum) &#123;</span><br><span class="line">      startIndex &#x3D; 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      startIndex &#x3D; this.startIndex + this.itemNum;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.allData.slice(startIndex, this.endIndex + 1);</span><br><span class="line">  &#125;,</span><br><span class="line">  blankStyle() &#123;</span><br><span class="line">    &#x2F;&#x2F; 上下方的空白处使用padding来充当</span><br><span class="line">    let startIndex &#x3D; 0;</span><br><span class="line">    if (this.startIndex &lt;&#x3D; this.itemNum) &#123;</span><br><span class="line">      startIndex &#x3D; 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      startIndex &#x3D; this.startIndex - this.itemNum;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      &#x2F;&#x2F; 上方空白的高度计算公式：(开始index * 列表项高度)</span><br><span class="line">      &#x2F;&#x2F; 比如你滚过了3个列表项，那么上方空白区高度就是3 * 150 &#x3D; 450，这样才能假装10000个数据的滚动状态</span><br><span class="line">      paddingTop: startIndex * this.itemHeight + &quot;px&quot;,</span><br><span class="line">      &#x2F;&#x2F; 下方空白的高度计算公式：(总数据的个数 - 结束index - 1) * 列表项高度</span><br><span class="line">      &#x2F;&#x2F; 例如现在结束index是100，那么下方空白高度就是：(10000 - 100 - 1) * 150 &#x3D; 1,484,850</span><br><span class="line">      paddingBottom: (this.allData.length - this.endIndex - 1) * this.itemHeight + &quot;px&quot;,</span><br><span class="line">      &#x2F;&#x2F; 不要忘了加px哦</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">methods: &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取可视区域的高度</span><br><span class="line">  getScrollBoxHeight() &#123;</span><br><span class="line">    this.boxHeight &#x3D; this.$refs.scrollBox.clientHeight;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 使用节流，提高性能</span><br><span class="line">  doScroll: throttle(function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 监听可视区域的滚动事件</span><br><span class="line">    &#x2F;&#x2F; 公式：~~(滚动的距离 &#x2F; 列表项 )，就能算出已经滚过了多少个列表项，也就能知道现在的startIndex是多少</span><br><span class="line">    &#x2F;&#x2F; 例如我滚动条滚过了160px，那么index就是1，因为此时第一个列表项已经被滚上去了，可视区域里的第一项的索引是1</span><br><span class="line">    const index &#x3D; ~~(this.$refs.scrollBox.scrollTop &#x2F; this.itemHeight);</span><br><span class="line">    if (index &#x3D;&#x3D;&#x3D; this.startIndex) return;</span><br><span class="line">    this.startIndex &#x3D; index;</span><br><span class="line">  &#125;, 200),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情参考：<a href="https://juejin.cn/post/6966179727329460232" target="_blank" rel="noopener"><strong>「百毒不侵(三)」结合“康熙选秀”，给大家讲讲“虚拟列表”</strong></a></p><p>但是存在一个<strong>缺点</strong>，就是列表的高度是定高的，但是在实际开发中，大多数情况下高度是自适应的，不确定列表高度，此时可以预估高度先行渲染，然后获取真实高度并缓存。</p><h2 id="服务端渲染-SSR-or-预渲染"><a href="#服务端渲染-SSR-or-预渲染" class="headerlink" title="服务端渲染 SSR or 预渲染"></a>服务端渲染 SSR or 预渲染</h2><h1 id="webpack-层面的优化"><a href="#webpack-层面的优化" class="headerlink" title="webpack 层面的优化"></a>webpack 层面的优化</h1><h2 id="减少-ES6-转为-ES5-的冗余代码"><a href="#减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="减少 ES6 转为 ES5 的冗余代码"></a>减少 ES6 转为 ES5 的冗余代码</h2><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。</p><p>为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require 的方式导入，这样就能做到只让它们出现一次<a href="https://babeljs.io/docs/babel-plugin-transform-runtime" target="_blank" rel="noopener">babel-plugin-transform-runtime</a> 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。</p><h2 id="提取公共代码"><a href="#提取公共代码" class="headerlink" title="提取公共代码"></a>提取公共代码</h2><p>如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：</p><ul><li>相同的资源被重复加载，浪费用户的流量和服务器的成本。</li><li>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。</li></ul><p>所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个 Chunk 中的公共部分的插件 <a href="https://webpack.docschina.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener">CommonsChunkPlugin</a>。</p><h2 id="分割大块代码"><a href="#分割大块代码" class="headerlink" title="分割大块代码"></a>分割大块代码</h2><p>webpack 内置了 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener">SplitChunksPlugin</a> 插件，使用它可以把大的代码快分割成小的代码。把一个大的文件的加载转变为多个小文件的并行加载，从而提高加载速度。</p><h2 id="生产环境打包移除-console-和-debugger"><a href="#生产环境打包移除-console-和-debugger" class="headerlink" title="生产环境打包移除 console 和 debugger"></a>生产环境打包移除 console 和 debugger</h2><p>使用 <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/" target="_blank" rel="noopener">terser-webpack-plugin</a> 插件可以控制是否移除 console 和 debugger。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2017/05/25/09/22/flower-2342706_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/categories/Web/"/>
    
      <category term="优化" scheme="http://crystalsummer.gitee.io/categories/Web/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/tags/Web/"/>
    
      <category term="优化" scheme="http://crystalsummer.gitee.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>图片懒加载</title>
    <link href="http://crystalsummer.gitee.io/2021/09/18/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>http://crystalsummer.gitee.io/2021/09/18/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</id>
    <published>2021-09-18T07:45:50.000Z</published>
    <updated>2023-06-14T08:04:35.896Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2019/09/16/06/26/fog-4479936_960_720.jpg" alt=""></p><a id="more"></a><h1 id="HTML-原生实现"><a href="#HTML-原生实现" class="headerlink" title="HTML 原生实现"></a>HTML 原生实现</h1><p>HTML 中的<code>&lt;img&gt;</code>标签支持<code>loading</code>属性，可以使用该属性设置图片是否懒加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;URL&quot; loading&#x3D;&quot;eager|lazy&quot;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; eager 默认，图像立即加载</span><br><span class="line">&#x2F;&#x2F; lazy  图像延迟加载，只有鼠标滚动到该图片所在位置才会显示</span><br></pre></td></tr></table></figure><p>根据demo测试发现该属性有以下5种行为特性：</p><ol><li>Lazy loading加载数量与屏幕高度有关，高度越小加载数量越少，但并不是线性关系。<br>demo中垂直展示了30张图片，屏幕上只显示了4张，但是控制台第一次加载显示加载了17张，将页面屏幕显示高度变小，再刷新发现加载了13张。</li><li>Lazy loading加载数量与网速有关，网速越慢，加载数量越多，但并不是线性关系。<br>浏览器设置成<code>Slow 3G</code>模式，控制台显示加载29张，<code>Fast 3G</code>模式，加载20张。</li><li>Lazy loading加载没有缓冲，滚动即会触发新的图片资源加载。</li><li>Lazy loading加载在窗口resize尺寸变化时候也会触发，例如屏幕高度从小变大的时候。</li><li>Lazy loading加载也有可能会先加载后面的图片资源，例如页面加载时滚动高度很高的时候。</li></ol><p>在使用时，需要考虑浏览器兼容性问题，所以需要判断浏览器是否支持该属性，不支持的话需要使用 JavaScript 来实现图片的懒加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 有三种方法判断浏览器是否支持loading属性</span><br><span class="line">var isSupportLoading &#x3D; &#39;loading&#39; in document.createElement(&#39;img&#39;);</span><br><span class="line">var isSupportLoading &#x3D; &#39;loading&#39; in new Image();</span><br><span class="line">var isSupportLoading &#x3D; &#39;loading&#39; in HTMLImageElement.prototype;</span><br></pre></td></tr></table></figure><h1 id="JS-实现原理"><a href="#JS-实现原理" class="headerlink" title="JS 实现原理"></a>JS 实现原理</h1><p>一张图片就是一个 img 标签，浏览器是否发起请求图片是根据 img 的 src 属性，所以实现懒加载的关键就是，在图片没有进入可视区域时，先不给 img 的 src 赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给 src 赋值。</p><h1 id="JS-实现步骤"><a href="#JS-实现步骤" class="headerlink" title="JS 实现步骤"></a>JS 实现步骤</h1><ol><li>加载loading图片</li><li>判断图片是否在可视区</li><li>替换真图片</li><li>优化-函数节流</li></ol><h2 id="加载loading图片"><a href="#加载loading图片" class="headerlink" title="加载loading图片"></a>加载loading图片</h2><p>将 img 的 src 传入一张表示加载中的图片路径，将真正要展示的图片路径保存在 img 的自定义属性如 data-src 上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;加载中图片路径&quot; data-src&#x3D;&quot;真正图片路径&quot; alt&#x3D;&quot;&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="判断图片是否在可视区"><a href="#判断图片是否在可视区" class="headerlink" title="判断图片是否在可视区"></a>判断图片是否在可视区</h2><p>通过 img 的 offsetTop、window 或者div 的 innerHeight 和 scrollTop 判断图片是否在可视区域内。如果<code>offsetTop &lt; scrollTop+innerHeight</code>，就表示当前图片在可视区域内。</p><blockquote><p>document.body.scrollWidth/scrollHeight 网页正文全文宽/高<br>document.body.offsetWidth/offsetHeight 网页可见区域宽/高(包含border和滚动条的宽高)<br>document.body.clientWidth/clientHeight 网页可见区域宽/高(不包含border和滚动条的宽高)<br>offsetTop 当前元素<strong>上边框外边缘</strong>到最近的已定位父级<strong>上边框内边缘</strong>的距离。如果父级都没有定位，则是到body顶部的距离<br>innerheight 显示区的高度，包括滚动条的高度<br>clientWidth = width  + 左右padding<br>clientTop = boder.top(上边框的宽度)<br>offsetWidth = width + 左右padding  + 左右border</p></blockquote><h2 id="替换真图片"><a href="#替换真图片" class="headerlink" title="替换真图片"></a>替换真图片</h2><p>如果图片已经在可视区域内，将真正图片的地址赋值给 src，替换掉加载中图片。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.src &#x3D; img.getAttribute(&quot;data-src&quot;)</span><br></pre></td></tr></table></figure><h2 id="优化-函数节流"><a href="#优化-函数节流" class="headerlink" title="优化-函数节流"></a>优化-函数节流</h2><p>使用节流函数让滚动事件在固定的时间之后再执行，避免重复加载，浪费资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 节流函数，保证每200ms触发一次</span><br><span class="line">function throttle(event, time) &#123;</span><br><span class="line">  let pre &#x3D; 0;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if (Date.now() - pre &gt; time) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer &#x3D; null;</span><br><span class="line">      pre &#x3D; Date.now();</span><br><span class="line">      event.apply(this, args);</span><br><span class="line">    &#125; else if (!timer) &#123;</span><br><span class="line">      timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        event.apply(this, args);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var img &#x3D; document.getElementsByTagName(&quot;img&quot;);</span><br><span class="line">var n &#x3D; 0; &#x2F;&#x2F;存储图片加载到的位置，避免每次都从第一张图片开始遍历</span><br><span class="line">lazyload(); &#x2F;&#x2F;页面载入完毕加载可视区域内的图片</span><br><span class="line">&#x2F;&#x2F; 节流函数，保证每200ms触发一次</span><br><span class="line">function throttle(event, time) &#123;</span><br><span class="line">  let pre &#x3D; 0;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if (Date.now() - pre &gt; time) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer &#x3D; null;</span><br><span class="line">      pre &#x3D; Date.now();</span><br><span class="line">      event.apply(this, args);</span><br><span class="line">    &#125; else if (!timer) &#123;</span><br><span class="line">      timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        event.apply(this, args);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&#39;scroll&#39;, throttle(lazyload, 200))</span><br><span class="line">function lazyload() &#123; &#x2F;&#x2F;监听页面滚动事件</span><br><span class="line">  var seeHeight &#x3D; window.innerHeight; &#x2F;&#x2F;可见区域高度</span><br><span class="line">  var scrollTop &#x3D; document.documentElement.scrollTop || document.body.scrollTop; &#x2F;&#x2F;滚动条距离顶部高度</span><br><span class="line">  for (var i &#x3D; n; i &lt; img.length; i++) &#123;</span><br><span class="line">    console.log(img[i].offsetTop, seeHeight, scrollTop);</span><br><span class="line">    if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123;</span><br><span class="line">      if (img[i].getAttribute(&quot;src&quot;) &#x3D;&#x3D; &quot;加载中图片路径&quot;) &#123;</span><br><span class="line">        img[i].src &#x3D; img[i].getAttribute(&quot;data-src&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      n &#x3D; i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h1><p>getBoundingClientRect() – 返回元素的大小及其相对于视口的位置，常用来判断元素是否出现在可视区域内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var divBox &#x3D; dovument.getElementById(&#39;#div-box&#39;)</span><br><span class="line">const rectDiv &#x3D; divBox.getBoundingClientRect()</span><br><span class="line">&#x2F;&#x2F; rectDiv.width 元素自身的宽度</span><br><span class="line">&#x2F;&#x2F; rectDiv.height 元素自身的高度</span><br><span class="line">&#x2F;&#x2F; rectDiv.top 元素上边到视窗上边的距离</span><br><span class="line">&#x2F;&#x2F; rectDiv.left 元素左边到视窗左边的距离</span><br><span class="line">&#x2F;&#x2F; rectDiv.right 元素右边到视窗左边的距离 (注意，这里没有写错)</span><br><span class="line">&#x2F;&#x2F; rectDiv.bottom 元素下边到视窗上边的距离 (注意，这里没有写错)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断元素是否在可视区域内</span><br><span class="line">function isInView(el,offset &#x3D; 0)&#123;</span><br><span class="line">  const rectDiv &#x3D; el.getBoundingClientRect()</span><br><span class="line"></span><br><span class="line">  const top &#x3D; rectDiv.top &gt;&#x3D; 0</span><br><span class="line"></span><br><span class="line">  const right &#x3D; rectDiv.right &lt;&#x3D; (window.innerWidth || document.element.clientWidth) + offset</span><br><span class="line"></span><br><span class="line">  const bottom &#x3D; rectDiv.bottom &lt;&#x3D; (window.innerHeight || document.element.clientHeight) + offset</span><br><span class="line"></span><br><span class="line">  const left  &#x3D; rectDiv.left &gt;&#x3D; 0</span><br><span class="line"></span><br><span class="line">  return top &amp;&amp; right &amp;&amp; bottom &amp;&amp; left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上述的lazyload可以进行如下修改</span><br><span class="line">function lazyload() &#123;</span><br><span class="line">  for (var i &#x3D; n; i &lt; img.length; i++) &#123;</span><br><span class="line">    if(isInView(img[i]))&#123;</span><br><span class="line">      if (img[i].getAttribute(&quot;src&quot;) &#x3D;&#x3D; &quot;加载中图片路径&quot;) &#123;</span><br><span class="line">        img[i].src &#x3D; img[i].getAttribute(&quot;data-src&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      n &#x3D; i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IntersectionObserver-交叉观察器"><a href="#IntersectionObserver-交叉观察器" class="headerlink" title="IntersectionObserver(交叉观察器)"></a>IntersectionObserver(交叉观察器)</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver" target="_blank" rel="noopener"><strong>IntersectionObserver</strong></a> 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法，即用来判断当前目标元素是否可见。传统实现方法就是监听 scroll 事件，但是由于scroll事件密集发生，计算量很大，容易造成性能问题。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var io &#x3D; new IntersectionObserver(callback, option);</span><br><span class="line">&#x2F;&#x2F; callback：可见性变化时的回调函数</span><br><span class="line">&#x2F;&#x2F; option：配置对象（可选）</span><br></pre></td></tr></table></figure><ol><li>callback：目标元素的可见性变化时，就会调用观察器的回调函数callback，一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。callback函数的参数（entries）是一个数组，举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。</li><li>option：</li></ol><ul><li>threshold：默认为[0]，即交叉比例（entries[i].intersectionRatio）达到0时触发回调函数。用户可以自定义这个数组。比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。</li><li>root、rootMargin：很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在iframe窗口里滚动）。容器内滚动也会影响目标元素的可见性。root属性指定目标元素所在的容器节点（即根元素）。rootMargin属性。后者定义根元素的margin，用来扩展或缩小rootBounds这个矩形的大小，从而影响intersectionRect交叉区域的大小。它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom 和 left 四个方向的值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 开始观察</span><br><span class="line">io.observe(document.getElementById(&#39;example1&#39;));</span><br><span class="line">io.observe(document.getElementById(&#39;example2&#39;));</span><br><span class="line">&#x2F;&#x2F; 停止观察</span><br><span class="line">io.unobserve(element);</span><br><span class="line">&#x2F;&#x2F; 关闭观察器</span><br><span class="line">io.disconnect();</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>监听滚动事件实现图片懒加载的方法就可以使用交叉观察器实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var img &#x3D; document.getElementsByTagName(&quot;img&quot;);</span><br><span class="line">if (IntersectionObserver) &#123;</span><br><span class="line">  let lazyImageObserver &#x3D; new IntersectionObserver((entries, observer) &#x3D;&gt; &#123;</span><br><span class="line">    entries.forEach((entry, index) &#x3D;&gt; &#123;</span><br><span class="line">      let lazyImage &#x3D; entry.target;</span><br><span class="line">      &#x2F;&#x2F; 如果元素可见            </span><br><span class="line">      if (entry.intersectionRatio &gt; 0) &#123;</span><br><span class="line">        if (lazyImage.getAttribute(&quot;src&quot;) &#x3D;&#x3D; &quot;加载中图片路径&quot;) &#123;</span><br><span class="line">          lazyImage.src &#x3D; lazyImage.getAttribute(&quot;data-src&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        lazyImageObserver.unobserve(lazyImage)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  for (let i &#x3D; 0; i &lt; img.length; i++) &#123;</span><br><span class="line">    lazyImageObserver.observe(img[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2019/09/16/06/26/fog-4479936_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/categories/Web/"/>
    
      <category term="JS" scheme="http://crystalsummer.gitee.io/categories/Web/JS/"/>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/tags/Web/"/>
    
      <category term="JS" scheme="http://crystalsummer.gitee.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶(三)</title>
    <link href="http://crystalsummer.gitee.io/2021/07/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%B8%89)/"/>
    <id>http://crystalsummer.gitee.io/2021/07/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%B8%89)/</id>
    <published>2021-07-17T10:45:50.000Z</published>
    <updated>2022-08-10T07:37:05.813Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2020/06/10/14/19/landscape-5282903_960_720.jpg" alt=""></p><a id="more"></a><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是无序属性的集合，属性包含基本值、对象或者函数。对象的创建有以下几种方式：</p><ol><li>对象字面量直接创建<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name: &quot;TOM&quot;,</span><br><span class="line">  getName: function() &#123;</span><br><span class="line">      return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用 new 关键字创建<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; new Object()</span><br><span class="line">person.name &#x3D; &quot;TOM&quot;;</span><br><span class="line">person.getName &#x3D; function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>工厂模式<br>以person对象为例，假如在实际开发中，不仅仅需要一个名字叫做TOM的person对象，同时还需要另外一个名为Jake的person对象，虽然他们有很多相似之处，但是我们不得不重复写两次。工厂模式就是为了解决这个问题，工厂模式相当于提供一个模子，通过模子复制出多个我们需要的对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var createPerson &#x3D; function(name, age) &#123;</span><br><span class="line">    &#x2F;&#x2F; 声明一个中间对象，该对象就是工厂模式的模子</span><br><span class="line">    var o &#x3D; new Object();</span><br><span class="line">    &#x2F;&#x2F; 依次添加我们需要的属性与方法</span><br><span class="line">    o.name &#x3D; name;</span><br><span class="line">    o.age &#x3D; age;</span><br><span class="line">    o.getName &#x3D; function() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 创建两个实例</span><br><span class="line">var perTom &#x3D; createPerson(&#39;TOM&#39;, 20);</span><br><span class="line">var PerJake &#x3D; createPerson(&#39;Jake&#39;, 22);</span><br></pre></td></tr></table></figure>但是，工厂模式有两个缺点：</li></ol><ul><li>没有办法识别实例和对象的关系，需要使用构造函数来解决这个问题；</li><li>对象复制，声明多个对象，就有多个getName的方法被重新生成，需要为getName分配空间。</li></ul><ol start="4"><li>构造函数<br>解决了实例和对象的关系，即判断实例类型的问题，但是依然没有解决对象复制的问题。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var Person &#x3D; function(name, age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.getName &#x3D; function() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p1 &#x3D; new Person(&#39;Ness&#39;, 20);</span><br><span class="line">console.log(p1.getName());  &#x2F;&#x2F; Ness</span><br><span class="line"></span><br><span class="line">console.log(p1 instanceof Person); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li></ol><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>构造函数虽然解决了判断实例类型的问题，但是对象复制问题依然没有解决。原型帮我们解决了这个问题。</p><ul><li>我们创建的每一个函数，都会有一个<code>prototype</code>属性，该属性指向一个对象。这个对象，就是我们这里说的原型。</li><li>当我们创建对象的时候，可以选择性的将一些属性和方法通过<code>prototype</code>属性，挂载在原型对象上。</li><li>每一个new出来的实例，都有一个<code>__proto__</code>属性，该属性指向构造函数的原型对象，通过这个属性，让实例对象也能够访问原型对象上的方法。</li><li>当所有的实例都能够通过<code>__proto__</code>访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性。</li><li>原型对象的<code>constructor</code>指向构造函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明构造函数</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 通过prototye属性，将方法挂载到原型对象上</span><br><span class="line">Person.prototype.getName &#x3D; function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">var p1 &#x3D; new Person(&#39;tim&#39;, 10);</span><br><span class="line">var p2 &#x3D; new Person(&#39;jak&#39;, 22);</span><br><span class="line">console.log(p1.getName &#x3D;&#x3D;&#x3D; p2.getName); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/03/15/dNIwf489nURFMLs.png" alt=""><br>通过图示我们可以看出，构造函数的<code>prototype</code>与所有实例对象的<code>__proto__</code>都指向原型对象。而原型对象的<code>constructor</code>指向构造函数。<br>根据构造函数与原型的特性，我们可以将在构造函数中，通过<strong>this声明</strong>的属性与方法称为<strong>私有变量与方法</strong>，它们被某一个实例对象所独有。而通过<strong>原型声明</strong>的属性与方法，我们可以称之为<strong>共有属性与方法</strong>，它们可以被所有的实例对象访问。<blockquote><p><strong>当我们访问实例对象中的属性或者方法时，会优先访问实例对象自身的属性和方法。</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  &#x2F;&#x2F; this 声明的属性和方法--私有变量和方法</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">  this.getName &#x3D; function() &#123;</span><br><span class="line">      console.log(&#39;this is constructor.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 通过原型声明的属性与方法--共有变量和方法</span><br><span class="line">Person.prototype.getName &#x3D; function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">var p1 &#x3D; new Person(&#39;tim&#39;, 10);</span><br><span class="line">&#x2F;&#x2F; 访问实例对象中的属性或者方法时，会优先访问实例对象自身的属性和方法。</span><br><span class="line">p1.getName(); &#x2F;&#x2F; this is constructor.</span><br></pre></td></tr></table></figure></li></ul><p>更简单的原型写法：<br><strong>注意：</strong><code>Person.prototype = {}</code>实际上是重新创建了一个<code>{}</code>对象并赋值给<code>Person.prototype</code>，这里的<code>{}</code>并不是最初的那个原型对象。因此它里面并不包含<code>constructor</code>属性。为了保证正确性，我们必须在新创建的<code>{}</code>对象中显式的设置<code>constructor</code>的指向，即<code>constructor: Person</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">Person.prototype &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 新建的对象无constructor，必须显式设置</span><br><span class="line">  constructor: Person,</span><br><span class="line">  getName: function() &#123;&#125;,</span><br><span class="line">  getAge: function() &#123;&#125;,</span><br><span class="line">  sayHello: function() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>由对象及其原型组成的链就叫做原型链。当访问一个对象的属性时，先在对象的本身找，找不到就去对象的原型上找，如果还是找不到，就去对象的原型（原型也是对象，也有它自己的原型）的原型上找，如此继续，直到找到为止，或者查找到最顶层的原型对象中也没有找到，就结束查找，返回undefined。<br>以函数对象的原型链为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add()&#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 分析过程如下：</span><br><span class="line">1.函数有__proto__属性，指向Function原型，所以add.__proto__&#x3D;&#x3D;&#x3D;Function.prototype</span><br><span class="line">2.原型Function.prototype也有__proto__属性，指向Object原型，所以</span><br><span class="line">  Function.prototype.__proto__&#x3D;&#x3D;&#x3D;Object.prototype</span><br><span class="line">3.这里需要注意：Object.prototype.__proto__&#x3D;&#x3D;&#x3D;null</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/15/kTzItvyePnXDGcS.png" alt=""><br>所以我们也可以换个方式描述下原型链 ：由对象的<code>__proto__</code>属性串连起来的直到<code>Object.prototype.__proto__</code>（为null）的链就是原型链。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 父级对象</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName &#x3D; function() &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getAge &#x3D; function() &#123;</span><br><span class="line">  return this.age;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子级对象-构造函数继承</span><br><span class="line">function Student(name, age, grade) &#123;</span><br><span class="line">  Person.call(this, name, age);</span><br><span class="line">  this.grade &#x3D; grade;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子级对象-原型继承</span><br><span class="line">Student.prototype &#x3D; new Person(name, age);</span><br><span class="line">Student.prototype.getGrade &#x3D; function() &#123;&#125;</span><br></pre></td></tr></table></figure><p>子级对象的原型继承，如何将子级对象的原型加入到原型链中？</p><ul><li>让子级对象的原型，成为父级对象的一个实例。</li><li>然后通过<code>__proto__</code>就可以访问父级对象的原型，这样就继承了父级原型中的方法与属性了。<br>这是<strong>更好的继承</strong>，封装一个继承的方法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function create(proto, options) &#123;</span><br><span class="line">  &#x2F;&#x2F; 创建一个空对象</span><br><span class="line">  var tmp &#x3D; &#123;&#125;;</span><br><span class="line">  &#x2F;&#x2F; 让这个新的空对象成为父类对象的实例</span><br><span class="line">  tmp.__proto__ &#x3D; proto;</span><br><span class="line">  &#x2F;&#x2F; 传入的方法都挂载到新对象上，新的对象将作为子类对象的原型</span><br><span class="line">  Object.defineProperties(tmp, options);</span><br><span class="line">  return tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实现原型的继承</span><br><span class="line">Student.prototype &#x3D; create(Person.prototype, &#123;</span><br><span class="line">  &#x2F;&#x2F; 不要忘了重新指定构造函数</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: Student</span><br><span class="line">  &#125;</span><br><span class="line">  getGrade: &#123;</span><br><span class="line">    value: function() &#123;</span><br><span class="line">      return this.grade</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>在ECMAScript5中提供了<code>Object.create()</code>方法来实现继承</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype &#x3D; Object.create(Person.prototype, &#123;</span><br><span class="line">  &#x2F;&#x2F; 不要忘了重新指定构造函数</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: Student</span><br><span class="line">  &#125;</span><br><span class="line">  getGrade: &#123;</span><br><span class="line">    value: function() &#123;</span><br><span class="line">      return this.grade</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="对象新增方法"><a href="#对象新增方法" class="headerlink" title="对象新增方法"></a>对象新增方法</h2><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p><code>Object.is()</code>用于比较两个值是否相等，比较两值是否相等可以使用运算符<code>==</code>或者<code>===</code>，但是<code>==</code>不严谨，会自动转换数据类型，<code>===</code>严谨，但是存在以下问题，使用<code>Object.is()</code>就可以解决该问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 &#x3D;&#x3D;&#x3D; -0 &#x2F;&#x2F; true</span><br><span class="line">NaN &#x3D;&#x3D;&#x3D; NaN &#x2F;&#x2F; false</span><br><span class="line">Object.is(0,-0) &#x2F;&#x2F; false</span><br><span class="line">Object.is(NaN,NaN) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p><code>Object.assign()</code>用于对象合并，将源对象（source，可选，一个或者多个）所有可枚举的属性复制到目标对象。<br><strong>注意：</strong>这里的复制是指拷贝属性名和对象的值，如果该属性是get（取值函数）或者set（赋值函数），拷贝的是函数执行之后返回的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const obj1 &#x3D; &#123;a:1&#125;</span><br><span class="line">const obj2 &#x3D; Object.assign(obj1) &#x2F;&#x2F; &#123;a:1&#125;</span><br><span class="line">obj2 &#x3D;&#x3D;&#x3D; obj1 &#x2F;&#x2F; true</span><br><span class="line">obj2.b &#x3D; 2 &#x2F;&#x2F; obj1&#x3D;obj2&#x3D;&#123;a:1,b:2&#125;</span><br><span class="line"></span><br><span class="line">const obj3 &#x3D; &#123;a:1,b:2&#125;</span><br><span class="line">const obj4 &#x3D; &#123;a:11,b:22,c:33&#125;</span><br><span class="line">const obj5 &#x3D; Object.assign(&#123;&#125;,obj3,obj4) &#x2F;&#x2F; &#123;a:11,b:22,c:33&#125;</span><br></pre></td></tr></table></figure><p>属于<strong>浅拷贝</strong>行为，如果源对象的某个属性是对象，那么目标对象里面合并的是该对象的引用，该对象数据发生变更，目标对象也会发生改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const source &#x3D; &#123;a:1,b:&#123;c:2&#125;&#125;</span><br><span class="line">const target &#x3D; Object.assign(&#123;&#125;,source) &#x2F;&#x2F; target &#x3D; &#123;a:1,b:&#123;c:2&#125;&#125;</span><br><span class="line">source.a &#x3D; 3</span><br><span class="line">source.b.c &#x3D; 4 &#x2F;&#x2F; target &#x3D; &#123;a:1,b:&#123;c:4&#125;&#125;</span><br></pre></td></tr></table></figure><p>如果目标对象不是对象，会先将其转为对象，像null、undefined这样不能转为对象的，会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(2) &#x2F;&#x2F; Number &#123;2&#125;</span><br><span class="line">Object.assign(null) &#x2F;&#x2F; 报错</span><br><span class="line">Object.assign(undefined) &#x2F;&#x2F; 报错</span><br><span class="line">const obj &#x3D; &#123;a:1&#125;</span><br><span class="line">Object.assign(obj,null) &#x3D;&#x3D;&#x3D; obj &#x2F;&#x2F; true</span><br><span class="line">Object.assign(obj,undefined) &#x3D;&#x3D;&#x3D; obj &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p><strong>用途：</strong>合并对象；为对象添加属性或者方法；克隆对象等等。</p><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p><code>Object.getOwnPropertyDescriptor()</code>返回对象指定属性的描述对象（descriptor）;<br><code>Object.getOwnPropertyDescriptors()</code>返回指定对象所有自身属性（非继承属性）的描述对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  foo: 123,</span><br><span class="line">  get bar() &#123; return &#39;abc&#39; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Object.getOwnPropertyDescriptor(obj,&#39;foo&#39;)</span><br><span class="line">&#x2F;&#x2F; foo:&#123;</span><br><span class="line">&#x2F;&#x2F;   configurable: true</span><br><span class="line">&#x2F;&#x2F;   enumerable: true</span><br><span class="line">&#x2F;&#x2F;   value: 123</span><br><span class="line">&#x2F;&#x2F;   writable: true</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line">Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F;   bar:&#123;</span><br><span class="line">&#x2F;&#x2F;     configurable:true,</span><br><span class="line">&#x2F;&#x2F;     enumerable:true,</span><br><span class="line">&#x2F;&#x2F;     get:[Function: get bar],</span><br><span class="line">&#x2F;&#x2F;     set:undefined,</span><br><span class="line">&#x2F;&#x2F;   &#125;,</span><br><span class="line">&#x2F;&#x2F;   foo:&#123;</span><br><span class="line">&#x2F;&#x2F;     configurable: true</span><br><span class="line">&#x2F;&#x2F;     enumerable: true</span><br><span class="line">&#x2F;&#x2F;     value: 123</span><br><span class="line">&#x2F;&#x2F;     writable: true</span><br><span class="line">&#x2F;&#x2F;   &#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure><p><strong>用途：</strong>解决<code>Object.assign()</code>无法正确拷贝 get 和 set 属性的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const source &#x3D; &#123;</span><br><span class="line">  set foo(value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const target1 &#x3D; &#123;&#125;;</span><br><span class="line">Object.assign(target1, source); &#x2F;&#x2F; target1&#x3D;&#123;foo:undefined&#125;</span><br><span class="line"></span><br><span class="line">const target2 &#x3D; &#123;&#125;;</span><br><span class="line">Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));</span><br><span class="line">Object.getOwnPropertyDescriptor(target2, &#39;foo&#39;)</span><br><span class="line">&#x2F;&#x2F; &#123; get: undefined,</span><br><span class="line">&#x2F;&#x2F;   set: [Function: set foo],</span><br><span class="line">&#x2F;&#x2F;   enumerable: true,</span><br><span class="line">&#x2F;&#x2F;   configurable: true &#125;</span><br></pre></td></tr></table></figure><h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p>每个对象都有<code>__proto__</code>属性，这个属性指向构造函数的原型对象<code>prototype</code>，我们可以通过<code>__proto__</code>这个属性来操作对象的原型对象。</p><p>但是这个属性前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，所以当我们想要生成、读、写原型上的方法时，尽量不使用这个属性，使用对应的方法<code>Object.create()</code>、<code>Object.getPrototypeOf()</code>、<code>Object.setPrototypeOf()</code>。</p><p><code>Object.setPrototypeOf(object,prototype)</code>用来设置一个对象的原型对象，返回的参数是对象本身。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将proto对象设为obj对象的原型，所以可以通过obj读取proto的属性</span><br><span class="line">let proto &#x3D; &#123;&#125;;</span><br><span class="line">let obj &#x3D; &#123; x: 10 &#125;;</span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line">proto.y &#x3D; 20;</span><br><span class="line">proto.z &#x3D; 40;</span><br><span class="line">obj.x &#x2F;&#x2F; 10</span><br><span class="line">obj.y &#x2F;&#x2F; 20</span><br><span class="line">obj.z &#x2F;&#x2F; 40</span><br></pre></td></tr></table></figure><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p><code>Object.getPrototypeOf()</code>用来读取对象的原型对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a&#x3D;[1,2,3]</span><br><span class="line">Object.getPrototypeOf(a) &#x3D;&#x3D;&#x3D; Array.prototype &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p><code>Object.keys()</code>返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。可以和<code>Object.values()</code>和<code>Object.entries()</code>搭配使用实现对象的循环遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;</span><br><span class="line">Object.keys(obj) &#x2F;&#x2F; [&#39;foo&#39;,&#39;baz&#39;]</span><br></pre></td></tr></table></figure><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p><code>Object.values()</code>返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p><p>如果入参不是对象，会先将入参转为对象，比如字符串转成数组字符串，但是数字或者布尔值的包装对象，都不会为实例添加非继承的属性。所以<code>Object.values</code>会返回空数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;</span><br><span class="line">Object.values(obj) &#x2F;&#x2F; [&#39;bar&#39;,42]</span><br><span class="line"></span><br><span class="line">Object.values(&#39;foo&#39;) &#x2F;&#x2F; [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]</span><br><span class="line">Object.values(42) &#x2F;&#x2F; []</span><br><span class="line">Object.values(true) &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p><code>Object.entries()</code>返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;</span><br><span class="line">Object.entries(obj) &#x2F;&#x2F; [[&#39;foo&#39;,&#39;bar&#39;],[&#39;baz&#39;,42]]</span><br></pre></td></tr></table></figure><p><strong>用途：</strong>1、遍历对象；2、对象转Map；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 遍历对象</span><br><span class="line">let obj &#x3D; &#123; one: 1, two: 2 &#125;;</span><br><span class="line">for (let [k, v] of Object.entries(obj)) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &#96;$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;&#96;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;one&quot;: 1</span><br><span class="line">&#x2F;&#x2F; &quot;two&quot;: 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象转Map</span><br><span class="line">const obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;;</span><br><span class="line">const map &#x3D; new Map(Object.entries(obj));</span><br><span class="line">map &#x2F;&#x2F; Map(2) &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br></pre></td></tr></table></figure><h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p><code>Object.fromEntries()</code>是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.fromEntries([</span><br><span class="line">  [&#39;foo&#39;, &#39;bar&#39;],</span><br><span class="line">  [&#39;baz&#39;, 42]</span><br><span class="line">])</span><br><span class="line">&#x2F;&#x2F; &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br></pre></td></tr></table></figure><p><strong>用途：</strong>1、将 Map 结构转换成对象；2、将查询字符串转换为对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Map转对象</span><br><span class="line">const entries &#x3D; new Map([</span><br><span class="line">  [&#39;foo&#39;, &#39;bar&#39;],</span><br><span class="line">  [&#39;baz&#39;, 42]</span><br><span class="line">]);</span><br><span class="line">Object.fromEntries(entries) &#x2F;&#x2F; &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br><span class="line">const map &#x3D; new Map().set(&#39;foo&#39;, true).set(&#39;bar&#39;, false);</span><br><span class="line">Object.fromEntries(map) &#x2F;&#x2F; &#123; foo: true, bar: false &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询字符串转对象</span><br><span class="line">Object.fromEntries(new URLSearchParams(&#39;foo&#x3D;bar&amp;baz&#x3D;qux&#39;))</span><br><span class="line">&#x2F;&#x2F; &#123; foo: &quot;bar&quot;, baz: &quot;qux&quot; &#125;</span><br></pre></td></tr></table></figure><h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><h3 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h3><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let birth &#x3D; &#39;2000&#x2F;01&#x2F;01&#39;;</span><br><span class="line">const Person &#x3D; &#123;</span><br><span class="line">  name: &#39;张三&#39;,</span><br><span class="line">  &#x2F;&#x2F;等同于birth: birth</span><br><span class="line">  birth,</span><br><span class="line">  &#x2F;&#x2F; 等同于hello: function ()...</span><br><span class="line">  hello() &#123; console.log(&#39;我的名字是&#39;, this.name); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>简写的对象方法不能用作构造函数，会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const obj&#x3D;&#123;</span><br><span class="line">    a:function()&#123;</span><br><span class="line">      console.log(111)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 函数简写</span><br><span class="line">    b()&#123;</span><br><span class="line">      console.log(222)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new obj.a())</span><br><span class="line">console.log(new obj.b())</span><br><span class="line">&#x2F;&#x2F; 111</span><br><span class="line">&#x2F;&#x2F; a &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: obj.b is not a constructor</span><br></pre></td></tr></table></figure><h3 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h3><p>对象的每个属性都有一个描述对象，可以用<code>Object.getOwnPrototypeDescriptor()</code>方法获取对象指定属性的描述对象，描述对象的<code>enumerable</code>属性，就是可枚举性。</p><p>如果<code>enumerable</code>属性为false，就表明该属性是不可枚举的，当我们使用以下四个方法操作对象的时候，会跳过不可枚举的属性：</p><ul><li>for…in循环：只遍历对象自身的和继承的可枚举的属性。</li><li>Object.keys()：返回对象自身的所有可枚举的属性的键名。</li><li>JSON.stringify()：只串行化对象自身的可枚举的属性。</li><li>Object.assign()：只拷贝对象自身的可枚举的属性。</li></ul><p>所以可以利用这个不可枚举来规避for…in循环对象内部所有属性和方法的问题。比如对象的toString()方法，因为不可枚举，循坏的时候就不会循环该方法。</p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>对象有一个super关键字，代表该对象的原型对象，但是super关键字只能用在对象的方法里面，用在其他地方会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const proto &#x3D; &#123;</span><br><span class="line">  foo: &#39;hello&#39;</span><br><span class="line">&#125;</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  foo: &#39;world&#39;,</span><br><span class="line">  find() &#123;</span><br><span class="line">    return super.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Object.setPrototypeOf(obj, proto) &#x2F;&#x2F; obj 的原型对象是 proto</span><br><span class="line">obj.find() &#x2F;&#x2F; &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以下三种情况都报错</span><br><span class="line">const obj &#x3D; &#123;foo: super.foo&#125;</span><br><span class="line">const obj &#x3D; &#123;foo: () &#x3D;&gt; super.foo&#125;</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  foo: function () &#123;</span><br><span class="line">    return super.foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>__proto__</code>和<code>prototype</code></li></ol><ul><li>对象有<code>__proto__</code>属性，函数有<code>__proto__</code>属性，数组也有<code>__proto__</code>属性，只要是引用类型，就有<code>__proto__</code>属性，指向其原型。</li><li>只有函数有<code>prototype</code>属性，只有函数有<code>prototype</code>属性，只有函数有<code>prototype</code>属性，指向new操作符加调用该函数创建的对象实例的原型对象。</li></ul><ol start="2"><li><code>instanceof</code><br>判断数据类型，可以使用<code>typeof</code>运算符，但是引用数据类型并不适用，除了函数返回的是<code>function</code>，其他返回的全是<code>object</code>。我们想要知道一个对象的具体类型，就需要使用到<code>instanceof</code>。<code>instanceof</code>的实际原理就是判断右侧的<code>prototype</code>是否在左侧对象的原型链上。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例：函数对象和数组对象最终的原型链顶层就是Object</span><br><span class="line">let fn &#x3D; function() &#123;&#125;</span><br><span class="line">let arr &#x3D; []</span><br><span class="line">fn instanceof Function &#x2F;&#x2F; true</span><br><span class="line">arr instanceof Array &#x2F;&#x2F; true</span><br><span class="line">fn instanceof Object &#x2F;&#x2F; true</span><br><span class="line">arr instanceof Object &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 手动实现instanceof</span><br><span class="line">var myInstanceof &#x3D; function(target,origin)&#123;</span><br><span class="line">  const proto &#x3D; target.__proto__</span><br><span class="line">  if(proto)&#123;</span><br><span class="line">    if(origin.prototype &#x3D;&#x3D;&#x3D; proto)&#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      return myInstanceof(proto,origin)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如何创建一个没有原型的对象？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const tempObj &#x3D; Object.create(null)</span><br><span class="line">console.log(tempObj.__proto__) &#x2F;&#x2F; undefined</span><br><span class="line">&#x2F;&#x2F; Object.create的第一个入参只能是null或者非原始包装对象，否则会抛出异常</span><br></pre></td></tr></table></figure></li></ol><h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>在JavaScript中，生成实例对象的传统写法是通过构造函数，但是这种写法和面向对象的传统编程语言差异很大，为了更接近传统语言，引入 Class 类，类可以看作是构造函数的另一种写法。</p><p><strong>类所有的属性和方法，都定义在类的prototype属性上面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 传统写法</span><br><span class="line">function Point1(x, y) &#123;</span><br><span class="line">  this.x &#x3D; x;</span><br><span class="line">  this.y &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line">Point1.prototype.toString &#x3D; function () &#123;</span><br><span class="line">  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">&#125;;</span><br><span class="line">var p1 &#x3D; new Point1(1, 2);</span><br><span class="line">&#x2F;&#x2F; Class 写法</span><br><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const p &#x3D; new Point(1,2)</span><br><span class="line">&#x2F;&#x2F; 类可以看作是构造函数的另一种写法</span><br><span class="line">Point &#x3D;&#x3D;&#x3D; Point.prototype.constructor &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 类所有的属性和方法，都定义在类的prototype属性上面</span><br><span class="line">p.constructor &#x3D;&#x3D;&#x3D; Point.prototype.constructor &#x2F;&#x2F; true</span><br><span class="line">p.hasOwnProperty(&#39;x&#39;) &#x2F;&#x2F; true</span><br><span class="line">p.hasOwnProperty(&#39;y&#39;) &#x2F;&#x2F; true</span><br><span class="line">p.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; false</span><br><span class="line">p.__proto__.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p><code>constructor()</code>类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的constructor()方法会被默认添加。</p><p><code>constructor()</code>方法默认返回实例对象（即this）</p><h2 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h2><h3 id="实例属性新写法"><a href="#实例属性新写法" class="headerlink" title="实例属性新写法"></a>实例属性新写法</h3><p>属性除了可以定义在<code>constructor()</code>里的<code>this</code>上，还可以定义在类内部的最顶层。虽然写法不一样，但是都是指向实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  &#x2F;&#x2F; 新写法</span><br><span class="line">  x &#x3D; 0</span><br><span class="line">  y &#x3D; 0</span><br><span class="line">  &#x2F;&#x2F; 旧写法</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取值函数-getter-和存值函数-setter"><a href="#取值函数-getter-和存值函数-setter" class="headerlink" title="取值函数(getter)和存值函数(setter)"></a>取值函数(getter)和存值函数(setter)</h3><p>类可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置取值函数和存值函数，拦截该属性的存取行为。<br>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;&#125;</span><br><span class="line">  get num() &#123;</span><br><span class="line">    return &#39;getter&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  set num(value) &#123;</span><br><span class="line">    console.log(&#39;setter:&#39;+value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const p &#x3D; new Point()</span><br><span class="line">p.num &#x3D; 1 &#x2F;&#x2F; setter:1</span><br><span class="line">p.num &#x2F;&#x2F; getter</span><br><span class="line">const desc &#x3D; Object.getOwnPropertyDescriptor(Point.prototype,&#39;num&#39;)</span><br><span class="line">&#39;get&#39; in desc &#x2F;&#x2F; true</span><br><span class="line">&#39;set&#39; in desc &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h3 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h3><p>静态属性和方法，就是在属性和方法前面加上<code>static</code>关键字，表示该属性和方法<strong>不会被实例继承</strong>，但是会被子类继承，可以直接通过类来操作。</p><p>静态方法里面的this，指向类，而不是实例。</p><p>静态方法可以和非静态方法重名，静态方法可以从<code>super</code>对象上调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static prop &#x3D; 1; &#x2F;&#x2F; 静态属性</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    return &#39;hello&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  static bar() &#123;</span><br><span class="line">    this.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  static baz() &#123;</span><br><span class="line">    console.log(&#39;hello&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  baz() &#123;   &#x2F;&#x2F; 静态方法可以和非静态方法重名</span><br><span class="line">    console.log(&#39;world&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() &#x2F;&#x2F; &#39;hello&#39; 静态方法通过类来操作</span><br><span class="line"></span><br><span class="line">var foo &#x3D; new Foo();</span><br><span class="line">foo.classMethod() &#x2F;&#x2F; 静态方法不会被实例继承</span><br><span class="line">&#x2F;&#x2F; TypeError: foo.classMethod is not a function</span><br><span class="line"></span><br><span class="line">Foo.bar() &#x2F;&#x2F; hello 静态方法里的this指向类</span><br><span class="line"></span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">  static classMethod2() &#123;</span><br><span class="line">    return super.classMethod() + &#39;, too&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() &#x2F;&#x2F; &#39;hello&#39; 静态方法可以被子类继承</span><br><span class="line">Bar.classMethod(2) &#x2F;&#x2F; &#39;hello, too&#39; 静态方法可以用super对象调用</span><br></pre></td></tr></table></figure><h3 id="私有属性和方法"><a href="#私有属性和方法" class="headerlink" title="私有属性和方法"></a>私有属性和方法</h3><p>私有属性和方法，就是在属性和方法前面加上<code>#</code>，表示该属性和方法<strong>只能在类的内部使用</strong>。</p><p>私有属性和方法<strong>不能被子类继承</strong>。</p><p>私有属性也可以设置 getter 和 setter 函数进行操作拦截。</p><h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><p>类可以通过<code>extends</code>关键字实现继承，让子类继承父类的所有属性和方法，除了私有属性和方法。</p><p><strong>子类必须在<code>constructor()</code>方法中先调用<code>super()</code>，否则会报错。</strong><br>这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用super()方法，子类就得不到自己的this对象。</p><p><code>super()</code>作为函数，表示父类的构造函数，只能在子类的<code>constructor()</code>里使用，被调用的时候用来创建一个父类的实例，但是返回的是子类的实例。<br><code>super</code>作为对象，在普通方法里，指向父类的原型对象；在静态方法里，指向父类。</p><p>如果子类没有显示的定义<code>constructor()</code>，这个方法默认添加，并且里面会调用<code>super()</code>。</p><p>可以使用<code>Object.getPrototypeOf()</code>来获取子类的父类。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>Set，它类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成 Set 数据结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const s &#x3D; new Set();</span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].forEach(x &#x3D;&gt; s.add(x));</span><br><span class="line">for (let i of s) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 2 3 5 4</span><br><span class="line"></span><br><span class="line">const set &#x3D; new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...set]</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 去除数组的重复成员</span><br><span class="line">const array&#x3D;[1,1,2,2,3,3]</span><br><span class="line">&#x2F;&#x2F; 方法一：</span><br><span class="line">[...new Set(array)]</span><br><span class="line">&#x2F;&#x2F; 方法二：该方法可将Set转换成数组</span><br><span class="line">Array.from(new Set(array))</span><br><span class="line">&#x2F;&#x2F; [1,2,3]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 去除字符串的重复字符</span><br><span class="line">[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)</span><br><span class="line">&#x2F;&#x2F; &quot;abc&quot;</span><br></pre></td></tr></table></figure><div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;'>往 Set 里面加值的时候，内部判断两值是否相等的算法，叫做“Same-value-zero equality”，它类似于精确相等运算符（`===`），区别就在于向 Set 加入值时认为NaN等于自身（即不能添加两个NaN），而精确相等运算符认为NaN不等于自身。</div><h2 id="实例属性-size"><a href="#实例属性-size" class="headerlink" title="实例属性-size"></a>实例属性-size</h2><p><code>Set.prototype.size</code>：返回Set实例的成员总数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.add(1).add(2).add(2);</span><br><span class="line">&#x2F;&#x2F; 注意2被加入了两次</span><br><span class="line"></span><br><span class="line">s.size &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure><h2 id="实例操作方法-add-delete-has-clear"><a href="#实例操作方法-add-delete-has-clear" class="headerlink" title="实例操作方法-add/delete/has/clear"></a>实例操作方法-add/delete/has/clear</h2><ul><li><code>Set.property.add()</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.property.delete()</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.property.has()</code>：返回一个布尔值，表示该值是否为Set的成员。</li><li><code>Set.property.clear()</code>：清除所有成员，没有返回值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s.add(1).add(2).add(2);</span><br><span class="line">&#x2F;&#x2F; 注意2被加入了两次</span><br><span class="line"></span><br><span class="line">s.size &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">s.has(1) &#x2F;&#x2F; true</span><br><span class="line">s.has(2) &#x2F;&#x2F; true</span><br><span class="line">s.has(3) &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">s.delete(2); &#x2F;&#x2F; true-表示删除成功</span><br><span class="line">s.has(2) &#x2F;&#x2F; false</span><br><span class="line">s.clear() &#x2F;&#x2F; 清空，无返回值</span><br></pre></td></tr></table></figure><h2 id="实例遍历方法-keys-values-entries-forEach"><a href="#实例遍历方法-keys-values-entries-forEach" class="headerlink" title="实例遍历方法-keys/values/entries/forEach"></a>实例遍历方法-keys/values/entries/forEach</h2><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Set.prototype.values()</code>：返回键值的遍历器。</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器。</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员。</li></ul><p>keys方法、values方法、entries方法返回的都是遍历器对象。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致，entries方法同时包含键名和键值，键名和键值一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let set &#x3D; new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);</span><br><span class="line"></span><br><span class="line">for (let item of set.keys()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; red</span><br><span class="line">&#x2F;&#x2F; green</span><br><span class="line">&#x2F;&#x2F; blue</span><br><span class="line"></span><br><span class="line">for (let item of set.values()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; red</span><br><span class="line">&#x2F;&#x2F; green</span><br><span class="line">&#x2F;&#x2F; blue</span><br><span class="line"></span><br><span class="line">for (let item of set.entries()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [&quot;red&quot;, &quot;red&quot;]</span><br><span class="line">&#x2F;&#x2F; [&quot;green&quot;, &quot;green&quot;]</span><br><span class="line">&#x2F;&#x2F; [&quot;blue&quot;, &quot;blue&quot;]</span><br><span class="line"></span><br><span class="line">set.forEach((value, key) &#x3D;&gt; console.log(key + &#39; : &#39; + value))</span><br><span class="line">&#x2F;&#x2F; red : red</span><br><span class="line">&#x2F;&#x2F; green : green</span><br><span class="line">&#x2F;&#x2F; blue : blue</span><br></pre></td></tr></table></figure><p><strong>Set 实例默认可遍历，它的默认遍历器生成函数就是它的values方法，所以可以省略values方法，直接使用<code>for...of</code>遍历</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 下面两种用法一致</span><br><span class="line">for (let item of set.values()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">for (let item of set) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。它与 Set 区别如下：</p><ul><li>WeakSet 的成员只能是对象，而不能是其他类型的值；Set 可以是任意类型。</li><li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</li><li>WeakSet 只有 <code>add()/delete()/has()</code> 方法，不支持<code>clear()</code>、<code>size</code>属性和遍历方法。</li></ul><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h2><p>Map，它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将对象作为键</span><br><span class="line">const m &#x3D; new Map();</span><br><span class="line">const o &#x3D; &#123;p: &#39;Hello World&#39;&#125;;</span><br><span class="line">m.set(o, &#39;content&#39;)</span><br><span class="line">&#x2F;&#x2F; 接受数组作为参数，数组的成员是一个个键值对的数组</span><br><span class="line">const map &#x3D; new Map([</span><br><span class="line">  [&#39;name&#39;, &#39;张三&#39;],</span><br><span class="line">  [&#39;title&#39;, &#39;Author&#39;]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h2 id="实例属性-size-1"><a href="#实例属性-size-1" class="headerlink" title="实例属性-size"></a>实例属性-size</h2><p><code>Map.property.size</code>：返回Map实例的成员总数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const map &#x3D; new Map();</span><br><span class="line">map.set(&#39;foo&#39;, true);</span><br><span class="line">map.set(&#39;bar&#39;, false);</span><br><span class="line"></span><br><span class="line">map.size &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure><h2 id="实例操作方法-set-get-has-delete-clear"><a href="#实例操作方法-set-get-has-delete-clear" class="headerlink" title="实例操作方法-set/get/has/delete/clear"></a>实例操作方法-set/get/has/delete/clear</h2><ul><li><code>Map.prototype.set(key, value)</code>：set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</li><li><code>Map.prototype.get(key)</code>：get方法读取key对应的键值，如果找不到key，返回undefined。</li><li><code>Map.prototype.has(key)</code>：has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li><li><code>Map.prototype.delete(key)</code>：delete方法删除某个键，返回true。如果删除失败，返回false。</li><li><code>Map.prototype.clear()</code>：clear方法清除所有成员，没有返回值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const m &#x3D; new Map();</span><br><span class="line"></span><br><span class="line">m.set(&#39;edition&#39;, 6)        &#x2F;&#x2F; 键是字符串</span><br><span class="line">m.set(262, &#39;standard&#39;)     &#x2F;&#x2F; 键是数值</span><br><span class="line">m.set(undefined, &#39;nah&#39;)    &#x2F;&#x2F; 键是 undefined</span><br><span class="line">m.set(1,&#39;1&#39;).set(2,&#39;2&#39;)    &#x2F;&#x2F; set返回的是当前Map对象，所以可以采用链式写法</span><br><span class="line">m.set(1,&#39;一&#39;)</span><br><span class="line">m.get(1)  &#x2F;&#x2F; 一 key已经存在，重复赋值键值会被更新</span><br><span class="line">m.set([&#39;aaa&#39;],1)</span><br><span class="line">m.get([&#39;aaa&#39;]) &#x2F;&#x2F; undefined </span><br><span class="line">&#x2F;&#x2F; 如果键是引用数据类型，那么set和get表面上针对的是同一个键，但是键的内存地址不同，所以get方法无法读物键值，返回undefined</span><br><span class="line">const k1 &#x3D; [&#39;a&#39;]</span><br><span class="line">const k2 &#x3D; [&#39;a&#39;]</span><br><span class="line">m.set(k1,1).set(k2,2)</span><br><span class="line">m.get(k1) &#x2F;&#x2F; 1</span><br><span class="line">m.get(k2) &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">m.has(&#39;edition&#39;) &#x2F;&#x2F; true</span><br><span class="line">m.has(11111) &#x2F;&#x2F; false</span><br><span class="line">m.delete(262) &#x2F;&#x2F; true</span><br><span class="line">m.get(262) &#x2F;&#x2F; undefined</span><br><span class="line">m.clear()</span><br><span class="line">m.size &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure><h2 id="实例遍历方法-keys-values-entries-forEach-1"><a href="#实例遍历方法-keys-values-entries-forEach-1" class="headerlink" title="实例遍历方法-keys/values/entries/forEach"></a>实例遍历方法-keys/values/entries/forEach</h2><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回键值对的遍历器。</li><li><code>Map.prototype.forEach()</code>：使用回调函数遍历每个成员。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">const map &#x3D; new Map([</span><br><span class="line">  [&#39;F&#39;, &#39;no&#39;],</span><br><span class="line">  [&#39;T&#39;,  &#39;yes&#39;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">for (let key of map.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot;</span><br><span class="line">[...map.keys()]</span><br><span class="line">&#x2F;&#x2F; [&quot;F&quot;,&quot;T&quot;]</span><br><span class="line"></span><br><span class="line">for (let value of map.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;yes&quot;</span><br><span class="line">[...map.values()]</span><br><span class="line">&#x2F;&#x2F; [&quot;no&quot;,&quot;yes&quot;]</span><br><span class="line"></span><br><span class="line">for (let item of map.entries()) &#123;</span><br><span class="line">  console.log(item[0], item[1]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot; &quot;yes&quot;</span><br><span class="line">[...map.entries()]</span><br><span class="line">&#x2F;&#x2F; [[&quot;F&quot;,&quot;no&quot;],[&quot;T&quot;,&quot;yes&quot;]]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">for (let [key, value] of map.entries()) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot; &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于使用map.entries()</span><br><span class="line">for (let [key, value] of map) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot; &quot;yes&quot;</span><br><span class="line">[...map]</span><br><span class="line">&#x2F;&#x2F; [[&quot;F&quot;,&quot;no&quot;],[&quot;T&quot;,&quot;yes&quot;]]</span><br><span class="line"></span><br><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; Key: F, Value: no</span><br><span class="line">&#x2F;&#x2F; Key: T, Value: yes</span><br></pre></td></tr></table></figure><h2 id="数据结构相互转化"><a href="#数据结构相互转化" class="headerlink" title="数据结构相互转化"></a>数据结构相互转化</h2><ul><li>Map &lt;==&gt; 数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Map 转 数组，使用扩展运算符(...)</span><br><span class="line">const myMap &#x3D; new Map().set(true, 7).set(&#123;foo: 3&#125;, [&#39;abc&#39;]);</span><br><span class="line">[...myMap]</span><br><span class="line">&#x2F;&#x2F; [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#39;abc&#39; ] ] ]</span><br><span class="line">&#x2F;&#x2F; 数组 转 Map，将数组传入Map构造函数即可</span><br><span class="line">new Map([</span><br><span class="line">  [true, 7],</span><br><span class="line">  [&#123;foo: 3&#125;, [&#39;abc&#39;]]</span><br><span class="line">])</span><br></pre></td></tr></table></figure></li><li>Map &lt;==&gt; 对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Map 转 对象，如果键是字符串可以无损转化，不是的话会被转成字符串</span><br><span class="line">function strMapToObj(strMap) &#123;</span><br><span class="line">  let obj &#x3D; Object.create(null);</span><br><span class="line">  for (let [k,v] of strMap) &#123;</span><br><span class="line">    obj[k] &#x3D; v;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 对象 转 Map，使用 Object.entries() 最方便</span><br><span class="line">let obj &#x3D; &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;</span><br><span class="line">let map &#x3D; new Map(Object.entries(obj));</span><br><span class="line">&#x2F;&#x2F; 也可以自己手写函数</span><br><span class="line">function objToStrMap(obj) &#123;</span><br><span class="line">  let strMap &#x3D; new Map();</span><br><span class="line">  for (let k of Object.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  return strMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p>WeakMap 与 Map 类似，都是用于生成键值对的集合。它与 Map 区别如下：</p><ul><li>WeakMap 只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li><li>WeakMap 的键名所指向的对象，不计入垃圾回收机制。<br>它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用<strong>手动删除</strong>引用。</li><li>WeakMap 只有 <code>set()/get()/delete()/has()</code> 方法，不支持<code>clear()</code>、<code>size</code>属性和遍历方法。</li></ul><h1 id="ES6新增运算符"><a href="#ES6新增运算符" class="headerlink" title="ES6新增运算符"></a>ES6新增运算符</h1><h2 id="指数运算符"><a href="#指数运算符" class="headerlink" title="** 指数运算符"></a>** 指数运算符</h2><p>当有多个指数运算符的时候，从最右边开始计算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 5</span><br><span class="line">a ** 3 &#x2F;&#x2F; 5*5*5 &#x3D; 125</span><br><span class="line">&#x2F;&#x2F; 右结合</span><br><span class="line">2 ** 3 ** 2 &#x2F;&#x2F; 2**(3**2) 先计算3*3等于9，再计算2^9等于512</span><br><span class="line">a **&#x3D; 3 &#x2F;&#x2F; a&#x3D;a**3&#x3D;a*a*a</span><br></pre></td></tr></table></figure><h2 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="?. 链判断运算符"></a>?. 链判断运算符</h2><p>直接访问对象上的某个属性，如<code>obj.a</code>，如果obj是null或者undefined，访问属性的话会报错。</p><p><code>?.</code>链判断运算符会判断左侧对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj ?. a</span><br><span class="line">obj ? obj.a : undefined</span><br></pre></td></tr></table></figure><h2 id="Null判断运算符"><a href="#Null判断运算符" class="headerlink" title="?? Null判断运算符"></a>?? Null判断运算符</h2><p>行为类似<code>||</code>，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值，否则返回左侧的值。<br><code>||</code>会在左操作数为假值（0,null,undefined,’’,NAN）时返回右侧的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const a &#x3D; 0</span><br><span class="line">const b &#x3D; a ?? 1 &#x2F;&#x2F; b&#x3D;0</span><br><span class="line">const c &#x3D; a || 1 &#x2F;&#x2F; b&#x3D;1</span><br></pre></td></tr></table></figure><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>Proxy 代理器，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var proxy &#x3D; new Proxy(target, handler)</span><br></pre></td></tr></table></figure><ul><li>target 参数表示所要拦截的目标对象</li><li>handler参数也是一个对象，用来定制拦截行为，具体拦截方法如下：<ul><li><code>get()</code>：用于拦截某个属性的读取操作</li><li><code>set()</code>：用于拦截某个属性的赋值操作</li><li><code>has()</code>：用于拦截判断对象是否具有某个属性的操作</li><li><code>apply()</code>：用于拦截函数的调用、call和apply操作</li><li><code>construct()</code>：用于拦截 new 操作</li><li><code>defineProperty()</code>：用于拦截添加属性操作</li><li><code>deleteProperty()</code>：用于拦截 delete 操作</li><li><code>setPrototypeOf()</code>：用于拦截设置对象的原型对象的操作，如<code>Object.setPrototypeOf()</code></li><li><code>getPrototypeOf()</code>：用于拦截读取对象的原型对象的操作，如<code>Object.getPrototypeOf()</code>等</li><li><code>ownKeys()</code>：用于拦截对象自身属性的读取的操作，如<code>Object.keys()</code>等</li><li><code>getOwnPropertyDescriptor()</code>：用于拦截取对象指定属性描述对象的操作，如<code>Object.getOwnPropertyDescriptor()</code></li><li><code>isExtensible()</code>：用于拦截判断对象是否可扩展（是否可以添加属性）的操作，如<code>Object.isExtensible()</code></li><li><code>preventExtensions()</code>：用于拦截将对象变得不可扩展的操作，如<code>Object.preventExtensions()</code></li></ul></li></ul><div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;'>如果想要 Proxy 起作用，必须针对 Proxy 的实例进行操作，而不是针对目标对象 target 进行操作。除非 handler 没有设置任何拦截行为，访问 Proxy 实例就相当于访问目标对象 target。</div><h2 id="拦截方法"><a href="#拦截方法" class="headerlink" title="拦截方法"></a>拦截方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p><code>get(target, propKey, receiver)</code>：用于拦截某个属性的读取操作，接受三个参数，依次为目标对象、属性名和 proxy 实例本身，最后一个参数可选。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果访问目标对象不存在的属性，会抛出一个错误。</span><br><span class="line">&#x2F;&#x2F; 如果没有这个拦截函数，访问不存在的属性，只会返回undefined。</span><br><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name: &quot;张三&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var proxy &#x3D; new Proxy(person, &#123;</span><br><span class="line">  get: function(target, propKey) &#123;</span><br><span class="line">    if (propKey in target) &#123;</span><br><span class="line">      return target[propKey];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new ReferenceError(&quot;Prop name \&quot;&quot; + propKey + &quot;\&quot; does not exist.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name &#x2F;&#x2F; &quot;张三&quot;</span><br><span class="line">proxy.age &#x2F;&#x2F; 抛出一个错误</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><code>set(target, propKey, value, receiver)</code>：用于拦截某个属性的赋值操作，接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。</span><br><span class="line">const handler &#x3D; &#123;</span><br><span class="line">  get (target, key) &#123;</span><br><span class="line">    invariant(key, &#39;get&#39;);</span><br><span class="line">    return target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, key, value) &#123;</span><br><span class="line">    invariant(key, &#39;set&#39;);</span><br><span class="line">    target[key] &#x3D; value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function invariant (key, action) &#123;</span><br><span class="line">  if (key[0] &#x3D;&#x3D;&#x3D; &#39;_&#39;) &#123;</span><br><span class="line">    throw new Error(&#96;Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const target &#x3D; &#123;&#125;;</span><br><span class="line">const proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">proxy._prop</span><br><span class="line">&#x2F;&#x2F; Error: Invalid attempt to get private &quot;_prop&quot; property</span><br><span class="line">proxy._prop &#x3D; &#39;c&#39;</span><br><span class="line">&#x2F;&#x2F; Error: Invalid attempt to set private &quot;_prop&quot; property</span><br></pre></td></tr></table></figure><h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><p><code>has(target, propKey)</code>：用于拦截判断对象是否具有某个属性的操作，典型的操作就是in运算符，返回布尔值。接受两个参数，分别是目标对象、需查询的属性名。</p><div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:10px;'>has()方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has()方法不判断一个属性是对象自身的属性，还是继承的属性。</div><div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:10px;'>虽然for...in循环也用到了in运算符，但是has()拦截对for...in循环不生效。</div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">let stu1 &#x3D; &#123;name: &#39;张三&#39;, score: 59&#125;;</span><br><span class="line">let stu2 &#x3D; &#123;name: &#39;李四&#39;, score: 99&#125;;</span><br><span class="line"></span><br><span class="line">let handler &#x3D; &#123;</span><br><span class="line">  has(target, prop) &#123;</span><br><span class="line">    if (prop &#x3D;&#x3D;&#x3D; &#39;score&#39; &amp;&amp; target[prop] &lt; 60) &#123;</span><br><span class="line">      console.log(&#96;$&#123;target.name&#125; 不及格&#96;);</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return prop in target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let oproxy1 &#x3D; new Proxy(stu1, handler);</span><br><span class="line">let oproxy2 &#x3D; new Proxy(stu2, handler);</span><br><span class="line"></span><br><span class="line">&#39;score&#39; in oproxy1</span><br><span class="line">&#x2F;&#x2F; 张三 不及格</span><br><span class="line">&#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#39;score&#39; in oproxy2</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">for (let a in oproxy1) &#123;</span><br><span class="line">  console.log(oproxy1[a]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 张三</span><br><span class="line">&#x2F;&#x2F; 59</span><br><span class="line"></span><br><span class="line">for (let b in oproxy2) &#123;</span><br><span class="line">  console.log(oproxy2[b]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 李四</span><br><span class="line">&#x2F;&#x2F; 99</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p><code>apply(target, object, args)</code>：用于拦截函数的调用、call和apply操作，接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截。</span><br><span class="line">var twice &#x3D; &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    return Reflect.apply(...arguments) * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function sum (left, right) &#123;</span><br><span class="line">  return left + right;</span><br><span class="line">&#125;;</span><br><span class="line">var proxy &#x3D; new Proxy(sum, twice);</span><br><span class="line">proxy(1, 2) &#x2F;&#x2F; 6</span><br><span class="line">proxy.call(null, 5, 6) &#x2F;&#x2F; 22</span><br><span class="line">proxy.apply(null, [7, 8]) &#x2F;&#x2F; 30</span><br></pre></td></tr></table></figure><h3 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h3><p><code>construct(terget, args, newTarget)</code>：用于拦截 new 操作，接受三个参数，依次是目标对象、构造函数的参数数组、创造实例对象时，new命令作用的构造函数（下面例子的p）。</p><p><strong>目标对象必须是函数，否则会报错</strong><br><strong><code>construct()</code>方法必须返回对象，否则报错</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const p &#x3D; new Proxy(function () &#123;&#125;, &#123;</span><br><span class="line">  construct: function(target, args) &#123;</span><br><span class="line">    console.log(&#39;called: &#39; + args.join(&#39;, &#39;));</span><br><span class="line">    return &#123; value: args[0] * 10 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(new p(1)).value</span><br><span class="line">&#x2F;&#x2F; &quot;called: 1&quot;</span><br><span class="line">&#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">const p1 &#x3D; new Proxy(function() &#123;&#125;, &#123;</span><br><span class="line">  construct: function(target, argumentsList) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new p1() &#x2F;&#x2F; 报错 construct必须返回对象</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: &#39;construct&#39; on proxy: trap returned non-object (&#39;1&#39;)</span><br><span class="line"></span><br><span class="line">const p2 &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  construct: function(target, argumentsList) &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new p2() &#x2F;&#x2F; 报错 目标对象必须是函数</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: p is not a constructor</span><br></pre></td></tr></table></figure><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h3><p><code>defineProperty(target, propKey, propDesc)</code>：用于拦截添加属性操作，如<code>Object.defineProperty()</code>，接受三个参数，依次是目标对象、要添加的属性和其描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var handler &#x3D; &#123;</span><br><span class="line">  defineProperty (target, key, descriptor) &#123;</span><br><span class="line">    return false; &#x2F;&#x2F; 返回布尔值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target &#x3D; &#123;&#125;;</span><br><span class="line">var proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">proxy.foo &#x3D; &#39;bar&#39; &#x2F;&#x2F; 不会生效</span><br></pre></td></tr></table></figure><h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty"></a>deleteProperty</h3><p><code>deleteProperty(target, propKey)</code>：用于拦截 delete 删除属性的操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除第一个字符为下划线的属性会报错。</span><br><span class="line">var handler &#x3D; &#123;</span><br><span class="line">  deleteProperty (target, key) &#123;</span><br><span class="line">    invariant(key, &#39;delete&#39;);</span><br><span class="line">    delete target[key];</span><br><span class="line">    return true; &#x2F;&#x2F; 返回布尔值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function invariant (key, action) &#123;</span><br><span class="line">  if (key[0] &#x3D;&#x3D;&#x3D; &#39;_&#39;) &#123;</span><br><span class="line">    throw new Error(&#96;Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var target &#x3D; &#123; _prop: &#39;foo&#39; &#125;;</span><br><span class="line">var proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">delete proxy._prop</span><br><span class="line">&#x2F;&#x2F; Error: Invalid attempt to delete private &quot;_prop&quot; property</span><br></pre></td></tr></table></figure><h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf"></a>setPrototypeOf</h3><p><code>setPrototypeOf(target, proto)</code>：用于拦截设置对象的原型对象的操作，如<code>Object.setPrototypeOf()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var handler &#x3D; &#123;</span><br><span class="line">  setPrototypeOf (target, proto) &#123;</span><br><span class="line">    throw new Error(&#39;Changing the prototype is forbidden&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var proto &#x3D; &#123;&#125;;</span><br><span class="line">var target &#x3D; function () &#123;&#125;;</span><br><span class="line">var proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">Object.setPrototypeOf(proxy, proto);</span><br><span class="line">&#x2F;&#x2F; Error: Changing the prototype is forbidden</span><br></pre></td></tr></table></figure><h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf"></a>getPrototypeOf</h3><p><code>getPrototypeOf(target)</code>：用于拦截读取对象的原型对象的操作。如：</p><ul><li><code>Object.prototype.__proto__</code></li><li><code>Object.prototype.isPrototypeOf()</code></li><li><code>Object.getPrototypeOf()</code></li><li><code>Reflect.getPrototypeOf()</code></li><li><code>instanceof</code></li></ul><p><strong><code>getPrototypeOf()</code>的返回值必须是对象或者null，否则报错</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var proto &#x3D; &#123;&#125;;</span><br><span class="line">var p &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  getPrototypeOf(target) &#123;</span><br><span class="line">    return proto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.getPrototypeOf(p) &#x3D;&#x3D;&#x3D; proto &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h3><p><code>ownKeys(target)</code>：用于拦截对象自身属性的读取的操作，如：</p><ul><li><code>Object.getOwnPropertyNames()</code></li><li><code>Object.getOwnPropertySymbols()</code></li><li><code>Object.keys()</code></li><li><code>for.....in</code>循环</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let target &#x3D; &#123;</span><br><span class="line">  _bar: &#39;foo&#39;,</span><br><span class="line">  _prop: &#39;bar&#39;,</span><br><span class="line">  prop: &#39;baz&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let handler &#x3D; &#123;</span><br><span class="line">  ownKeys (target) &#123;</span><br><span class="line">    return Reflect.ownKeys(target).filter(key &#x3D;&gt; key[0] !&#x3D;&#x3D; &#39;_&#39;); &#x2F;&#x2F; 返回满足条件的keys数组</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">for (let key of Object.keys(proxy)) &#123;</span><br><span class="line">  console.log(target[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;baz&quot;</span><br></pre></td></tr></table></figure><h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor"></a>getOwnPropertyDescriptor</h3><p><code>getOwnPropertyDescriptor(target, propKey)</code>：用于拦截取对象指定属性描述对象的操作，如<code>Object.getOwnPropertyDescriptor()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var handler &#x3D; &#123;</span><br><span class="line">  getOwnPropertyDescriptor (target, key) &#123;</span><br><span class="line">    if (key[0] &#x3D;&#x3D;&#x3D; &#39;_&#39;) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    return Object.getOwnPropertyDescriptor(target, key); &#x2F;&#x2F; 返回描述对象</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target &#x3D; &#123; _foo: &#39;bar&#39;, baz: &#39;tar&#39; &#125;;</span><br><span class="line">var proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, &#39;wat&#39;)</span><br><span class="line">&#x2F;&#x2F; undefined</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, &#39;_foo&#39;)</span><br><span class="line">&#x2F;&#x2F; undefined</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, &#39;baz&#39;)</span><br><span class="line">&#x2F;&#x2F; &#123; value: &#39;tar&#39;, writable: true, enumerable: true, configurable: true &#125;</span><br></pre></td></tr></table></figure><h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible"></a>isExtensible</h3><p><code>isExtensible(target)</code>：用于拦截判断对象是否可扩展（是否可以添加属性）的操作，如<code>Object.isExtensible()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: function(target) &#123;</span><br><span class="line">    console.log(&quot;called&quot;);</span><br><span class="line">    return true; &#x2F;&#x2F; 返回布尔值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.isExtensible(p)</span><br><span class="line">&#x2F;&#x2F; &quot;called&quot;</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions"></a>preventExtensions</h3><p><code>preventExtensions(target)</code>：用于拦截将对象变得不可扩展的操作，如<code>Object.preventExtensions()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var proxy &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: function(target) &#123;</span><br><span class="line">    console.log(&#39;called&#39;);</span><br><span class="line">    Object.preventExtensions(target); &#x2F;&#x2F; 如果没有这步操作，会报错</span><br><span class="line">    return true; &#x2F;&#x2F; 返回布尔值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.preventExtensions(proxy)</span><br><span class="line">&#x2F;&#x2F; &quot;called&quot;</span><br><span class="line">&#x2F;&#x2F; Proxy &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h2><p><code>Proxy.revocable(target,handler)</code>方法返回一个可取消的 Proxy 实例，主要使用场景是：目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let target &#x3D; &#123;&#125;;</span><br><span class="line">let handler &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">let &#123;proxy, revoke&#125; &#x3D; Proxy.revocable(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo &#x3D; 123;</span><br><span class="line">proxy.foo &#x2F;&#x2F; 123</span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo &#x2F;&#x2F; TypeError: Revoked</span><br></pre></td></tr></table></figure><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p>在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const target &#x3D; &#123;</span><br><span class="line">  m: function () &#123;</span><br><span class="line">    console.log(this &#x3D;&#x3D;&#x3D; proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const handler &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">const proxy &#x3D; new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">target.m() &#x2F;&#x2F; false</span><br><span class="line">proxy.m()  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><p>Reflect 和 Proxy 一样，也是用来操作对象，不同点在于：</p><ul><li>将 Object 对象的内部方法放到 Reflect 对象上，目前某些方法 Object 和 Reflect 都部署了，未来只会在 Reflect 上部署。</li><li>修改某些 Object 方法的返回值，让其合理，比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回false。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 老写法</span><br><span class="line">try &#123;</span><br><span class="line">  Object.defineProperty(target, property, attributes);</span><br><span class="line">  &#x2F;&#x2F; success</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  &#x2F;&#x2F; failure</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新写法</span><br><span class="line">if (Reflect.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  &#x2F;&#x2F; success</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; failure</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>让 Object 的命令式操作变成函数行为。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 老写法</span><br><span class="line">&#39;assign&#39; in Object &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新写法</span><br><span class="line">Reflect.has(Object, &#39;assign&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li><li>Reflect 对象的方法和 Proxy 对象的13中拦截方法一一对应。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Proxy(target, &#123;</span><br><span class="line">  set: function(target, name, value, receiver) &#123;</span><br><span class="line">    var success &#x3D; Reflect.set(target, name, value, receiver);</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      console.log(&#39;property &#39; + name + &#39; on &#39; + target + &#39; set to &#39; + value);</span><br><span class="line">    &#125;</span><br><span class="line">    return success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组常用方法总结如下：</p><ul><li>调用之后会改变原有的数组的方法，如：<ul><li><code>unshift()</code>：在数组第一位添加元素，返回更新后的数组长度</li><li><code>shift()</code>：删除数组的第一个元素，返回该元素</li><li><code>push()</code>：在数组末尾添加元素，返回更新后的数组的长度</li><li><code>pop()</code>：删除数组最后一个元素，返回该元素</li><li><code>sort()</code>：数组排序，也可添加回调函数定义自己想要的排序规则</li><li><code>reverse()</code>：数组倒序</li><li><code>splice(index,howMany)</code>：从index位置删除howMany个数组元素<br><code>splice(index,howMany,item1...itemX)</code>：从index位置删除howMany个数组元素，然后添加item1…itemX元素至数组</li></ul></li><li>调用之后不会改变原有数组的方法，如：<ul><li><code>concat(arr1,arr2...)</code>：连接两个或者更多个数组</li><li><code>every((index,value,arr)=&gt;{},thisArg)</code>：遍历每一个元素，判断所有元素是不是都符合条件，有一个不符合就返回false，全部符合返回true</li><li><code>some((index,value,arr)=&gt;{},thisArg)</code>：遍历每一个元素，判断所有元素是不是都符合条件，有一个符合就返回true，全部不符合返回false</li><li><code>filter()</code>：数组过滤</li><li><code>map()</code>：数组遍历</li><li><code>forEach()</code>：数组遍历</li><li><code>slice(start=0,end=this.length)</code>：数组截取，包含开始参数，不包含结束参数</li></ul></li></ul><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p><code>Array.form()</code>将 类似数组的对象 / 可遍历的对象 转为数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 类似数组的对象</span><br><span class="line">let arrayLike &#x3D; &#123;</span><br><span class="line">    &#39;0&#39;: &#39;a&#39;,</span><br><span class="line">    &#39;1&#39;: &#39;b&#39;,</span><br><span class="line">    &#39;2&#39;: &#39;c&#39;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;</span><br><span class="line">Array.from(arrayLike) &#x2F;&#x2F; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可遍历的对象 - 即该对象带有length属性</span><br><span class="line">function foo() &#123;</span><br><span class="line">  var args &#x3D; Array.from(arguments);</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.from(&#39;hello&#39;) &#x2F;&#x2F; [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]</span><br></pre></td></tr></table></figure><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p><code>Array.of()</code>将一组值转化成数组，用于解决<code>Array()</code>或者<code>new Array()</code>因为参数个数不同引起行为差异的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Array() &#x2F; new Array()</span><br><span class="line">Array() &#x2F;&#x2F; [] 无参数的时候返回的是空数组</span><br><span class="line">Array(2) &#x2F;&#x2F; [,,] 只有一个参数时，实际上指的是数组的长度</span><br><span class="line">Array(3,4) &#x2F;&#x2F; [3,4] 只有当参数不少于2个的时候，才会是数组</span><br><span class="line">Array(3,4,5) &#x2F;&#x2F; [3,4,5]</span><br><span class="line"></span><br><span class="line">Array.of() &#x2F;&#x2F; []</span><br><span class="line">Array.of(undefined) &#x2F;&#x2F; [undefined]</span><br><span class="line">Array.of(2) &#x2F;&#x2F; [2]</span><br><span class="line">Array.of(3,4) &#x2F;&#x2F; [3,4]</span><br><span class="line">&#x2F;&#x2F; 具体实现</span><br><span class="line">function ArrayOf()&#123;</span><br><span class="line">  return [].slice.call(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Array-prototype-at"><a href="#Array-prototype-at" class="headerlink" title="Array.prototype.at()"></a>Array.prototype.at()</h2><p>根据传入的参数索引获取索引对应的值。解决之前数据没有办法倒序获取元素的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [5, 12, 8, 130, 44]</span><br><span class="line">arr[arr.length-1] &#x2F;&#x2F; 44</span><br><span class="line">arr.at(-1) &#x2F;&#x2F; 44</span><br><span class="line">arr.at(2) &#x2F;&#x2F; 8</span><br><span class="line">arr.at(-2) &#x2F;&#x2F; 130</span><br><span class="line">arr.at(10) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure><h2 id="Array-prototype-copyWithin"><a href="#Array-prototype-copyWithin" class="headerlink" title="Array.prototype.copyWithin()"></a>Array.prototype.copyWithin()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.copyWithin(target, start &#x3D; 0, end &#x3D; this.length)</span><br></pre></td></tr></table></figure><p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p><ul><li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li><li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li><li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3) &#x2F;&#x2F; [4, 5, 3, 4, 5]</span><br><span class="line">&#x2F;&#x2F; 从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将3号位复制到0号位</span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3, 4) &#x2F;&#x2F; [4, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -2相当于3号位，-1相当于4号位</span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, -2, -1) &#x2F;&#x2F; [4, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0,2) &#x2F;&#x2F; [3, 4, 5, 4, 5]</span><br></pre></td></tr></table></figure><h2 id="Array-prototype-find-findIndex-findLast-findLastIndex-indexOf"><a href="#Array-prototype-find-findIndex-findLast-findLastIndex-indexOf" class="headerlink" title="Array.prototype.find/findIndex/findLast/findLastIndex/indexOf()"></a>Array.prototype.find/findIndex/findLast/findLastIndex/indexOf()</h2><ul><li><code>find()</code>：从前向后，返回符合条件的第一个元素的值，不符合返回 undefined；</li><li><code>findIndex()</code>：从前向后，返回符合条件的第一个元素的下标，不符合返回-1；</li><li><code>findLast()</code>：从后向前，返回符合条件的第一个元素的值，不符合返回 undefined；</li><li><code>findLastIndex()</code>：从后向前，返回符合条件的第一个元素的下标，不符合返回-1；</li><li><code>indexOf()</code>：从前向后，返回元素所在的第一个下标，元素不存在返回-1。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 4, -5, 10, -5]</span><br><span class="line">arr.find((value,index,arr)&#x3D;&gt;&#123;return value &lt; 0&#125;) &#x2F;&#x2F; -5</span><br><span class="line">arr.findIndex((value,index,arr)&#x3D;&gt;&#123;return value &lt; 0&#125;) &#x2F;&#x2F; 2</span><br><span class="line">let person &#x3D; &#123;name: &#39;John&#39;, age: 9&#125;;</span><br><span class="line">arr.find((value,index,arr)&#x3D;&gt;&#123;</span><br><span class="line">  return value &gt; this.age  &#x2F;&#x2F; this 指向第二个入参 -- person</span><br><span class="line">&#125;,person) &#x2F;&#x2F; 10</span><br><span class="line">arr.findIndex((value,index,arr)&#x3D;&gt;&#123;</span><br><span class="line">  return value &gt; this.age &#x2F;&#x2F; this 指向第二个入参 -- person</span><br><span class="line">&#125;,person) &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">arr.indexOf(-5) &#x2F;&#x2F; 2</span><br><span class="line">arr.indexOf(-5,3) &#x2F;&#x2F; 从3号位开始找-5，所以下标是4</span><br><span class="line">arr.indexOf(-5,2) &#x2F;&#x2F; 2</span><br><span class="line">arr.indexOf(-5,6) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure><h2 id="Array-prototype-fill"><a href="#Array-prototype-fill" class="headerlink" title="Array.prototype.fill()"></a>Array.prototype.fill()</h2><p><code>fill(target, start=0, end=this.length)</code>方法用来填充数组，一般用于数组初始化的时候赋值。<br>target：要填充的数值；start：填充起始位置；end：填充结束位置。<br><strong>如果填充的是对象，那么被赋值的是同一个内存地址的对象，是浅拷贝，会相互影响。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3].fill(7) &#x2F;&#x2F; [7,7,7] 数组有值默认会被覆盖</span><br><span class="line">new Array(3).fill(7) &#x2F;&#x2F; [7,7,7]</span><br><span class="line">[1,2,3].fill(7,1,2) &#x2F;&#x2F; [1,7,3] 从一号位开始填充，2号位结束</span><br><span class="line"></span><br><span class="line">let arr &#x3D; new Array(3).fill(&#123;name: &quot;Mike&quot;&#125;);</span><br><span class="line">arr[0].name &#x3D; &quot;Ben&quot;;</span><br><span class="line">arr &#x2F;&#x2F; [&#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;]</span><br></pre></td></tr></table></figure><h2 id="Array-prototype-keys-values-entries"><a href="#Array-prototype-keys-values-entries" class="headerlink" title="Array.prototype.keys/values/entries()"></a>Array.prototype.keys/values/entries()</h2><p>这三个方法用来搭配<code>for...of</code>对数组进行遍历，返回的是遍历器对象：</p><ul><li><code>keys()</code>是对键名的遍历；</li><li><code>values()</code>是对键值的遍历；</li><li><code>entries()</code>是对键值对的遍历。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &#39;a&#39;</span><br><span class="line">&#x2F;&#x2F; &#39;b&#39;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0 &quot;a&quot;</span><br><span class="line">&#x2F;&#x2F; 1 &quot;b&quot;</span><br></pre></td></tr></table></figure><h2 id="Array-prototype-flat-flatMap"><a href="#Array-prototype-flat-flatMap" class="headerlink" title="Array.prototype.flat/flatMap()"></a>Array.prototype.flat/flatMap()</h2><ul><li><code>flat(num=1)</code>：将多维数组拉平为一维数组，num表示拉平的层数，默认为1，num=Infinity表示不管数组是几维，都被拉平为一维数组。</li><li><code>flatMap((value,index,arr)=&gt;{},thisArg)</code>：执行函数遍历数组成员，将返回的新的数组进行flat操作，thisArg用来绑定遍历函数里面this的指向。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, [3, [4, 5]]].flat()</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, [4, 5]]  默认拉平一层</span><br><span class="line"></span><br><span class="line">[1, 2, [3, [4, 5]]].flat(2)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 5]   指定拉平两层</span><br><span class="line"></span><br><span class="line">[1, [2, [3]]].flat(Infinity)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3] 不管多少层，全部拉平至一维</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span><br><span class="line">[1, 2, 3, 4].flatMap(x &#x3D;&gt; [[x * 2]])</span><br><span class="line">&#x2F;&#x2F; [[2], [4], [6], [8]]  flatMap只能拉平一层</span><br></pre></td></tr></table></figure><h2 id="Array-prototype-toReversed-toSorted-toSplice-with"><a href="#Array-prototype-toReversed-toSorted-toSplice-with" class="headerlink" title="Array.prototype.toReversed/toSorted/toSplice/with()"></a>Array.prototype.toReversed/toSorted/toSplice/with()</h2><p>数组有一些方法调用后会修改原有的数组，为了实现调用该方法但是不修改原有数组，就有了以下和之前方法类似单数不修改原有数组的新方法。</p><ul><li><code>toReversed()</code>对应<code>reverse()</code>，用来颠倒数组成员的位置。</li><li><code>toSorted()</code>对应<code>sort()</code>，用来对数组成员排序。</li><li><code>toSpliced()</code>对应<code>splice()</code>，用来在指定位置，删除指定数量的成员，并插入新成员。</li><li><code>with(index, value)</code>对应<code>splice(index, 1, value)</code>，用来将指定位置的成员替换为新的值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const sequence &#x3D; [1, 2, 3];</span><br><span class="line">sequence.toReversed() &#x2F;&#x2F; [3, 2, 1]</span><br><span class="line">sequence &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line"></span><br><span class="line">const outOfOrder &#x3D; [3, 1, 2];</span><br><span class="line">outOfOrder.toSorted() &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">outOfOrder &#x2F;&#x2F; [3, 1, 2]</span><br><span class="line"></span><br><span class="line">const array &#x3D; [1, 2, 3, 4];</span><br><span class="line">array.toSpliced(1, 2, 5, 6, 7) &#x2F;&#x2F; [1, 5, 6, 7, 4]</span><br><span class="line">array &#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">const correctionNeeded &#x3D; [1, 1, 3];</span><br><span class="line">correctionNeeded.with(1, 2) &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">correctionNeeded &#x2F;&#x2F; [1, 1, 3]</span><br></pre></td></tr></table></figure><h2 id="Array-prototype-group-groupMap"><a href="#Array-prototype-group-groupMap" class="headerlink" title="Array.prototype.group/groupMap()"></a>Array.prototype.group/groupMap()</h2><ul><li><code>group((value,index,arr)=&gt;{},thisArg)</code>：该方法用来对数组进行分组，返回值是一个对象，键名是分组名，值是被分组的数组，入参函数必须返回一个字符串，即分组名。</li><li><code>groupMap((value,index,arr)=&gt;{},thisArg)</code>：作用和用法和``group()`一致，区别在于返回值是Map。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const array &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">array.group((num, index, array) &#x3D;&gt; &#123;</span><br><span class="line">  return num % 2 &#x3D;&#x3D;&#x3D; 0 ? &#39;even&#39;: &#39;odd&#39;;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; &#123; odd: [1, 3, 5], even: [2, 4] &#125;</span><br><span class="line"></span><br><span class="line">const odd  &#x3D; &#123; odd: true &#125;;</span><br><span class="line">const even &#x3D; &#123; even: true &#125;;</span><br><span class="line">array.groupToMap((num, index, array) &#x3D;&gt; &#123;</span><br><span class="line">  return num % 2 &#x3D;&#x3D;&#x3D; 0 ? even: odd;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;  Map &#123; &#123;odd: true&#125;: [1, 3, 5], &#123;even: true&#125;: [2, 4] &#125;</span><br></pre></td></tr></table></figure><h2 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h2><p><code>reduce((total,value,index,arr)=&gt;{},initialValue)</code>：该方法将数组缩减为单个值，入参函数第一个入参是先前执行后返回的结果，initialValue是要传给入参函数的初始值。<br><strong>如果没有设置initialValue，total是数组的第一个元素，value是数组的第二个元素；如果有，total=initialValue,value是数组的第一个元素。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var numbers &#x3D; [175, 50, 25];</span><br><span class="line">numbers.reduce((total,value)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(total,value)</span><br><span class="line">    return total - value</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 175 50</span><br><span class="line">&#x2F;&#x2F; 125 25</span><br><span class="line">&#x2F;&#x2F; 100</span><br><span class="line"></span><br><span class="line">numbers.reduce((total,value)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(total,value)</span><br><span class="line">    return total - value</span><br><span class="line">&#125;,10);</span><br><span class="line">&#x2F;&#x2F; 10 175</span><br><span class="line">&#x2F;&#x2F; -165 50</span><br><span class="line">&#x2F;&#x2F; -215 25</span><br><span class="line">&#x2F;&#x2F; -240</span><br></pre></td></tr></table></figure><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><ul><li>方法一：flat<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const flat &#x3D; arr &#x3D;&gt; arr.flat(Infinity)</span><br></pre></td></tr></table></figure></li><li>方法二：递归<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const flat &#x3D; (array) &#x3D;&gt; &#123;</span><br><span class="line">  let result &#x3D; [];</span><br><span class="line">  for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if (Array.isArray(array[i])) &#123;</span><br><span class="line">      result &#x3D; result.concat(flat(array[i]));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>方法三：reduce<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const flat &#x3D; (array) &#x3D;&gt; &#123;</span><br><span class="line">  return array.reduce(</span><br><span class="line">    (target, current) &#x3D;&gt;</span><br><span class="line">      Array.isArray(current) ?</span><br><span class="line">        target.concat(flatten(current)) :</span><br><span class="line">        target.concat(current)</span><br><span class="line">    , [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定拉平层数</span><br><span class="line">const flattenByDeep &#x3D; (array, deep &#x3D; 1) &#x3D;&gt; &#123;</span><br><span class="line">  return array.reduce(</span><br><span class="line">    (target, current) &#x3D;&gt;</span><br><span class="line">      Array.isArray(current) &amp;&amp; deep &gt; 1 ?</span><br><span class="line">        target.concat(flattenByDeep(current, deep - 1)) :</span><br><span class="line">        target.concat(current)</span><br><span class="line">    , [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><ul><li>方法一：使用Set<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const unique &#x3D; arr &#x3D;&gt; Array.from(new Set(arr));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const unique &#x3D; arr &#x3D;&gt; [...new Set(arr)];</span><br></pre></td></tr></table></figure></li><li>方法二：filter + indexOf <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const unique &#x3D; arr &#x3D;&gt; arr.filter((e,i) &#x3D;&gt; arr.indexOf(e) &#x3D;&#x3D;&#x3D; i);</span><br></pre></td></tr></table></figure></li><li>方法三：indexOf/includes + push<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const unique &#x3D; (array)&#x3D;&gt; &#123;</span><br><span class="line">  const newArray &#x3D; []</span><br><span class="line">  array.forEach((cu,index)&#x3D;&gt;&#123;</span><br><span class="line">    if(newArray.indexOf(cu)&#x3D;&#x3D;&#x3D;-1) newArray.push(cu)</span><br><span class="line">    &#x2F;&#x2F; if(!newArray.includes(cu)) newArray.push(cu)</span><br><span class="line">  &#125;)</span><br><span class="line">  return newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>方法四：对象：标记元素是否存在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const unique &#x3D; (array)&#x3D;&gt; &#123;</span><br><span class="line">    var container &#x3D; &#123;&#125;;</span><br><span class="line">    return array.filter((item, index) &#x3D;&gt;  container.hasOwnProperty(item) ? false : (container[item] &#x3D; true));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组乱序-洗牌"><a href="#数组乱序-洗牌" class="headerlink" title="数组乱序-洗牌"></a>数组乱序-洗牌</h2><p>实现原理：从最后一个元素开始，从数组中随机选出一个位置，交换，直到第一个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function disorder(array) &#123;</span><br><span class="line">  const length &#x3D; array.length;</span><br><span class="line">  let current &#x3D; length - 1;</span><br><span class="line">  let random;</span><br><span class="line">  while (current &gt;-1) &#123;</span><br><span class="line">    random &#x3D; Math.floor(length * Math.random());</span><br><span class="line">    [array[current], array[random]] &#x3D; [array[random], array[current]];</span><br><span class="line">    current--;</span><br><span class="line">  &#125;</span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p>函数的name属性返回函数名，对象的方法也是函数，所以也有name属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const a &#x3D; function()&#123;&#125;</span><br><span class="line">console.log(a.name) &#x2F;&#x2F; a</span><br><span class="line"></span><br><span class="line">const obj1 &#x3D; &#123;</span><br><span class="line">  getName()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj1.getName.name) &#x2F;&#x2F; getName</span><br></pre></td></tr></table></figure><p>如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const obj2 &#x3D; &#123;</span><br><span class="line">  get func()&#123;&#125;</span><br><span class="line">  set func(val)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj2.func.name) &#x2F;&#x2F; TypeError: Cannot read property &#39;name&#39; of undefined</span><br><span class="line">const descriptor &#x3D; Object.getOwnPropertyDescriptor(obj2, &#39;func&#39;);</span><br><span class="line">descriptor.get.name &#x2F;&#x2F; &quot;get func&quot;</span><br><span class="line">descriptor.set.name &#x2F;&#x2F; &quot;set func&quot;</span><br></pre></td></tr></table></figure><p>Function构造函数创造的函数，name属性返回anonymous。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log((new Function()).name) &#x2F;&#x2F; &quot;anonymous&quot;</span><br></pre></td></tr></table></figure><p>bind方法创造的函数，name属性返回bound加上原函数的名字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(a.bind().name) &#x2F;&#x2F; &quot;bound a&quot;</span><br></pre></td></tr></table></figure><p>如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const key1 &#x3D; Symbol(&#39;description&#39;)</span><br><span class="line">let obj3 &#x3D; &#123;</span><br><span class="line">  [key1]() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj3[key1].name) &#x2F;&#x2F; &quot;[description]&quot;</span><br></pre></td></tr></table></figure><h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><ul><li>箭头函数没有this，普通函数有（独立调用this指向全局，对象内部调用，this指向这个对象）；</li><li>箭头函数全是匿名函数，普通函数既可以是匿名函数，也可以是具名函数；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 具名函数</span><br><span class="line">function func()&#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 匿名函数</span><br><span class="line">let func &#x3D; function()&#123;&#125;</span><br></pre></td></tr></table></figure></li><li>箭头函数不能当做构造函数，即不可以使用new命令，普通函数可以；</li><li>箭头函数不可以使用arguments函数，如果要用，可以使用reset参数代替，普通函数可以使用arguments；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function A(a)&#123;</span><br><span class="line">  console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">A(1,2,3,4,5) &#x2F;&#x2F; [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">let B &#x3D; (b)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">B(1,2,3,4,5) &#x2F;&#x2F; Uncaught ReferenceError: arguments is not defined</span><br><span class="line"></span><br><span class="line">let C &#x3D; (...c)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(c)</span><br><span class="line">&#125;</span><br><span class="line">C(1,2,3,4,5) &#x2F;&#x2F; [1,2,3,4,5]</span><br></pre></td></tr></table></figure></li><li>箭头函数没有prototype原型对象，不具有super。</li></ul><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>Symbol，生成一个独一无二的值，引入这个 API 的原因是对象的键名是字符串，很容易冲突，如果键名是 Symbol 类型的话，就是独一无二的，不会产生冲突。</p><p>针对 Symbol，ES6 新增了两个新的方法：<code>Symbol.for()</code> 和 <code>Symbol().keyFor()</code></p><ul><li><code>Symbol.for(key)</code>：可以用来生成同一个 symbol 值，它会根据传入的 key 值登记，再次调用该方法的时候回去搜索 key 是否存在，如果不存在才会直接创建新值。而<code>Symbol(key)</code>没有登记搜索这一操作，每次调用都会创建新值。</li><li><code>Symbol.keyFor()</code>：返回一个已登记的 Symbol 类型值的key。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let s &#x3D; Symbol()</span><br><span class="line">typeof s &#x2F;&#x2F; &#39;symbol&#39;</span><br><span class="line"></span><br><span class="line">let s1 &#x3D; Symbol(&#39;foo&#39;);</span><br><span class="line">let s2 &#x3D; Symbol(&#39;bar&#39;);</span><br><span class="line">s1 &#x2F;&#x2F; Symbol(foo)</span><br><span class="line">s2 &#x2F;&#x2F; Symbol(bar)</span><br><span class="line">s1.toString() &#x2F;&#x2F; &quot;Symbol(foo)&quot;</span><br><span class="line">s2.toString() &#x2F;&#x2F; &quot;Symbol(bar)&quot;</span><br><span class="line"></span><br><span class="line">let s3 &#x3D; Symbol.for(&#39;foo&#39;);</span><br><span class="line">let s4 &#x3D; Symbol.for(&#39;foo&#39;);</span><br><span class="line">s3 &#x3D;&#x3D;&#x3D; s4 &#x2F;&#x2F; true</span><br><span class="line">Symbol(&quot;bar&quot;) &#x3D;&#x3D;&#x3D; Symbol(&quot;bar&quot;) &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">Symbol.keyFor(s3) &#x2F;&#x2F; &quot;foo&quot;</span><br><span class="line">let s5 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class="line">Symbol.keyFor(s5) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2020/06/10/14/19/landscape-5282903_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/categories/Web/"/>
    
      <category term="JS" scheme="http://crystalsummer.gitee.io/categories/Web/JS/"/>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/tags/Web/"/>
    
      <category term="JS" scheme="http://crystalsummer.gitee.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶(二)</title>
    <link href="http://crystalsummer.gitee.io/2021/05/30/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%BA%8C)/"/>
    <id>http://crystalsummer.gitee.io/2021/05/30/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%BA%8C)/</id>
    <published>2021-05-30T10:45:50.000Z</published>
    <updated>2022-08-10T07:37:05.813Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2018/02/28/10/04/soap-bubble-3187617_960_720.jpg" alt=""></p><a id="more"></a><h1 id="浅拷贝、深拷贝"><a href="#浅拷贝、深拷贝" class="headerlink" title="浅拷贝、深拷贝"></a>浅拷贝、深拷贝</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>JS执行上下文后会创建一个特殊对象叫做变量对象，JS的数据类型都会保存在变量对象中，对于基本数据类型来说，变量对象的变量名是数据参数，变量对象的具体值是数据值，而对于引用数据类型来说，变量对象的变量名是数据参数，变量对象的具体值是地址引用，数据值是保存在堆内存中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a1 &#x3D; 0;   &#x2F;&#x2F; 变量对象</span><br><span class="line">var a2 &#x3D; &#39;this is string&#39;; &#x2F;&#x2F; 变量对象</span><br><span class="line">var a3 &#x3D; null; &#x2F;&#x2F; 变量对象</span><br><span class="line">var b &#x3D; &#123; m: 20 &#125;; &#x2F;&#x2F; 变量b存在于变量对象中，&#123;m: 20&#125; 作为对象存在于堆内存中</span><br><span class="line">var c &#x3D; [1, 2, 3]; &#x2F;&#x2F; 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/08/FJMUZwGP62KvNjz.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 20;</span><br><span class="line">var b &#x3D; a;</span><br><span class="line">b &#x3D; 30;</span><br><span class="line">&#x2F;&#x2F; 这时a的值是多少？a&#x3D;20 b&#x3D;30</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/09/Lur3nBRVvwUftk7.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var m &#x3D; &#123; a: 10, b: 20 &#125;</span><br><span class="line">var n &#x3D; m;</span><br><span class="line">n.a &#x3D; 15;</span><br><span class="line">&#x2F;&#x2F; 这时m.a的值是多少 m&#x3D;n&#x3D;&#123;a:15,b:20&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/09/HXWIhxLNCAEvgaT.jpg" alt=""><br><strong>总结</strong>：<br>所谓拷贝，就是赋值，把一个变量赋给另外一个变量，把变量的内容进行拷贝。</p><ol><li>基本数据类型进行拷贝数据改变不会相互影响，是深拷贝；</li><li>引用数据类型进行拷贝数据改变会相互影响，是浅拷贝。</li></ol><h2 id="判断数据类型的方式"><a href="#判断数据类型的方式" class="headerlink" title="判断数据类型的方式"></a>判断数据类型的方式</h2><ol><li><strong>typeof</strong><br>typeof 返回的是数据类型的字符串，对于JS的基本数据类型除了null之外适用，但是引用数据类型和null全部返回object。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof 1) &#x2F;&#x2F; number</span><br><span class="line">console.log(typeof &#39;12w&#39;) &#x2F;&#x2F; string</span><br><span class="line">console.log(typeof true) &#x2F;&#x2F; boolean</span><br><span class="line">console.log(typeof undefined) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(typeof Symbol(1)) &#x2F;&#x2F; symbol</span><br><span class="line">console.log(typeof function()&#123;&#125;) &#x2F;&#x2F; function</span><br><span class="line">console.log(typeof null) &#x2F;&#x2F; object</span><br><span class="line">console.log(typeof []) &#x2F;&#x2F; object</span><br><span class="line">&#x2F;&#x2F; 其他的全是object</span><br></pre></td></tr></table></figure></li><li><strong>instanceof</strong><br>instanceof 是判断A是否是B的实例，返回的是true or false，但是不能判断一个对象实例具体属于哪种类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log([] instanceof Array) &#x2F;&#x2F; true</span><br><span class="line">console.log([] instanceof Object) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; []的原型指向Array.prototype，间接指向Object.prototype，因此上面两个都是true</span><br><span class="line">console.log(function()&#123;&#125; instanceof Function) &#x2F;&#x2F; true</span><br><span class="line">console.log(&#123;&#125; instanceof Object) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li><li><strong>constructor</strong><br>除了null和undefined之外，都可以使用constructor来判断数据类型，返回true or false。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(100.constructor &#x3D;&#x3D;&#x3D; Number) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log(&#39;qwe&#39;.constructor &#x3D;&#x3D;&#x3D; String) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log(false.constructor &#x3D;&#x3D;&#x3D; Boolean) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log(Symbol(1).constructor &#x3D;&#x3D;&#x3D; Symbol) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log(&#x2F;^[a-zA-Z]&#123;5,20&#125;$&#x2F;.constructor &#x3D;&#x3D;&#x3D; RegExp) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log((function()&#123;&#125;).constructor &#x3D;&#x3D;&#x3D; Function) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log([].constructor &#x3D;&#x3D;&#x3D; Array) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log(&#123;&#125;.constructor &#x3D;&#x3D;&#x3D; Object) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log((new Date()).constructor &#x3D;&#x3D;&#x3D; Date) &#x2F;&#x2F;&#x3D;&gt; true</span><br><span class="line">console.log((new Error()).constructor &#x3D;&#x3D;&#x3D; Error) &#x2F;&#x2F;&#x3D;&gt; true</span><br></pre></td></tr></table></figure></li><li><strong>toString</strong><br>toString 是最完美的方法，返回格式为 [object Xxx] ，其中 Xxx 就是对象的类型。对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(1) &#x2F;&#x2F; [object Number]</span><br><span class="line">Object.prototype.toString.call(&#39;&#39;) &#x2F;&#x2F; [object String]</span><br><span class="line">Object.prototype.toString.call(true) &#x2F;&#x2F; [object Boolean]</span><br><span class="line">Object.prototype.toString.call(null) &#x2F;&#x2F; [object Null]</span><br><span class="line">Object.prototype.toString.call(undefined) &#x2F;&#x2F; [object Undefined]</span><br><span class="line">Object.prototype.toString.call(Symbol()) &#x2F;&#x2F;[object Symbol]</span><br><span class="line">Object.prototype.toString.call([]) &#x2F;&#x2F; [object Array]</span><br><span class="line">Object.prototype.toString.call(new Date()) &#x2F;&#x2F; [object Date]</span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;) &#x2F;&#x2F; [object Function]</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;) &#x2F;&#x2F; [object Object]</span><br><span class="line">Object.prototype.toString.call(new RegExp()) &#x2F;&#x2F; [object RegExp]</span><br><span class="line">Object.prototype.toString.call(new Error()) &#x2F;&#x2F; [object Error]</span><br><span class="line">Object.prototype.toString.call(document) &#x2F;&#x2F; [object HTMLDocument]</span><br><span class="line">Object.prototype.toString.call(new Map()) &#x2F;&#x2F; [object Map]</span><br><span class="line">Object.prototype.toString.call(new Set()) &#x2F;&#x2F; [object Set]</span><br><span class="line">&#x2F;&#x2F; [object Window] window 是全局对象 global 的引用</span><br><span class="line">Object.prototype.toString.call(window)</span><br></pre></td></tr></table></figure></li></ol><h2 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 简易版</span><br><span class="line">deepClone(source) &#123;</span><br><span class="line">  if (!source &amp;&amp; typeof source !&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">    throw new Error(&#39;error arguments&#39;, &#39;deepClone&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  const targetObj &#x3D; source.constructor &#x3D;&#x3D;&#x3D; Array ? [] : &#123;&#125;</span><br><span class="line">  Object.keys(source).forEach(keys &#x3D;&gt; &#123;</span><br><span class="line">    if (source[keys] &amp;&amp; typeof source[keys] &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">      targetObj[keys] &#x3D; deepClone(source[keys])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      targetObj[keys] &#x3D; source[keys]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return targetObj</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 还可以使用JSON.parse(JSON.stringfy()) for..in 实现</span><br><span class="line">&#x2F;&#x2F; 也可以使用lodash._cloneDeep</span><br></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>闭包是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>读取函数内部变量；</li><li>变量始终保存在内存中：JS的垃圾回收机制会每隔一段时间回收失去引用的值，释放内存，但是闭包的存在会阻止这一过程。</li></ol><h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><ol><li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除；</li><li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li></ol><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>原生的setTimeout第一个函数入参不同带参数，可以使用闭包实现传参效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f1(a)&#123;</span><br><span class="line">  return function f2()&#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var fun &#x3D; f1(5)</span><br><span class="line">setTimeout(fun,1000) &#x2F;&#x2F; 1秒后打印出5</span><br></pre></td></tr></table></figure><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>事件被触发N毫秒后再执行回调，若在这N毫秒内再次触发则将重新计算执行时间。<br>实际实现的关键是使用setTimeout这个函数，由于需要一个变量来保存计时器，为了维护全局纯净，可以借助闭包实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var debounce &#x3D; function(event, time &#x3D; 1000)&#123;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function(...args)&#123;</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    timer &#x3D; setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">      event.apply(this, args)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流（throttle）:不管事件触发频率多高，只在单位时间内执行一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function throttle(event, time) &#123;</span><br><span class="line">  let pre &#x3D; 0;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if (Date.now() - pre &gt; time) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer &#x3D; null;</span><br><span class="line">      pre &#x3D; Date.now();</span><br><span class="line">      event.apply(this, args);</span><br><span class="line">    &#125; else if (!timer) &#123;</span><br><span class="line">      timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        event.apply(this, args);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="instanceof的实现"><a href="#instanceof的实现" class="headerlink" title="instanceof的实现"></a>instanceof的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; instanceof的实际原理就是判断右侧的prototype是否在左侧对象的原型链上</span><br><span class="line">var myInstanceof &#x3D; function(target,origin)&#123;</span><br><span class="line">  const proto &#x3D; target.__proto__</span><br><span class="line">  if(proto)&#123;</span><br><span class="line">    if(origin.prototype &#x3D;&#x3D;&#x3D; proto)&#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      return myInstanceof(proto,origin)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>详情请看下文。</p><h1 id="防抖-1"><a href="#防抖-1" class="headerlink" title="防抖"></a>防抖</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>防抖（debounce）：事件被触发N毫秒后再执行回调，若在这N毫秒内再次触发则将重新计算执行时间。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var debounce &#x3D; function(event, time &#x3D; 1000)&#123;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function(...args)&#123;</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    timer &#x3D; setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">      event.apply(this, args)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候我们需要让函数立即执行一次，再等后面事件触发后等待n秒执行，我们给debounce函数一个flag用于标示是否立即执行。当定时器变量timer为空时，说明是第一次执行，我们立即执行它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var debounce &#x3D; function(event, time &#x3D; 1000, flag) &#123;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    if (flag &amp;&amp; !timer) &#123;</span><br><span class="line">      event.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      event.apply(this, args);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>监听窗口大小变化：使用防抖让函数在窗口大小改变之后再执行，窗口大小改变过程中不执行。<br><code>window.addEventListener(&#39;resize&#39;, debounce(handleResize, 200));</code></li><li>搜索框实时搜索：使用防抖让函数在用户输入完毕之后再执行，输入过程中不执行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-input v-model&#x3D;&quot;queryParams.sellerName&quot; placeholder&#x3D;&quot;请输入专柜名称&quot; clearable @input&#x3D;&quot;nameInput&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">queryParams:&#123;</span><br><span class="line">  sellerName:undefined,</span><br><span class="line">  pageNo:1,</span><br><span class="line">  pageSize:10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实时搜索</span><br><span class="line">nameInput(val)&#123;</span><br><span class="line">  &#x2F;&#x2F; val &#x3D; this.queryParams.sellerName</span><br><span class="line">  debounce(this.getTableData, 1000)(val)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 获取表格数据</span><br><span class="line"> * 入参 sellerName 没有值代表是通过点击查询&#x2F;重置按钮调用的接口</span><br><span class="line"> * 入参 sellerName 有值代表是实时搜索调用的接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">getTableData(sellerName) &#123;</span><br><span class="line">  this.loading &#x3D; true</span><br><span class="line">  sellerList(&#123;</span><br><span class="line">    ...this.queryParams,</span><br><span class="line">    sellerName: sellerName || this.queryParams.sellerName</span><br><span class="line">  &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">    this.tableData &#x3D; res.result.list || []</span><br><span class="line">    this.total &#x3D; res.result.total</span><br><span class="line">    this.loading &#x3D; false</span><br><span class="line">  &#125;).catch(() &#x3D;&gt; &#123;</span><br><span class="line">    this.loading &#x3D; false</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>表单验证：比如用户名、手机号、邮箱等的输入校验，使用防抖让函数在用户输入完成后校验，输入过程中不校验。</li></ol><h1 id="节流-1"><a href="#节流-1" class="headerlink" title="节流"></a>节流</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>节流（throttle）:不管事件触发频率多高，只在单位时间内执行一次。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ol><li><strong>时间戳</strong><br>用时间戳来判断是否已到执行时间，记录上次执行的时间戳，然后每次触发事件执行回调，回调中判断当前时间戳距离上次执行时间戳的间隔是否已经达到时间差（Xms） ，如果是则执行，并更新上次执行的时间戳，如此循环。<blockquote><p>第一次事件肯定触发，最后一次不会触发</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function throttle(event, time) &#123;</span><br><span class="line">  let pre &#x3D; 0;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if (Date.now() - pre &gt; time) &#123;</span><br><span class="line">      pre &#x3D; Date.now();</span><br><span class="line">      event.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>定时器</strong><blockquote><p>第一次事件不会触发，最后一次一定触发</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function throttle(event, time) &#123;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        timer &#x3D; null;</span><br><span class="line">        event.apply(this, args);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>结合版</strong><blockquote><p>定时器和时间戳的结合版，也相当于节流和防抖的结合版，第一次和最后一次都会触发</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function throttle(event, time) &#123;</span><br><span class="line">  let pre &#x3D; 0;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if (Date.now() - pre &gt; time) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer &#x3D; null;</span><br><span class="line">      pre &#x3D; Date.now();</span><br><span class="line">      event.apply(this, args);</span><br><span class="line">    &#125; else if (!timer) &#123;</span><br><span class="line">      timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        event.apply(this, args);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>滚动条滚动：比如<a href="https://crystalsummer.gitee.io/2021/09/18/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"><strong>图片懒加载</strong></a></li><li>防止按钮频繁点击触发多余请求</li><li>搜索框联想功能</li></ol><p>总体来看，函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行</p><h1 id="函数柯里化-1"><a href="#函数柯里化-1" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><h2 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h2><p><strong>柯里化</strong>是指这样一个函数(假设叫做createCurry)，他接收函数fn作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数fn的剩余参数。函数柯里化主要就是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><blockquote><p>通俗易懂的解释：用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数。</p></blockquote><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><ul><li>判断当前函数传入的参数是否大于或等于fn需要参数的数量，如果是，直接执行fn；</li><li>如果传入参数数量不够，返回一个闭包，暂存传入的参数，并重新返回createCurry函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 柯里化函数</span><br><span class="line">function createCurry(fn, ...args) &#123;</span><br><span class="line">  if (args.length &gt;&#x3D; fn.length) &#123;</span><br><span class="line">    return fn(...args);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (...args2) &#x3D;&gt; createCurry(fn, ...args, ...args2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 求和函数</span><br><span class="line">function A(a,b,c)&#123;</span><br><span class="line">  return a+b+c</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 柯里化函数使用</span><br><span class="line">const curring &#x3D; createCurry(A)</span><br><span class="line">curring(1,2,3)</span><br><span class="line">curring(1)(2)(3)</span><br><span class="line">curring(1,2)(3)</span><br></pre></td></tr></table></figure></li></ul><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h2><ol><li>异步任务：同步任务在主线程上排队执行，只有上一个任务执行完毕，才能执行下一个任务；而异步任务是前一个任务有没有执行完毕不影响下一个任务的执行。</li><li>回调函数：将一个函数作为参数传入另一个函数中，并且这个函数不会立刻执行，需要满足一定的条件才会执行的函数就叫做回调函数。回调函数主要是为了实现异步操作。</li></ol><p>比如前端发送一个请求，但是这个请求需要a请求返回的数据，而a请求又需要b请求的数据，像这样回调函数嵌套回调函数，代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为”回调函数地狱”（callback hell）。回调地狱就是为是实现代码顺序执行而出现的一种操作，它会造成我们的代码可读性非常差，后期不好维护。Promise就可以通过then的链式来解决这个问题。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(resolve,reject)&#123;...&#125;)</span><br></pre></td></tr></table></figure><p>Promise对象是一个构造函数，用来生成Promise实例，将一个函数作为参数，这个函数就是用来处理Promise的状态变化。这个函数有resolve和reject入参：</p><ul><li>resolve的作用是将Promise对象的状态从pending变成fulfilled，在异步操作成功时回调，并将异步操作的结果作为参数传递出去；</li><li>reject的作用是将Promise对象的状态从pending变成rejected，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li></ul><p>Promise的缺点：</p><ol><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消；</li><li>如果不设置catch()指定错误处理的回调函数，Promise内部出错，不会反映到外部；</li><li>当处于pending状态，无法得知是刚刚开始还是即将结束。</li></ol><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>Promise对象有三个状态：</p><ul><li>pending：进行中</li><li>fulfilled：已成功</li><li>rejected：已失败</li></ul><p>这三个状态不受外界影响，而且一旦状态从pending变成fulfilled或者rejected，就不会再变。</p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><ol><li>Promise.prototype.then()<br>它的作用是为 Promise 实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数，它们都是可选的。但是建议第二个参数使用Promise.prototype.catch()。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  if(&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class="line">    resolve(data)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(</span><br><span class="line">  data &#x3D;&gt;&#123;&#x2F;&#x2F; 成功操作&#125;,</span><br><span class="line">  error &#x3D;&gt;&#123;&#x2F;&#x2F; 失败操作&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>then方法返回的是一个新的Promise实例，不是原来的Promise实例。因此可以采用链式操作。链式调用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&quot;foo&quot;).then((string)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(string) &#x2F;&#x2F; foo</span><br><span class="line">  return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      string +&#x3D; &#39;bar&#39;;</span><br><span class="line">      resolve(string);</span><br><span class="line">    &#125;, 1);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then((string)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(string) &#x2F;&#x2F; foobar</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    string +&#x3D; &#39;baz&#39;;</span><br><span class="line">    console.log(string+&#39;1&#39;);</span><br><span class="line">  &#125;, 1)</span><br><span class="line">  return string</span><br><span class="line">&#125;).then((string)&#x3D;&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>Promise.prototype.catch()<br>它是<code>.then(null/undefined,rejection)</code>的别名，用于异步操作发生错误的时候执行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  if(&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class="line">    resolve(data)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(data &#x3D;&#123;&#x2F;&#x2F; 成功操作&#125;).catch(error &#x3D;&gt;&#123;&#x2F;&#x2F; 失败操作&#125;)</span><br></pre></td></tr></table></figure>Promise会吃掉错误：当Promise内部出错但是没有指定catch()处理错误的回调函数，控制台会打印错误但是不影响下面代码的运行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncThing &#x3D; function() &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    &#x2F;&#x2F; 下面一行会报错，因为x没有声明</span><br><span class="line">    resolve(x + 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">someAsyncThing().then(function() &#123;</span><br><span class="line">  console.log(&#39;everything is great&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123; console.log(123) &#125;, 2000);</span><br><span class="line">&#x2F;&#x2F; Uncaught (in promise) ReferenceError: x is not defined</span><br><span class="line">&#x2F;&#x2F; 123</span><br></pre></td></tr></table></figure></li><li>Promise.prototype.finally()<br>finally是不管Promise最后一步操作是成功还是失败，都会执行的操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(result &#x3D;&gt; &#123;···&#125;)</span><br><span class="line">.catch(error &#x3D;&gt; &#123;···&#125;)</span><br><span class="line">.finally(() &#x3D;&gt; &#123;···&#125;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>定义各方法入参的Promise对象数组为PA，定义各方法创建的实例对象为P</p><ol><li>Promise.all()<br><code>Promise.all()</code>接收一个Promise对象组成的数组PA作为参数，如果数组元素不是Promise对象，那么会调用<code>Promise.resolve()</code>转成Promise对象。<code>Promise.all()</code>处理完后返回的是一个新的Promise对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p &#x3D; Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure></li></ol><ul><li>所有参数实例的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li><li>只要参数实例之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。但是如果p1、p2、p3 rejected的实例有自己的catch方法，那么一旦被rejected，并不会触发<code>Promise.all()</code>的catch方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; p2有自己的catch方法</span><br><span class="line">const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&#39;hello&#39;);</span><br><span class="line">&#125;).then(result &#x3D;&gt; result)</span><br><span class="line">.catch(e &#x3D;&gt; e);</span><br><span class="line"></span><br><span class="line">const p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  throw new Error(&#39;报错了&#39;);</span><br><span class="line">&#125;).then(result &#x3D;&gt; result)</span><br><span class="line">.catch(e &#x3D;&gt; e);</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2])</span><br><span class="line">.then(result &#x3D;&gt; console.log(result))</span><br><span class="line">.catch(e &#x3D;&gt; console.log(e));</span><br><span class="line">&#x2F;&#x2F; p2有自己的catch方法，会返回一个新的Promise实例，p2指向的实际上是这个实例。该实例执行完catch方法后，</span><br><span class="line">&#x2F;&#x2F; 也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数。</span><br><span class="line">&#x2F;&#x2F; [&quot;hello&quot;, Error: 报错了]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。</span><br><span class="line">&#x2F;&#x2F; Error: 报错了</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>Promise.race()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p &#x3D; Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>参数实例中任意一个的状态变成fulfilled或者rejected，p的状态才会变成fulfilled或者rejected。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">    setTimeout(resolve, 500, &#39;one&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">var p2 &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">    setTimeout(resolve, 100, &#39;two&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">var p3 &#x3D; new Promise(function(resolve, reject) &#123; </span><br><span class="line">    setTimeout(reject, 100, &quot;three&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; p2先变成fulfilled状态，所以打印出value two</span><br><span class="line">Promise.race([p1, p2]).then(function(value) &#123;</span><br><span class="line">  console.log(&#39;value &#39;+value);</span><br><span class="line">&#125;).catch(error&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;error &#39;+error)</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; p3先变成rejected状态，所以执行catch，打印出error three</span><br><span class="line">Promise.race([p1, p3]).then(function(value) &#123;</span><br><span class="line">  console.log(&#39;value &#39;+value);</span><br><span class="line">&#125;).catch(error&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;error &#39;+error)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>Promise.allSettled()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p &#x3D; Promise.allSettled([p1, p2, p3]);</span><br></pre></td></tr></table></figure>参数实例全都变成fulfilled或者rejected，p才会变成fulfilled。只有fulfilled状态，没有rejected状态。状态变成fulfilled后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。</li><li>Promise.any()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p &#x3D; Promise.any([p1, p2, p3]);</span><br></pre></td></tr></table></figure></li></ol><ul><li>只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态。</li><li>如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</li></ul><ol start="5"><li>Promise.resolve()<br>将现有对象转为Promise对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#39;foo&#39;)</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">new Promise(resolve &#x3D;&gt; resolve(&#39;foo&#39;))</span><br></pre></td></tr></table></figure></li><li>Promise.reject()<br>返回一个rejected状态的Promise实例。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const p &#x3D; Promise.reject(&#39;出错了&#39;);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">const p &#x3D; new Promise((resolve, reject) &#x3D;&gt; reject(&#39;出错了&#39;))</span><br></pre></td></tr></table></figure></li><li>Promie.try()<br><code>Promie.try</code>是模拟try catch中的try。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  database.users.get(&#123;id: userId&#125;)</span><br><span class="line">  .then(...)</span><br><span class="line">  .catch(...)</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 使用Promise.try</span><br><span class="line">Promise.try(() &#x3D;&gt; database.users.get(&#123;id: userId&#125;))</span><br><span class="line">  .then(...)</span><br><span class="line">  .catch(...)</span><br></pre></td></tr></table></figure></li></ol><p>总结：</p><ul><li><code>Promise.all</code>：PA里面所有的实例的状态变成fulfilled，P的状态才会变成fulfilled；PA里面所有的实例，只要有一个实例状态变成rejected，P的实例的状态才会变成rejected。</li><li><code>Promise.any</code>：PA里面所有的实例状态，只要任意一个的状态变成fulfilled，P的状态才会变成fulfilled；PA里面所有的实例状态全部变成rejected，P实例的状态才会变成rejected。</li><li><code>Promise.race</code>：PA里面所有的实例，只要任意一个的状态变成fulfilled或者rejected，P的状态才会变成fulfilled或者rejected。</li><li><code>Promise.allSettled</code>：PA里面所有的实例状态变成fulfilled或者rejected，P的状态才会变成fulfilled，没有rejected。回调函数的入参是一个数组，数组里面的元素是PA数组里面的Promise对象。</li></ul><h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><p>具体内容参考：<a href="https://juejin.cn/post/6994594642280857630" target="_blank" rel="noopener"><strong>看了就会，手写Promise原理，最通俗易懂的版本！！！</strong></a><br>解析过程如下：</p><ol><li>实现 resolve 和 reject</li></ol><ul><li>PromiseState-保存Promise状态，pending、fulfilled、rejected；<br>PromiseResult-保存Promise状态改变回调函数的入参，fulfilled时是value，rejected时是reason；</li><li>执行resolve，Promise状态会变成fulfilled；执行reject，Promise状态会变成rejected</li><li>Promise只以第一次为准，第一次成功就永久为fulfilled，第一次失败就永远状态为rejected</li><li>Promise中有throw的话，就相当于执行了reject</li></ul><ol start="2"><li>实现then</li></ol><ul><li>then接收两个回调，一个是成功回调，一个是失败回调，当Promise状态为fulfilled执行成功回调，为rejected执行失败回调。</li><li>如果resolve或reject在定时器里，则定时器结束后再执行then：我们可以在定时器还未结束的时候将then的两个回调函数保存起来，等定时器结束执行resolve或者reject的时候再去执行回调函数。我们可以通过当转状态是不是pending来判断定时器是否结束。</li><li>then支持链式调用，下一次then执行受上一次then返回值的影响：我们可以在then执行完毕之后返回一个新的Promise（thenPromise），这样就可以实现then的链式调用。在thenPromise里面定义一个<code>resolvePromise</code>函数，这个专门用来处理回调函数</li><li>then方法是微任务：只需要让<code>resolvePromise</code>函数异步执行就可以了，可以使用setTimeout实现。</li></ul><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化值</span><br><span class="line">    this.initValue()</span><br><span class="line">    &#x2F;&#x2F; 初始化this指向</span><br><span class="line">    this.initBind()</span><br><span class="line">    &#x2F;&#x2F; Promise中有throw的话，就相当于执行了reject</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 执行传进来的函数</span><br><span class="line">      executor(this.resolve, this.reject)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      &#x2F;&#x2F; 捕捉到错误直接执行reject</span><br><span class="line">      this.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 初始化值</span><br><span class="line">  initValue() &#123;</span><br><span class="line">    this.PromiseResult &#x3D; null &#x2F;&#x2F; 终值</span><br><span class="line">    this.PromiseState &#x3D; &#39;pending&#39; &#x2F;&#x2F; 状态</span><br><span class="line">    this.onFulfilledCallbacks &#x3D; [] &#x2F;&#x2F; 保存成功回调</span><br><span class="line">    this.onRejectedCallbacks &#x3D; [] &#x2F;&#x2F; 保存失败回调</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 初始化this</span><br><span class="line">  initBind() &#123;</span><br><span class="line">    this.resolve &#x3D; this.resolve.bind(this)</span><br><span class="line">    this.reject &#x3D; this.reject.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  resolve(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; state是不可变的</span><br><span class="line">    if (this.PromiseState !&#x3D;&#x3D; &#39;pending&#39;) return</span><br><span class="line">    &#x2F;&#x2F; 如果执行resolve，状态变为fulfilled</span><br><span class="line">    this.PromiseState &#x3D; &#39;fulfilled&#39;</span><br><span class="line">    &#x2F;&#x2F; 终值为传进来的值</span><br><span class="line">    this.PromiseResult &#x3D; value</span><br><span class="line">    &#x2F;&#x2F; 执行保存的成功回调</span><br><span class="line">    while (this.onFulfilledCallbacks.length) &#123;</span><br><span class="line">      this.onFulfilledCallbacks.shift()(this.PromiseResult)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    &#x2F;&#x2F; state是不可变的</span><br><span class="line">    if (this.PromiseState !&#x3D;&#x3D; &#39;pending&#39;) return</span><br><span class="line">    &#x2F;&#x2F; 如果执行reject，状态变为rejected</span><br><span class="line">    this.PromiseState &#x3D; &#39;rejected&#39;</span><br><span class="line">    &#x2F;&#x2F; 终值为传进来的reason</span><br><span class="line">    this.PromiseResult &#x3D; reason</span><br><span class="line">    &#x2F;&#x2F; 执行保存的失败回调</span><br><span class="line">    while (this.onRejectedCallbacks.length) &#123;</span><br><span class="line">      this.onRejectedCallbacks.shift()(this.PromiseResult)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    &#x2F;&#x2F; 接收两个回调 onFulfilled, onRejected</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 参数校验，确保一定是函数</span><br><span class="line">    onFulfilled &#x3D; typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : val &#x3D;&gt; val</span><br><span class="line">    onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onRejected : reason &#x3D;&gt; &#123; throw reason &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 新建一个thenPromise并返回，实现then的链式操作</span><br><span class="line">    var thenPromise &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      const resolvePromise &#x3D; cb &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; then是微任务，让resolvePromise异步执行</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            const x &#x3D; cb(this.PromiseResult)</span><br><span class="line">            if (x &#x3D;&#x3D;&#x3D; thenPromise) &#123;</span><br><span class="line">              &#x2F;&#x2F; 不能返回自身</span><br><span class="line">              throw new Error(&#39;不能返回自身。。。&#39;)</span><br><span class="line">            &#125;</span><br><span class="line">            if (x instanceof MyPromise) &#123;</span><br><span class="line">              &#x2F;&#x2F; 如果返回值是Promise</span><br><span class="line">              &#x2F;&#x2F; 如果返回值是promise对象，返回值为成功，新promise就是成功</span><br><span class="line">              &#x2F;&#x2F; 如果返回值是promise对象，返回值为失败，新promise就是失败</span><br><span class="line">              &#x2F;&#x2F; 谁知道返回的promise是失败成功？只有then知道</span><br><span class="line">              x.then(resolve, reject)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              &#x2F;&#x2F; 非Promise就直接成功</span><br><span class="line">              resolve(x)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; catch (err) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理报错</span><br><span class="line">            reject(err)</span><br><span class="line">            throw new Error(err)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      if (this.PromiseState &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果当前为成功状态，执行第一个回调</span><br><span class="line">        resolvePromise(onFulfilled)</span><br><span class="line">      &#125; else if (this.PromiseState &#x3D;&#x3D;&#x3D; &#39;rejected&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果当前为失败状态，执行第二个回调</span><br><span class="line">        resolvePromise(onRejected)</span><br><span class="line">      &#125; else if (this.PromiseState &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果状态为待定状态，暂时保存两个回调</span><br><span class="line">        this.onFulfilledCallbacks.push(onFulfilled.bind(this))</span><br><span class="line">        this.onRejectedCallbacks.push(onRejected.bind(this))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回这个包装的Promise</span><br><span class="line">    return thenPromise</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h1><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p><code>async/await</code>的用处就是：<strong>用同步方式，执行异步操作</strong>，比如回调地狱，Promise 虽然可以解决，但是 then 的链式会很长，Generator 函数也可以解决，但是<code>async/await</code>比星号和<code>yield</code>更加语义化。</p><p><code>async/await</code>是 Generator 的语法糖，是使用 Promise + Generator 的 next传参实现的。</p><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>async 函数返回一个 promise 对象，可以使用 then 方法添加回调函数，函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。</p><p>async 函数返回的 Promise 对象，必须等所有的 await 异步操作完成后才会进入 fulfilled 状态，只要有一个 await 语句后面的 Promise 对象变为 reject 状态，那么整个async函数都会中断执行。如果想要 await 的 Promise reject 之后继续执行下面的代码，可以将 await 的 Promise 放在<code>try...catch</code>里面或者后面跟着<code>catch()</code>方法。</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>await 命令后面跟着 Promise 对象，返回该对象的结果，如果不是，就直接返回对应的值。</p><p>如果 await 后面的异步操作出错，那么等同于 async 函数返回的 Promise 对象被reject。防止出错的方法，也是将其放在<code>try...catch</code>代码块之中，多个 await 可以统一放在该结构中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2018/02/28/10/04/soap-bubble-3187617_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/categories/Web/"/>
    
      <category term="JS" scheme="http://crystalsummer.gitee.io/categories/Web/JS/"/>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/tags/Web/"/>
    
      <category term="JS" scheme="http://crystalsummer.gitee.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶(一)</title>
    <link href="http://crystalsummer.gitee.io/2021/03/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%B8%80)/"/>
    <id>http://crystalsummer.gitee.io/2021/03/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6(%E4%B8%80)/</id>
    <published>2021-03-28T02:45:50.000Z</published>
    <updated>2022-08-10T07:37:05.812Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2021/09/23/05/27/butterflies-6648681_960_720.jpg" alt=""></p><a id="more"></a><h1 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h1><h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><ul><li>基本数据类型：number string boolean null undefined symbol；</li><li>引用数据类型：数组 对象 函数。</li></ul><p>两种数据类型的区别：</p><ul><li>基本数据类型保存在栈内存中，引用数据类型的变量名是保存在栈内存中，变量值保存在堆内存中；</li><li>基本数据类型如果定义在函数中，函数执行完毕这个变量就会自动销毁，而引用数据类型的变量只有在没有引用的时候，垃圾回收机制回收；</li><li>基本数据类型的赋值不会相互影响，而引用数据类型会；</li><li>基本数据类型无法添加属性和方法，引用数据类型可以。</li></ul><h2 id="栈、堆、队列"><a href="#栈、堆、队列" class="headerlink" title="栈、堆、队列"></a>栈、堆、队列</h2><ul><li>栈内存：先进后出；</li><li>堆内存：对数据结构是树状结构，存取很方便，但是JS不允许直接访问堆内存中的数据，在操作对象的时候，实际上操作的是对象的引用，而不是实际的对象。这里的引用，可以理解为保存在变量对象中的一个地址，这个地址与堆内存的实际值相关联；</li><li>队列：先进先出。</li></ul><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>程序的运行需要内存，只要程序提出要求，操作系统或者运行是就必须供给内存。对于持续运行的服务进程，必须及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏。但是现在大多数语言都提供了内存的自动管理，就像JS有垃圾回收机制，减轻程序员的负担。</p><p>V8垃圾回收机制会将内存分成新生代空间和老生代空间：</p><ul><li>新生代空间：用于存放存活时间较短的对象</li><li>老生代空间：用于存放存活时间较长的对象</li></ul><p>常见的内存泄漏：</p><ol><li>全局变量的声明：如果有可能尽可能使用var、let、const声明变量，如果不得不使用全局变量的话，使用完要手动置为null释放内存；</li><li>setInterval或者setTimeout：定义定时器或者计时器，如果不使用clearInterval或者clearTimeout清除的话，这些变量和对象会一直保存在内存里面；</li><li>监听scroll、resize等频繁操作节点的事件没有用removeEvenetListener清除；</li><li>闭包的滥用。</li></ol><h2 id="内存管理-垃圾回收"><a href="#内存管理-垃圾回收" class="headerlink" title="内存管理-垃圾回收"></a>内存管理-垃圾回收</h2><p>原理：垃圾收集器每隔固定时间找到那些不再继续使用的值，然后释放它占用的内存。<br>常用算法：<br>&emsp;&emsp;<strong>标记-清除</strong> </p><ul><li>从根集合出发，将所有活动对象及其子对象打上标记；</li><li>遍历堆，将未打上标记的链接到空的链表上释放；</li><li>实现简单，容易和其他算法组合；但是太碎片化，导致无数小分块散布在堆的各处。</li></ul><p>&emsp;&emsp;<strong>标记-压缩</strong> </p><ul><li>从根集合出发，将所有活动对象及其子对象打上标记</li><li>遍历堆，将打上标记的对象紧密的排在堆的一侧（压缩）；</li><li>消除了碎片化；但是压缩过程需要多次遍历堆，开销大。</li></ul><p>&emsp;&emsp;<strong>引用-计数</strong></p><ul><li>每次新建和操作对象的同时更新计数器；</li><li>计数器为0的直接回收内存；</li></ul><p>另外还有其他的几种回收算法：三色标记法、GC复制算法等。</p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>执行上下文可以理解为代码的执行环境，分为全局环境和函数环境。</p><h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2><p>在JS程序中，必定会产生多个上下文，JS引擎会以栈的方式处理它们，叫做函数调用栈，栈底永远是全局上下文，栈顶是当前正在执行的上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var color &#x3D; &#39;blue&#39;;</span><br><span class="line"></span><br><span class="line">function changeColor() &#123;</span><br><span class="line">  var anotherColor &#x3D; &#39;red&#39;;</span><br><span class="line"></span><br><span class="line">  function swapColors() &#123;</span><br><span class="line">    var tempColor &#x3D; anotherColor;</span><br><span class="line">    anotherColor &#x3D; color;</span><br><span class="line">    color &#x3D; tempColor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  swapColors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure><p>根据以上JS执行顺序举例说明：</p><ul><li>全局上下文入栈；</li><li>可执行代码开始执行，遇到<code>changeColor()</code>，激活该函数创建自己的上下文，因此changeColor的执行上下文入栈；</li><li>changeColor的执行上下文入栈后，控制器开始执行changeColor中的可执行代码，遇到<code>swapColors()</code>，激活swapColors函数创建自己的上下文并且入栈；</li><li>swapColors的可执行代码中没有遇到其他能生成执行上下文的情况，因此这段代码执行完毕，swapColors执行上下文从栈中弹出；</li><li>swapColors的执行上下文弹出之后，继续执行changeColor的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出；</li><li>最后只剩下全局上下文，全局上下文在浏览器窗口关闭后出栈。<br><img src="https://s2.loli.net/2022/03/08/bYjZUtNoI9p2J5L.png" alt=""></li></ul><p><strong>注意</strong>：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。以闭包为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var n &#x3D; 999;</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    alert(n);</span><br><span class="line">  &#125;</span><br><span class="line">  return f2;</span><br><span class="line">&#125;</span><br><span class="line">var result &#x3D; f1();</span><br><span class="line">result(); &#x2F;&#x2F; 999</span><br></pre></td></tr></table></figure><p>具体上下文执行如下：<br><img src="https://s2.loli.net/2022/03/08/VltD9umQ6BzAyNn.png" alt=""></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>执行上下文中，除了<strong>函数调用栈</strong>这种特殊的数据结构，还有另外一个特殊的队列结构，页面中所有由setTimeout回调、Promise的then定义的操作，都将放在同一个队列中依次执行。</p><blockquote><p><strong>队列执行的时间，需要等待到函数调用栈清空之后才开始执行。即所有可执行代码执行完毕之后，才会开始执行由setTimeout定义的操作。而这些操作进入队列的顺序，则由设定的延迟时间来决定。</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">  setTimeout(function timer() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, i * 1000);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 输出结果6 6 6 6 6</span><br><span class="line">for (let i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">  setTimeout(function timer() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, i * 1000);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 输出结果 1 2 3 4 5</span><br><span class="line">for (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">  (function (i) &#123;</span><br><span class="line">    setTimeout(function timer() &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;, i * 1000);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 输出结果 1 2 3 4 5</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>当调用一个函数时（激活），一个新的执行上下文就会被创建，一个执行上下文的生命周期如下：</p><ul><li>创建阶段：执行上下文会生成变量对象，建立作用域链，确定this的指向；</li><li>代码执行阶段：创建完成后开始执行代码，变量赋值，函数引用，执行其他的代码；</li><li>销毁阶段：可执行代码执行完毕后，执行上下文出栈，对应的内存空间失去引用，等待回收。</li></ul><p><img src="https://s2.loli.net/2022/03/12/U2YOV3mZPy5XxQi.png" alt=""><br>下面依次介绍变量对象的生成、作用域链的建立、this指向的确定。</p><h1 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h1><blockquote><p>变量对象在新版本中叫做环境记录对象<br>环境记录对象有分为词法环境对象和变量环境对象<br>为了方便理解，这里统一采用变量对象的说法</p></blockquote><h2 id="创建执行过程"><a href="#创建执行过程" class="headerlink" title="创建执行过程"></a>创建执行过程</h2><ol><li><strong>创建</strong></li></ol><ul><li>检查当前上下文，生成变量对象，建立该对象下的属性与属性值；</li><li>检查当前上下文的函数声明，在变量对象中以函数名建立一个属性，属性值指向该函数的内存地址引用；</li><li>检查当前上下文的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined，<strong>如果是const/let 声明的变量没有赋值，不能提前使用</strong>。</li></ul><ol start="2"><li><strong>执行</strong><br>变量对象创建完成之后，<strong>未进入执行阶段之前，变量对象中的属性都不能访问！</strong>进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作，就是给变量对象里面的声明赋值。</li></ol><p><strong>注意</strong>：如果var声明的变量和函数同名，以函数为准。<br><img src="https://s2.loli.net/2022/03/09/bvMy12akwufzi56.png" alt=""><br>根据这个规则，理解变量提升就变得十分简单了，可以用变量对象的创建过程来解释变量提升，看以下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo); &#x2F;&#x2F; function foo</span><br><span class="line">function foo() &#123; console.log(&#39;function foo&#39;) &#125;</span><br><span class="line">var foo &#x3D; 20;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上例的执行顺序为</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 首先将所有函数声明放入变量对象中</span><br><span class="line">function foo() &#123; console.log(&#39;function foo&#39;) &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，此时以函数值为准，而不会被undefined覆盖</span><br><span class="line">&#x2F;&#x2F; var foo &#x3D; undefined;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后开始执行阶段代码的执行</span><br><span class="line">console.log(foo); &#x2F;&#x2F; function foo</span><br><span class="line">foo &#x3D; 20;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; demo01</span><br><span class="line">function test() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(foo());</span><br><span class="line"></span><br><span class="line">    var a &#x3D; 1;</span><br><span class="line">    function foo() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>创建test执行上下文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建过程</span><br><span class="line">&#x2F;&#x2F; 创建执行上下文</span><br><span class="line">testEC &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 变量对象</span><br><span class="line">    VO: &#123;&#125;,</span><br><span class="line">    scopeChain: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; VO 为 Variable Object的缩写，即变量对象</span><br><span class="line">VO &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理</span><br><span class="line">  arguments: &#123;...&#125;,  </span><br><span class="line">  foo: &lt;foo reference&gt;  &#x2F;&#x2F; 表示foo的地址引用</span><br><span class="line">  a: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p><blockquote><p>变量对象和活动对象<br>他们其实都是同一个对象，只是处于执行上下文的不同生命周期。<br>不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行阶段</span><br><span class="line">VO -&gt;  AO   &#x2F;&#x2F; Active Object</span><br><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;...&#125;,</span><br><span class="line">    foo: &lt;foo reference&gt;,</span><br><span class="line">    a: 1,</span><br><span class="line">    this: Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    console.log(foo);</span><br><span class="line">    console.log(bar);</span><br><span class="line"></span><br><span class="line">    var foo &#x3D; &#39;Hello&#39;;</span><br><span class="line">    console.log(foo);</span><br><span class="line">    var bar &#x3D; function () &#123;</span><br><span class="line">        return &#39;world&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function foo() &#123;</span><br><span class="line">        return &#39;hello&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建阶段</span><br><span class="line">VO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;...&#125;,</span><br><span class="line">    foo: &lt;foo reference&gt;,</span><br><span class="line">    bar: undefined</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这里有一个需要注意的地方，var声明的变量与函数同名，以函数为准</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行阶段</span><br><span class="line">VO -&gt; AO</span><br><span class="line">VO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;...&#125;,</span><br><span class="line">    foo: &#39;Hello&#39;,</span><br><span class="line">    bar: &lt;bar reference&gt;,</span><br><span class="line">    this: Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="var-const-let"><a href="#var-const-let" class="headerlink" title="var const let"></a>var const let</h2><ol><li>var</li></ol><ul><li>var声明的变量，如果在函数内就属于当前函数作用域，如果在函数外的顶层，那么这个变量就属于全局作用域；</li><li>var 声明的变量存在提升</li></ul><ol start="2"><li>let</li></ol><ul><li>let 声明的变量属于块作用域；</li><li>在同一个块级作用域，不能重复声明变量；</li><li>let 声明的变量不存在变量提升，换一种说法，就是 let 声明存在暂时性死区。</li></ul><ol start="3"><li>const</li></ol><ul><li>const 声明的变量属于块作用域；</li><li>在同一个块级作用域，不能重复声明变量；</li><li>const 声明的变量不存在变量提升，换一种说法，就是 const 声明存在暂时性死区；</li><li>const 声明的变量值不可更改，也就是说是一个常量。</li><li>一旦声明必须赋值,不能使用null占位；如果声明的是复合类型数据，可以修改其属性。</li></ul><p>总结如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; var 声明的变量属于函数作用域，let 和 const 声明的变量属于块级作用域</span><br><span class="line">if(1)&#123;</span><br><span class="line">    var a &#x3D; 100;</span><br><span class="line">    let b &#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); &#x2F;&#x2F; 100</span><br><span class="line">console.log(b)  &#x2F;&#x2F; 报错：b is not defined  &#x3D;&#x3D;&#x3D;&gt; 找不到b这个变量</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; var声明变量存在变量提升，let和const不存在变量提升</span><br><span class="line">console.log(a); &#x2F;&#x2F; undefined  &#x3D;&#x3D;&#x3D;&gt;  a已声明还没赋值，默认得到undefined值</span><br><span class="line">var a &#x3D; 100;</span><br><span class="line">console.log(b); &#x2F;&#x2F; 报错：b is not defined  &#x3D;&#x3D;&#x3D;&gt; 找不到b这个变量</span><br><span class="line">let b &#x3D; 10;</span><br><span class="line">console.log(c); &#x2F;&#x2F; 报错：c is not defined  &#x3D;&#x3D;&#x3D;&gt; 找不到c这个变量</span><br><span class="line">const c &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; var 变量可以重复声明，而在同一个块级作用域，let 变量不能重新声明，const 变量不能修改</span><br><span class="line">var a &#x3D; 100;</span><br><span class="line">console.log(a); &#x2F;&#x2F; 100</span><br><span class="line">var a &#x3D; 10;</span><br><span class="line">console.log(a); &#x2F;&#x2F; 10</span><br><span class="line">let b &#x3D; 100;</span><br><span class="line">let b &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F; 控制台报错：Identifier &#39;b&#39; has already been declared </span><br><span class="line">&#x2F;&#x2F; 标识符b已经被声明了。</span><br></pre></td></tr></table></figure><h2 id="变量提升-函数提升"><a href="#变量提升-函数提升" class="headerlink" title="变量提升 函数提升"></a>变量提升 函数提升</h2><ol><li><strong>变量提升</strong><br>在JS中，变量提升只是提升变量的声明，并不会把变量赋值也提升上来。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1</span><br><span class="line">(</span><br><span class="line">  function()&#123;</span><br><span class="line">    console.log(a) &#x2F;&#x2F; undefined &#x3D;&#x3D;&#x3D;&gt;  a已声明还没赋值，默认得到undefined值</span><br><span class="line">    var a &#x3D; 2</span><br><span class="line">  &#125;</span><br><span class="line">)()</span><br><span class="line">&#x2F;&#x2F; 变量提升为以下内容：   </span><br><span class="line">var a &#x3D; 1</span><br><span class="line">(</span><br><span class="line">  function()&#123;</span><br><span class="line">    var a</span><br><span class="line">    console.log(a)</span><br><span class="line">    a &#x3D; 2</span><br><span class="line">  &#125;</span><br><span class="line">)()</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong>：当一个函数被调用（激活）的时候，会创建一个执行上下文，执行上下文会生成变量对象，建立变量对象下的属性；然后检查上下文的函数声明，在变量对象中以函数名建立一个属性，属性值指向该函数的内存地址引用；然后检查当前上下文的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined，比如<code>console.log(a);var a = 1</code>就会创建一个属性为a，属性值为undefined的属性，当变量对象创建完成后会去执行代码，这个时候才会把属性a赋值为1，也就是说先声明，后赋值，那么刚刚那段代码就是被解析成<code>var a;console.log(a);a=1</code>，这就是变量提升。</p><ol start="2"><li><strong>函数提升</strong><br>在JS中，函数的写法与两种，一种是函数声明，一种是函数表达式，函数提升只对函数声明式的函数有效。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数声明</span><br><span class="line">function myTest()&#123;</span><br><span class="line">  foo();</span><br><span class="line">  function foo()&#123;</span><br><span class="line">    alert(&quot;我来自 foo&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myTest();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数表达式的提升会报错：foo is not a function</span><br><span class="line">function myTest()&#123;</span><br><span class="line">  foo();</span><br><span class="line">  &#x2F;&#x2F; 函数表达式</span><br><span class="line">  var foo &#x3D;function foo()&#123;</span><br><span class="line">    alert(&quot;我来自 foo&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myTest();</span><br></pre></td></tr></table></figure></li></ol><h1 id="作用域-作用域链"><a href="#作用域-作用域链" class="headerlink" title="作用域 作用域链"></a>作用域 作用域链</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域是JS的一套规则，可以理解成上下文中声明的函数和变量的作用范围。分为全局作用域、函数作用域、块作用域。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链是作用域的具体实现，是由当前环境和上层环境的变量对象组成的，所以我们能通过作用域链访问到父级里声明的变量或者函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 20;</span><br><span class="line">function test() &#123;</span><br><span class="line">  var b &#x3D; a + 10;</span><br><span class="line">  function innerTest() &#123;</span><br><span class="line">    var c &#x3D; 10;</span><br><span class="line">    return b + c;</span><br><span class="line">  &#125;</span><br><span class="line">  return innerTest();</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">&#x2F;&#x2F; 以上，全局、函数test、函数innerTest的执行上下文会依次创建；</span><br><span class="line">&#x2F;&#x2F; 我们设定他们的变量对象分别为VO(global)，VO(test), VO(innerTest)；</span><br><span class="line">&#x2F;&#x2F; 而innerTest的作用域链，则同时包含了这三个变量对象，所以innerTest的执行上下文可如下表示。</span><br><span class="line">innerTestEC &#x3D; &#123;</span><br><span class="line">  VO: &#123;...&#125;,  &#x2F;&#x2F; 变量对象</span><br><span class="line">  scopeChain: [VO(innerTest), VO(test), VO(global)], &#x2F;&#x2F; 作用域链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里使用一个数组来模拟作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。</p><h1 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h1><blockquote><p><strong>this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。</strong><br><strong>在函数执行过程中，this一旦被确定，就不可更改了。</strong></p></blockquote><h2 id="全局this"><a href="#全局this" class="headerlink" title="全局this"></a>全局this</h2><p>全局环境中的this，指向它本身。因此，这也相对简单，没有那么多复杂的情况需要考虑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过this绑定到全局对象</span><br><span class="line">this.a2 &#x3D; 20;</span><br><span class="line">&#x2F;&#x2F; 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身</span><br><span class="line">var a1 &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F; 仅仅只有赋值操作，标识符会隐式绑定到全局对象</span><br><span class="line">a3 &#x3D; 30;</span><br><span class="line">&#x2F;&#x2F; 输出结果会全部符合预期</span><br><span class="line">console.log(a1);</span><br><span class="line">console.log(a2);</span><br><span class="line">console.log(a3);</span><br></pre></td></tr></table></figure><h2 id="普通函数中的this"><a href="#普通函数中的this" class="headerlink" title="普通函数中的this"></a>普通函数中的this</h2><p>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。</p><ol><li>如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。</li><li>如果函数独立调用，严格模式下，该函数内部的this，指向undefined；在非严格模式中，当this指向undefined时，它会被自动指向全局对象。目前基本已经全部采用严格模式。</li><li>单独的{}不会形成新的作用域，因此对象属性中的this仍然处于全局作用域之中，所以这里的this是指向全局对象。</li></ol><p>所以，如果想要准确确定this指向，就要找到函数的<strong>调用者</strong>以及区分他<strong>是否独立调用</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;</span><br><span class="line">&#x2F;&#x2F; demo01</span><br><span class="line">var a &#x3D; 20;</span><br><span class="line">function fn() &#123;</span><br><span class="line">  console.log(this.a); </span><br><span class="line">&#125;</span><br><span class="line">fn(); &#x2F;&#x2F; 调用者是fn，独立调用，严格模式，this是undefined</span><br><span class="line">window.fn();  &#x2F;&#x2F; 调用者是fn，被window所拥有，this指向window</span><br><span class="line">&#x2F;&#x2F; demo02</span><br><span class="line">var a &#x3D; 20;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  c: this.a + 20,</span><br><span class="line">  fn: function () &#123;</span><br><span class="line">    return this.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.c); &#x2F;&#x2F; 40 对象属性中的this指向全局 </span><br><span class="line">console.log(obj.fn()); &#x2F;&#x2F; 10 调用者fn被对象拥有，this指向对象</span><br><span class="line">&#x2F;&#x2F; demo03</span><br><span class="line">var a &#x3D; 20;</span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  getA: function () &#123;</span><br><span class="line">    return this.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo.getA()); &#x2F;&#x2F; 10 调用者getA被对象拥有，this指向对象</span><br><span class="line">var test &#x3D; foo.getA;</span><br><span class="line">console.log(test());  &#x2F;&#x2F; 报错 调用者test，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined</span><br></pre></td></tr></table></figure><h2 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h2><p><strong>箭头函数没有自己的this，它会捕获所在上下文的this作为自己的this值。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;  </span><br><span class="line">    this.age &#x3D; 0;  </span><br><span class="line">    setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 回调里面的 &#96;this&#96; 变量就指向了期望的那个对象了</span><br><span class="line">        this.age++;</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line">var p &#x3D; new Person();</span><br></pre></td></tr></table></figure><h2 id="构造函数和原型方法上的this"><a href="#构造函数和原型方法上的this" class="headerlink" title="构造函数和原型方法上的this"></a>构造函数和原型方法上的this</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里的this指向了谁?</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;   </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里的this又指向了谁？</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 上面的2个this，是同一个吗，他们是否指向了原型对象？</span><br><span class="line">var p1 &#x3D; new Person(&#39;Nick&#39;, 20);</span><br><span class="line">p1.getName();</span><br></pre></td></tr></table></figure><p>通过new操作符调用构造函数，会经历以下4个阶段：</p><ol><li>创建一个新的对象；</li><li>将构造函数的this指向这个新对象；</li><li>指向构造函数的代码，为这个对象添加属性，方法等；</li><li>返回新对象。</li></ol><p>因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象：p1。</p><p>而原型方法上的this就好理解多了，根据上边对函数中this的定义，p1.getName()中的getName为调用者，他被p1所拥有，因此getName中的this，也是指向了p1。</p><h2 id="call-apply-bind-指定-this"><a href="#call-apply-bind-指定-this" class="headerlink" title="call apply bind 指定 this"></a>call apply bind 指定 this</h2><p>call apply bind都是用来指定this，第一个入参是this的指向对象（如果此参数是null或者undefined，this指向全局），差别在于后面的入参：</p><ol><li>call后面的入参是多个参数，一个一个传递；</li><li>appy后面的入参是数组；</li><li>bind后面的入参和call一样，但是bind返回的是函数，并没有立即执行。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn(b,c) &#123;</span><br><span class="line">  console.log(this.a+&#39;-&#39;+b+&#39;-&#39;+c);</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: 20</span><br><span class="line">&#125;</span><br><span class="line">fn.call(obj,1,2);</span><br><span class="line">fn.apply(obj,[1,2]);</span><br><span class="line">fn.bind(obj,1,2)();</span><br></pre></td></tr></table></figure><p>常用做法：当匿名函数的存在导致this指向丢失时，确保this的指向不变，也可以使用箭头函数来代替。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: 20,</span><br><span class="line">  getA: function () &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(this.a)</span><br><span class="line">    &#125;.bind(this), 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure><h2 id="手动实现call-apply-bind"><a href="#手动实现call-apply-bind" class="headerlink" title="手动实现call apply bind"></a>手动实现call apply bind</h2><ol><li>call</li></ol><ul><li>判断当前this是否为函数，防止Function.prototype.myCall() 直接调用</li><li>context 为可选参数，如果不传的话默认上下文为 window</li><li>为 context 创建一个 Symbol（保证不会重名）属性，将当前函数赋值给这个属性</li><li>处理参数，传入第一个参数后的其余参数</li><li>调用函数后即删除该Symbol属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall &#x3D; function (context &#x3D; window, ...args) &#123;</span><br><span class="line">  if (this &#x3D;&#x3D;&#x3D; Function.prototype) &#123;</span><br><span class="line">    return undefined; &#x2F;&#x2F; 用于防止 Function.prototype.myCall() 直接调用</span><br><span class="line">  &#125;</span><br><span class="line">  const fn &#x3D; Symbol();</span><br><span class="line">  context[fn] &#x3D; this;</span><br><span class="line">  const result &#x3D; context[fn](...args);</span><br><span class="line">  delete context[fn];</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>apply<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply &#x3D; function (context &#x3D; window, args) &#123;</span><br><span class="line">  if (this &#x3D;&#x3D;&#x3D; Function.prototype) &#123;</span><br><span class="line">    return undefined; &#x2F;&#x2F; 用于防止 Function.prototype.myCall() 直接调用</span><br><span class="line">  &#125;</span><br><span class="line">  const fn &#x3D; Symbol();</span><br><span class="line">  context[fn] &#x3D; this;</span><br><span class="line">  let result;</span><br><span class="line">  if (Array.isArray(args)) &#123;</span><br><span class="line">    result &#x3D; context[fn](...args);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result &#x3D; context[fn]();</span><br><span class="line">  &#125;</span><br><span class="line">  delete context[fn];</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>bind</li></ol><ul><li>处理参数，返回一个闭包</li><li>判断是否为构造函数调用，如果是则使用new调用当前函数</li><li>如果不是，使用apply，将context和处理好的参数传入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind &#x3D; function (context,...args1) &#123;</span><br><span class="line">  if (this &#x3D;&#x3D;&#x3D; Function.prototype) &#123;</span><br><span class="line">    throw new TypeError(&#39;Error&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  const _this &#x3D; this</span><br><span class="line">  return function F(...args2) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断是否用于构造函数</span><br><span class="line">    if (this instanceof F) &#123;</span><br><span class="line">      return new _this(...args1, ...args2)</span><br><span class="line">    &#125;</span><br><span class="line">    return _this.apply(context, args1.concat(args2))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h1><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>事件循环机制(Event Loop)从整体上的告诉了我们所写的JavaScript代码的执行顺序。需要理解以下几个知识点：</p><ul><li>堆、栈、队列等数据结构</li><li>执行上下文(Execution context)</li><li>函数调用栈(call stack)</li><li>队列数据结构(queue)</li></ul><p>JavaScript的一大特点就是单线程，而这个线程中拥有唯一的一个事件循环。</p><p>JavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行。</p><ul><li>一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。</li><li>任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。</li><li>宏任务大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。</li><li>微任务大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)</li><li>setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。所以setTimeout中的回调函数是进入任务队列的任务，而Promise进入任务队列的是then。</li><li><strong>async/await情况特殊：</strong>遇到async函数和普通函数一样执行就可以了，特殊的是await，await会先等后面跟着的内容执行并返回结果，然后<strong>中断async函数</strong>，先执行async外的代码，等到执行完之后返回async内部执行剩下的代码，最后执行队列。</li><li>来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。</li><li>事件循环的顺序，决定了JavaScript代码的执行顺序。</li><li>每一个任务的执行，无论是宏任务还是微任务，都是借助函数调用栈来完成。</li></ul><span style="color: #409eff;">事件循环它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的微任务。当所有可执行的微任务执行完毕之后。循环再次从宏任务开始，找到其中一个任务队列执行完毕，然后再执行所有的微任务，这样一直循环下去。</span><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#39;timeout1&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">setImmediate(function() &#123;</span><br><span class="line">    console.log(&#39;immediate1&#39;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&#39;immediate1_nextTick&#39;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#39;immediate1_promise&#39;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#39;immediate1_then&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&#39;promise1&#39;);</span><br><span class="line">    for(var i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        i &#x3D;&#x3D; 99 &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#39;promise2&#39;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#39;then1&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;global1&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;结果：</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">global1</span><br><span class="line">then1</span><br><span class="line"></span><br><span class="line">timeout1</span><br><span class="line">immediate1</span><br><span class="line">immediate1_promise</span><br><span class="line">immediate1_nextTick</span><br><span class="line">immediate1_then</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解析</span><br><span class="line">1.从上往下依次执行，script(整体代码)宏任务进入，全局global入栈。</span><br><span class="line">2.遇到setTimeout，setTimeout作为任务分发器，将任务分发到对应的宏任务队列中。</span><br><span class="line">3.遇到setImmediate，是一个宏任务分发器，将任务分发到对应的任务队列。setImmediate的任务队列会在setTimeout队列的后面执行。</span><br><span class="line">4.遇到Promise，Promise的then方法会将任务分发到对应的微任务队列中，但是它构造函数中的方法会直接执行。</span><br><span class="line">  promise1打印，resolve入栈，then进入微任务队列，promise2打印。</span><br><span class="line">5.global1打印，script(整体代码)宏任务结束，执行所有微任务队列。当前微任务队列有then,打印then1。</span><br><span class="line">6.循环结束，进行下次循环。执行setTimeout,打印timeout1。当前微任务队列为空。执行下一次循环。</span><br><span class="line">7.执行setImmediate，打印immediate1。</span><br><span class="line">8.执行遇到nextTick，process.nextTick是一个微任务分发器，它会将任务分发到对应的微任务队列中去。</span><br><span class="line">9.执行遇到Promise。Promise的then方法会将任务分发到对应的微任务队列中，但是它构造函数中的方法会直接执行。</span><br><span class="line">  所以打印immediate1_promise。</span><br><span class="line">10.当前宏任务执行完毕，再执行所有微任务nextTick和Promise。打印immediate1_nextTick，打印immediate1_then。</span><br><span class="line">全部任务执行完毕，global出栈。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">    console.log(&quot;async1 start&quot;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&quot;async1 end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">    console.log(&quot;async2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;script start&quot;);</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&quot;setTimeout&quot;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">async1();</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&quot;promise1&quot;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&quot;promise2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;script end&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行结果如下：</span><br><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解析</span><br><span class="line">1.从上往下依次执行，script(整体代码)宏任务进入，全局global入栈。</span><br><span class="line">2.遇到console.log(&quot;script start&quot;);打印script start。</span><br><span class="line">3.遇到setTimeout，进入宏观任务的timeout队列。</span><br><span class="line">4.执行async1，先直接打印async1 start，遇到await，执行async2，打印async2。</span><br><span class="line">5.await会中断async函数，继续往下执行其他的同步代码。</span><br><span class="line">6.遇到Promise，先执行回调函数，打印promise1，then方法进入微任务的then队列。</span><br><span class="line">7.遇到console.log(&quot;script end&quot;);打印script end。</span><br><span class="line">8.代码执行完毕，回去执行async剩下的代码，打印async1 end。</span><br><span class="line">9.执行微任务队列，打印promise2。</span><br><span class="line">10.执行宏任务队列，打印setTimeout。</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.jianshu.com/p/12b9f73c5a4f" target="_blank" rel="noopener"><strong>深入核心，详解事件循环机制</strong></a></p><h2 id="为什么要分宏任务和微任务"><a href="#为什么要分宏任务和微任务" class="headerlink" title="为什么要分宏任务和微任务"></a>为什么要分宏任务和微任务</h2><p>事件循环中的任务分宏任务和微任务，是为了给高优先级任务一个插队的机会，微任务比宏任务有更高的优先级。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2021/09/23/05/27/butterflies-6648681_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/categories/Web/"/>
    
      <category term="JS" scheme="http://crystalsummer.gitee.io/categories/Web/JS/"/>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/tags/Web/"/>
    
      <category term="JS" scheme="http://crystalsummer.gitee.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>小程序开发踩坑</title>
    <link href="http://crystalsummer.gitee.io/2021/02/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91/"/>
    <id>http://crystalsummer.gitee.io/2021/02/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91/</id>
    <published>2021-02-20T07:21:19.000Z</published>
    <updated>2023-06-14T08:04:35.896Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/11/16/12/55/winter-1828779_960_720.jpg" alt=""></p><a id="more"></a><style>  .border{    padding: 10px;    border: 1px solid #ebebeb;    border-radius: 4px;    margin-bottom: 20px;  }  .border .title{    font-size: 16px;    font-weight: 500;  }  .border .content-slove{    text-indent: 20px;  }</style><h3 id="钉钉小程序，线上环境有的组件失效"><a href="#钉钉小程序，线上环境有的组件失效" class="headerlink" title="钉钉小程序，线上环境有的组件失效"></a>钉钉小程序，线上环境有的组件失效</h3><div class="border">    <div class="title">uni-app + uView 开发钉钉小程序，线上环境有的组件失效问题。</div>    <div class="content-slove">开发钉钉小程序，实际上和开发支付宝小程序一样，uView 必须开启 component2 模式才能支持支付宝小程序的开发，详情请查看：<a href="https://www.uviewui.com/components/feature.html" target="_blank" rel="noopener">uView 开发注意事项</a></div></div><h3 id="小程序配置安全域名无效问题"><a href="#小程序配置安全域名无效问题" class="headerlink" title="小程序配置安全域名无效问题"></a>小程序配置安全域名无效问题</h3><div class="border">    <div class="title">小程序配置安全域名无效问题。</div>    <div class="content-slove">在后台系统配置安全域名必须要在发布版本之前，否则接口不同，如果对安全域名进行了修改，必须要重新发布版本。</div></div><h3 id="开发工具预览问题"><a href="#开发工具预览问题" class="headerlink" title="开发工具预览问题"></a>开发工具预览问题</h3><div class="border">    <div class="title">开发钉钉小程序，在开发工具中预览问题。</div>    <div class="content-slove">开发工具预览功能，只能当前用户自己预览，即使其他用户已经加入开发者名单中，扫码依然预览不了。</div></div><h3 id="钉钉小程序页面禁止下拽"><a href="#钉钉小程序页面禁止下拽" class="headerlink" title="钉钉小程序页面禁止下拽"></a>钉钉小程序页面禁止下拽</h3><div class="border">    <div class="title">钉钉小程序页面禁止下拽。</div>    <div class="content-slove">开发完小程序之后，下拉页面发现页面会被下拽拖动，需要禁止这一操作，可以使用 "allowsBounceVertical": "NO" 来禁止下拽行为，但是该属性只只对支付宝、钉钉小程序。</div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在page.json里面的globalStyle里面配置</span><br><span class="line">&quot;globalStyle&quot;: &#123;</span><br><span class="line">  &quot;mp-alipay&quot;:&#123;</span><br><span class="line">    &quot;allowsBounceVertical&quot;: &quot;NO&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小程序缓存问题"><a href="#小程序缓存问题" class="headerlink" title="小程序缓存问题"></a>小程序缓存问题</h3><div class="border">    <div class="title">小程序缓存问题。</div>    <div class="content-slove">小程序发布版本之后，再去打开小程序还是之前的样子，这个时候是热启动，这个过程只是将后台的小程序切换到前台，并不会重新加载或者启动小程序。只有小程序进入后台超过一定时间（一般5分钟）或者小程序被销毁之后，打开小程序才会冷启动，重新加载小程序。</div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; uni-app 强制更新代码</span><br><span class="line">onLaunch: function() &#123;</span><br><span class="line">  &#x2F;&#x2F; 管理小程序更新</span><br><span class="line">  const updateManager &#x3D; uni.getUpdateManager();</span><br><span class="line">  updateManager.onCheckForUpdate(function(res) &#123;</span><br><span class="line">    if (res.hasUpdate) &#123;</span><br><span class="line">      updateManager.onUpdateReady(function(res) &#123;</span><br><span class="line">        uni.showModal(&#123;</span><br><span class="line">          title: &#39;更新提示&#39;,</span><br><span class="line">          content: &#39;新版本已经准备好，是否重启应用？&#39;,</span><br><span class="line">          showCancel: false,</span><br><span class="line">          success(res) &#123;</span><br><span class="line">            if (res.confirm) &#123;</span><br><span class="line">              updateManager.applyUpdate();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="uView-折叠面板展开内容显示不全"><a href="#uView-折叠面板展开内容显示不全" class="headerlink" title="uView 折叠面板展开内容显示不全"></a>uView 折叠面板展开内容显示不全</h3><div class="border">    <div class="title">uni-app + uView 开发钉钉应用，折叠面板组件展开后显示的内容不全。</div>    <div class="content-slove">由于数据(无论是名称还是对应的值)是从后台接口查回来的，然后通过 v-for 循环展示在面板里面，但是打开面板之后发现显示的内容不全，原因可能是面板计算高度的时候接口数据还未返回或者数据还未渲染完成，查看了面板组件的源码之后，使用组件内部的计算高度的方法解决问题。</div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;u-collapse ref&#x3D;&quot;uCollapse&quot;&gt;</span><br><span class="line">  &lt;u-collapse-item v-for&#x3D;&quot;(item, index) in monthlyWorkTargetList&quot; :key&#x3D;&quot;index&quot; :index&#x3D;&quot;index&quot;</span><br><span class="line">    ref&#x3D;&quot;collapseMonth&quot; @change&#x3D;&quot;handleOpenChange(index)&quot;&gt;</span><br><span class="line">    ......</span><br><span class="line">  &lt;&#x2F;u-collapse-item&gt;</span><br><span class="line">&lt;&#x2F;u-collapse&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解决打开面板内容显示不全问题  使用 $nextTick 也无法解决问题，之后用了 setTimeout</span><br><span class="line">handleOpenChange()&#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 重新计算面板的高度</span><br><span class="line">    this.$refs.collapseMonth[index].queryRect()</span><br><span class="line">  &#125;, 20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按钮-disabled-依然触发-touchstart"><a href="#按钮-disabled-依然触发-touchstart" class="headerlink" title="按钮 disabled 依然触发 touchstart"></a>按钮 disabled 依然触发 touchstart</h3><div class="border">    <div class="title">移动端开发，按钮设置 disabled 之后，touchstart 事件依然被触发问题</div>    <div style='text-indent: 30px;'>为了消除 click 带来的 300 毫秒的延迟，我们用 touchstart 事件来模拟 tab 代替 click 事件，但是按钮 disabled 之后，touchstart 事件依然会被触发。可能是因为 disabled 只对 click 事件有效。为了解决这一问题，让元素不能点击触摸的方法很简单，使用 <code>pointer-events: none;</code> 这个 css3 属性就行，IE9 和以下不支持，想让 disabled 的东西不能点击触摸就这样写 <code>[disabled]{pointer-events: none;}</code>。</div></div><h3 id="页面改变title"><a href="#页面改变title" class="headerlink" title="页面改变title"></a>页面改变title</h3><div class="border">    <div class="title">开发浙政钉遇到的问题：Vue 路由跳转的时候想改变页面 title，但是 title 不变，必须刷新之后才会改变</div>    <div class="content-slove">解决方法：引入钉钉 API，具体方法如下：</div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.引入 js</span><br><span class="line">&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;g.alicdn.com&#x2F;dingding&#x2F;dingtalk-jsapi&#x2F;2.3.0&#x2F;dingtalk.open.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F; 或者查看钉钉开发手册，里面有一个包</span><br><span class="line">npm install dingtalk-jsapi --save </span><br><span class="line">import * as dd from &#39;dingtalk-jsapi&#39;; &#x2F;&#x2F; 此方式为整体加载，也可按需进行加载</span><br><span class="line">&#x2F;&#x2F; 2.改变 title</span><br><span class="line">dd.ready(function() &#123;</span><br><span class="line">    dd.biz.navigation.setTitle(&#123;</span><br><span class="line">      title: &quot;123&quot;, </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Vant-步骤条切换值消失"><a href="#Vant-步骤条切换值消失" class="headerlink" title="Vant 步骤条切换值消失"></a>Vant 步骤条切换值消失</h3><div class="border">    <div class="title">Vant 步骤条组件，切换步骤，页面输入框填写的值消失问题。</div>    <div class="content-slove">使用 van-steps 来实现分步骤表单填写，每个步骤 div 里有会上一页和下一页按钮，由于表单里面的按钮自带 submit 属性，所以在切换步骤的时候会自动对表单进行校验，这不是想要的结果，所以将按钮的 native-type 的值改成 reset，这样虽然在切换的时候不会校验了，但是在安卓手机上，来回切换步骤会导致页面表单输入的内容消失，但是苹果手机上没有这个问题，最终的解决方法是将 native-type 的值改成 button。</div></div><h3 id="微信公众平台的图片显示失败"><a href="#微信公众平台的图片显示失败" class="headerlink" title="微信公众平台的图片显示失败"></a>微信公众平台的图片显示失败</h3><div class="border">    <div class="title">微信公众平台的图片显示失败。</div>    <div class="content-slove">解决：在index.html页面加上标签 meta name="referrer" content="never"。</div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2016/11/16/12/55/winter-1828779_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="uni-app" scheme="http://crystalsummer.gitee.io/categories/uni-app/"/>
    
      <category term="问题记录" scheme="http://crystalsummer.gitee.io/categories/uni-app/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="uni-app" scheme="http://crystalsummer.gitee.io/tags/uni-app/"/>
    
      <category term="问题记录" scheme="http://crystalsummer.gitee.io/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>浏览器输入URL之后发生了什么</title>
    <link href="http://crystalsummer.gitee.io/2021/01/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://crystalsummer.gitee.io/2021/01/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2021-01-17T10:45:50.000Z</published>
    <updated>2023-06-14T08:04:35.897Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/02/19/11/47/flowers-1209948_960_720.jpg" alt=""></p><a id="more"></a><p>从输入url到页面展示大概经过下面这些过程：</p><ul><li>DNS域名解析</li><li>建立TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP响应</li><li>浏览器渲染页面</li><li>关闭TCP连接</li></ul><p>在浏览器地址栏里面输入url，在没有 enter 搜索之前，会先从历史记录、书签或者缓存中查找地址，如果没找到就按照上面的步骤执行，如果找到了会直接从缓存中调出页面显示。</p><h1 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h1><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p><strong>URL</strong>：(Uniform Resource Locator)统一资源定位符，是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。</p><p><strong>IP地址</strong>：(Internet Protocol Address)网际协议地址，一种在internet上某一台计算机或计算机组的名称，是分配给网上使用网际协议（英语：Internet Protocol, IP）的设备的数字标签。常见的IP地址分为IPv4与IPv6两大类，但是也有其他不常用的小分类。</p><p>每个IP可唯一标识一台主机，但是IP地址是一个32位的数字，为了便于记忆，我们通常把按每字节(8位)划分，然后用10进制表示出来，即我们通常说的点分十进制（在IPV6的中采用的是冒号分十六进制）。<br>比如192.168.144.1用二进制表示就是：11000000 10101000 10010000 00000001</p><p><strong>域名</strong>：(Domain Name)，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。<br>以 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> 为例，http是通信使用的协议，baidu.com是域名，www是提供服务的机器的名字（计算机名），计算机名+域名才是主机名，即 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 是主机名（hostname）。</p><p><strong>DNS</strong>：(Domain Name System)，因特网上域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。</p><p><strong>Hosts文件</strong>：系统文件，将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。<br>Hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。</p><h2 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h2><p>以 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> 为例，事实上真正的网址是 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>. ，这里多了一个点，这个点对应的就是根域名服务器，默认情况下所有的网址的最后一位都是点，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上。网址的解析是一个从右向左的过程，所有网址真正的解析过程为: . -&gt; .com -&gt; baidu.com。</p><ol><li><p><strong>从缓存中寻找域名对应的IP</strong>：(浏览器缓存-&gt; 本地Hosts文件-&gt;路由器缓存) 先在浏览器的缓存里面查找是否有该域名对应的IP地址，如果有，则直接返回该IP地址；如果没有，则查找本地的Hosts文件中是否有，如果有，则返回对应的IP地址；如果没有，则查找路由器缓存中是否有对应的IP地址，如果有，则返回，如果没有，向本地域名服务器进行查询；</p></li><li><p><strong>本地域名服务器递归查询</strong>：如果在浏览器缓存中、hosts文件中、路由器缓存中都没有找到IP地址，浏览器会发出一个 DNS请求到本地域名服务器（本地域名服务器一般都是你的网络接入服务器商提供，比如中国电信等）；DNS请求到达本地域名服务器之后，本地域名服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是以递归方式进行查询。如果没有，本地域名服务器还要向根域名服务器进行查询。</p></li><li><p><strong>根域名服务器迭代查询</strong>：本地域名服务器向根域名服务器发送一个DNS请求，根域名服务器没有记录域名和IP的对应关系，会告诉本地域名服务器，可以到顶级域名服务器上去继续查询，并给出顶级域名服务器的地址。这种过程是迭代的过程。</p></li><li><p><strong>.com顶级域名服务器迭代查询</strong>：本地域名服务器向顶级域名服务器发送一个DNS请求，.com顶级域名服务器也没有记录域名和IP的对应关系，会告诉本地域名服务器，可以到域名解析服务器上去继续查询，并给出域名解析服务器的地址。</p></li><li><p><strong>baidu.com域名解析服务器查询</strong>：本地域名服务器向域名解析服务器发送一个DNS请求，本地域名服务器就能收到一个域名和IP的对应关系，本地域名服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p></li></ol><p><img src="https://s2.loli.net/2022/03/23/OfHzkyctmES8eDv.png" alt=""></p><h2 id="DNS查询方式：递归查询-迭代查询"><a href="#DNS查询方式：递归查询-迭代查询" class="headerlink" title="DNS查询方式：递归查询 迭代查询"></a>DNS查询方式：递归查询 迭代查询</h2><ol><li><p>递归查询<br>局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。<br><img src="https://s2.loli.net/2022/03/23/Jw4hqoCa581IBNF.png" alt=""><br>比如DNS解析过程中，客户端向本地域名服务器发出查询请求就属于递归查询，因为本地域名服务器没有一级一级往下查询，查到结果后告诉客户端。</p></li><li><p>迭代查询<br>局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。<br>也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。<br><img src="https://s2.loli.net/2022/03/23/yfLOr7x89CwiSoz.png" alt=""><br>比如DNS解析过程中，本地域名服务器向根域名服务器、顶级域名服务器、域名解析器发出的查询请求就属于迭代查询。</p></li></ol><h1 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h1><p>浏览器拿到IP后，会向服务端发送TCP连接请求，客户端和服务器经过三次握手，建立TCP连接。</p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p><strong>协议</strong>：协议就是计算机与计算机之间通过网络通信时，事先达成的一种 “约定”。这种“约定”使不同厂商的设备、不同的CPU以及不同操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。</p><p><strong>TCP/IP协议</strong>：TCP/IP协议是用于因特网 (Internet) 的通信协议。TCP/IP 通信协议是对计算机必须遵守的规则的描述，只有遵守这些规则，计算机之间才能进行通信。<br>TCP/IP是基于TCP和IP这两个最初的协议之上的不同的通信协议的大集合。</p><p><strong>TCP/IP五层模型的协议</strong>：应用层(HTTP)、传输层(TCP/UDP)、网络层(IP)、数据链路层、物理层</p><p><strong>TCP/IP的数据包</strong>结构如下：<br><img src="https://s2.loli.net/2022/03/25/XeEwJBjr7tS1C4L.png" alt=""><br>TCP首部最小为20字节，这20字节分为5行，每行4个字节也就是32个位。</p><ol><li>源端口号 目标端口号<ul><li>源端口号：包含初始化通信的端口，源端口和源IP地址的作用是标识报文的返回地址。</li><li>目标端口号：定义传输的目的，指明报文接收计算机上的应用程序地址接口。</li></ul></li><li>序列号seq：用于标记客户端和服务器发送的数据包的序号。</li><li>确认号ack：客户端或者服务端收到对方的报文之后，会返回一个对应的确认报文来表示确认收到，确认报文包含确认号，确认号<strong>ack=seq+1</strong>。</li><li>6个标志位<br>每一个标志位的值只有 0 和 1，分别表达不同意思。<ul><li>URG：<strong>紧急指针</strong>，当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据；</li><li>ACK：<strong>确认</strong>，当ACK=0时，表示这是发送报文，没有包含确认信息；当ACK=1时，表示接收到报文，并且返回确认报文表示收到；</li><li>PSH：<strong>推送</strong>，当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序；</li><li>RST：<strong>复位</strong>，当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接；</li><li>SYN：<strong>同步</strong>，当 SYN = 1 的时候，表明这是一个请求连接报文段，对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1；</li><li>FIN：<strong>终止</strong>，当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。</li></ul></li></ol><p>关于TCP/IP的具体内容，可以查看<a href="https://zhuanlan.zhihu.com/p/33889997" target="_blank" rel="noopener">TCP/IP协议详解</a>这篇文章。</p><h2 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h2><p><img src="https://s2.loli.net/2022/03/25/hokNgveHSDC89PW.png" alt=""><br>客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求。<br>这个时候，客户端开始发起请求：</p><ul><li><p>第一次握手：客户端调用connect()函数，将标志位SYN置为1，请求建立连接，并随机产生一个序列号seq为J的数据包发送到服务器，客户端进入SYN_SENT状态，等待服务端确认；</p></li><li><p>第二次握手：服务端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和ACK都置为1，ACK=1表示确认收到，生成确认号ack=seq+1=J+1，然后随机产生一个序列号seq为K的数据包，将该数据包发送给客户端以确认连接请求，服务端进入SYN_RCVD状态；</p></li><li><p>第三次握手：客户端收到确认后，检查确认号ack是否为J+1，标志位ACK是否为1，如果正确则将标志位ACK置为1表示收到，并将确认号ack置为K+1，并将该数据包发送给服务端，服务端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务端进入ESTABLISHED(established)状态，完成三次握手，随后客户端与服务端之间就可以开始传输数据了。</p></li></ul><h2 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h2><p>三次握手的关键是确认对方收到了自己的数据包，目的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>已失效的连接请求报文段的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。</p><p>假设不是三次握手，已失效的请求报文突然发送到服务端，服务端就直接建立连接，但是客户端并没有发出建立连接的请求，也不会向服务端发送数据，但是服务端以为新的连接已经建立，就会一直等待客户端发送数据过来，这样就会浪费资源。也可以说三次握手的主要目的就是防止服务端一直等待，浪费资源。</p><h1 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h1><p>客户端和服务端建立TCP安全连接之后，就可以进行HTTP请求，发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口。</p><p>HTTP请求报文构成：请求行、请求头、空行、请求正文<br><img src="https://s2.loli.net/2022/03/25/GCtJkL6D4F2Qoic.png" alt=""></p><ul><li>请求行：请求方法 URI协议 版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET&#x2F;sample.jsp HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure></li><li>请求头：包含许多有关的客户端环境和请求正文的有用信息，常用的Accept，Content-Type……<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Accept: application&#x2F;json, text&#x2F;plain, *&#x2F;*</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 179</span><br><span class="line">Content-Type: application&#x2F;json;charset&#x3D;UTF-8</span><br><span class="line">Host: localhost:1001</span><br><span class="line">Origin: http:&#x2F;&#x2F;localhost:1001</span><br><span class="line">sec-ch-ua: &quot; Not A;Brand&quot;;v&#x3D;&quot;99&quot;, &quot;Chromium&quot;;v&#x3D;&quot;99&quot;, &quot;Google Chrome&quot;;v&#x3D;&quot;99&quot;</span><br><span class="line">sec-ch-ua-mobile: ?0</span><br><span class="line">sec-ch-ua-platform: &quot;Windows&quot;</span><br><span class="line">Sec-Fetch-Dest: empty</span><br><span class="line">Sec-Fetch-Mode: cors</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;99.0.4844.51 Safari&#x2F;537.36</span><br></pre></td></tr></table></figure></li><li>空行：表示请求头已经结束；</li><li>请求正文：请求正文包含客户提交的查询字符串信息。</li></ul><p>HTTP协议的详情，可以查看阮一峰老师的网络日志：<a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门</a></p><h1 id="服务器处理请求并返回HTTP响应"><a href="#服务器处理请求并返回HTTP响应" class="headerlink" title="服务器处理请求并返回HTTP响应"></a>服务器处理请求并返回HTTP响应</h1><p>服务端接收到请求报文后，会对请求报文进行解析，然后返回响应报文。</p><p>HTTP响应报文由三部分构成：状态行、响应头、空行、响应正文。<br><img src="https://s2.loli.net/2022/03/25/9z53cBkH6lWAoMs.png" alt=""></p><ul><li>状态行：协议版本、状态码、状态描述，各部分用空格分隔开。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.0 200 OK \r\n</span><br></pre></td></tr></table></figure></li><li>响应头：包含服务端有用信息。</li><li>空行：表示响应头结束。</li><li>响应正文：包含客户端需要的具体信息，比如页面需要的HTML、CSS、JS、图片等等。</li></ul><h1 id="浏览器渲染页面"><a href="#浏览器渲染页面" class="headerlink" title="浏览器渲染页面"></a>浏览器渲染页面</h1><h2 id="页面渲染过程"><a href="#页面渲染过程" class="headerlink" title="页面渲染过程"></a>页面渲染过程</h2><p>浏览器接收到服务端的响应报文后，开始渲染页面，具体过程如下：</p><ul><li><p><strong>解析HTML文件构建文档对象模型(DOM树)</strong>：浏览器从上到下读取标签，把他们分解成节点，从而创建 DOM 树。</p></li><li><p><strong>解析CSS文件构建CSS对象模型(CSSOM树)</strong>：当浏览器发现任何与节点相关的样式时，比如：外部，内部，或行内样式，立即停止渲染 DOM ，并利用这些节点创建 CSSOM。这就是 CSS “渲染阻塞“ 的由来。</p></li><li><p><strong>基于DOM和CSSOM执行脚本(Scripts)</strong>：浏览器不断构建 DOM / CSSOM 节点，直到发现外部或者行内的脚本，脚本需要等到CSS解析完才能执行，所以浏览器会停下对节点的解析，按成构建CSSOM，然后执行脚本，然后再继续解析节点，解析CSS。</p></li><li><p><strong>合并DOM树和CSSOM树合并形成渲染树(Render Tree)</strong>：所有的节点被解析完后，DOM 树和 CSSOM 树合并，形成渲染树。</p></li><li><p><strong>使用渲染树布局(Layout)所有元素</strong>：确定元素的位置和大小等。</p></li><li><p><strong>渲染(Paint)所有元素</strong>：调用 GPU 绘制所有元素，合成图层，显示在屏幕上。</p></li></ul><p>具体的浏览器渲染页面过程，请查看<a href="http://jinlong.github.io/2017/05/08/optimising-the-front-end-for-the-browser/" target="_blank" rel="noopener">浏览器前端优化</a></p><h2 id="回流-重绘"><a href="#回流-重绘" class="headerlink" title="回流 重绘"></a>回流 重绘</h2><ol><li>回流(reflow)<br>当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。<br>会触发回流的操作:<ul><li>页面初次渲染</li><li>浏览器窗口大小改变</li><li>元素尺寸、位置、内容发生改变</li><li>元素字体大小变化</li><li>添加或者删除可见的 dom 元素</li><li>激活 CSS 伪类（例如：:hover）</li><li>查询某些属性或调用某些方法：<ul><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>getComputedStyle()</li><li>getBoundingClientRect() </li><li>scrollTo()</li></ul></li></ul></li></ol><ol start="2"><li>重绘(repaint)<br>当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此损耗较少。</li></ol><p>总结：回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。</p><p><strong>如何减少回流和重绘</strong></p><ul><li>CSS<ul><li>避免使用 table 布局；</li><li>将动画效果应用到 position 属性为 absolute 或 fixed 的元素上；</li></ul></li><li>JavaScript<ul><li>避免频繁操作样式，如果真的要操作样式的话，汇总之后一一修改；</li><li>尽量使用 class 修改样式；</li><li>减少 dom 的增删次数，可使用<strong>字符串</strong>或者 documentFragment 一次性插入；</li><li>避免多次触发上面提到的那些会触发回流的属性或者方法，可以的话尽量用变量保存下来。</li></ul></li></ul><h1 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h1><h2 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h2><p><img src="https://s2.loli.net/2022/03/26/wDtTLEcHveudXpC.png" alt=""></p><ul><li><p>第一次挥手：客户端调用close()函数，发送请求关闭连接数据包给服务端，FIN=1,seq=u，客户端进入FIN_WAIT_1状态；</p></li><li><p>第二次挥手：服务端接收到数据包后，发送确认报文给客户端，ACK=1,ack=u+1,seq=v，告知客户端已收到关闭连接的请求，准备一下之后再关闭连接，服务端进入CLOSE_WAIT状态；</p><p>  客户端收到来自服务端的确认报文后，客户端就进入FIN_WAIT_2状态，等待服务端发送关闭连接的数据包。</p></li><li><p>第三次挥手：服务端做好准备之后(保证所有的数据都发送完毕)，发送关闭连接数据包给客户端，FIN=1,ACK=1,seq=w,ack=u+1，服务端进入LAST_ACK状态；</p></li><li><p>第四次挥手：客户端收到关闭连接数据包后，向服务端发送确认报文，ACK=1,seq=u+1,ack=w+1，客户端进入TIME_WAIT状态，服务端接收到确认报文会立刻进入CLOSE状态，但是客户端此时并没有关闭连接，需要等待2MSL之后，才会进入CLOSE状态。</p></li></ul><h2 id="为什么客户端在-TIME-WAIT-阶段要等2MSL才会关闭连接？"><a href="#为什么客户端在-TIME-WAIT-阶段要等2MSL才会关闭连接？" class="headerlink" title="为什么客户端在 TIME-WAIT 阶段要等2MSL才会关闭连接？"></a>为什么客户端在 TIME-WAIT 阶段要等2MSL才会关闭连接？</h2><p>为的是确认服务端是否收到客户端发送的确认关闭连接的报文。</p><p>当客户端发出最后的确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL(最大报文段生存时间)的计时器。</p><p>如果服务器端在1MSL内没有收到客户端发出的确认关闭连接的报文，就会再次向客户端发出关闭连接的报文；</p><p>也就是说客户端如果在2MSL内，再次收到了来自服务器端的关闭连接报文，说明服务端由于各种原因没有接收到客户端发出的确认报文；</p><p>客户端再次向服务器端发出确认报文，计时器重置，重新开始2MSL的计时；否则的话说明服务端已经收到确认报文，客户端进入CLOSE状态，完成四次挥手。</p><h2 id="为什么建立连接是三次握手，而关闭连接却是四次挥手？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手？</h2><p>这是因为服务端在LISTEN状态下，收到建立连接的SYN报文后，可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送给客户端。</p><p>但关闭连接时，当收到对方的FIN报文时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭连接,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://chensanr.gitee.io/2019/02/23/url-opeation/" target="_blank" rel="noopener">浏览器输入url发生了什么？</a><br><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">前端经典面试题: 从输入URL到页面加载发生了什么？</a><br><a href="https://xianyulaodi.github.io/2017/03/22/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88-%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">老生常谈-从输入url到页面展示到底发生了什么</a><br><a href="https://www.cnblogs.com/bj-mr-li/p/11106390.html" target="_blank" rel="noopener">TCP的三次握手与四次挥手</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2016/02/19/11/47/flowers-1209948_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/categories/Web/"/>
    
      <category term="浏览器" scheme="http://crystalsummer.gitee.io/categories/Web/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/tags/Web/"/>
    
      <category term="浏览器" scheme="http://crystalsummer.gitee.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>RSA</title>
    <link href="http://crystalsummer.gitee.io/2020/12/20/RSA/"/>
    <id>http://crystalsummer.gitee.io/2020/12/20/RSA/</id>
    <published>2020-12-20T04:15:16.000Z</published>
    <updated>2022-08-10T07:37:05.811Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/03/17/23/07/abstract-1264071_960_720.png" alt=""></p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;RSA加密算法是一种非对称加密算法，非对称加密算法指加密和解密采用不同的密钥（加密用公钥，解密用私钥），是可逆的。详细的算法原理可以参考这两篇文章：</p><ul><li><a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener"><strong>阮一峰网络日志-RSA算法原理（一）</strong></a></li><li><a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener"><strong>阮一峰网络日志-RSA算法原理（二）</strong></a></li></ul><h1 id="密钥对生成"><a href="#密钥对生成" class="headerlink" title="密钥对生成"></a>密钥对生成</h1><ol><li>MAC系统内置OpenSSL(开源加密库),所以可以直接在终端上使用命令；</li><li>Windows系统可以使用Git命令行工具；</li><li>在线生成密钥对：<a href="http://web.chacuo.net/netrsakeypair" target="_blank" rel="noopener"><strong>http://web.chacuo.net/netrsakeypair</strong></a>。</li></ol><h1 id="jsencrypt-基于RSA加解密的JS库"><a href="#jsencrypt-基于RSA加解密的JS库" class="headerlink" title="jsencrypt-基于RSA加解密的JS库"></a>jsencrypt-基于RSA加解密的JS库</h1><p>&emsp;&emsp;目前最常用的场景就是前端记住密码的操作，将密码加密保存在cookie中，比如若依前端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 安装</span><br><span class="line">npm install jsencrypt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 引入</span><br><span class="line">import JSEncrypt from &#39;jsencrypt&#x2F;bin&#x2F;jsencrypt.min&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 具体使用</span><br><span class="line">const publicKey &#x3D; &#39;...........&#39;</span><br><span class="line">const privateKey &#x3D; &#39;...........&#39;</span><br><span class="line">&#x2F;&#x2F; 加密</span><br><span class="line">export function encrypt(txt) &#123;</span><br><span class="line">  const encryptor &#x3D; new JSEncrypt()</span><br><span class="line">  encryptor.setPublicKey(publicKey) &#x2F;&#x2F; 设置公钥</span><br><span class="line">  return encryptor.encrypt(txt) &#x2F;&#x2F; 对数据进行加密</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解密</span><br><span class="line">export function decrypt(txt) &#123;</span><br><span class="line">  const encryptor &#x3D; new JSEncrypt()</span><br><span class="line">  encryptor.setPrivateKey(privateKey) &#x2F;&#x2F; 设置私钥</span><br><span class="line">  return encryptor.decrypt(txt) &#x2F;&#x2F; 对数据进行解密</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2016/03/17/23/07/abstract-1264071_960_720.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/categories/Web/"/>
    
      <category term="加密算法" scheme="http://crystalsummer.gitee.io/categories/Web/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/tags/Web/"/>
    
      <category term="加密算法" scheme="http://crystalsummer.gitee.io/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>工具函数</title>
    <link href="http://crystalsummer.gitee.io/2020/11/22/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"/>
    <id>http://crystalsummer.gitee.io/2020/11/22/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</id>
    <published>2020-11-22T02:24:16.000Z</published>
    <updated>2022-08-10T07:37:05.811Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2019/03/12/17/18/the-night-sky-4051288_960_720.jpg" alt=""></p><a id="more"></a><h1 id="桌面通知"><a href="#桌面通知" class="headerlink" title="桌面通知"></a>桌面通知</h1><p><img src="https://i.loli.net/2021/07/23/mDxVtl9zJSAjrcd.png" alt=""><br>&emsp;&emsp;具体代码请查看：<a href="https://gitee.com/crystalSummer/record-code/blob/master/JS/notify.js" target="_blank" rel="noopener"><strong>桌面通知方法封装</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">1、创建公共方法：新建notify.js文件</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 创建通知</span><br><span class="line"> * @param &#123;string&#125; title 一定会被显示的通知标题</span><br><span class="line"> * @param &#123;object&#125; options 一个被允许用来设置通知的对象。它包含以下属性：</span><br><span class="line"> * @param &#123;object&#125; events 4个事件 </span><br><span class="line"> *&#x2F;</span><br><span class="line">const doNotify &#x3D; (title, options &#x3D; &#123;&#125;, events &#x3D; &#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">  const notification &#x3D; new Notification(title, options);</span><br><span class="line">  for (let event in events) &#123;</span><br><span class="line">      notification[event] &#x3D; events[event];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 通知创建前的校验</span><br><span class="line"> * @param &#123;string&#125; title 一定会被显示的通知标题</span><br><span class="line"> * @param &#123;object&#125; options 一个被允许用来设置通知的对象。它包含以下属性：</span><br><span class="line"> *        dir : 文字的方向；它的值可以是 auto（自动）, ltr（从左到右）, or rtl（从右到左），但是好像没有作用</span><br><span class="line"> *        lang: 指定通知中所使用的语言。这个字符串必须在 BCP 47 language tag 文档中是有效的。</span><br><span class="line"> *        body: 通知中额外显示的字符串</span><br><span class="line"> *        tag: 赋予通知一个ID，以便在必要的时候对通知进行刷新、替换或移除，常用于处理重复的通知。</span><br><span class="line"> *        icon: 一个图片的URL，将被用于显示通知的图标，如果是本地图标的话，请使用require引入图标。</span><br><span class="line"> *        image：要在通知中显示的图像的URL，图片显示在通知的最下方。</span><br><span class="line"> *        requireInteraction：通知保持有效不自动关闭，默认为false。</span><br><span class="line"> *        data：想要和通知关联的任务类型的数据。</span><br><span class="line"> * @param &#123;object&#125; events 4个事件 </span><br><span class="line"> *        onshow：通知显示时触发</span><br><span class="line"> *        onclick：用户点击通知时触发</span><br><span class="line"> *        onclose：通知关闭时触发</span><br><span class="line"> *        onerror：通知发生错误的时候触发</span><br><span class="line"> *&#x2F;</span><br><span class="line">const notify &#x3D; (title, options &#x3D; &#123;&#125;, events &#x3D; &#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">  if (!(&quot;Notification&quot; in window)) &#123; &#x2F;&#x2F; 不支持Notifications功能</span><br><span class="line">      return console.error(&quot;This browser does not support desktop notification&quot;);</span><br><span class="line">  &#125;else if (Notification.permission &#x3D;&#x3D;&#x3D; &quot;granted&quot;) &#123;&#x2F;&#x2F; 查看是否已经有权限-之前已经询问过用户，并且用户已经授予了显示通知的权限</span><br><span class="line">      doNotify(title, options, events) &#x2F;&#x2F; 弹出通知</span><br><span class="line">  &#125; else if (Notification.permission !&#x3D;&#x3D; &quot;denied&quot;) &#123;&#x2F;&#x2F; 查看是否已经有权限-未授权</span><br><span class="line">      &#x2F;&#x2F; 向客户发起授权选择</span><br><span class="line">      Notification.requestPermission().then(function (permission) &#123;           </span><br><span class="line">          if (permission &#x3D;&#x3D;&#x3D; &quot;granted&quot;) &#123; &#x2F;&#x2F; 客户授权</span><br><span class="line">              doNotify(title, options, events);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default notify</span><br><span class="line"></span><br><span class="line">2、引入方法并使用</span><br><span class="line">&lt;el-button @click&#x3D;&quot;sendNotify&quot;&gt;发送通知&lt;&#x2F;el-button&gt;</span><br><span class="line"></span><br><span class="line">import notify from &#39;@&#x2F;utils&#x2F;notify.js&#39;</span><br><span class="line"></span><br><span class="line">sendNotify()&#123;</span><br><span class="line">  notify(&quot;中奖提示&quot;, &#123;</span><br><span class="line">      icon: &#39;https:&#x2F;&#x2F;source.unsplash.com&#x2F;user&#x2F;erondu&#x2F;80x80&#39;,</span><br><span class="line">      image: &#39;https:&#x2F;&#x2F;source.unsplash.com&#x2F;user&#x2F;erondu&#x2F;1600x900&#39;,</span><br><span class="line">      body: &#96;恭喜你，你中了一等奖&#96;,</span><br><span class="line">      tag: &quot;prize&quot;,</span><br><span class="line">      requireInteraction:true,</span><br><span class="line">      data:&#123;</span><br><span class="line">        entName:&#39;公司名称&#39;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">      onshow(ev) &#123;</span><br><span class="line">          console.log(&#39;通知显示&#39;)</span><br><span class="line">      &#125;,</span><br><span class="line">      onclick(ev) &#123;</span><br><span class="line">          &#x2F;&#x2F; ev.target.close()</span><br><span class="line">          console.log(&#39;通知被点击&#39;)</span><br><span class="line">          &#x2F;&#x2F; 可以定位到有消息的窗口</span><br><span class="line">          window.focus()</span><br><span class="line">          &#x2F;&#x2F; 获取定义的data</span><br><span class="line">          console.log(ev)</span><br><span class="line">          console.log(ev.target.data)</span><br><span class="line">      &#125;,</span><br><span class="line">      onclose(ev) &#123;</span><br><span class="line">        console.log(&#39;通知关闭&#39;)</span><br><span class="line">      &#125;,</span><br><span class="line">      onerror(ev) &#123;</span><br><span class="line">        console.log(&#39;通知出错&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="无插件原生base64编码和解码"><a href="#无插件原生base64编码和解码" class="headerlink" title="无插件原生base64编码和解码"></a>无插件原生base64编码和解码</h1><p>&emsp;&emsp;浏览器内置了base64编码和解码的能力，不需要第三方库。<br>&emsp;&emsp;CanIUse兼容性:<a href="https://caniuse.com/?search=btoa" target="_blank" rel="noopener"><strong>btoa 99.68%</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function utf8_to_b64( str ) &#123;</span><br><span class="line">  return window.btoa(unescape(encodeURIComponent( str )));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b64_to_utf8( str ) &#123;</span><br><span class="line">  return decodeURIComponent(escape(window.atob( str )));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">utf8_to_b64(&#39;✓ à la mode&#39;); &#x2F;&#x2F; &quot;4pyTIMOgIGxhIG1vZGU&#x3D;&quot;</span><br><span class="line">b64_to_utf8(&#39;4pyTIMOgIGxhIG1vZGU&#x3D;&#39;); &#x2F;&#x2F; &quot;✓ à la mode&quot;</span><br></pre></td></tr></table></figure><h1 id="基于Array-from的序列生成器"><a href="#基于Array-from的序列生成器" class="headerlink" title="基于Array.from的序列生成器"></a>基于Array.from的序列生成器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const range &#x3D; (start, stop, step) &#x3D;&gt; Array.from(</span><br><span class="line">    &#123; length: (stop - start) &#x2F; step + 1&#125;, </span><br><span class="line">    (_, i) &#x3D;&gt; start + (i * step)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">range(0, 4, 1); &#x2F;&#x2F; [0, 1, 2, 3, 4]</span><br><span class="line">range(0, 9, 3); &#x2F;&#x2F; [0, 3, 6, 9]</span><br><span class="line">range(0, 8, 2.5) &#x2F;&#x2F; [0, 2.5, 5, 7.5]</span><br></pre></td></tr></table></figure><h1 id="基于toLocaleString千分位"><a href="#基于toLocaleString千分位" class="headerlink" title="基于toLocaleString千分位"></a>基于toLocaleString千分位</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const formatMoney &#x3D; (num) &#x3D;&gt; &#123;</span><br><span class="line">    return (+num).toLocaleString(&quot;en-US&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(formatMoney(123456789));  &#x2F;&#x2F; 123,456,789</span><br><span class="line">console.log(formatMoney(6781)) &#x2F;&#x2F; 6,781</span><br><span class="line">console.log(formatMoney(5)) &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">超大的数</span><br><span class="line">formatMoney(19999999933333333333333) &#x2F;&#x2F; 19,999,999,933,333,333,000,000</span><br></pre></td></tr></table></figure><h1 id="禁止选择和赋值"><a href="#禁止选择和赋值" class="headerlink" title="禁止选择和赋值"></a>禁止选择和赋值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、JS方案</span><br><span class="line">[&#39;contextmenu&#39;, &#39;selectstart&#39;, &#39;copy&#39;].forEach(function(ev)&#123;</span><br><span class="line">    document.addEventListener(ev, function(ev)&#123;</span><br><span class="line">        ev.preventDefault();</span><br><span class="line">        ev.returnValue &#x3D; false;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">2、CSS方案</span><br><span class="line">body &#123;</span><br><span class="line">    -moz-user-select: none;</span><br><span class="line">    -webkit-user-select: none;</span><br><span class="line">    -ms-user-select: none;</span><br><span class="line">    -khtml-user-select: none;</span><br><span class="line">    user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Data-URLs-gt-Blob转换"><a href="#Data-URLs-gt-Blob转换" class="headerlink" title="Data URLs =&gt; Blob转换"></a>Data URLs =&gt; Blob转换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function dataUrlToBlob(base64, mimeType) &#123;</span><br><span class="line">  let bytes &#x3D; window.atob(base64.split(&quot;,&quot;)[1]);</span><br><span class="line">  let ab &#x3D; new ArrayBuffer(bytes.length);</span><br><span class="line">  let ia &#x3D; new Uint8Array(ab);</span><br><span class="line">  for (let i &#x3D; 0; i &lt; bytes.length; i++) &#123;</span><br><span class="line">    ia[i] &#x3D; bytes.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return new Blob([ab], &#123; type: mimeType &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一键复制"><a href="#一键复制" class="headerlink" title="一键复制"></a>一键复制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  一键复制</span><br><span class="line"> *  @param &#123;id&#125; string 要复制内容的Dom节点的id，如：#copyDiv</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function copyById(id) &#123;</span><br><span class="line">  let target &#x3D; null</span><br><span class="line">  target &#x3D; document.querySelector(id)</span><br><span class="line">  const range &#x3D; document.createRange()</span><br><span class="line">  range.selectNode(target)</span><br><span class="line">  window.getSelection().removeAllRanges()</span><br><span class="line">  window.getSelection().addRange(range)</span><br><span class="line">  document.execCommand(&#39;copy&#39;)</span><br><span class="line">  window.getSelection().removeAllRanges()</span><br><span class="line">  console.log(&#39;复制成功&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简易版深度拷贝"><a href="#简易版深度拷贝" class="headerlink" title="简易版深度拷贝"></a>简易版深度拷贝</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * This is just a simple version of deep copy</span><br><span class="line"> * Has a lot of edge cases bug</span><br><span class="line"> * If you want to use a perfect deep copy, use lodash&#39;s _.cloneDeep</span><br><span class="line"> * @param &#123;Object&#125; source</span><br><span class="line"> * @returns &#123;Object&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function deepClone(source) &#123;</span><br><span class="line">  if (!source &amp;&amp; typeof source !&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">    throw new Error(&#39;error arguments&#39;, &#39;deepClone&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  const targetObj &#x3D; source.constructor &#x3D;&#x3D;&#x3D; Array ? [] : &#123;&#125;</span><br><span class="line">  Object.keys(source).forEach(keys &#x3D;&gt; &#123;</span><br><span class="line">    if (source[keys] &amp;&amp; typeof source[keys] &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">      targetObj[keys] &#x3D; deepClone(source[keys])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      targetObj[keys] &#x3D; source[keys]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return targetObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通用下载回调"><a href="#通用下载回调" class="headerlink" title="通用下载回调"></a>通用下载回调</h1><p>&emsp;&emsp;以下是a标签下载文件的函数，在该函数内部，我们使用了 <code>HTMLAnchorElement.download</code> 属性，该属性值表示下载文件的名称。如果该名称不是操作系统的有效文件名，浏览器将会对其进行调整。此外，该属性的作用是表明链接的资源将被下载，而不是显示在浏览器中。当设置好 a 元素的 download 属性之后，我们会调用 <code>URL.createObjectURL</code> 方法来创建 <code>Object URL</code>，并把返回的 URL 赋值给 a 元素的 href 属性。接着通过调用 a 元素的 click 方法来触发文件的下载操作，最后还会调用一次 <code>URL.revokeObjectURL</code> 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">downLoadFile(res, fileName) &#123;</span><br><span class="line">  const blob &#x3D; new Blob([res])</span><br><span class="line">  const eLink &#x3D; document.createElement(&#39;a&#39;)</span><br><span class="line">  eLink.download &#x3D; fileName</span><br><span class="line">  eLink.style.display &#x3D; &#39;none&#39;</span><br><span class="line">  eLink.href &#x3D; URL.createObjectURL(blob)</span><br><span class="line">  document.body.appendChild(eLink)</span><br><span class="line">  eLink.click()</span><br><span class="line">  URL.revokeObjectURL(eLink.href) &#x2F;&#x2F; 释放URL 对象</span><br><span class="line">  document.body.removeChild(eLink)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2019/03/12/17/18/the-night-sky-4051288_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/categories/Web/"/>
    
      <category term="JS" scheme="http://crystalsummer.gitee.io/categories/Web/JS/"/>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/tags/Web/"/>
    
      <category term="JS" scheme="http://crystalsummer.gitee.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>网络与安全</title>
    <link href="http://crystalsummer.gitee.io/2020/10/17/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    <id>http://crystalsummer.gitee.io/2020/10/17/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/</id>
    <published>2020-10-17T04:45:50.000Z</published>
    <updated>2022-08-10T07:37:05.812Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2020/08/06/20/18/wheat-5469124_960_720.jpg" alt=""></p><a id="more"></a><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>HTTP协议是超文本传输协议的缩写，用于从万维网服务器传输超文本到本地浏览器的传送协议。</p><p>HTTP协议是基于TCP/IP通信协议来传递数据（HTML文件、图片文件、查询结果）的。</p><p>HTTP协议与TCP协议不冲突，HTTP协议定义在七层协议的应用层，TCP解决的是传输层逻辑。</p><p>HTTP使用TCP而不用UDP是因为网页传送的数据很多，而TCP协议提供传输控制，按顺序组织数据和错误纠正。</p><h2 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h2><ul><li><strong>TCP面向连接，UDP无连接</strong><br>TCP需要经过三次握手建立连接，而UDP不需要，想发送数据就可以直接发送。</li><li><strong>TCP可靠传输，提供流量控制和拥塞控制，UDP不可靠传输，不提供流量控制和拥塞控制</strong><br>由于TCP需要经过三次握手建立连接，所以TCP属于可靠传输，当网络出现堵塞的时候，TCP会减小向网络注入数据的数量和速率，缓解堵塞情况，但是UDP完全相反，UDP一直以恒定的速度发送数据，不管网络条件是好是坏。</li><li><strong>TCP一对一，UDP支持一对一，一对多，多对一和多对多的交互通信</strong></li><li><strong>TCP面向字节流，UDP面向报文</strong></li><li><strong>TCP首部最小为20字节，最大60字节，而UDP仅有8字节</strong></li><li><strong>TCP适用于可靠传输，如文件传输，UDP适用于实时应用，如电话、视频、直播</strong></li></ul><h2 id="HTTP版本区别"><a href="#HTTP版本区别" class="headerlink" title="HTTP版本区别"></a>HTTP版本区别</h2><h3 id="HTTP0-9"><a href="#HTTP0-9" class="headerlink" title="HTTP0.9"></a>HTTP0.9</h3><p>最早的版本，只能发送GET请求，返回的数据只能是HTML格式。</p><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><p>优点：</p><ul><li>第一个在通讯中指定版本号的HTTP协议版本；</li><li>任何格式的内容都可以发送，除文字外，增加了视频、图像、二进制文件；</li><li>除了GET命令，还引入了POST和HEAD命令；</li><li>请求和回应格式发生改变：<br>  请求格式：第一行是请求命令，尾部跟着协议版本号，后面是多行头信息，描述客户端情况。<br>  回应格式：头信息（ASCII码）+空行+数据（任何数据），其中第一行是协议版本号+状态码+状态描述。</li></ul><p>缺点：</p><ul><li>连接无法复用：每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</li><li>性能差：TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</li></ul><p>解决连接无法复用的方法：<br>请求时声明一个非标准字段Connection:keep-alive，这个字段要求服务器不关闭TCP连接，服务器同样返回这个字段。但这不是根本的解决之法。</p><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><p>优点：</p><ul><li><strong>持久连接</strong><br>TCP连接默认不关闭，可以被多个请求复用，不用声明Connection:keep-alive，客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。大多数浏览器允许同时建立6个长久连接。</li><li><strong>管道机制</strong><br>同一个TCP连接里，可以同时发送多个请求，提高了传输速度。举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</li><li><strong>新增了许多动词方法</strong><br>PUT、PATCH、HEAD、 OPTIONS、DELETE。</li><li><strong>客户端请求的头信息新增了Host字段，用来指定服务器的域名</strong>。</li></ul><p>缺点：</p><ul><li><strong>队头堵塞</strong><br>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。</li></ul><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><p>优点：</p><ul><li><strong>二进制协议</strong><br>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。<br>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</li><li><strong>多工</strong><br>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。<br>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。<br>这样双向的、实时的通信，就叫做多工（Multiplexing）。</li><li><strong>数据流</strong><br>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<br>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。<br>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。<br>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</li><li><strong>头信息压缩</strong><br>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。<br>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</li><li><strong>服务器推送</strong><br>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。<br>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</li></ul><p>缺点：</p><ul><li><strong>往返时延</strong><br>信号传播延迟(光在光纤和铜介质导线中传播速度是不同的)、网络服务器端以及用户端路由器跨越的数量、路由器是否拥堵以及路由器自身容量等。</li><li><strong>多工导致服务器压力上升，容易TimeOut</strong><br>多工没有限制同时请求的数量，大批量的请求同时发送，由于服务器资源有限，有可能导致超时。</li></ul><h3 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h3><p>HTTP3在2022年6月官宣，实现了巨大的改革，底层支撑协议由TCP换成UDP。该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。</p><ul><li><strong>实现快速握手功能</strong><br>由于UDP是无连接的，这意味着可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</li><li><strong>实现了类似TCP的可靠传输、流量控制和拥塞控制</strong></li></ul><h2 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h2><p>HTTP协议工作于客户端-服务端架构上，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。WEB服务器根据接收到的请求，向客户端发送响应信息。</p><p>HTTP默认端口号是80，也可以改成8080或者其他。</p><p>HTTP工作流程：</p><ul><li>客户端与服务端通过三次握手建立TCP连接；</li><li>客户端发送HTTP请求；</li><li>服务端解析请求并返回响应；</li><li>客户端与服务端通过四次挥手关闭TCP连接。</li></ul><p>详情请查看 <a href="https://crystalsummer.gitee.io/2021/01/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/#%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5"><strong>浏览器输入URL之后发生了什么</strong></a>，里面详细介绍了建立TCP连接的三次握手和关闭TCP连接的四次挥手过程。</p><h2 id="HTTP消息结构"><a href="#HTTP消息结构" class="headerlink" title="HTTP消息结构"></a>HTTP消息结构</h2><h3 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h3><p>HTTP请求报文构成：请求行、请求头、空行、请求正文<br><img src="https://s2.loli.net/2022/03/25/GCtJkL6D4F2Qoic.png" alt=""></p><ul><li>请求行：请求方法 URI协议 版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET&#x2F;sample.jsp HTTP&#x2F;1.1 \r\n</span><br></pre></td></tr></table></figure></li><li>请求头：包含客户端环境和请求正文的有用信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 浏览器可接受的MIME类型</span><br><span class="line">Accept: application&#x2F;json, text&#x2F;plain, *&#x2F;*</span><br><span class="line">&#x2F;&#x2F; 浏览器能够进行解码的数据编码方式</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">&#x2F;&#x2F; 浏览器所希望的语言种类</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">&#x2F;&#x2F; 表示是否需要持久连接</span><br><span class="line">Connection: keep-alive</span><br><span class="line">&#x2F;&#x2F; 表示请求消息正文的长度</span><br><span class="line">Content-Length: 179</span><br><span class="line">&#x2F;&#x2F; 文档支持的MIME类型</span><br><span class="line">Content-Type: application&#x2F;json;charset&#x3D;UTF-8</span><br><span class="line">&#x2F;&#x2F; Host头域指定请求资源的主机和端口号。</span><br><span class="line">Host: localhost:1001</span><br><span class="line">Origin: http:&#x2F;&#x2F;localhost:1001</span><br><span class="line">&#x2F;&#x2F; 浏览器类型</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;99.0.4844.51 Safari&#x2F;537.36</span><br><span class="line">&#x2F;&#x2F; Referer 设置响应体的过期时间</span><br><span class="line">&#x2F;&#x2F; Last-Modified的值</span><br><span class="line">if-Modified-Since</span><br><span class="line">&#x2F;&#x2F; Etag的值</span><br><span class="line">if-None-Match</span><br></pre></td></tr></table></figure></li><li>空行：表示请求头已经结束；</li><li>请求正文：请求正文包含客户提交的查询字符串信息。</li></ul><h3 id="服务器响应消息"><a href="#服务器响应消息" class="headerlink" title="服务器响应消息"></a>服务器响应消息</h3><p>HTTP响应报文由三部分构成：状态行、响应头、空行、响应正文。<br><img src="https://s2.loli.net/2022/03/25/9z53cBkH6lWAoMs.png" alt=""></p><ul><li>状态行：协议版本、状态码、状态描述，各部分用空格分隔开。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.0 200 OK \r\n</span><br></pre></td></tr></table></figure></li><li>响应头：包含服务端有用信息。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Expires 设置响应体的过期时间</span><br><span class="line">&#x2F;&#x2F; 跨域资源设置</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;wxdev9.600280.com</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">&#x2F;&#x2F; 设置请求响应链上所有的缓存机制必须遵守的指令</span><br><span class="line">Cache-Control: no-cache, no-store</span><br><span class="line">Express</span><br><span class="line">&#x2F;&#x2F; 表示是否需要持久连接</span><br><span class="line">Connection: keep-alive</span><br><span class="line">&#x2F;&#x2F; 文档支持的MIME类型</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">&#x2F;&#x2F; 当前的GMT时间</span><br><span class="line">Date: Sun, 27 Mar 2022 12:23:20 GMT</span><br><span class="line">&#x2F;&#x2F; 服务器名称</span><br><span class="line">Server: nginx&#x2F;1.11.6</span><br><span class="line">&#x2F;&#x2F; 设置传输实体的编码格式，目前支持的格式： chunked, compress, deflate, gzip, identity</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Etag 资源文件的一个唯一标识</span><br></pre></td></tr></table></figure></li><li>空行：表示响应头已经结束；</li><li>响应正文：包含客户端需要的具体信息，比如页面需要的HTML、CSS、JS、图片等等。</li></ul><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD等等。<br><img src="https://s2.loli.net/2022/03/25/YtJpXx6LfGiz3QM.png" alt=""></p><p><strong>GET和POST有什么区别？</strong></p><ul><li>GET：可被缓存，会被历史记录保存，请求长度受限</li><li>POST：安全，大数据，更多编码类型<br><img src="https://s2.loli.net/2022/03/25/1XLcMgeAVusUGra.png" alt=""></li></ul><p><strong>fetch()请求两次的原因？</strong><br>当使用fetch发送POST请求时，会先发送一个OPTION请求进行预检查，用来获知服务端是否允许该跨域请求，服务器确认允许之后会返回204状态码，表示允许该跨域请求，这时才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）</p><ul><li><strong>状态码204</strong>：当服务器返回这个状态码时，就表示服务器已经成功收到请求，但是没有数据。对应到浏览器，不会刷新界面，也不会导向新界面。当我们只关注于请求是否成功，而无所谓返回数据时，就可以借助204状态码，省掉了多余的数据传输，从而节省开销。</li><li><strong>OPTION请求</strong>：属于请求中的复杂请求，该类请求有一个特点，在正式发送请求之前，都会先发送一个请求，进行一个预检查，简称：预检请求。</li><li><strong>预检请求</strong>：可以向服务器请求权限信息，也可以获取目的资源所支持的通信选项（例如：检查HTTP请求方法），还可以用来检查服务器性能。</li></ul><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><ul><li><p>1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。</p></li><li><p>2xx：成功状态码，表示服务器已成功接收到请求并进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">200: 请求成功。一般用于GET与POST请求</span><br><span class="line">201: 已创建。成功请求并创建了新的资源</span><br><span class="line">202: 已接受。已经接受请求，但未处理完成</span><br><span class="line">203: 成为，但未授权</span><br><span class="line">204: 成功，无内容</span><br><span class="line">205: 成功，重置内容</span><br><span class="line">206: 成功，部分内容</span><br></pre></td></tr></table></figure></li><li><p>3xx：重定向状态码，表示服务器要求客户端重定向。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">301: 永久移动，重定向</span><br><span class="line">302: 临时移动，可使用原有URI</span><br><span class="line">303：请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源</span><br><span class="line">304: 资源未修改，可使用缓存</span><br><span class="line">305: 需代理访问</span><br></pre></td></tr></table></figure></li><li><p>4xx：客户端错误状态码，表示客户端的请求有非法内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">400: 请求语法错误</span><br><span class="line">401: 要求身份认证</span><br><span class="line">403: 拒绝请求，通常会在响应正文中给出拒绝的原因</span><br><span class="line">404: 资源不存在</span><br></pre></td></tr></table></figure></li><li><p>5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">500: 服务器未知错误</span><br><span class="line">503：服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</span><br><span class="line">505：服务器不支持请求的HTTP协议的版本，无法完成处理</span><br></pre></td></tr></table></figure></li></ul><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="HTTPS简介"><a href="#HTTPS简介" class="headerlink" title="HTTPS简介"></a>HTTPS简介</h2><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。现在的HTTPS都是用的TLS(SSL3.0)协议，但是由于SSL出现的时间比较早，并且依旧被现在浏览器所支持，因此SSL依然是HTTPS的代名词。</p><p>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，TLS/SSL中使用了 非对称加密，对称加密以及HASH算法。</p><p><strong>对称加密算法</strong>：使用同一个密钥对数据进行加密和解密，速度快，但是密钥明文传输存在安全隐患，如DES，AES，3DES，RC2，RC4；</p><p><strong>非对称加密算法</strong>：使用不同的密钥（公钥、私钥）对数据进行加密和解密，公钥和算法都是公开的，私钥是保密的，安全性强，但是性能低，耗时长，如RSA，DSA、ECDSA、 DH、ECDHE；</p><p><strong>哈希算法</strong>：将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆，如MD5，SHA-1，SHA-2(SHA-224 SHA-256 SHA-384 SHA-512)；</p><h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><ul><li><p>HTTPS协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p></li><li><p>HTTP是超文本传输协议，信息是明文传输，安全性差，HTTPS则是具有安全性的SSL加密传输协议，安全性好；</p></li><li><p>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p></li><li><p>HTTP页面响应速度比HTTPS快，主要是因为HTTP使用TCP三次握手建立连接，客户端和服务器需要交换3个包，而HTTPS除了TCP的三个包，还要加上SSL握手需要的9个包，所以一共是12个包。</p></li><li><p>HTTPS其实就是建构在SSL/TLS之上的HTTP协议，所以HTTPS比HTTP要更耗费服务器资源。</p></li></ul><h2 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h2><p>HTTPS的工作原理和HTTP类似，只是在通过三次握手建立TCP连接后，再建立SSL会话：</p><ul><li>客户端与服务端通过三次握手建立TCP连接；</li><li><strong>客户端与服务端建立SSL会话</strong>；</li><li>客户端发送HTTP请求；</li><li>服务端解析请求并返回响应；</li><li>客户端与服务端通过四次挥手关闭TCP连接。</li></ul><p>客户端与服务端建立SSL会话具体过程如下：<br><img src="https://s2.loli.net/2022/03/29/TNw4K2vd1JzYXhQ.png" alt=""></p><ul><li>浏览器将自己支持的一套加密规则发送给服务端；<ul><li>SSL/TLS协议版本号</li><li>支持的加密算法种类</li><li>支持的HASH算法种类</li><li>session ID</li><li>握手消息</li></ul></li></ul><ul><li>服务端从中选出一组加密算法和HASH算法，并将证书返回给客户端；<ul><li>证书包含了网站信息、加密公钥、证书签名、证书的颁发机构和过期时间等等。</li></ul></li></ul><ul><li>客户端接收到证书之后对其进行解析，这一过程由浏览器内置的TSL完成：<ul><li>验证证书的合法性：<strong>验证签名</strong>是否一致，证书颁发机构是否合法，证书的网站地址是否和正在访问的地址一致，证书有没有过期等等，如果证书可以信任，浏览器的地址栏前面就会出现一个锁；</li><li>如果证书合法，客户端产生一个随机数 R，并用证书的公钥对随机数进行加密，生成<strong>对称密码</strong>；</li><li>根据服务端指定的HASH算法（如SHA1）计算握手消息，并使用生成的对称密码对握手消息进行加密；</li></ul></li></ul><ul><li><p>客户端将握手消息、对称密码和加密的握手消息发送给服务端；</p></li><li><p>服务端接收到数据后对数据进行解析：</p><ul><li>用私钥对对称密码进行解密，获取随机数R；</li><li>将随机数R保存在客户端对应的session ID下面，这样的话就不需要每次请求都要建立握手传输密钥了；</li><li>用随机数R对加密后的握手消息进行解密得到hash1；</li><li>使用指定的HASH算法计算握手消息得到hash2;</li><li>判断hash1和hash2是否一致；</li></ul></li></ul><ul><li><p>服务端使用随机数加密握手信息，发送给客户端；</p></li><li><p>客户端使用随机数解密握手消息，并比较服务端发送的hash是否一致；一致此时握手结束，以后的通讯都是使用这个随机数加密。</p></li></ul><p>总结：</p><ul><li>使用服务端的公钥和密钥对客户端产生的随机数进行加密和解密，这一过程是非对称加密；</li><li>使用随机数对客户端和服务端的数据进行加密和解密，这一过程是对称加密；</li><li>使用HASH算法将数据转换为较短的固定长度的值。</li></ul><h2 id="只用对称加密可行吗？"><a href="#只用对称加密可行吗？" class="headerlink" title="只用对称加密可行吗？"></a>只用对称加密可行吗？</h2><p>不可行，因为密钥在传输过程中会被别人劫持，然后去解密客户端和服务端传输的数据，不安全。</p><h2 id="只用非对称加密可行吗？"><a href="#只用非对称加密可行吗？" class="headerlink" title="只用非对称加密可行吗？"></a>只用非对称加密可行吗？</h2><p>不可行，服务端将公钥传给客户端，客户端用公钥对数据进行加密传给服务端，服务端在用私钥解密，客户端到服务端的单向传输过程是安全的。</p><p>但是如果公钥被人劫持，服务端发送用私钥数据加密的数据给客户端，那么劫持者就可以用劫持的公钥解密数据，服务端到客户端的单向传输就存在安全问题。</p><p>除非客户端有自己的公钥和私钥，服务端也有自己的公钥和私钥，双方交换公钥，然后用公钥加密传输数据，用私钥解密数据，这样的话双向传输都是安全的。但是<strong>非对称加密算法非常复杂，耗时长</strong>。</p><p>所以就需要对称加密 + 非对称机密的结合，既可以保证安全，又可以节省时间。但是使用此方法依然有安全漏洞，那就是<strong>中间人攻击</strong>。</p><h2 id="数字证书的作用"><a href="#数字证书的作用" class="headerlink" title="数字证书的作用"></a>数字证书的作用</h2><p>只采用对称加密 + 非对称加密的算法，但是没有数字证书传输数据的时候，还是存在安全漏洞–<strong>中间人攻击</strong>。</p><p>中间人攻击：中间人劫持服务端的公钥A，并将数据包中的公钥A换成自己的公钥B，然后客户端使用公钥B加密数据并传送给服务端，中间人就可以劫持数据并用私钥B对数据进行解密，得到客户端生成的随机数R，中间人再使用公钥A加密后传输给服务端。这样在客户端和服务端不知情的情况下，调包了服务端的公钥，并且得到了随机数R，<strong>根本原因是浏览器无法确认收到的公钥是不是网站自己的，因为公钥本身是明文传输的。</strong></p><p>为了解决中间人攻击的问题，CA机构给网站办法身份证明–数字证书。服务端把证书传输给客户端，客户端从证书里获取公钥就可以完美的解决中间人攻击的问题。</p><h2 id="如何防止证书被篡改-数字签名"><a href="#如何防止证书被篡改-数字签名" class="headerlink" title="如何防止证书被篡改 - 数字签名"></a>如何防止证书被篡改 - 数字签名</h2><p>数字签名的制作过程：</p><ul><li>CA机构拥有非对称加密的私钥和公钥；</li><li>CA机构对证书明文数据T进行hash；</li><li>对hash后的值用私钥加密，得到数字签名S；</li></ul><p>客户端验证数字签名的过程：</p><ul><li>拿到证书，得到明文数据T和数字签名S；</li><li>使用公钥对数字签名S进行解密，得到S’；</li><li>用证书中指明的HASH算法对明文数据T进行hash，得到T’；</li><li>判断S’和T’是否相等，相等说明证书可信，不相等说明证书被篡改。</li></ul><p>如果中间人篡改证书，但是由于拿不到CA机构的私钥，就无法篡改相对应的数字签名S。</p><p>如果中间人掉包整个证书也不会发生问题，因为证书包含了网站的信息，包括域名，浏览器把自己的域名和证书中的域名一比对就知道证书有没有被调包。</p><h2 id="为什么制作数字签名需要hash一下？"><a href="#为什么制作数字签名需要hash一下？" class="headerlink" title="为什么制作数字签名需要hash一下？"></a>为什么制作数字签名需要hash一下？</h2><p>如果把数字签名过程中的hash步骤省略，在安全方面也是没有问题的，但是会有性能问题。</p><p>证书的明文数据一般都很长，如果直接用非对称加密算法加密或者解密的话，会非常耗时，但是证书明文经过hash之后得到固定长度的信息，比如用md5算法hash后可以得到固定的128位的值，这样加密解密过程就会快很多。</p><h2 id="每次进行HTTPS请求时都必须在SSL-TLS层进行握手传输密钥吗？"><a href="#每次进行HTTPS请求时都必须在SSL-TLS层进行握手传输密钥吗？" class="headerlink" title="每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗？"></a>每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗？</h2><p>不是。服务端会为每个客户端维护一个 <strong>session ID</strong>，在建立SSL会话阶段传给客户端，客户端把生成好的对称密码发送个服务端后，服务端会把对称密码保存到对应的session ID下面，之后客户端每次请求都会携带session ID，服务端根据session ID去找到对称密码进行加密和解密，这样就不必要每次重新制作、传输密钥了！</p><h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><h2 id="缓存定义"><a href="#缓存定义" class="headerlink" title="缓存定义"></a>缓存定义</h2><p>浏览器缓存机制，也叫HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的。</p><p>浏览器缓存就是把一个已经请求过的资源（如html页面，图片，JS，数据）拷贝一份放在浏览器中。当下一个请求到来的时候，如果是相同的URL，浏览器会根据缓存机制决定是直接从缓存中获取资源还是向服务器再次发起请求。</p><p>使用浏览器缓存的原因：</p><ul><li>减少网络延迟：缓存的使用可以明显加快页面打开速度，达到更好的用户体验。</li><li>减少网络带宽消耗：从缓存中获取资源只会产生极小的网络流量，可以有效降低运营成本。</li><li>降低服务器压力：缓存可以减少对服务器的请求</li></ul><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>缓存位置有以下四种，按照顺序查找缓存：</p><ul><li><p><strong>Service Worker</strong>：Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。Service Worker可以自由的控制哪些文件可以缓存，如何读取缓存，缓存的持续时间等等；</p></li><li><p><strong>Memory Cache</strong>：将资源缓存到内存中，读取速度快，但是容量小，并且持续性短，当页面关闭的时候内存就会被释放。当刷新页面的时候，很多资源都是来自内存。一般脚本、字体、图片会存在内存当中。</p></li><li><p><strong>Disk Cache</strong>：将资源缓存到磁盘中，读取速度慢，但是容量大，持续时间长，一般非脚本会存在磁盘当中，如css等。</p></li><li><p><strong>Push Cache</strong>：推送缓存，只在会话(session)中存在，一旦会话结束就会释放。</p></li></ul><p>如果以上四种缓存都没有找到的话，那么只能发起请求来获取资源了。</p><h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><p>浏览器在第一次请求资源后，会获取到请求的结果以及缓存规则。接下来，浏览器会根据第一次请求返回的响应头来确定缓存处理的方式，分别是强缓存和协商缓存。</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存：不会向服务端发送请求，直接从缓存中读取资源，但是会返回200状态码。</p><p>我们第一次进入页面，请求服务器，然后服务器进行应答，浏览器会根据response Header来判断是否对资源进行缓存，如果响应头中有Expires或者Cache-Control字段，代表这是强缓存，浏览器就会把资源缓存下来。</p><ul><li><p><strong>Expires</strong><br>  服务器响应消息头字段，HTTP1.0的规范，指明缓存失效时间，是一个绝对时间。<br>  <strong>缺点</strong>：由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。</p></li><li><p><strong>Cache-Control</strong><br>服务器响应消息头字段，HTTP1.1的规范，指明缓存失效时间，是一个相对时间。</p><ul><li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）；</li><li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值；</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存；</li><li>no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。</li><li>max-age=N：缓存内容将在N秒后失效；</li></ul></li></ul><p><strong>Expires和Cache-Control两者对比</strong><br>两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来决定是否使用缓存的过程。<br><strong>Etag 的优先级高于 Last-Modified。</strong></p><ul><li><p><strong>Last-Modified / If-Modified-Since</strong><br>  Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。</p><p>  If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。</p><p>  服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件。</p><p>  <strong>缺点</strong>：最小粒度只到 s， s 以内的改动无法检测到；周期性变化，如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为，因此便有了 ETag。</p></li><li><p><strong>Etag / If-None-Match</strong><br>  Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)。</p><p>  If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。</p><p>  服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://s2.loli.net/2022/04/08/r3aKd8AXDskNhUQ.jpg" alt=""></p><h2 id="缓存实践"><a href="#缓存实践" class="headerlink" title="缓存实践"></a>缓存实践</h2><ul><li><p><strong>频繁变动的资源</strong>：使用 Cache-Control:no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p></li><li><p><strong>不常变化的资源</strong>：给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。</p></li></ul><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>浏览器有一个同源策略的安全功能，若协议、域名(主域名+子域名)和端口号都相同才属于同源，当不同源的客户端脚本在没有明确授权的情况下读写对方的资源，就会产生跨域问题。<br><img src="https://s2.loli.net/2022/03/30/WBnX4xbrh2tGCwg.png" alt=""></p><p>注意：<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> = <a href="http://www.baidu.com:80" target="_blank" rel="noopener">http://www.baidu.com:80</a> ，http协议默认端口号就是80，https默认端口号是443.</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>以下是解决跨域的方法，前四种是最常用的方法，后面的方法了解即可。</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p><strong>CORS</strong>：跨域资源分享的缩写，是解决跨域的根本方法，支持任何类型的请求，需要服务端和浏览器同时支持。</p><p><strong>CORS方法</strong>：<br>普通跨域请求 —— 服务端在响应头上添加<code>Access-Control-Allow-Origin</code>属性，指定同源策略的地址，可以使用通配符  *；</p><p>带cookie的跨域请求 —— 前后端都需要设置，前端设置<code>widthCredentials</code>是否带cookie，服务端设置<code>Access-Control-Allow-Origin</code>，这里不可以使用通配符 *，必须指定同源策略的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; axios</span><br><span class="line">axios.default.widthCredentials &#x3D; true</span><br></pre></td></tr></table></figure><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><ul><li><strong>简单请求</strong>：只要同时满足以下两大条件，就属于简单请求：<br>条件一：请求方法为 GET POST HEAD 三个之一；<br>条件二：HTTP的头信息不超出以下几种字段：<ul><li>Accept  </li><li>Accept-Language  </li><li>Content-Language  </li><li>Last-Event-ID</li><li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul></li></ul><p>对于简单请求，浏览器直接发出CORS请求，就是在头信息之中，增加一个Origin字段。Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">&#x2F;&#x2F; 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。</span><br><span class="line">&#x2F;&#x2F; 设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。</span><br><span class="line">&#x2F;&#x2F; 这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">&#x2F;&#x2F; 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：</span><br><span class="line">&#x2F;&#x2F; Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma</span><br><span class="line">&#x2F;&#x2F; 如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br></pre></td></tr></table></figure><ul><li><strong>非简单请求</strong>：不满足简单请求条件的都是非简单请求。<br>对于非简单请求，会在正式通信之前，增加一次HTTP查询请求，称为<strong>“预检”请求</strong>（preflight）。</li></ul><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p><h3 id="Node中间件代理"><a href="#Node中间件代理" class="headerlink" title="Node中间件代理"></a>Node中间件代理</h3><p>node中间件实现跨域代理，是通过启动一个代理服务器，实现数据的转发。<br>实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</p><ul><li>非Vue框架<br>使用 node + express + http-proxy-middleware 搭建一个proxy服务器</li><li>Vue框架<br>使用 node + webpack + webpack-dev-server 代理接口跨域<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack vec-cli 配置proxy代理如下：</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        host: &#39;0.0.0.0&#39;,</span><br><span class="line">        port: 8000,</span><br><span class="line">        open: true,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            &#39;&#x2F;market&#39;: &#123;</span><br><span class="line">                target: &#96;http:&#x2F;&#x2F;wxdev6.600280.com&#96;,</span><br><span class="line">                changeOrigin: true,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    &#39;^&#x2F;market&#39;: &#39;&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        disableHostCheck: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Nignx反向代理"><a href="#Nignx反向代理" class="headerlink" title="Nignx反向代理"></a>Nignx反向代理</h3><p>实现原理类似于Node中间件代理，需要搭建一个中转nginx服务器，用于转发请求。</p><p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP，填充式JSON，适合老版本的浏览器，只支持get请求。</p><p><strong>JSONP原理</strong>：利用 script 标签没有跨域限制的漏洞，通过script标签引入JS文件，这个JS文件载入成功后会执行我们在url参数中指定的函数，并且把需要的json数据作为入参传入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 原生实现</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var sc &#x3D; document.createElement(&#39;script&#39;)</span><br><span class="line">    sc.type &#x3D; &#39;text&#x2F;javascript&#39;</span><br><span class="line">    sc.src &#x3D; &#39;http:&#x2F;&#x2F;www.domain.com:8080&#x2F;login?user&#x3D;admin&amp;callback&#x3D;onBack&#39;</span><br><span class="line">    document.head.appendChild(sc)</span><br><span class="line">    &#x2F;&#x2F; 回调函数执行</span><br><span class="line">    function onBack(res)&#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F; 封装成功公共方法</span><br><span class="line">function jsonp(url, params, jsonpCallback) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        const script &#x3D; document.createElement(&#39;script&#39;)</span><br><span class="line">        let arrs &#x3D; []</span><br><span class="line">        for (let key in params) &#123;</span><br><span class="line">            arrs.push(&#96;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;)</span><br><span class="line">        &#125;</span><br><span class="line">        script.src &#x3D; &#96;$&#123;url&#125;?$&#123;arrs.join(&#39;&amp;&#39;)&#125;&#96;</span><br><span class="line">        script.async &#x3D; true</span><br><span class="line">        script.type &#x3D; &#39;text&#x2F;javascript&#39;</span><br><span class="line">        window[jsonpCallback] &#x3D; function(data) &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">            document.body.removeChild(script)</span><br><span class="line">        &#125;</span><br><span class="line">        document.body.appendChild(script)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 公共方法使用</span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;say&#39;,</span><br><span class="line">  params: &#123; wd: &#39;Iloveyou&#39; &#125;,</span><br><span class="line">  callback: &#39;show&#39;</span><br><span class="line">&#125;).then(data &#x3D;&gt; &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="WebScoket"><a href="#WebScoket" class="headerlink" title="WebScoket"></a>WebScoket</h3><p>WebSocket 协议是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯。</p><h3 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain+iframe"></a>document.domain+iframe</h3><p>这个方案仅限于主域相同，子域不同的跨域场景。</p><p>实现原理：两个页面都通过JS强制设置document.domain为基础主域，就实现了同域。</p><p>注意：子窗口只能获取父窗口的cookie和iframe数据，localstorage和indexDB的数据获取不到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 父窗口</span><br><span class="line">&lt;iframe id&#x3D;&quot;iframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;child.domain.com&#x2F;b.html&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.domain &#x3D; &#39;domain.com&#39;</span><br><span class="line">var user &#x3D; &#39;admin&#39;</span><br><span class="line">document.cookie&#x3D;&quot;userId&#x3D;0001&quot;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子窗口</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.domain &#x3D; &#39;domain.com&#39;</span><br><span class="line">&#x2F;&#x2F; 获取父窗口的数据</span><br><span class="line">cosole.log(window.parent.user)</span><br><span class="line">cosole.log(document.cookie)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>还有 postMessage、window.name+iframe、document.hash+iframe等方法，这里不再一一赘述，平时开发用不到。</p><h1 id="安全-XSS-CSRF"><a href="#安全-XSS-CSRF" class="headerlink" title="安全(XSS CSRF)"></a>安全(XSS CSRF)</h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>XSS(Cross-Site Scripting)，跨站脚本攻击，是一种代码注入攻击，攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p><p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p><p><strong>任何可以输入的地方都有可能引起XSS，包括URL！</strong></p><p>为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li><strong>存储型XSS</strong></li></ol><ul><li>攻击者将恶意代码提交到目标网站的数据库中。</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ul><ol start="2"><li><strong>反射型XSS</strong></li></ol><ul><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ul><ol start="3"><li><strong>DOM型XSS</strong></li></ol><ul><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL。</li><li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ul><p>三种XSS对比：</p><table><thead><tr><th align="center">类型</th><th align="center">存储区</th><th align="center">插入点</th><th align="center">常见操作</th></tr></thead><tbody><tr><td align="center">存储型XSS</td><td align="center">后端数据库</td><td align="center">响应HTML</td><td align="center">常见于带有用户保存数据的功能的网站</td></tr><tr><td align="center">反射型XSS</td><td align="center">URL</td><td align="center">响应HTML</td><td align="center">常见于通过URL传递参数，如网站搜索、跳转等</td></tr><tr><td align="center">DOM型XSS</td><td align="center">后端数据库/前端存储/URL</td><td align="center">前端JavaScript</td><td align="center">常见于前端从浏览器某个地方直接获取内容中包含恶意代码</td></tr></tbody></table><h3 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h3><ol><li><strong>cookie设置HttpOnly属性</strong><br>后台在响应的头部设置HttpOnly属性，如果浏览器支持该属性的话，客户端就无法读取cookie的信息。</li><li><strong>输入过滤</strong><br>对于要输入的内容进行格式校验，比如手机号、邮箱等等，不仅前端要这么做，后端也需要，防止攻击者绕过正常的输入流程，直接利用接口向服务器发送相关配置。</li><li><strong>转义页面上的输入和输出内容</strong><br>如果前端需要拼接HTML，可以使用转义库将尖括号、引号、斜杠等进行转义，可以看一下这个<a href="https://jsxss.com/zh/index.html" target="_blank" rel="noopener"><strong>转义库</strong></a>。</li></ol><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>CSRF(Cross-site request forgery)，跨站请求伪造，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。如:攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ol><li><strong>get类型的CSRF</strong><br>用户访问某个页面中包含一张第三方网站的图片，浏览器会自动发送一个get请求给第三方网站。</li><li><strong>post类型的CSRF</strong><br>用户访问某个页面的时候，自动提交表单，模拟用户完成一次post操作。</li><li><strong>链接类型的CSRF</strong><br>这种CSRF并不常见，需要用户主动点击链接才会触发，常见的是以广告的形式引导用户点击。</li></ol><h3 id="防范方法-1"><a href="#防范方法-1" class="headerlink" title="防范方法"></a>防范方法</h3><ol><li><strong>验证码</strong><br>强制用户必须与应用进行交互，才能完成最终请求，但是用户体验差。</li><li><strong>请求校验</strong><br>在接口请求中都上token，<strong>token 验证的 CSRF 防御机制是公认最合适的方案</strong>。</li><li><strong>阻止外域访问</strong><br>同源检测，根据请求的Referer判断请求的来源。</li></ol><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门</a><br><a href="https://zhuanlan.zhihu.com/p/43789231" target="_blank" rel="noopener">彻底搞懂HTTPS的加密原理</a><br><a href="https://juejin.cn/post/6947936223126093861" target="_blank" rel="noopener">前端浏览器缓存知识梳理</a><br><a href="https://blog.csdn.net/csdnnews/article/details/89324384" target="_blank" rel="noopener">彻底吃透浏览器的缓存机制！</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a><br><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">前端常见跨域解决方案（全）</a><br><a href="https://juejin.cn/post/6844903781704925191" target="_blank" rel="noopener">XSS攻击与CSRF攻击</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2020/08/06/20/18/wheat-5469124_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/categories/Web/"/>
    
      <category term="网络" scheme="http://crystalsummer.gitee.io/categories/Web/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/tags/Web/"/>
    
      <category term="网络" scheme="http://crystalsummer.gitee.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>大屏可视化开发</title>
    <link href="http://crystalsummer.gitee.io/2020/09/10/%E5%A4%A7%E5%B1%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>http://crystalsummer.gitee.io/2020/09/10/%E5%A4%A7%E5%B1%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E5%8F%91/</id>
    <published>2020-09-10T03:08:19.000Z</published>
    <updated>2022-08-10T07:37:05.811Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/07/28/00/57/bank-2547356_960_720.jpg" alt=""></p><a id="more"></a><h1 id="常用技术库"><a href="#常用技术库" class="headerlink" title="常用技术库"></a>常用技术库</h1><ul><li><a href="http://datav.jiaminghi.com/" target="_blank" rel="noopener"><strong>DataV</strong></a>：Vue 大屏数据展示组件库；</li><li><a href="https://echarts.apache.org/zh/index.html" target="_blank" rel="noopener"><strong>ECharts</strong></a>：基于JavaScript的开源可视化图标库；</li><li>ECharts社区Gallery：这里收录了许多很炫酷的图表示例，但是官方已经将其关闭，可以使用备份镜像；<br><a href="http://www.ppchart.com/#/" target="_blank" rel="noopener"><strong>PPChart</strong></a><br><a href="https://www.isqqw.com/#/homepage" target="_blank" rel="noopener"><strong>ECharts Demo集</strong></a></li><li><a href="https://lbs.amap.com/api/jsapi-v2/summary/" target="_blank" rel="noopener"><strong>高德地图开放平台API</strong></a></li><li><a href="https://lbsyun.baidu.com/index.php?title=jspopularGL" target="_blank" rel="noopener"><strong>百度地图开放平台API</strong></a></li></ul><h1 id="单位概念"><a href="#单位概念" class="headerlink" title="单位概念"></a>单位概念</h1><h2 id="视窗单位"><a href="#视窗单位" class="headerlink" title="视窗单位"></a>视窗单位</h2><ol><li>视窗单位主要包括以下4个：<ul><li>vw: 视窗宽度的百分比（1vw 代表视窗的宽度为 1%）；</li><li>vh：视窗高度的百分比；</li><li>vmin：当前 vw 和 vh 中较小的一个值；</li><li>vmax：当前 vw 和 vh 中较大的一个值。</li></ul></li></ol><div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>    vh 和 vw：相对于视口的高度和宽度，而不是父元素的（CSS百分比是相对于包含它的最近的父元素的高度和宽度）。1vh 等于1/100的视口高度，1vw 等于1/100的视口宽度。<br/>    比如：浏览器高度950px，宽度为1920px, 1 vh = 950px/100 = 9.5 px，1vw = 1920px/100 =19.2 px。</div><div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>    vmax相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmax。<br/>    vmin相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin。<br/>    比如：如果宽度设置为800px，高度设置为1080px，1vmin将会等于8px，而1vmax将会是10.8px。</div><ol start="2"><li>vw、vh 与 % 百分比的区别：<br>% 是相对于父元素的大小设定的比率，vw、vh 是视窗大小决定的。<br>vw、vh 优势在于能够直接获取高度，而用 % 在没有设置 body 高度的情况下，是无法正确获得可视区域的高度的。</li><li>vmin、vmax 用处：<br>做移动开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的。但是由于 vmin 和 vmax 是当前较小的 vw 和 vh 和当前较大的 vw 和 vh。这里就可以用到 vmin 和 vmax。使得文字大小在横竖屏下保持一致。</li></ol><h2 id="px、em、rem的区别"><a href="#px、em、rem的区别" class="headerlink" title="px、em、rem的区别"></a>px、em、rem的区别</h2><ul><li>px：固定长度单位，不随其它元素的变化而变化；</li><li>em：相对长度单位，相对于父级元素的单位，会随父级元素的属性（font-size或其它属性）变化而变化；</li><li>rem：是css3新增的一个相对长度单位，相对于根目录（HTML元素）的，它会随HTML元素的属性（font-size）变化而变化，一般用于自适应布局。</li></ul><div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>    一般来说，浏览器默认是：1em = 1rem = 16 px</div><h2 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h2><ul><li><code>screen.width/height</code>：屏幕尺寸；</li><li><code>window.innerWidth/innerHeight</code>：浏览器窗口尺寸（包含滚动条）；</li><li><code>document.documentElement.clientWidth/clientHeight</code>：某个元素的尺寸（不包含滚动条），如果 <code>documentElement</code> 是 <code>&lt;html&gt;&lt;/html&gt;</code>，那么就是浏览器窗口尺寸（不包含滚动条）；</li><li><code>window.pageXOffset/pageYOffset</code>：滚动条滚出部分内容的宽高，在 IE 8 及之前版本的IE不支持，使用 <code>document.body.scrollLeft</code> 和 <code>document.body.scrollTop</code> 来取代；</li><li><code>viewport 视窗</code>：在桌面端，视窗指的是浏览器的可视区域，即 <code>window.innerWidth/window.innerHeight</code> 大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小；而在移动端，它涉及3个视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口），移动端指的就是Layout Viewport。</li></ul><h1 id="自适应方案-scale缩放"><a href="#自适应方案-scale缩放" class="headerlink" title="自适应方案 - scale缩放"></a>自适应方案 - scale缩放</h1><p>目前，最常见的大屏尺寸是16:9或者32:9，设计稿给出来的UI图的尺寸大多数是1920*1080（16:9）。</p><p>在日常开发中，如果按照设计稿的尺寸开发，16:9尺寸的大屏展示是没有问题的，但是考虑到<strong>兼容性</strong>问题，比如除了大屏之外，页面开发完成后一般需要先在笔记本上看一下效果，所以还要兼容不同尺寸的笔记本。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>以设计稿<strong>1920*1080</strong>为例，将页面容器 div 的宽高设置成 1920px 1080px；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置宽高</span><br><span class="line">setCss() &#123;</span><br><span class="line">  this.$refs.bigScreen.style.width &#x3D; &#96;1920px&#96;</span><br><span class="line">  this.$refs.bigScreen.style.height &#x3D; &#96;1080px&#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>根据屏幕尺寸大小设置缩放比例；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置缩放</span><br><span class="line">setScale() &#123;</span><br><span class="line">  const widthRadio &#x3D; document.body.clientWidth &#x2F; 1920</span><br><span class="line">  const heightRadio &#x3D; document.body.clientHeight &#x2F; 1080</span><br><span class="line">  &#x2F;&#x2F; 缩放一：取宽高最小缩放数作为缩放系数</span><br><span class="line">  &#x2F;&#x2F; 页面呈现效果：取heightRadio上下两侧出现留白，取widthRadio左右两侧出现留白</span><br><span class="line">  this.$refs.bigScreen.style.transform &#x3D; &#96;scale($&#123;Math.min(widthRadio,heightRadio)&#125;) translateX(-50%) translateY(-50%)&#96;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 缩放二：取widthRadio作为X轴的缩放系数，取heightRadio作为Y轴缩放系数</span><br><span class="line">  &#x2F;&#x2F; 页面呈现效果：不留白，平铺整个屏幕</span><br><span class="line">  this.$refs.bigScreen.style.transform &#x3D; &#96;scale($&#123;widthRadio&#125;,$&#123;heightRadio&#125;) translateX(-50%) translateY(-50%)&#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>防抖监听窗口大小变化，重新设置缩放比例。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;resize&quot;,()&#x3D;&gt;&#123;</span><br><span class="line">  this.setScale()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>DataV中已经封装了一个全屏容器组件——<code>dv-full-screen-container</code>，里面已经实现了缩放的功能，但是该缩放不支持PC端，查看源码后，定义公共组件-<code>CustomerDiv</code>，重写缩放逻辑实现尺寸的兼容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref&#x3D;&quot;customer&quot; class&#x3D;&quot;customer-div&quot;&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;dv-full-screen-container&quot; :ref&#x3D;&quot;ref&quot;&gt;</span><br><span class="line">      &lt;template v-if&#x3D;&quot;ready&quot;&gt;</span><br><span class="line">        &lt;slot &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import autoResize from &#39;@jiaminghi&#x2F;data-view&#x2F;src&#x2F;mixin&#x2F;autoResize.js&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;CustomerDiv&#39;,</span><br><span class="line">  mixins: [autoResize],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      ref: &#39;full-screen-container&#39;,</span><br><span class="line">      allWidth: 0,</span><br><span class="line">      scale: 0,</span><br><span class="line">      datavRoot: &#39;&#39;,</span><br><span class="line">      ready: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    afterAutoResizeMixinInit() &#123;</span><br><span class="line">      const &#123; initConfig, setAppScale &#125; &#x3D; this</span><br><span class="line">      initConfig()</span><br><span class="line">      setAppScale()</span><br><span class="line">      this.ready &#x3D; true</span><br><span class="line">    &#125;,</span><br><span class="line">    initConfig() &#123;</span><br><span class="line">      const &#123; dom &#125; &#x3D; this</span><br><span class="line">      this.allWidth &#x3D; 1920</span><br><span class="line">      dom.style.width &#x3D; &#96;1920px&#96;</span><br><span class="line">      dom.style.height &#x3D; &#96;1080px&#96;</span><br><span class="line">    &#125;,</span><br><span class="line">    setAppScale() &#123;</span><br><span class="line">      const &#123; allWidth, dom &#125; &#x3D; this</span><br><span class="line">      const widthRadio &#x3D; document.body.clientWidth &#x2F; allWidth</span><br><span class="line">      const heightRadio &#x3D; document.body.clientHeight &#x2F; 1080</span><br><span class="line">      console.log(widthRadio, heightRadio)</span><br><span class="line">      &#x2F;&#x2F; 缩放一</span><br><span class="line">      dom.style.transform &#x3D; &#96;scale($&#123;Math.min(widthRadio,heightRadio)&#125;) translateX(-50%) translateY(-50%)&#96;</span><br><span class="line">      &#x2F;&#x2F; 缩放二</span><br><span class="line">      &#x2F;&#x2F; dom.style.transform &#x3D; &#96;scale($&#123;widthRadio&#125;,$&#123;heightRadio&#125;) translateX(-50%) translateY(-50%)&#96;</span><br><span class="line">    &#125;,</span><br><span class="line">    onResize() &#123;</span><br><span class="line">      const &#123; setAppScale &#125; &#x3D; this</span><br><span class="line">      setAppScale()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">.customer-div &#123;</span><br><span class="line">  width: 100vw;</span><br><span class="line">  height: 100vh;</span><br><span class="line">  background: #000;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">#dv-full-screen-container &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  transform-origin: left top;</span><br><span class="line">  z-index: 999;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h1 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h1><ul><li>通过meta标签，设置设备宽度以及缩放比例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1, minimum-scale&#x3D;1, user-scalable&#x3D;no&quot;&gt;</span><br></pre></td></tr></table></figure></li><li>安装 amfe-flexible<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm  install -S amfe-flexible &#x2F;&#x2F; 用于给根元素设置字体大小</span><br></pre></td></tr></table></figure></li><li>在 main.js 中引入 amfe-flexible<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#39;amfe-flexible&#x2F;index.js&#39;</span><br></pre></td></tr></table></figure></li><li>安装 postcss-pxtorem<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-pxtorem &#x2F;&#x2F; 用于将 px 转化为 rem</span><br></pre></td></tr></table></figure></li></ul><div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>    对于移动端来说，字体大小不需要使用 rem 来适配，使用 px 即可，在大屏手机上查看的时候显示更多的文本就可以了。</div><h2 id="flexible-rem"><a href="#flexible-rem" class="headerlink" title="flexible+rem"></a>flexible+rem</h2><p>　　在项目根目录下的 postcss.config.js 文件里配置如下（1rem = 37.5px）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    autoprefixer: &#123;</span><br><span class="line">      overrideBrowserslist: [&#39;Android 4.1&#39;, &#39;iOS 7.1&#39;, &#39;Chrome &gt; 31&#39;, &#39;ff &gt; 31&#39;, &#39;ie &gt;&#x3D; 8&#39;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#39;postcss-pxtorem&#39;: &#123;</span><br><span class="line">      rootValue: 37.5,&#x2F;&#x2F;vant-UI的官方根字体大小是37.5</span><br><span class="line">      unitPrecision: 5,</span><br><span class="line">      propList: [&#39;*&#39;, &#39;!font-size&#39;, &#39;!border&#39;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>    rootValue这个配置项, 通常根据ui图尺寸来定这个值。假如ui图尺寸给的宽度是750，我们通常就会把rootValue设置为75，这样我们写样式时，可以直接按照ui图尺寸标注的宽高来1:1还原开发。<br/>    但是在此设为37.5，是为了引用vant、mint-ui等第三方UI框架，因为第三方框架没有兼容rem，用的是px单位，将rootValue的值设置为设计图宽度（这里为750px）75的一半，即可以1:1还原vant、mint-ui的组件，否则会样式会有变化，例如按钮会变小。<br/>    设置成了37.5后，我们在根据ui图设置样式时要将值改为设计图的一半。</div><h2 id="amfe-flexible-和-lib-flexible"><a href="#amfe-flexible-和-lib-flexible" class="headerlink" title="amfe-flexible 和 lib-flexible"></a>amfe-flexible 和 lib-flexible</h2><p>　　amfe-flexible 是在 lib-flexible 的基础上进行开发，lib-flexible 目前已经不再维护，所以选择使用 amfe-flexible。该组件中有一个 index.js 文件，通过 js 动态修改 body 的font-size，然后 postcss-pxtorem 将 px 转换成 rem ，rem 的值根据 body 的 font-size 改变，以此来实现屏幕适配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">(function flexible (window, document) &#123;</span><br><span class="line">  var docEl &#x3D; document.documentElement</span><br><span class="line">  var dpr &#x3D; window.devicePixelRatio || 1</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; adjust body font size</span><br><span class="line">  function setBodyFontSize () &#123;</span><br><span class="line">    if (document.body) &#123;</span><br><span class="line">      document.body.style.fontSize &#x3D; (12 * dpr) + &#39;px&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      document.addEventListener(&#39;DOMContentLoaded&#39;, setBodyFontSize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setBodyFontSize();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; set 1rem &#x3D; viewWidth &#x2F; 10</span><br><span class="line">  function setRemUnit () &#123;</span><br><span class="line">    var rem &#x3D; docEl.clientWidth &#x2F; 10</span><br><span class="line">    docEl.style.fontSize &#x3D; rem + &#39;px&#39;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setRemUnit()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; reset rem unit on page resize</span><br><span class="line">  window.addEventListener(&#39;resize&#39;, setRemUnit)</span><br><span class="line">  window.addEventListener(&#39;pageshow&#39;, function (e) &#123;</span><br><span class="line">    if (e.persisted) &#123;</span><br><span class="line">      setRemUnit()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; detect 0.5px supports</span><br><span class="line">  if (dpr &gt;&#x3D; 2) &#123;</span><br><span class="line">    var fakeBody &#x3D; document.createElement(&#39;body&#39;)</span><br><span class="line">    var testElement &#x3D; document.createElement(&#39;div&#39;)</span><br><span class="line">    testElement.style.border &#x3D; &#39;.5px solid transparent&#39;</span><br><span class="line">    fakeBody.appendChild(testElement)</span><br><span class="line">    docEl.appendChild(fakeBody)</span><br><span class="line">    if (testElement.offsetHeight &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">      docEl.classList.add(&#39;hairlines&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    docEl.removeChild(fakeBody)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(window, document))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2017/07/28/00/57/bank-2547356_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/categories/Web/"/>
    
      <category term="CSS" scheme="http://crystalsummer.gitee.io/categories/Web/CSS/"/>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/tags/Web/"/>
    
      <category term="CSS" scheme="http://crystalsummer.gitee.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>钉钉免登录</title>
    <link href="http://crystalsummer.gitee.io/2020/08/26/%E9%92%89%E9%92%89%E5%85%8D%E7%99%BB%E5%BD%95/"/>
    <id>http://crystalsummer.gitee.io/2020/08/26/%E9%92%89%E9%92%89%E5%85%8D%E7%99%BB%E5%BD%95/</id>
    <published>2020-08-26T03:46:55.000Z</published>
    <updated>2022-08-10T07:37:05.812Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2020/03/25/14/57/orbs-4967554_960_720.jpg" alt=""></p><a id="more"></a><h1 id="钉钉内部微应用免登"><a href="#钉钉内部微应用免登" class="headerlink" title="钉钉内部微应用免登"></a>钉钉内部微应用免登</h1><p>　　具体官方文档查看<a href="https://ding-doc.dingtalk.com/doc#/dev/ep7bpq" target="_blank" rel="noopener"><strong>H5微应用免登流程</strong></a></p><ol><li>安装钉钉 API<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install dingtalk-jsapi –save</span><br></pre></td></tr></table></figure></li><li>引入钉钉 API<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * as dd from &#39;dingtalk-jsapi&#39;;</span><br></pre></td></tr></table></figure></li><li>获取微应用免登授权码，再根据免登授权码 code 登录应用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">export const ddLogin &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">        axios.post(&#39;&#x2F;api&#x2F;dtalk&#x2F;getDingParam&#39;).then((res)&#x3D;&gt;&#123;</span><br><span class="line">            if (res.data.code &#x3D;&#x3D; &#39;0000&#39;) &#123;</span><br><span class="line">                let corpId &#x3D; res.data.data.corpId;&#x2F;&#x2F; 公司的 corpId</span><br><span class="line">                dd.ready(function() &#123;</span><br><span class="line">                    &#x2F;&#x2F; 获取微应用免登授权码</span><br><span class="line">                    dd.runtime.permission.requestAuthCode(&#123;</span><br><span class="line">                        corpId: corpId, &#x2F;&#x2F; 企业id</span><br><span class="line">                        onSuccess: function (info) &#123;</span><br><span class="line">                            let code &#x3D; info.code; &#x2F;&#x2F; 通过该免登授权码可以获取用户身份</span><br><span class="line">                            axios(&#123;</span><br><span class="line">                                method: &#39;post&#39;,</span><br><span class="line">                                url: &#39;&#x2F;api&#x2F;dtalkLogin&#39;, &#x2F;&#x2F; 路径</span><br><span class="line">                                data: &#123;</span><br><span class="line">                                    code</span><br><span class="line">                                &#125;,</span><br><span class="line">                                transformRequest: [function (data) &#123;</span><br><span class="line">                                    let ret &#x3D; &#39;&#39;;</span><br><span class="line">                                    ret &#x3D; qs.stringify(data);</span><br><span class="line">                                    return ret;</span><br><span class="line">                                &#125;],</span><br><span class="line">                                headers: &#123;</span><br><span class="line">                                    &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;).then(res&#x3D;&gt;&#123;</span><br><span class="line">                                if(res.data.code &#x3D;&#x3D; &#39;0000&#39;)&#123;</span><br><span class="line">                                    setLocalStorage(&#39;token&#39;,res.data.data.token.token);</span><br><span class="line">                                    setLocalStorage(&quot;curl&quot;, res.data.data.permission);</span><br><span class="line">                                    setLocalStorage(&quot;grider&quot;, res.data.data.grider);</span><br><span class="line">                                    setLocalStorage(&quot;permissionDing&quot;, res.data.data.permissionDing);</span><br><span class="line">                                    setLocalStorage(&quot;level&quot;, res.data.data.level);</span><br><span class="line">                                    resolve(res.data);</span><br><span class="line">                                &#125;else&#123;</span><br><span class="line">                                    Toast(&#39;登录失败&#39;);</span><br><span class="line">                                    location.href &#x3D; localStorage.getItem(&quot;loginUrl&quot;);&#x2F;&#x2F;登录页</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125;,</span><br><span class="line">                        onFail: function (err) &#123;</span><br><span class="line">                            Toast(err.errorMessage);</span><br><span class="line">                            location.href &#x3D; localStorage.getItem(&quot;loginUrl&quot;);&#x2F;&#x2F;登录页</span><br><span class="line">                            reject();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Toast(&#39;登录失败&#39;);</span><br><span class="line">                location.href &#x3D; localStorage.getItem(&quot;loginUrl&quot;);&#x2F;&#x2F;登录页</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="钉钉扫码登录第三方网站"><a href="#钉钉扫码登录第三方网站" class="headerlink" title="钉钉扫码登录第三方网站"></a>钉钉扫码登录第三方网站</h1><p>　　具体官方文档查看<a href="https://ding-doc.dingtalk.com/doc#/serverapi2/kymkv6/jfDu3" target="_blank" rel="noopener"><strong>身份验证-扫码登录第三方网站</strong></a>，这里采用了官网中的方法二：支持网站将钉钉登录二维码内嵌到自己页面中。用户使用钉钉扫码登录后 JS 会将 loginTmpCode 返回给网站。JS 钉钉登录主要用途：网站希望用户在网站内就能完成登录，无需跳转到钉钉域下登录后再返回，提升钉钉登录的流畅性与成功率。<br>　　项目地址：<a href="http://lylobsysc.cet0570.com/gov/login.html#/" target="_blank" rel="noopener"><strong>龙游企情通登录页</strong></a><br><img src="https://i.loli.net/2020/08/26/TjmEkMUcNy5LSaR.gif" alt=""></p><ol><li>创建一个div，用于显示钉钉带过来的二维码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;scan_box&quot; id&#x3D;&quot;scan_box&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li><li>通过公司的 appid 拿到二维码，用户扫码-扫码成功-跳转 ddLogin 页面登录应用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 重定向地址</span><br><span class="line">redirect_uri:window.location.href +&#39;ddLogin&#39;</span><br><span class="line">mounted()&#123;</span><br><span class="line">this.codeLogin();</span><br><span class="line">&#125;,</span><br><span class="line">codeLogin()&#123;</span><br><span class="line">    let that &#x3D; this;</span><br><span class="line">    api.getQrDingParam().then(res&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F; console.log(res);</span><br><span class="line">        if(res.code &#x3D;&#x3D; &#39;0000&#39;)&#123;</span><br><span class="line">            &#x2F;&#x2F; 1.调用后台接口拿到公司的 appid</span><br><span class="line">            this.appid &#x3D; res.data.appId;</span><br><span class="line">            &#x2F;&#x2F; 2.在需要使用钉钉登录的地方实例以下 JS 对象</span><br><span class="line">            let obj &#x3D; DDLogin(&#123;</span><br><span class="line">                id: &#39;scan_box&#39;, &#x2F;&#x2F; 这里的 id 就是上面定义的用来存放二维码 div 的 id</span><br><span class="line">                goto: encodeURIComponent(&#39;https:&#x2F;&#x2F;oapi.dingtalk.com&#x2F;connect&#x2F;oauth2&#x2F;sns_authorize?appid&#x3D;&#39; + this.appid + &#39;&amp;response_type&#x3D;code&amp;scope&#x3D;snsapi_login&amp;state&#x3D;STATE&amp;redirect_uri&#x3D;&#39; + this.redirect_uri + &#39;&#39;),</span><br><span class="line">                style: &#39;border:none;background-color:#FFFFFF;&#39;,</span><br><span class="line">                &#x2F;&#x2F; 表示显示二维码的区域的宽、高，width 和 height 不代表二维码的大小，二维码大小是固定的210px*210px</span><br><span class="line">                width: &#39;220&#39;,</span><br><span class="line">                height: &#39;300&#39;</span><br><span class="line">            &#125;)</span><br><span class="line">            let hanndleMessage &#x3D; function (event) &#123;</span><br><span class="line">                let origin &#x3D; event.origin;</span><br><span class="line">                &#x2F;&#x2F; 判断是否来自 ddLogin 扫码事件</span><br><span class="line">                if (origin &#x3D;&#x3D;&#x3D; &#39;https:&#x2F;&#x2F;login.dingtalk.com&#39;) &#123;</span><br><span class="line">                    let loginTmpCode &#x3D; event.data;</span><br><span class="line">                    &#x2F;&#x2F; 这里 url 不用进行 urlencode 编码</span><br><span class="line">                    let url &#x3D; &#39;https:&#x2F;&#x2F;oapi.dingtalk.com&#x2F;connect&#x2F;oauth2&#x2F;sns_authorize?appid&#x3D;&#39; + that.appid + &#39;&amp;response_type&#x3D;code&amp;scope&#x3D;snsapi_login&amp;state&#x3D;STATE&amp;redirect_uri&#x3D;&#39; + that.redirect_uri + &#39;&amp;loginTmpCode&#x3D;&#39; + loginTmpCode;</span><br><span class="line">                    &#x2F;&#x2F; 跳转链接到新页面</span><br><span class="line">                    window.location.href &#x3D; url;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            if (typeof window.addEventListener !&#x3D;&#x3D; &#39;undefined&#39;) &#123; &#x2F;&#x2F; 添加事件</span><br><span class="line">                window.addEventListener(&#39;message&#39;, hanndleMessage, false)</span><br><span class="line">            &#125; else if (typeof window.attachEvent !&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">                window.attachEvent(&#39;onmessage&#39;, hanndleMessage)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return this.$message.error(res.msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li>跳转到 ddLogin 页面后，后台会在新页面带上 code，根据 code 进行登录<br>　　此页面和登录页面相似，只是一个过渡页面，在二维码显示上面加了一个遮罩层，显示登录中，请稍后。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">    &#x2F;&#x2F; 由于该页面带上了后台返回的 code 和 state，所以重定向地址需要重写</span><br><span class="line">    this.redirect_uri &#x3D; location.origin + location.pathname ;</span><br><span class="line">    &#x2F;&#x2F; 获取后台返回的 code</span><br><span class="line">    this.code &#x3D; location.query.code;</span><br><span class="line">    if(this.code)&#123;</span><br><span class="line">        this.getdd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    this.codeLogin(); &#x2F;&#x2F; 和上面第二步同样的方法</span><br><span class="line">&#125;,</span><br><span class="line">getdd()&#123;</span><br><span class="line">    api.dtalkPcQrLogin(&#123;code:this.code&#125;).then(res&#x3D;&gt;&#123;</span><br><span class="line">        if (res.code &#x3D;&#x3D; &quot;0000&quot;) &#123;</span><br><span class="line">            setLocalStorage(&quot;token&quot;, res.data.token.token);</span><br><span class="line">            setLocalStorage(&quot;curl&quot;, res.data.permission);</span><br><span class="line">            setLocalStorage(&quot;department&quot;, res.data.department);</span><br><span class="line">            setLocalStorage(&quot;level&quot;, res.data.level);</span><br><span class="line">            setLocalStorage(&quot;grider&quot;, res.data.grider);</span><br><span class="line">            setLocalStorage(&quot;username&quot;, res.data.username);</span><br><span class="line">            setLocalStorage(&quot;name&quot;, res.data.realName);</span><br><span class="line">            setLocalStorage(&quot;permissionDing&quot;, res.data.permissionDing);</span><br><span class="line">            document.cookie &#x3D; &quot;token&#x3D;&quot; + res.data.token.token;</span><br><span class="line">            let arr &#x3D; JSON.parse(res.data.permission);</span><br><span class="line">            let item &#x3D; arr[0];</span><br><span class="line">            let child &#x3D; item.child[0];</span><br><span class="line">            &#x2F;&#x2F; 根据权限登录对应页面</span><br><span class="line">            if (item.url &amp;&amp; item.child.length&#x3D;&#x3D;0) &#123;</span><br><span class="line">                gotoGovURL(&#96;$&#123;item.url&#125;&#96;);</span><br><span class="line">            &#125; else if (child) &#123;</span><br><span class="line">                gotoGovURL(&#96;$&#123;item.url&#125;#&#x2F;$&#123;child.url&#125;&#96;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.$message(&#123;</span><br><span class="line">                message: res.msg,</span><br><span class="line">                type: &#39;warning&#39;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ol><h1 id="钉钉免登2-0版本（专有钉钉）"><a href="#钉钉免登2-0版本（专有钉钉）" class="headerlink" title="钉钉免登2.0版本（专有钉钉）"></a>钉钉免登2.0版本（专有钉钉）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML文件引入api</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;g.alicdn.com&#x2F;gdt&#x2F;jsapi&#x2F;1.3.5&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接口</span><br><span class="line">&#x2F;&#x2F; 免登接口 authCode</span><br><span class="line">export const autoLogin &#x3D; (params) &#x3D;&gt; request.get(&#39;&#x2F;dtalk&#x2F;autoLogin&#39;, &#123; params &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 绑定用户</span><br><span class="line">export const loginAndBind &#x3D; (params) &#x3D;&gt; request.get(&#39;&#x2F;dtalk&#x2F;loginAndBind&#39;, &#123; params &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 退出登录-解绑</span><br><span class="line">export const exitAndRemove &#x3D; (params) &#x3D;&gt; request.get(&#39;&#x2F;dtalkExit&#x2F;exitAndRemove&#39;, &#123; params &#125;)</span><br><span class="line"></span><br><span class="line">**</span><br><span class="line"> * @description: 政务钉钉2.0版本迭代 api修改dd.runtime.permission.requestAuthCode-》dd.getAuthCode 接口修改&#x2F;api&#x2F;dtalkLogin -》&#x2F;api&#x2F;dtalkLoginV2</span><br><span class="line"> *               流程：dd.getAuthCode 钉钉api 获取钉钉免登授权码》》》&#x2F;dtalk&#x2F;user&#x2F;dtalkLogin通过免登授权码获取用户信息</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const ddLoginV2 &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; console.log(&#39;ddLoginV2&#39;);</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; console.log(&#39;ddV2&#39;)</span><br><span class="line">    dd.ready(function() &#123;</span><br><span class="line">      &#x2F;&#x2F; console.log(&#39;ddV2 进&#39;)</span><br><span class="line">      dd.getAuthCode().then((result) &#x3D;&gt; &#123;</span><br><span class="line">        let authCode &#x3D; result.code</span><br><span class="line">        console.log(result)</span><br><span class="line">        &#x2F;&#x2F; 通过该免登授权码可以获取用户身份</span><br><span class="line">        autoLogin(&#123; authCode &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; console.log(&#39;dtalkLoginV2接口返回信息&#39;,res)</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125;).catch(() &#x3D;&gt; &#123;</span><br><span class="line">          Toast(&#39;免登失败，请重新登录绑定&#39;)</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            location.href &#x3D; &#39;&#x2F;dd.html#&#x2F;login&#39;&#x2F;&#x2F; 登录页</span><br><span class="line">          &#125;, 1500)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      return false</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">&#x2F;&#x2F; 1. 默认进入首页</span><br><span class="line">mounted() &#123;</span><br><span class="line">    &#x2F;&#x2F; 免登</span><br><span class="line">    ddLoginV2().then(res &#x3D;&gt; &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">      setLocalStorage(&#39;token&#39;, res.access_token)</span><br><span class="line">      setLocalStorage(&#39;nickNameCn&#39;, res.dtalkUserInfo)</span><br><span class="line">      setLocalStorage(&#39;accountId&#39;, res.dtalkId)</span><br><span class="line">      setLocalStorage(&#39;clientId&#39;, res.clientId)</span><br><span class="line">      setLocalStorage(&#39;lastName&#39;, res.lastName)</span><br><span class="line">      setToken(res.access_token)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; 退出登录</span><br><span class="line">    logout() &#123;</span><br><span class="line">      this.$dialog.confirm(&#123;</span><br><span class="line">        title: &#39;提示&#39;,</span><br><span class="line">        message: &#39;是否确定退出登录？&#39;</span><br><span class="line">      &#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 接除绑定</span><br><span class="line">        exitAndRemove().then(res &#x3D;&gt; &#123;</span><br><span class="line">          this.$router.push(&#39;login&#39;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;).catch(() &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; on cancel</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.登录</span><br><span class="line">methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; 登录</span><br><span class="line">    login() &#123;</span><br><span class="line">      if (!this.username || !this.password) return</span><br><span class="line">      login(&#123;</span><br><span class="line">        username: this.username,</span><br><span class="line">        password: this.password,</span><br><span class="line">        source: 1</span><br><span class="line">      &#125;).then(response &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 重新获取免登授权码</span><br><span class="line">        dd.getAuthCode().then((result) &#x3D;&gt; &#123;</span><br><span class="line">          let code &#x3D; result.code</span><br><span class="line">          let pwd &#x3D; this.password</span><br><span class="line">          loginAndBind(&#123;</span><br><span class="line">            userName: this.username,</span><br><span class="line">            password: md5(pwd),</span><br><span class="line">            authCode: code</span><br><span class="line">          &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">            setLocalStorage(&#39;token&#39;, res.access_token)</span><br><span class="line">            setLocalStorage(&#39;nickNameCn&#39;, res.dtalkUserInfo)</span><br><span class="line">            setLocalStorage(&#39;accountId&#39;, res.dtalkId)</span><br><span class="line">            setLocalStorage(&#39;clientId&#39;, res.clientId)</span><br><span class="line">            setLocalStorage(&#39;lastName&#39;, res.lastName)</span><br><span class="line">            setToken(res.access_token)</span><br><span class="line">            this.$notify(&#123; type: &#39;success&#39;, message: &#39;绑定成功&#39; &#125;)</span><br><span class="line">            this.$router.push(&#39;dashboard&#39;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>代码地址：<a href="https://gitee.com/crystalSummer/record-code/tree/master/ddAutoLogin" target="_blank" rel="noopener"><strong>钉钉免登2.0版本（专有钉钉）</strong></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2020/03/25/14/57/orbs-4967554_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="H5" scheme="http://crystalsummer.gitee.io/categories/H5/"/>
    
      <category term="钉钉" scheme="http://crystalsummer.gitee.io/categories/H5/%E9%92%89%E9%92%89/"/>
    
    
      <category term="H5" scheme="http://crystalsummer.gitee.io/tags/H5/"/>
    
      <category term="钉钉" scheme="http://crystalsummer.gitee.io/tags/%E9%92%89%E9%92%89/"/>
    
  </entry>
  
  <entry>
    <title>常用工具库记录</title>
    <link href="http://crystalsummer.gitee.io/2020/07/02/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93%E8%AE%B0%E5%BD%95/"/>
    <id>http://crystalsummer.gitee.io/2020/07/02/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-02T07:21:30.000Z</published>
    <updated>2022-08-10T07:37:05.812Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/11/04/11/25/fog-2917232_960_720.jpg" alt=""></p><a id="more"></a><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ol><li><p>地图综合神器：<a href="https://mapshaper.org/" target="_blank" rel="noopener"><strong>https://mapshaper.org/</strong></a><br>对地图数据进行简化和格式转换，目前支持Shapefile、GeoJSON、TopoJSON三种数据格式。</p></li><li><p>地图拾取器：<br><a href="http://datav.aliyun.com/tools/atlas/#&lat=30.332329214580188&lng=106.72278672066881&zoom=3.5" target="_blank" rel="noopener"><strong>http://datav.aliyun.com/tools/atlas/#&amp;lat=30.332329214580188&amp;lng=106.72278672066881&amp;zoom=3.5</strong></a><br>用于获取国、省、市、区的经纬度数据，但是获取不到镇街的经纬度数据，经纬度数据来源于高德地图。</p></li><li><p>geojson.io：<a href="http://geojson.io/" target="_blank" rel="noopener"><strong>http://geojson.io/</strong></a><br>在线生成地图 GeoJSON 数据。</p></li><li><p>bigemap：<a href="http://www.bigemap.com/" target="_blank" rel="noopener"><strong>官网</strong></a><br>谷歌地图、高清卫星地图下载器，功能很全，但是常用于获取镇街的经纬度数据，在地图下载器-&gt;行政区划边界（省市县乡镇）里面介绍了具体的操作步骤。这个软件如果要下载地图要正版授权，但如果只是用导出选择区域 kml 文件功能是不需要授权的，可以直接免费使用，将导出的的 kml 文件导入到 <a href="http://geojson.io/" target="_blank" rel="noopener">geojson.io</a> 网站，左边就会显示地图区域，右边就是该区域的 GeoJSON 数据，多个镇街数据挨个导入就可以了。</p></li><li><p>JSON校验格式化工具：<a href="https://www.bejson.com/" target="_blank" rel="noopener"><strong>https://www.bejson.com/</strong></a><br>有JSON工具，在线加密解密、前端、后端等工具。</p></li><li><p>自制icon：<a href="https://favicon.io/" target="_blank" rel="noopener"><strong>https://favicon.io/</strong></a><br>可以将图片、文字、表情等制作成icon。</p></li><li><p>tinypng：<a href="https://tinypng.com/" target="_blank" rel="noopener"><strong>https://tinypng.com/</strong></a><br>用于将图片进行压缩。</p></li><li><p>Tampermonkey<br>&emsp;&emsp;<a href="https://www.tampermonkey.net/index.php?ext=dhdg&show=dhdg" target="_blank" rel="noopener"><strong>Tampermonkey</strong></a>，油猴，它是一款浏览器插件，它之所以强大是因为这款插件可以安装和管理各种用户脚本。用户脚本就是一段代码，可以优化你的浏览器体验，实现很多自动化的操作，让网站变得更加易用，比如广告过滤、自动翻译等等。油猴支持各大浏览器。可以去官网下载油猴插件，并添加到扩展程序中。<br>&emsp;&emsp;网上脚本有很多，但是要注意安全性，这里推荐<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener"><strong>Greasy Fork</strong></a>来下载脚本，这个网站相对来说比较安全，但是也不要乱下载脚本，脚本里面可能包含获取你用户信息的程序。</p></li></ol><h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><ol><li><p>ECharts示例库：<a href="https://www.makeapie.com/explore.html#sort=rank~timeframe=all~author=all" target="_blank" rel="noopener"><strong>ECharts gallery</strong></a></p></li><li><p>免费无版权图片素材库：<a href="https://pixabay.com/zh/" target="_blank" rel="noopener"><strong>https://pixabay.com/zh/</strong></a></p></li><li><p>不同类型的随机图片库：<br><a href="https://source.unsplash.com/" target="_blank" rel="noopener"><strong>https://source.unsplash.com/</strong></a>，<br><a href="https://picsum.photos/" target="_blank" rel="noopener"><strong>https://picsum.photos/</strong></a>，<br>以上两个图片库都可以拿到随机图片，但是第二个库要比第一个库更为强大，可以模糊图片和给图片加上灰色调。</p></li><li><p>中华珍宝馆：<a href="http://www.ltfc.net/" target="_blank" rel="noopener"><strong>http://www.ltfc.net/</strong></a><br>中国古画库。</p></li><li><p>markdown用法参考：<a href="https://www.zybuluo.com/mdeditor?url=https%3A%2F%2Fwww.zybuluo.com%2Fstatic%2Feditor%2Fmd-help.markdown#12" target="_blank" rel="noopener"><strong>Cmd Markdown 简明语法手册</strong></a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2017/11/04/11/25/fog-2917232_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Other" scheme="http://crystalsummer.gitee.io/categories/Other/"/>
    
      <category term="tool" scheme="http://crystalsummer.gitee.io/categories/Other/tool/"/>
    
    
      <category term="Other" scheme="http://crystalsummer.gitee.io/tags/Other/"/>
    
      <category term="tool" scheme="http://crystalsummer.gitee.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>Base64</title>
    <link href="http://crystalsummer.gitee.io/2020/05/21/Base64/"/>
    <id>http://crystalsummer.gitee.io/2020/05/21/Base64/</id>
    <published>2020-05-21T08:06:12.000Z</published>
    <updated>2022-08-10T07:37:05.811Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2019/09/06/12/08/bridge-4456255_960_720.jpg" alt=""></p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>　　Base64是一种编码算法。为什么叫做Base64呢？因为这种算法只支持64个可打印字符。ASCII码的范围是0-127，其中0-31和127这33个字符属于控制字符（Controlcharacters）。剩下32-126这95个字符属于可打印字符（Printable characters）,包含数字、大小写字母、常用符号。</p><div style='color:#409EFF;border:1px solid #409EFF;border-radius:4px;background:rgba(64,158,255,0.1);padding:5px 10px;margin-bottom:20px;'>   Base64只是一种编码算法，而非加密算法。任何人都可以将Base64的编码结果解码成唯一的原文。</div><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ol><li>将字节转换成ASCII码：比如<code>s</code>对应的ASCII码就是<code>115</code>；</li><li>将ASCII码转换成二进制：<code>115</code>的二进制数是<code>0111 0011</code>，因为一个字节占8位，所以转换成8位二进制数；</li><li>将二进制数按6位一个划分，不足末位补0，但是每次补0需要补八个0，所以最后的位数应该是大于等于当前二进制位数的6和8的最小公倍数。比如当前位数为8，所以补位后长度应该是24，<code>0111 0011</code>划分完成后就是<code>011100 110000 000000 000000</code>；</li><li>将划分后的二进制数进行转换：非末位补位转换成十进制，末位补位转换成=；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">011100 110000 000000 000000</span><br><span class="line">  28     48     &#x3D;      &#x3D;</span><br></pre></td></tr></table></figure></li><li>将转换后的十进制数按照数据字典找到对应的字符，如下表格所示，28对应c，48对应w，所以s进行base64编码后就是cw==。<table><thead><tr><th align="center">索引</th><th align="center">对应字符</th><th align="center">索引</th><th align="center">对应字符</th><th align="center">索引</th><th align="center">对应字符</th><th align="center">索引</th><th align="center">对应字符</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">A</td><td align="center">16</td><td align="center">Q</td><td align="center">32</td><td align="center">g</td><td align="center">48</td><td align="center">w</td></tr><tr><td align="center">1</td><td align="center">B</td><td align="center">17</td><td align="center">R</td><td align="center">33</td><td align="center">h</td><td align="center">49</td><td align="center">x</td></tr><tr><td align="center">2</td><td align="center">C</td><td align="center">18</td><td align="center">S</td><td align="center">34</td><td align="center">i</td><td align="center">50</td><td align="center">y</td></tr><tr><td align="center">3</td><td align="center">D</td><td align="center">19</td><td align="center">T</td><td align="center">35</td><td align="center">j</td><td align="center">51</td><td align="center">z</td></tr><tr><td align="center">4</td><td align="center">E</td><td align="center">20</td><td align="center">U</td><td align="center">36</td><td align="center">k</td><td align="center">52</td><td align="center">0</td></tr><tr><td align="center">5</td><td align="center">F</td><td align="center">21</td><td align="center">V</td><td align="center">37</td><td align="center">l</td><td align="center">53</td><td align="center">1</td></tr><tr><td align="center">6</td><td align="center">G</td><td align="center">22</td><td align="center">W</td><td align="center">38</td><td align="center">m</td><td align="center">54</td><td align="center">2</td></tr><tr><td align="center">7</td><td align="center">H</td><td align="center">23</td><td align="center">X</td><td align="center">39</td><td align="center">n</td><td align="center">55</td><td align="center">3</td></tr><tr><td align="center">8</td><td align="center">I</td><td align="center">24</td><td align="center">Y</td><td align="center">40</td><td align="center">o</td><td align="center">56</td><td align="center">4</td></tr><tr><td align="center">9</td><td align="center">J</td><td align="center">25</td><td align="center">Z</td><td align="center">41</td><td align="center">p</td><td align="center">57</td><td align="center">5</td></tr><tr><td align="center">10</td><td align="center">K</td><td align="center">26</td><td align="center">a</td><td align="center">42</td><td align="center">q</td><td align="center">58</td><td align="center">6</td></tr><tr><td align="center">11</td><td align="center">L</td><td align="center">27</td><td align="center">b</td><td align="center">43</td><td align="center">r</td><td align="center">59</td><td align="center">7</td></tr><tr><td align="center">12</td><td align="center">M</td><td align="center">28</td><td align="center">c</td><td align="center">44</td><td align="center">s</td><td align="center">60</td><td align="center">8</td></tr><tr><td align="center">13</td><td align="center">N</td><td align="center">29</td><td align="center">d</td><td align="center">45</td><td align="center">t</td><td align="center">61</td><td align="center">9</td></tr><tr><td align="center">14</td><td align="center">O</td><td align="center">30</td><td align="center">e</td><td align="center">46</td><td align="center">u</td><td align="center">62</td><td align="center">+</td></tr><tr><td align="center">15</td><td align="center">P</td><td align="center">31</td><td align="center">f</td><td align="center">47</td><td align="center">v</td><td align="center">63</td><td align="center">/</td></tr></tbody></table></li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol><li>安装 <code>js-base64</code>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save js-base64</span><br></pre></td></tr></table></figure></li><li>单独使用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Base64 &#125; from &#39;js-base64&#39;</span><br><span class="line">&#x2F;&#x2F; 编码</span><br><span class="line">Base64.encode(&#39;123456&#39;) &#x2F;&#x2F; MTIzNDU2</span><br></pre></td></tr></table></figure></li><li>全局使用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在main.js里面</span><br><span class="line">import base64 from &#39;js-base64&#39;;</span><br><span class="line">Vue.prototype.$base64 &#x3D; base64;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 编码</span><br><span class="line">this.$base64.encode(&#39;123456&#39;) &#x2F;&#x2F; MTIzNDU2</span><br></pre></td></tr></table></figure></li><li>常用方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base64.encode(&#39;123456&#39;); &#x2F;&#x2F; 编码</span><br><span class="line">Base64.decode(&#39;MTIzNDU2&#39;); &#x2F;&#x2F; 解码</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2019/09/06/12/08/bridge-4456255_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/categories/Web/"/>
    
      <category term="编码算法" scheme="http://crystalsummer.gitee.io/categories/Web/%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/tags/Web/"/>
    
      <category term="编码算法" scheme="http://crystalsummer.gitee.io/tags/%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MD5</title>
    <link href="http://crystalsummer.gitee.io/2020/05/15/MD5/"/>
    <id>http://crystalsummer.gitee.io/2020/05/15/MD5/</id>
    <published>2020-05-15T07:42:39.000Z</published>
    <updated>2022-08-10T07:37:05.811Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2019/10/14/20/09/nature-4549913_960_720.jpg" alt=""></p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>　　MD5是哈希散列算法，对于MD5而言，有三个特性是很重要的：</p><ul><li>明文数据经过散列以后的值是定长的，32位；（MD5算法对输入任意长度的消息进行运行，产生一个128位的消息摘要，换算成十六进制，128/4=32位，对于网上说的16位等等，只是在32位的基础上进行字符串截取。）</li><li>任意一段明文数据，经过散列以后，其结果必须永远是不变的；（也就是一个原始数据，只对应一个MD5值；但是一个MD5值，可能对应多个原始数据。）</li><li>不可逆性保证了信息的安全性。（知道了MD5值后，是无法解密出原始数据的，只能用穷举法，把可能出现的明文，用MD5算法散列之后，把得到的散列值和原始的数据形成一个一对一的映射表，通过匹配从映射表中找出破解密码所对应的原始明文，还有就是暴力破解。）</li></ul><h1 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h1><p>　　MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由4个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p><ol><li>数据填充：<br>先对信息进行填充，使其字节长度对512求余数的结果等于448。设消息长度为X，即满足X mod 512=448，如果不满足，就对信息进行填充。填充的方法：在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。<br>因此，信息的字节长度将被扩展至<code>N*512+448</code>，即<code>N*64+56</code>个字节，N为整数。</li><li>添加信息长度：<br>将第一步得到的结果后面，附加一个值，这个值是以64位二进制表示的填充前的信息长度。此时<code>信息字节长度=N*512+448+64=(N+1)*512</code>，即长度恰好是512的整数倍数。这样做的原因是为满足后面处理中对信息长度的要求。</li><li>数据处理：<br>把消息以512位为一组进行分组处理，每一个分组进行4轮循环，以下面所说4个链接变量常数为起始变量进行计算，每次操作对A、B、C、D中的其中三个作一次非线性函数（即下面提到的四个函数）运算，然后将所得结果加上第四个变量，重新输出4个变量，以这4个变量再进行下一分组的运算，如果已经是最后一个分组，则这4个变量A、B、C、D为最后的结果，A是低位，D为高位，DCBA组成128位输出结果，换算成十六进制就是MD5值。需要用到的数据如下：<ul><li>4个链接变量常数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; 0x67452301</span><br><span class="line">B &#x3D; 0x0EFCDAB89</span><br><span class="line">C &#x3D; 0x98BADCFE</span><br><span class="line">D &#x3D; 0x10325476</span><br></pre></td></tr></table></figure></li><li>4个函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F(X,Y,Z)&#x3D;(X &amp; Y) | ((~X) &amp; Z)</span><br><span class="line">G(X,Y,Z)&#x3D;(X &amp; Z) | (Y &amp; (~Z))</span><br><span class="line">H(X,Y,Z)&#x3D;X ^ Y ^ Z</span><br><span class="line">I(X,Y,Z)&#x3D;Y ^ (X | (~Z))</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><img src="https://i.loli.net/2020/08/15/DUK1XpoNeTBxMHt.png" alt=""></p><ol><li>安装 <code>js-md5</code>：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save js-md5</span><br></pre></td></tr></table></figure></li><li>单独使用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import md5 from &#39;js-md5&#39;;</span><br><span class="line">md5(&#39;123456&#39;)  &#x2F;&#x2F; aac5f0d28478d9ea5ee6af4bba68c3bb</span><br></pre></td></tr></table></figure></li><li>全局使用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在main.js里面</span><br><span class="line">import md5 from &#39;js-md5&#39;;</span><br><span class="line">Vue.prototype.$md5 &#x3D; md5;</span><br><span class="line"></span><br><span class="line">this.$md5(&#39;123456&#39;)  &#x2F;&#x2F; aac5f0d28478d9ea5ee6af4bba68c3bb</span><br></pre></td></tr></table></figure></li><li>常用方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">md5(&#39;123456&#39;) &#x2F;&#x2F; aac5f0d28478d9ea5ee6af4bba68c3bb</span><br><span class="line">md5.hex(&#39;123456&#39;) &#x2F;&#x2F; aac5f0d28478d9ea5ee6af4bba68c3bb</span><br><span class="line">md5.array(&#39;123456&#39;) &#x2F;&#x2F; [170, 197, 240, 210, 132, 120, 217, 234, 94, 230, 175, 75, 186, 104, 195, 187]</span><br><span class="line">md5.digest(&#39;123456&#39;) &#x2F;&#x2F; [170, 197, 240, 210, 132, 120, 217, 234, 94, 230, 175, 75, 186, 104, 195, 187]</span><br><span class="line">md5.arrayBuffer(&#39;123456&#39;) &#x2F;&#x2F; ArrayBuffer(16) &#123;&#125;</span><br><span class="line">md5.buffer(&#39;123456&#39;) &#x2F;&#x2F; ArrayBuffer(16) &#123;&#125;</span><br><span class="line">md5.base64(&#39;123456&#39;) &#x2F;&#x2F; qsXw0oR42epe5q9LumjDuw&#x3D;&#x3D;</span><br></pre></td></tr></table></figure></li></ol><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><p>　　在目前的信息系统中，对MD5加密方法的利用主要通过在脚本页面中引用包含MD5加密函数代码的文件，如果将加密的MD5值直接保存在数据库，当网站存在注入或者其它漏洞时，入侵者极有可能获取用户的MD5值，通过MD5在线查询或者暴力破解可以得到明文。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ol><li>附加字符串：<br>在对明文进行加密之前，给明文附加一个内容确定的字符串（比如说用户名），然后再对明文进行加密，这样就可以针对性的防止穷举法破译MD5值。但是不可以用随机字串，因为这样会使原算法无法重现。</li><li>字符串次序干涉：<br>将明文的顺序按照统一的约定进行调转，然后在对明文加密。</li><li>签名验证：<br>安全性比较高的系统，都会对每个接口都进行了签名验证，防止被别人恶意攻击，频繁调用接口。这个需要前后端配合，商量出一套统一的方案，之前在做银行后台系统的时候，是将参数（除了接口的参数外还有几个固定的参数）按照字母从小到大的顺序拼接，然后在最后面加一个固定的字符串，最后将整个字符串进行MD5加密生成的就是签名，后台也会用同样的方法生成签名进行比对，来验证接口是否属于该平台。</li></ol><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://github.com/emn178/js-md5" target="_blank" rel="noopener"><strong>js-md5 github</strong></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2019/10/14/20/09/nature-4549913_960_720.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/categories/Web/"/>
    
      <category term="加密算法" scheme="http://crystalsummer.gitee.io/categories/Web/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Web" scheme="http://crystalsummer.gitee.io/tags/Web/"/>
    
      <category term="加密算法" scheme="http://crystalsummer.gitee.io/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
